[
  {
    "function_name": "lookup_kiocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1646-1663",
    "snippet": "static struct kiocb *lookup_kiocb(struct kioctx *ctx, struct iocb __user *iocb,\n\t\t\t\t  u32 key)\n{\n\tstruct list_head *pos;\n\n\tassert_spin_locked(&ctx->ctx_lock);\n\n\tif (key != KIOCB_KEY)\n\t\treturn NULL;\n\n\t/* TODO: use a hash or array, this sucks. */\n\tlist_for_each(pos, &ctx->active_reqs) {\n\t\tstruct kiocb *kiocb = list_kiocb(pos);\n\t\tif (kiocb->ki_obj.user == iocb)\n\t\t\treturn kiocb;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_kiocb",
          "args": [
            "pos"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos",
            "&ctx->active_reqs"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kiocb *lookup_kiocb(struct kioctx *ctx, struct iocb __user *iocb,\n\t\t\t\t  u32 key)\n{\n\tstruct list_head *pos;\n\n\tassert_spin_locked(&ctx->ctx_lock);\n\n\tif (key != KIOCB_KEY)\n\t\treturn NULL;\n\n\t/* TODO: use a hash or array, this sucks. */\n\tlist_for_each(pos, &ctx->active_reqs) {\n\t\tstruct kiocb *kiocb = list_kiocb(pos);\n\t\tif (kiocb->ki_obj.user == iocb)\n\t\t\treturn kiocb;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "do_io_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1572-1623",
    "snippet": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i = 0;\n\tstruct blk_plug plug;\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(nr > LONG_MAX/sizeof(*iocbpp)))\n\t\tnr = LONG_MAX/sizeof(*iocbpp);\n\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tblk_start_plug(&plug);\n\n\t/*\n\t * AKPM: should this return a partial result if some of the IOs were\n\t * successfully submitted?\n\t */\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tpercpu_ref_put(&ctx->users);\n\treturn i ? i : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&ctx->users"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_submit_one",
          "args": [
            "ctx",
            "user_iocb",
            "&tmp",
            "compat"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "io_submit_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "1500-1570",
          "snippet": "static int io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,\n\t\t\t struct iocb *iocb, bool compat)\n{\n\tstruct kiocb *req;\n\tssize_t ret;\n\n\t/* enforce forwards compatibility on users */\n\tif (unlikely(iocb->aio_reserved1 || iocb->aio_reserved2)) {\n\t\tpr_debug(\"EINVAL: reserve field set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* prevent overflows */\n\tif (unlikely(\n\t    (iocb->aio_buf != (unsigned long)iocb->aio_buf) ||\n\t    (iocb->aio_nbytes != (size_t)iocb->aio_nbytes) ||\n\t    ((ssize_t)iocb->aio_nbytes < 0)\n\t   )) {\n\t\tpr_debug(\"EINVAL: overflow check\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treq = aio_get_req(ctx);\n\tif (unlikely(!req))\n\t\treturn -EAGAIN;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp)) {\n\t\tret = -EBADF;\n\t\tgoto out_put_req;\n\t}\n\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD) {\n\t\t/*\n\t\t * If the IOCB_FLAG_RESFD flag of aio_flags is set, get an\n\t\t * instance of the file* now. The file descriptor must be\n\t\t * an eventfd() fd, and will be signaled for each completed\n\t\t * event using the eventfd_signal() function.\n\t\t */\n\t\treq->ki_eventfd = eventfd_ctx_fdget((int) iocb->aio_resfd);\n\t\tif (IS_ERR(req->ki_eventfd)) {\n\t\t\tret = PTR_ERR(req->ki_eventfd);\n\t\t\treq->ki_eventfd = NULL;\n\t\t\tgoto out_put_req;\n\t\t}\n\t}\n\n\tret = put_user(KIOCB_KEY, &user_iocb->aio_key);\n\tif (unlikely(ret)) {\n\t\tpr_debug(\"EFAULT: aio_key\\n\");\n\t\tgoto out_put_req;\n\t}\n\n\treq->ki_obj.user = user_iocb;\n\treq->ki_user_data = iocb->aio_data;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_nbytes = iocb->aio_nbytes;\n\n\tret = aio_run_iocb(req, iocb->aio_lio_opcode,\n\t\t\t   (char __user *)(unsigned long)iocb->aio_buf,\n\t\t\t   compat);\n\tif (ret)\n\t\tgoto out_put_req;\n\n\treturn 0;\nout_put_req:\n\tput_reqs_available(ctx, 1);\n\tpercpu_ref_put(&ctx->reqs);\n\tkiocb_free(req);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,\n\t\t\t struct iocb *iocb, bool compat)\n{\n\tstruct kiocb *req;\n\tssize_t ret;\n\n\t/* enforce forwards compatibility on users */\n\tif (unlikely(iocb->aio_reserved1 || iocb->aio_reserved2)) {\n\t\tpr_debug(\"EINVAL: reserve field set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* prevent overflows */\n\tif (unlikely(\n\t    (iocb->aio_buf != (unsigned long)iocb->aio_buf) ||\n\t    (iocb->aio_nbytes != (size_t)iocb->aio_nbytes) ||\n\t    ((ssize_t)iocb->aio_nbytes < 0)\n\t   )) {\n\t\tpr_debug(\"EINVAL: overflow check\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treq = aio_get_req(ctx);\n\tif (unlikely(!req))\n\t\treturn -EAGAIN;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp)) {\n\t\tret = -EBADF;\n\t\tgoto out_put_req;\n\t}\n\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD) {\n\t\t/*\n\t\t * If the IOCB_FLAG_RESFD flag of aio_flags is set, get an\n\t\t * instance of the file* now. The file descriptor must be\n\t\t * an eventfd() fd, and will be signaled for each completed\n\t\t * event using the eventfd_signal() function.\n\t\t */\n\t\treq->ki_eventfd = eventfd_ctx_fdget((int) iocb->aio_resfd);\n\t\tif (IS_ERR(req->ki_eventfd)) {\n\t\t\tret = PTR_ERR(req->ki_eventfd);\n\t\t\treq->ki_eventfd = NULL;\n\t\t\tgoto out_put_req;\n\t\t}\n\t}\n\n\tret = put_user(KIOCB_KEY, &user_iocb->aio_key);\n\tif (unlikely(ret)) {\n\t\tpr_debug(\"EFAULT: aio_key\\n\");\n\t\tgoto out_put_req;\n\t}\n\n\treq->ki_obj.user = user_iocb;\n\treq->ki_user_data = iocb->aio_data;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_nbytes = iocb->aio_nbytes;\n\n\tret = aio_run_iocb(req, iocb->aio_lio_opcode,\n\t\t\t   (char __user *)(unsigned long)iocb->aio_buf,\n\t\t\t   compat);\n\tif (ret)\n\t\tgoto out_put_req;\n\n\treturn 0;\nout_put_req:\n\tput_reqs_available(ctx, 1);\n\tpercpu_ref_put(&ctx->reqs);\n\tkiocb_free(req);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copy_from_user(&tmp, user_iocb, sizeof(tmp))"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&tmp",
            "user_iocb",
            "sizeof(tmp)"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__get_user(user_iocb, iocbpp + i)"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "user_iocb",
            "iocbpp + i"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EINVAL: invalid context id\\n\""
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_ioctx",
          "args": [
            "ctx_id"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_ioctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "983-1008",
          "snippet": "static struct kioctx *lookup_ioctx(unsigned long ctx_id)\n{\n\tstruct aio_ring __user *ring  = (void __user *)ctx_id;\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx, *ret = NULL;\n\tstruct kioctx_table *table;\n\tunsigned id;\n\n\tif (get_user(id, &ring->id))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tif (!table || id >= table->nr)\n\t\tgoto out;\n\n\tctx = table->table[id];\n\tif (ctx && ctx->user_id == ctx_id) {\n\t\tpercpu_ref_get(&ctx->users);\n\t\tret = ctx;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kioctx *lookup_ioctx(unsigned long ctx_id)\n{\n\tstruct aio_ring __user *ring  = (void __user *)ctx_id;\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx, *ret = NULL;\n\tstruct kioctx_table *table;\n\tunsigned id;\n\n\tif (get_user(id, &ring->id))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tif (!table || id >= table->nr)\n\t\tgoto out;\n\n\tctx = table->table[id];\n\tif (ctx && ctx->user_id == ctx_id) {\n\t\tpercpu_ref_get(&ctx->users);\n\t\tret = ctx;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "iocbpp",
            "(nr*sizeof(*iocbpp))"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr > LONG_MAX/sizeof(*iocbpp)"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr < 0"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nlong do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i = 0;\n\tstruct blk_plug plug;\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(nr > LONG_MAX/sizeof(*iocbpp)))\n\t\tnr = LONG_MAX/sizeof(*iocbpp);\n\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tblk_start_plug(&plug);\n\n\t/*\n\t * AKPM: should this return a partial result if some of the IOs were\n\t * successfully submitted?\n\t */\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tpercpu_ref_put(&ctx->users);\n\treturn i ? i : ret;\n}"
  },
  {
    "function_name": "io_submit_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1500-1570",
    "snippet": "static int io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,\n\t\t\t struct iocb *iocb, bool compat)\n{\n\tstruct kiocb *req;\n\tssize_t ret;\n\n\t/* enforce forwards compatibility on users */\n\tif (unlikely(iocb->aio_reserved1 || iocb->aio_reserved2)) {\n\t\tpr_debug(\"EINVAL: reserve field set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* prevent overflows */\n\tif (unlikely(\n\t    (iocb->aio_buf != (unsigned long)iocb->aio_buf) ||\n\t    (iocb->aio_nbytes != (size_t)iocb->aio_nbytes) ||\n\t    ((ssize_t)iocb->aio_nbytes < 0)\n\t   )) {\n\t\tpr_debug(\"EINVAL: overflow check\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treq = aio_get_req(ctx);\n\tif (unlikely(!req))\n\t\treturn -EAGAIN;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp)) {\n\t\tret = -EBADF;\n\t\tgoto out_put_req;\n\t}\n\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD) {\n\t\t/*\n\t\t * If the IOCB_FLAG_RESFD flag of aio_flags is set, get an\n\t\t * instance of the file* now. The file descriptor must be\n\t\t * an eventfd() fd, and will be signaled for each completed\n\t\t * event using the eventfd_signal() function.\n\t\t */\n\t\treq->ki_eventfd = eventfd_ctx_fdget((int) iocb->aio_resfd);\n\t\tif (IS_ERR(req->ki_eventfd)) {\n\t\t\tret = PTR_ERR(req->ki_eventfd);\n\t\t\treq->ki_eventfd = NULL;\n\t\t\tgoto out_put_req;\n\t\t}\n\t}\n\n\tret = put_user(KIOCB_KEY, &user_iocb->aio_key);\n\tif (unlikely(ret)) {\n\t\tpr_debug(\"EFAULT: aio_key\\n\");\n\t\tgoto out_put_req;\n\t}\n\n\treq->ki_obj.user = user_iocb;\n\treq->ki_user_data = iocb->aio_data;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_nbytes = iocb->aio_nbytes;\n\n\tret = aio_run_iocb(req, iocb->aio_lio_opcode,\n\t\t\t   (char __user *)(unsigned long)iocb->aio_buf,\n\t\t\t   compat);\n\tif (ret)\n\t\tgoto out_put_req;\n\n\treturn 0;\nout_put_req:\n\tput_reqs_available(ctx, 1);\n\tpercpu_ref_put(&ctx->reqs);\n\tkiocb_free(req);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kiocb_free",
          "args": [
            "req"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "kiocb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "974-981",
          "snippet": "static void kiocb_free(struct kiocb *req)\n{\n\tif (req->ki_filp)\n\t\tfput(req->ki_filp);\n\tif (req->ki_eventfd != NULL)\n\t\teventfd_ctx_put(req->ki_eventfd);\n\tkmem_cache_free(kiocb_cachep, req);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*kiocb_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic void kiocb_free(struct kiocb *req)\n{\n\tif (req->ki_filp)\n\t\tfput(req->ki_filp);\n\tif (req->ki_eventfd != NULL)\n\t\teventfd_ctx_put(req->ki_eventfd);\n\tkmem_cache_free(kiocb_cachep, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&ctx->reqs"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_reqs_available",
          "args": [
            "ctx",
            "1"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "put_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "838-853",
          "snippet": "static void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_run_iocb",
          "args": [
            "req",
            "iocb->aio_lio_opcode",
            "(char __user *)(unsigned long)iocb->aio_buf",
            "compat"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "aio_run_iocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "1390-1498",
          "snippet": "static ssize_t aio_run_iocb(struct kiocb *req, unsigned opcode,\n\t\t\t    char __user *buf, bool compat)\n{\n\tstruct file *file = req->ki_filp;\n\tssize_t ret;\n\tunsigned long nr_segs;\n\tint rw;\n\tfmode_t mode;\n\taio_rw_op *rw_op;\n\trw_iter_op *iter_op;\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\n\tswitch (opcode) {\n\tcase IOCB_CMD_PREAD:\n\tcase IOCB_CMD_PREADV:\n\t\tmode\t= FMODE_READ;\n\t\trw\t= READ;\n\t\trw_op\t= file->f_op->aio_read;\n\t\titer_op\t= file->f_op->read_iter;\n\t\tgoto rw_common;\n\n\tcase IOCB_CMD_PWRITE:\n\tcase IOCB_CMD_PWRITEV:\n\t\tmode\t= FMODE_WRITE;\n\t\trw\t= WRITE;\n\t\trw_op\t= file->f_op->aio_write;\n\t\titer_op\t= file->f_op->write_iter;\n\t\tgoto rw_common;\nrw_common:\n\t\tif (unlikely(!(file->f_mode & mode)))\n\t\t\treturn -EBADF;\n\n\t\tif (!rw_op && !iter_op)\n\t\t\treturn -EINVAL;\n\n\t\tret = (opcode == IOCB_CMD_PREADV ||\n\t\t       opcode == IOCB_CMD_PWRITEV)\n\t\t\t? aio_setup_vectored_rw(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t&iovec, compat)\n\t\t\t: aio_setup_single_vector(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t  iovec);\n\t\tif (!ret)\n\t\t\tret = rw_verify_area(rw, file, &req->ki_pos, req->ki_nbytes);\n\t\tif (ret < 0) {\n\t\t\tif (iovec != inline_vecs)\n\t\t\t\tkfree(iovec);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_nbytes = ret;\n\n\t\t/* XXX: move/kill - rw_verify_area()? */\n\t\t/* This matches the pread()/pwrite() logic */\n\t\tif (req->ki_pos < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_start_write(file);\n\n\t\tif (iter_op) {\n\t\t\tiov_iter_init(&iter, rw, iovec, nr_segs, req->ki_nbytes);\n\t\t\tret = iter_op(req, &iter);\n\t\t} else {\n\t\t\tret = rw_op(req, iovec, nr_segs, req->ki_pos);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_end_write(file);\n\t\tbreak;\n\n\tcase IOCB_CMD_FDSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 1);\n\t\tbreak;\n\n\tcase IOCB_CMD_FSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"EINVAL: no operation provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iovec != inline_vecs)\n\t\tkfree(iovec);\n\n\tif (ret != -EIOCBQUEUED) {\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tif (unlikely(ret == -ERESTARTSYS || ret == -ERESTARTNOINTR ||\n\t\t\t     ret == -ERESTARTNOHAND ||\n\t\t\t     ret == -ERESTART_RESTARTBLOCK))\n\t\t\tret = -EINTR;\n\t\taio_complete(req, ret, 0);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_run_iocb(struct kiocb *req, unsigned opcode,\n\t\t\t    char __user *buf, bool compat)\n{\n\tstruct file *file = req->ki_filp;\n\tssize_t ret;\n\tunsigned long nr_segs;\n\tint rw;\n\tfmode_t mode;\n\taio_rw_op *rw_op;\n\trw_iter_op *iter_op;\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\n\tswitch (opcode) {\n\tcase IOCB_CMD_PREAD:\n\tcase IOCB_CMD_PREADV:\n\t\tmode\t= FMODE_READ;\n\t\trw\t= READ;\n\t\trw_op\t= file->f_op->aio_read;\n\t\titer_op\t= file->f_op->read_iter;\n\t\tgoto rw_common;\n\n\tcase IOCB_CMD_PWRITE:\n\tcase IOCB_CMD_PWRITEV:\n\t\tmode\t= FMODE_WRITE;\n\t\trw\t= WRITE;\n\t\trw_op\t= file->f_op->aio_write;\n\t\titer_op\t= file->f_op->write_iter;\n\t\tgoto rw_common;\nrw_common:\n\t\tif (unlikely(!(file->f_mode & mode)))\n\t\t\treturn -EBADF;\n\n\t\tif (!rw_op && !iter_op)\n\t\t\treturn -EINVAL;\n\n\t\tret = (opcode == IOCB_CMD_PREADV ||\n\t\t       opcode == IOCB_CMD_PWRITEV)\n\t\t\t? aio_setup_vectored_rw(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t&iovec, compat)\n\t\t\t: aio_setup_single_vector(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t  iovec);\n\t\tif (!ret)\n\t\t\tret = rw_verify_area(rw, file, &req->ki_pos, req->ki_nbytes);\n\t\tif (ret < 0) {\n\t\t\tif (iovec != inline_vecs)\n\t\t\t\tkfree(iovec);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_nbytes = ret;\n\n\t\t/* XXX: move/kill - rw_verify_area()? */\n\t\t/* This matches the pread()/pwrite() logic */\n\t\tif (req->ki_pos < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_start_write(file);\n\n\t\tif (iter_op) {\n\t\t\tiov_iter_init(&iter, rw, iovec, nr_segs, req->ki_nbytes);\n\t\t\tret = iter_op(req, &iter);\n\t\t} else {\n\t\t\tret = rw_op(req, iovec, nr_segs, req->ki_pos);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_end_write(file);\n\t\tbreak;\n\n\tcase IOCB_CMD_FDSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 1);\n\t\tbreak;\n\n\tcase IOCB_CMD_FSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"EINVAL: no operation provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iovec != inline_vecs)\n\t\tkfree(iovec);\n\n\tif (ret != -EIOCBQUEUED) {\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tif (unlikely(ret == -ERESTARTSYS || ret == -ERESTARTNOINTR ||\n\t\t\t     ret == -ERESTARTNOHAND ||\n\t\t\t     ret == -ERESTART_RESTARTBLOCK))\n\t\t\tret = -EINTR;\n\t\taio_complete(req, ret, 0);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EFAULT: aio_key\\n\""
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "KIOCB_KEY",
            "&user_iocb->aio_key"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req->ki_eventfd"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req->ki_eventfd"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_fdget",
          "args": [
            "(int) iocb->aio_resfd"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_fdget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "347-356",
          "snippet": "struct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstruct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req->ki_filp"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "iocb->aio_fildes"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "656-659",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_get_req",
          "args": [
            "ctx"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "aio_get_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "951-972",
          "snippet": "static inline struct kiocb *aio_get_req(struct kioctx *ctx)\n{\n\tstruct kiocb *req;\n\n\tif (!get_reqs_available(ctx)) {\n\t\tuser_refill_reqs_available(ctx);\n\t\tif (!get_reqs_available(ctx))\n\t\t\treturn NULL;\n\t}\n\n\treq = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);\n\tif (unlikely(!req))\n\t\tgoto out_put;\n\n\tpercpu_ref_get(&ctx->reqs);\n\n\treq->ki_ctx = ctx;\n\treturn req;\nout_put:\n\tput_reqs_available(ctx, 1);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*kiocb_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic inline struct kiocb *aio_get_req(struct kioctx *ctx)\n{\n\tstruct kiocb *req;\n\n\tif (!get_reqs_available(ctx)) {\n\t\tuser_refill_reqs_available(ctx);\n\t\tif (!get_reqs_available(ctx))\n\t\t\treturn NULL;\n\t}\n\n\treq = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);\n\tif (unlikely(!req))\n\t\tgoto out_put;\n\n\tpercpu_ref_get(&ctx->reqs);\n\n\treq->ki_ctx = ctx;\n\treturn req;\nout_put:\n\tput_reqs_available(ctx, 1);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EINVAL: overflow check\\n\""
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(iocb->aio_buf != (unsigned long)iocb->aio_buf) ||\n\t    (iocb->aio_nbytes != (size_t)iocb->aio_nbytes) ||\n\t    ((ssize_t)iocb->aio_nbytes < 0)"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EINVAL: reserve field set\\n\""
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "iocb->aio_reserved1 || iocb->aio_reserved2"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,\n\t\t\t struct iocb *iocb, bool compat)\n{\n\tstruct kiocb *req;\n\tssize_t ret;\n\n\t/* enforce forwards compatibility on users */\n\tif (unlikely(iocb->aio_reserved1 || iocb->aio_reserved2)) {\n\t\tpr_debug(\"EINVAL: reserve field set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* prevent overflows */\n\tif (unlikely(\n\t    (iocb->aio_buf != (unsigned long)iocb->aio_buf) ||\n\t    (iocb->aio_nbytes != (size_t)iocb->aio_nbytes) ||\n\t    ((ssize_t)iocb->aio_nbytes < 0)\n\t   )) {\n\t\tpr_debug(\"EINVAL: overflow check\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treq = aio_get_req(ctx);\n\tif (unlikely(!req))\n\t\treturn -EAGAIN;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp)) {\n\t\tret = -EBADF;\n\t\tgoto out_put_req;\n\t}\n\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD) {\n\t\t/*\n\t\t * If the IOCB_FLAG_RESFD flag of aio_flags is set, get an\n\t\t * instance of the file* now. The file descriptor must be\n\t\t * an eventfd() fd, and will be signaled for each completed\n\t\t * event using the eventfd_signal() function.\n\t\t */\n\t\treq->ki_eventfd = eventfd_ctx_fdget((int) iocb->aio_resfd);\n\t\tif (IS_ERR(req->ki_eventfd)) {\n\t\t\tret = PTR_ERR(req->ki_eventfd);\n\t\t\treq->ki_eventfd = NULL;\n\t\t\tgoto out_put_req;\n\t\t}\n\t}\n\n\tret = put_user(KIOCB_KEY, &user_iocb->aio_key);\n\tif (unlikely(ret)) {\n\t\tpr_debug(\"EFAULT: aio_key\\n\");\n\t\tgoto out_put_req;\n\t}\n\n\treq->ki_obj.user = user_iocb;\n\treq->ki_user_data = iocb->aio_data;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_nbytes = iocb->aio_nbytes;\n\n\tret = aio_run_iocb(req, iocb->aio_lio_opcode,\n\t\t\t   (char __user *)(unsigned long)iocb->aio_buf,\n\t\t\t   compat);\n\tif (ret)\n\t\tgoto out_put_req;\n\n\treturn 0;\nout_put_req:\n\tput_reqs_available(ctx, 1);\n\tpercpu_ref_put(&ctx->reqs);\n\tkiocb_free(req);\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_run_iocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1390-1498",
    "snippet": "static ssize_t aio_run_iocb(struct kiocb *req, unsigned opcode,\n\t\t\t    char __user *buf, bool compat)\n{\n\tstruct file *file = req->ki_filp;\n\tssize_t ret;\n\tunsigned long nr_segs;\n\tint rw;\n\tfmode_t mode;\n\taio_rw_op *rw_op;\n\trw_iter_op *iter_op;\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\n\tswitch (opcode) {\n\tcase IOCB_CMD_PREAD:\n\tcase IOCB_CMD_PREADV:\n\t\tmode\t= FMODE_READ;\n\t\trw\t= READ;\n\t\trw_op\t= file->f_op->aio_read;\n\t\titer_op\t= file->f_op->read_iter;\n\t\tgoto rw_common;\n\n\tcase IOCB_CMD_PWRITE:\n\tcase IOCB_CMD_PWRITEV:\n\t\tmode\t= FMODE_WRITE;\n\t\trw\t= WRITE;\n\t\trw_op\t= file->f_op->aio_write;\n\t\titer_op\t= file->f_op->write_iter;\n\t\tgoto rw_common;\nrw_common:\n\t\tif (unlikely(!(file->f_mode & mode)))\n\t\t\treturn -EBADF;\n\n\t\tif (!rw_op && !iter_op)\n\t\t\treturn -EINVAL;\n\n\t\tret = (opcode == IOCB_CMD_PREADV ||\n\t\t       opcode == IOCB_CMD_PWRITEV)\n\t\t\t? aio_setup_vectored_rw(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t&iovec, compat)\n\t\t\t: aio_setup_single_vector(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t  iovec);\n\t\tif (!ret)\n\t\t\tret = rw_verify_area(rw, file, &req->ki_pos, req->ki_nbytes);\n\t\tif (ret < 0) {\n\t\t\tif (iovec != inline_vecs)\n\t\t\t\tkfree(iovec);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_nbytes = ret;\n\n\t\t/* XXX: move/kill - rw_verify_area()? */\n\t\t/* This matches the pread()/pwrite() logic */\n\t\tif (req->ki_pos < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_start_write(file);\n\n\t\tif (iter_op) {\n\t\t\tiov_iter_init(&iter, rw, iovec, nr_segs, req->ki_nbytes);\n\t\t\tret = iter_op(req, &iter);\n\t\t} else {\n\t\t\tret = rw_op(req, iovec, nr_segs, req->ki_pos);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_end_write(file);\n\t\tbreak;\n\n\tcase IOCB_CMD_FDSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 1);\n\t\tbreak;\n\n\tcase IOCB_CMD_FSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"EINVAL: no operation provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iovec != inline_vecs)\n\t\tkfree(iovec);\n\n\tif (ret != -EIOCBQUEUED) {\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tif (unlikely(ret == -ERESTARTSYS || ret == -ERESTARTNOINTR ||\n\t\t\t     ret == -ERESTARTNOHAND ||\n\t\t\t     ret == -ERESTART_RESTARTBLOCK))\n\t\t\tret = -EINTR;\n\t\taio_complete(req, ret, 0);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aio_complete",
          "args": [
            "req",
            "ret",
            "0"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "aio_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "1013-1115",
          "snippet": "void aio_complete(struct kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\n\t/*\n\t * Special case handling for sync iocbs:\n\t *  - events go directly into the iocb for fast handling\n\t *  - the sync task with the iocb in its stack holds the single iocb\n\t *    ref, no other paths have a way to get another ref\n\t *  - the sync task helpfully left a reference to itself in the iocb\n\t */\n\tif (is_sync_kiocb(iocb)) {\n\t\tiocb->ki_user_data = res;\n\t\tsmp_wmb();\n\t\tiocb->ki_ctx = ERR_PTR(-EXDEV);\n\t\twake_up_process(iocb->ki_obj.tsk);\n\t\treturn;\n\t}\n\n\tif (iocb->ki_list.next) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\t\tlist_del(&iocb->ki_list);\n\t\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n\t}\n\n\t/*\n\t * Add a completion event to the ring buffer. Must be done holding\n\t * ctx->completion_lock to prevent other code from messing with the tail\n\t * pointer since we might be called from irq context.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\n\tevent->obj = (u64)(unsigned long)iocb->ki_obj.user;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_obj.user, iocb->ki_user_data,\n\t\t res, res2);\n\n\t/* after flagging the request as done, we\n\t * must never even look at it again\n\t */\n\tsmp_wmb();\t/* make event visible before updating tail */\n\n\tctx->tail = tail;\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\n\t/*\n\t * Check if the user asked us to deliver the result through an\n\t * eventfd. The eventfd_signal() function is safe to be called\n\t * from IRQ context.\n\t */\n\tif (iocb->ki_eventfd != NULL)\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\n\t/* everything turned out well, dispose of the aiocb. */\n\tkiocb_free(iocb);\n\n\t/*\n\t * We have to order our ring_info tail store above and test\n\t * of the wait list below outside the wait lock.  This is\n\t * like in wake_up_bit() where clearing a bit has to be\n\t * ordered with the unlocked test.\n\t */\n\tsmp_mb();\n\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\n\tpercpu_ref_put(&ctx->reqs);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)",
            "#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)\n#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))\n\nvoid aio_complete(struct kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\n\t/*\n\t * Special case handling for sync iocbs:\n\t *  - events go directly into the iocb for fast handling\n\t *  - the sync task with the iocb in its stack holds the single iocb\n\t *    ref, no other paths have a way to get another ref\n\t *  - the sync task helpfully left a reference to itself in the iocb\n\t */\n\tif (is_sync_kiocb(iocb)) {\n\t\tiocb->ki_user_data = res;\n\t\tsmp_wmb();\n\t\tiocb->ki_ctx = ERR_PTR(-EXDEV);\n\t\twake_up_process(iocb->ki_obj.tsk);\n\t\treturn;\n\t}\n\n\tif (iocb->ki_list.next) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\t\tlist_del(&iocb->ki_list);\n\t\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n\t}\n\n\t/*\n\t * Add a completion event to the ring buffer. Must be done holding\n\t * ctx->completion_lock to prevent other code from messing with the tail\n\t * pointer since we might be called from irq context.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\n\tevent->obj = (u64)(unsigned long)iocb->ki_obj.user;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_obj.user, iocb->ki_user_data,\n\t\t res, res2);\n\n\t/* after flagging the request as done, we\n\t * must never even look at it again\n\t */\n\tsmp_wmb();\t/* make event visible before updating tail */\n\n\tctx->tail = tail;\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\n\t/*\n\t * Check if the user asked us to deliver the result through an\n\t * eventfd. The eventfd_signal() function is safe to be called\n\t * from IRQ context.\n\t */\n\tif (iocb->ki_eventfd != NULL)\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\n\t/* everything turned out well, dispose of the aiocb. */\n\tkiocb_free(iocb);\n\n\t/*\n\t * We have to order our ring_info tail store above and test\n\t * of the wait list below outside the wait lock.  This is\n\t * like in wake_up_bit() where clearing a bit has to be\n\t * ordered with the unlocked test.\n\t */\n\tsmp_mb();\n\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\n\tpercpu_ref_put(&ctx->reqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -ERESTARTSYS || ret == -ERESTARTNOINTR ||\n\t\t\t     ret == -ERESTARTNOHAND ||\n\t\t\t     ret == -ERESTART_RESTARTBLOCK"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iovec"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EINVAL: no operation provided\\n\""
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->aio_fsync",
          "args": [
            "req",
            "0"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->aio_fsync",
          "args": [
            "req",
            "1"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_op",
          "args": [
            "req",
            "iovec",
            "nr_segs",
            "req->ki_pos"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter_op",
          "args": [
            "req",
            "&iter"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&iter",
            "rw",
            "iovec",
            "nr_segs",
            "req->ki_nbytes"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iovec"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "rw",
            "file",
            "&req->ki_pos",
            "req->ki_nbytes"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_setup_single_vector",
          "args": [
            "req",
            "rw",
            "buf",
            "&nr_segs",
            "iovec"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "aio_setup_single_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "1372-1384",
          "snippet": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, kiocb->ki_nbytes)))\n\t\treturn -EFAULT;\n\n\tiovec->iov_base = buf;\n\tiovec->iov_len = kiocb->ki_nbytes;\n\t*nr_segs = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, kiocb->ki_nbytes)))\n\t\treturn -EFAULT;\n\n\tiovec->iov_base = buf;\n\tiovec->iov_len = kiocb->ki_nbytes;\n\t*nr_segs = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_setup_vectored_rw",
          "args": [
            "req",
            "rw",
            "buf",
            "&nr_segs",
            "&iovec",
            "compat"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "aio_setup_vectored_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "1344-1370",
          "snippet": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\n\t*nr_segs = kiocb->ki_nbytes;\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* ki_nbytes now reflect bytes instead of segs */\n\tkiocb->ki_nbytes = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\n\t*nr_segs = kiocb->ki_nbytes;\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* ki_nbytes now reflect bytes instead of segs */\n\tkiocb->ki_nbytes = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(file->f_mode & mode)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_run_iocb(struct kiocb *req, unsigned opcode,\n\t\t\t    char __user *buf, bool compat)\n{\n\tstruct file *file = req->ki_filp;\n\tssize_t ret;\n\tunsigned long nr_segs;\n\tint rw;\n\tfmode_t mode;\n\taio_rw_op *rw_op;\n\trw_iter_op *iter_op;\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\n\tswitch (opcode) {\n\tcase IOCB_CMD_PREAD:\n\tcase IOCB_CMD_PREADV:\n\t\tmode\t= FMODE_READ;\n\t\trw\t= READ;\n\t\trw_op\t= file->f_op->aio_read;\n\t\titer_op\t= file->f_op->read_iter;\n\t\tgoto rw_common;\n\n\tcase IOCB_CMD_PWRITE:\n\tcase IOCB_CMD_PWRITEV:\n\t\tmode\t= FMODE_WRITE;\n\t\trw\t= WRITE;\n\t\trw_op\t= file->f_op->aio_write;\n\t\titer_op\t= file->f_op->write_iter;\n\t\tgoto rw_common;\nrw_common:\n\t\tif (unlikely(!(file->f_mode & mode)))\n\t\t\treturn -EBADF;\n\n\t\tif (!rw_op && !iter_op)\n\t\t\treturn -EINVAL;\n\n\t\tret = (opcode == IOCB_CMD_PREADV ||\n\t\t       opcode == IOCB_CMD_PWRITEV)\n\t\t\t? aio_setup_vectored_rw(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t&iovec, compat)\n\t\t\t: aio_setup_single_vector(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t  iovec);\n\t\tif (!ret)\n\t\t\tret = rw_verify_area(rw, file, &req->ki_pos, req->ki_nbytes);\n\t\tif (ret < 0) {\n\t\t\tif (iovec != inline_vecs)\n\t\t\t\tkfree(iovec);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_nbytes = ret;\n\n\t\t/* XXX: move/kill - rw_verify_area()? */\n\t\t/* This matches the pread()/pwrite() logic */\n\t\tif (req->ki_pos < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_start_write(file);\n\n\t\tif (iter_op) {\n\t\t\tiov_iter_init(&iter, rw, iovec, nr_segs, req->ki_nbytes);\n\t\t\tret = iter_op(req, &iter);\n\t\t} else {\n\t\t\tret = rw_op(req, iovec, nr_segs, req->ki_pos);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_end_write(file);\n\t\tbreak;\n\n\tcase IOCB_CMD_FDSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 1);\n\t\tbreak;\n\n\tcase IOCB_CMD_FSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"EINVAL: no operation provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iovec != inline_vecs)\n\t\tkfree(iovec);\n\n\tif (ret != -EIOCBQUEUED) {\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tif (unlikely(ret == -ERESTARTSYS || ret == -ERESTARTNOINTR ||\n\t\t\t     ret == -ERESTARTNOHAND ||\n\t\t\t     ret == -ERESTART_RESTARTBLOCK))\n\t\t\tret = -EINTR;\n\t\taio_complete(req, ret, 0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_setup_single_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1372-1384",
    "snippet": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, kiocb->ki_nbytes)))\n\t\treturn -EFAULT;\n\n\tiovec->iov_base = buf;\n\tiovec->iov_len = kiocb->ki_nbytes;\n\t*nr_segs = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(!rw, buf, kiocb->ki_nbytes)"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "!rw",
            "buf",
            "kiocb->ki_nbytes"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, kiocb->ki_nbytes)))\n\t\treturn -EFAULT;\n\n\tiovec->iov_base = buf;\n\tiovec->iov_len = kiocb->ki_nbytes;\n\t*nr_segs = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_setup_vectored_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1344-1370",
    "snippet": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\n\t*nr_segs = kiocb->ki_nbytes;\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* ki_nbytes now reflect bytes instead of segs */\n\tkiocb->ki_nbytes = ret;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rw_copy_check_uvector",
          "args": [
            "rw",
            "(struct iovec __user *)buf",
            "*nr_segs",
            "UIO_FASTIOV",
            "*iovec",
            "iovec"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "compat_rw_copy_check_uvector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "546-617",
          "snippet": "ssize_t compat_rw_copy_check_uvector(int type,\n\t\tconst struct compat_iovec __user *uvector, unsigned long nr_segs,\n\t\tunsigned long fast_segs, struct iovec *fast_pointer,\n\t\tstruct iovec **ret_pointer)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec *iov = *ret_pointer = fast_pointer;\n\tssize_t ret = 0;\n\tint seg;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nr_segs > UIO_MAXIOV || nr_segs < 0)\n\t\tgoto out;\n\tif (nr_segs > fast_segs) {\n\t\tret = -ENOMEM;\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL)\n\t\t\tgoto out;\n\t}\n\t*ret_pointer = iov;\n\n\tret = -EFAULT;\n\tif (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))\n\t\tgoto out;\n\n\t/*\n\t * Single unix specification:\n\t * We should -EINVAL if an element length is not >= 0 and fitting an\n\t * ssize_t.\n\t *\n\t * In Linux, the total length is limited to MAX_RW_COUNT, there is\n\t * no overflow possibility.\n\t */\n\ttot_len = 0;\n\tret = -EINVAL;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tcompat_uptr_t buf;\n\t\tcompat_ssize_t len;\n\n\t\tif (__get_user(len, &uvector->iov_len) ||\n\t\t   __get_user(buf, &uvector->iov_base)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < 0)\t/* size_t not fitting in compat_ssize_t .. */\n\t\t\tgoto out;\n\t\tif (type >= 0 &&\n\t\t    !access_ok(vrfy_dir(type), compat_ptr(buf), len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - tot_len)\n\t\t\tlen = MAX_RW_COUNT - tot_len;\n\t\ttot_len += len;\n\t\tiov->iov_base = compat_ptr(buf);\n\t\tiov->iov_len = (compat_size_t) len;\n\t\tuvector++;\n\t\tiov++;\n\t}\n\tret = tot_len;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nssize_t compat_rw_copy_check_uvector(int type,\n\t\tconst struct compat_iovec __user *uvector, unsigned long nr_segs,\n\t\tunsigned long fast_segs, struct iovec *fast_pointer,\n\t\tstruct iovec **ret_pointer)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec *iov = *ret_pointer = fast_pointer;\n\tssize_t ret = 0;\n\tint seg;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nr_segs > UIO_MAXIOV || nr_segs < 0)\n\t\tgoto out;\n\tif (nr_segs > fast_segs) {\n\t\tret = -ENOMEM;\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL)\n\t\t\tgoto out;\n\t}\n\t*ret_pointer = iov;\n\n\tret = -EFAULT;\n\tif (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))\n\t\tgoto out;\n\n\t/*\n\t * Single unix specification:\n\t * We should -EINVAL if an element length is not >= 0 and fitting an\n\t * ssize_t.\n\t *\n\t * In Linux, the total length is limited to MAX_RW_COUNT, there is\n\t * no overflow possibility.\n\t */\n\ttot_len = 0;\n\tret = -EINVAL;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tcompat_uptr_t buf;\n\t\tcompat_ssize_t len;\n\n\t\tif (__get_user(len, &uvector->iov_len) ||\n\t\t   __get_user(buf, &uvector->iov_base)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < 0)\t/* size_t not fitting in compat_ssize_t .. */\n\t\t\tgoto out;\n\t\tif (type >= 0 &&\n\t\t    !access_ok(vrfy_dir(type), compat_ptr(buf), len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - tot_len)\n\t\t\tlen = MAX_RW_COUNT - tot_len;\n\t\ttot_len += len;\n\t\tiov->iov_base = compat_ptr(buf);\n\t\tiov->iov_len = (compat_size_t) len;\n\t\tuvector++;\n\t\tiov++;\n\t}\n\tret = tot_len;\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\n\t*nr_segs = kiocb->ki_nbytes;\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* ki_nbytes now reflect bytes instead of segs */\n\tkiocb->ki_nbytes = ret;\n\treturn 0;\n}"
  },
  {
    "function_name": "read_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1220-1261",
    "snippet": "static long read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\tstruct io_event __user *event,\n\t\t\tstruct timespec __user *timeout)\n{\n\tktime_t until = { .tv64 = KTIME_MAX };\n\tlong ret = 0;\n\n\tif (timeout) {\n\t\tstruct timespec\tts;\n\n\t\tif (unlikely(copy_from_user(&ts, timeout, sizeof(ts))))\n\t\t\treturn -EFAULT;\n\n\t\tuntil = timespec_to_ktime(ts);\n\t}\n\n\t/*\n\t * Note that aio_read_events() is being called as the conditional - i.e.\n\t * we're calling it after prepare_to_wait() has set task state to\n\t * TASK_INTERRUPTIBLE.\n\t *\n\t * But aio_read_events() can block, and if it blocks it's going to flip\n\t * the task state back to TASK_RUNNING.\n\t *\n\t * This should be ok, provided it doesn't flip the state back to\n\t * TASK_RUNNING and return 0 too much - that causes us to spin. That\n\t * will only happen if the mutex_lock() call blocks, and we then find\n\t * the ringbuffer empty. So in practice we should be ok, but it's\n\t * something to be aware of when touching this code.\n\t */\n\tif (until.tv64 == 0)\n\t\taio_read_events(ctx, min_nr, nr, event, &ret);\n\telse\n\t\twait_event_interruptible_hrtimeout(ctx->wait,\n\t\t\t\taio_read_events(ctx, min_nr, nr, event, &ret),\n\t\t\t\tuntil);\n\n\tif (!ret && signal_pending(current))\n\t\tret = -EINTR;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_hrtimeout",
          "args": [
            "ctx->wait",
            "aio_read_events(ctx, min_nr, nr, event, &ret)",
            "until"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_read_events",
          "args": [
            "ctx",
            "min_nr",
            "nr",
            "event",
            "&ret"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "aio_read_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "1203-1218",
          "snippet": "static bool aio_read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\t    struct io_event __user *event, long *i)\n{\n\tlong ret = aio_read_events_ring(ctx, event + *i, nr - *i);\n\n\tif (ret > 0)\n\t\t*i += ret;\n\n\tif (unlikely(atomic_read(&ctx->dead)))\n\t\tret = -EINVAL;\n\n\tif (!*i)\n\t\t*i = ret;\n\n\treturn ret < 0 || *i >= min_nr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic bool aio_read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\t    struct io_event __user *event, long *i)\n{\n\tlong ret = aio_read_events_ring(ctx, event + *i, nr - *i);\n\n\tif (ret > 0)\n\t\t*i += ret;\n\n\tif (unlikely(atomic_read(&ctx->dead)))\n\t\tret = -EINVAL;\n\n\tif (!*i)\n\t\t*i = ret;\n\n\treturn ret < 0 || *i >= min_nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec_to_ktime",
          "args": [
            "ts"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copy_from_user(&ts, timeout, sizeof(ts))"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ts",
            "timeout",
            "sizeof(ts)"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic long read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\tstruct io_event __user *event,\n\t\t\tstruct timespec __user *timeout)\n{\n\tktime_t until = { .tv64 = KTIME_MAX };\n\tlong ret = 0;\n\n\tif (timeout) {\n\t\tstruct timespec\tts;\n\n\t\tif (unlikely(copy_from_user(&ts, timeout, sizeof(ts))))\n\t\t\treturn -EFAULT;\n\n\t\tuntil = timespec_to_ktime(ts);\n\t}\n\n\t/*\n\t * Note that aio_read_events() is being called as the conditional - i.e.\n\t * we're calling it after prepare_to_wait() has set task state to\n\t * TASK_INTERRUPTIBLE.\n\t *\n\t * But aio_read_events() can block, and if it blocks it's going to flip\n\t * the task state back to TASK_RUNNING.\n\t *\n\t * This should be ok, provided it doesn't flip the state back to\n\t * TASK_RUNNING and return 0 too much - that causes us to spin. That\n\t * will only happen if the mutex_lock() call blocks, and we then find\n\t * the ringbuffer empty. So in practice we should be ok, but it's\n\t * something to be aware of when touching this code.\n\t */\n\tif (until.tv64 == 0)\n\t\taio_read_events(ctx, min_nr, nr, event, &ret);\n\telse\n\t\twait_event_interruptible_hrtimeout(ctx->wait,\n\t\t\t\taio_read_events(ctx, min_nr, nr, event, &ret),\n\t\t\t\tuntil);\n\n\tif (!ret && signal_pending(current))\n\t\tret = -EINTR;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_read_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1203-1218",
    "snippet": "static bool aio_read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\t    struct io_event __user *event, long *i)\n{\n\tlong ret = aio_read_events_ring(ctx, event + *i, nr - *i);\n\n\tif (ret > 0)\n\t\t*i += ret;\n\n\tif (unlikely(atomic_read(&ctx->dead)))\n\t\tret = -EINVAL;\n\n\tif (!*i)\n\t\t*i = ret;\n\n\treturn ret < 0 || *i >= min_nr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&ctx->dead)"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ctx->dead"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_read_events_ring",
          "args": [
            "ctx",
            "event + *i",
            "nr - *i"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "aio_read_events_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "1122-1201",
          "snippet": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\t/*\n\t * The mutex can block and wake us up and that will cause\n\t * wait_event_interruptible_hrtimeout() to schedule without sleeping\n\t * and repeat. This should be rare enough that it doesn't cause\n\t * peformance issues. See the comment in read_events() for more detail.\n\t */\n\tsched_annotate_sleep();\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\t/*\n\t * Ensure that once we've read the current tail pointer, that\n\t * we also see the events that were stored up to the tail.\n\t */\n\tsmp_rmb();\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)",
            "#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)\n#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))\n\nstatic long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\t/*\n\t * The mutex can block and wake us up and that will cause\n\t * wait_event_interruptible_hrtimeout() to schedule without sleeping\n\t * and repeat. This should be rare enough that it doesn't cause\n\t * peformance issues. See the comment in read_events() for more detail.\n\t */\n\tsched_annotate_sleep();\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\t/*\n\t * Ensure that once we've read the current tail pointer, that\n\t * we also see the events that were stored up to the tail.\n\t */\n\tsmp_rmb();\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic bool aio_read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\t    struct io_event __user *event, long *i)\n{\n\tlong ret = aio_read_events_ring(ctx, event + *i, nr - *i);\n\n\tif (ret > 0)\n\t\t*i += ret;\n\n\tif (unlikely(atomic_read(&ctx->dead)))\n\t\tret = -EINVAL;\n\n\tif (!*i)\n\t\t*i = ret;\n\n\treturn ret < 0 || *i >= min_nr;\n}"
  },
  {
    "function_name": "aio_read_events_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1122-1201",
    "snippet": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\t/*\n\t * The mutex can block and wake us up and that will cause\n\t * wait_event_interruptible_hrtimeout() to schedule without sleeping\n\t * and repeat. This should be rare enough that it doesn't cause\n\t * peformance issues. See the comment in read_events() for more detail.\n\t */\n\tsched_annotate_sleep();\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\t/*\n\t * Ensure that once we've read the current tail pointer, that\n\t * we also see the events that were stored up to the tail.\n\t */\n\tsmp_rmb();\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)",
      "#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%li  h%u t%u\\n\"",
            "ret",
            "head",
            "tail"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copy_ret"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "event + ret",
            "ev + pos",
            "sizeof(*ev) * avail"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "long",
            "avail",
            "AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "avail",
            "nr - ret"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"h%u t%u m%u\\n\"",
            "head",
            "tail",
            "ctx->nr_events"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)\n#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))\n\nstatic long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\t/*\n\t * The mutex can block and wake us up and that will cause\n\t * wait_event_interruptible_hrtimeout() to schedule without sleeping\n\t * and repeat. This should be rare enough that it doesn't cause\n\t * peformance issues. See the comment in read_events() for more detail.\n\t */\n\tsched_annotate_sleep();\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\t/*\n\t * Ensure that once we've read the current tail pointer, that\n\t * we also see the events that were stored up to the tail.\n\t */\n\tsmp_rmb();\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "1013-1115",
    "snippet": "void aio_complete(struct kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\n\t/*\n\t * Special case handling for sync iocbs:\n\t *  - events go directly into the iocb for fast handling\n\t *  - the sync task with the iocb in its stack holds the single iocb\n\t *    ref, no other paths have a way to get another ref\n\t *  - the sync task helpfully left a reference to itself in the iocb\n\t */\n\tif (is_sync_kiocb(iocb)) {\n\t\tiocb->ki_user_data = res;\n\t\tsmp_wmb();\n\t\tiocb->ki_ctx = ERR_PTR(-EXDEV);\n\t\twake_up_process(iocb->ki_obj.tsk);\n\t\treturn;\n\t}\n\n\tif (iocb->ki_list.next) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\t\tlist_del(&iocb->ki_list);\n\t\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n\t}\n\n\t/*\n\t * Add a completion event to the ring buffer. Must be done holding\n\t * ctx->completion_lock to prevent other code from messing with the tail\n\t * pointer since we might be called from irq context.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\n\tevent->obj = (u64)(unsigned long)iocb->ki_obj.user;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_obj.user, iocb->ki_user_data,\n\t\t res, res2);\n\n\t/* after flagging the request as done, we\n\t * must never even look at it again\n\t */\n\tsmp_wmb();\t/* make event visible before updating tail */\n\n\tctx->tail = tail;\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\n\t/*\n\t * Check if the user asked us to deliver the result through an\n\t * eventfd. The eventfd_signal() function is safe to be called\n\t * from IRQ context.\n\t */\n\tif (iocb->ki_eventfd != NULL)\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\n\t/* everything turned out well, dispose of the aiocb. */\n\tkiocb_free(iocb);\n\n\t/*\n\t * We have to order our ring_info tail store above and test\n\t * of the wait list below outside the wait lock.  This is\n\t * like in wake_up_bit() where clearing a bit has to be\n\t * ordered with the unlocked test.\n\t */\n\tsmp_mb();\n\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\n\tpercpu_ref_put(&ctx->reqs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)",
      "#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&ctx->reqs"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&ctx->wait"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wait"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kiocb_free",
          "args": [
            "iocb"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "kiocb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "974-981",
          "snippet": "static void kiocb_free(struct kiocb *req)\n{\n\tif (req->ki_filp)\n\t\tfput(req->ki_filp);\n\tif (req->ki_eventfd != NULL)\n\t\teventfd_ctx_put(req->ki_eventfd);\n\tkmem_cache_free(kiocb_cachep, req);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*kiocb_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic void kiocb_free(struct kiocb *req)\n{\n\tif (req->ki_filp)\n\t\tfput(req->ki_filp);\n\tif (req->ki_eventfd != NULL)\n\t\teventfd_ctx_put(req->ki_eventfd);\n\tkmem_cache_free(kiocb_cachep, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "iocb->ki_eventfd",
            "1"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "54-67",
          "snippet": "__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, POLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\n__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, POLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"added to ring %p at [%u]\\n\"",
            "iocb",
            "tail"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->completion_lock",
            "flags"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refill_reqs_available",
          "args": [
            "ctx",
            "head",
            "tail"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "refill_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "892-915",
          "snippet": "static void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%p[%u]: %p: %p %Lx %lx %lx\\n\"",
            "ctx",
            "tail",
            "iocb",
            "iocb->ki_obj.user",
            "iocb->ki_user_data",
            "res",
            "res2"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ev_page"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->completion_lock",
            "flags"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->ctx_lock",
            "flags"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&iocb->ki_list"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->ctx_lock",
            "flags"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "iocb->ki_obj.tsk"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EXDEV"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)\n#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))\n\nvoid aio_complete(struct kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\n\t/*\n\t * Special case handling for sync iocbs:\n\t *  - events go directly into the iocb for fast handling\n\t *  - the sync task with the iocb in its stack holds the single iocb\n\t *    ref, no other paths have a way to get another ref\n\t *  - the sync task helpfully left a reference to itself in the iocb\n\t */\n\tif (is_sync_kiocb(iocb)) {\n\t\tiocb->ki_user_data = res;\n\t\tsmp_wmb();\n\t\tiocb->ki_ctx = ERR_PTR(-EXDEV);\n\t\twake_up_process(iocb->ki_obj.tsk);\n\t\treturn;\n\t}\n\n\tif (iocb->ki_list.next) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\t\tlist_del(&iocb->ki_list);\n\t\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n\t}\n\n\t/*\n\t * Add a completion event to the ring buffer. Must be done holding\n\t * ctx->completion_lock to prevent other code from messing with the tail\n\t * pointer since we might be called from irq context.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\n\tevent->obj = (u64)(unsigned long)iocb->ki_obj.user;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_obj.user, iocb->ki_user_data,\n\t\t res, res2);\n\n\t/* after flagging the request as done, we\n\t * must never even look at it again\n\t */\n\tsmp_wmb();\t/* make event visible before updating tail */\n\n\tctx->tail = tail;\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\n\t/*\n\t * Check if the user asked us to deliver the result through an\n\t * eventfd. The eventfd_signal() function is safe to be called\n\t * from IRQ context.\n\t */\n\tif (iocb->ki_eventfd != NULL)\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\n\t/* everything turned out well, dispose of the aiocb. */\n\tkiocb_free(iocb);\n\n\t/*\n\t * We have to order our ring_info tail store above and test\n\t * of the wait list below outside the wait lock.  This is\n\t * like in wake_up_bit() where clearing a bit has to be\n\t * ordered with the unlocked test.\n\t */\n\tsmp_mb();\n\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\n\tpercpu_ref_put(&ctx->reqs);\n}"
  },
  {
    "function_name": "lookup_ioctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "983-1008",
    "snippet": "static struct kioctx *lookup_ioctx(unsigned long ctx_id)\n{\n\tstruct aio_ring __user *ring  = (void __user *)ctx_id;\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx, *ret = NULL;\n\tstruct kioctx_table *table;\n\tunsigned id;\n\n\tif (get_user(id, &ring->id))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tif (!table || id >= table->nr)\n\t\tgoto out;\n\n\tctx = table->table[id];\n\tif (ctx && ctx->user_id == ctx_id) {\n\t\tpercpu_ref_get(&ctx->users);\n\t\tret = ctx;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_get",
          "args": [
            "&ctx->users"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "id",
            "&ring->id"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kioctx *lookup_ioctx(unsigned long ctx_id)\n{\n\tstruct aio_ring __user *ring  = (void __user *)ctx_id;\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx, *ret = NULL;\n\tstruct kioctx_table *table;\n\tunsigned id;\n\n\tif (get_user(id, &ring->id))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tif (!table || id >= table->nr)\n\t\tgoto out;\n\n\tctx = table->table[id];\n\tif (ctx && ctx->user_id == ctx_id) {\n\t\tpercpu_ref_get(&ctx->users);\n\t\tret = ctx;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "kiocb_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "974-981",
    "snippet": "static void kiocb_free(struct kiocb *req)\n{\n\tif (req->ki_filp)\n\t\tfput(req->ki_filp);\n\tif (req->ki_eventfd != NULL)\n\t\teventfd_ctx_put(req->ki_eventfd);\n\tkmem_cache_free(kiocb_cachep, req);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*kiocb_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kiocb_cachep",
            "req"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "req->ki_eventfd"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventfd.c",
          "lines": "102-105",
          "snippet": "void eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "req->ki_filp"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic void kiocb_free(struct kiocb *req)\n{\n\tif (req->ki_filp)\n\t\tfput(req->ki_filp);\n\tif (req->ki_eventfd != NULL)\n\t\teventfd_ctx_put(req->ki_eventfd);\n\tkmem_cache_free(kiocb_cachep, req);\n}"
  },
  {
    "function_name": "aio_get_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "951-972",
    "snippet": "static inline struct kiocb *aio_get_req(struct kioctx *ctx)\n{\n\tstruct kiocb *req;\n\n\tif (!get_reqs_available(ctx)) {\n\t\tuser_refill_reqs_available(ctx);\n\t\tif (!get_reqs_available(ctx))\n\t\t\treturn NULL;\n\t}\n\n\treq = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);\n\tif (unlikely(!req))\n\t\tgoto out_put;\n\n\tpercpu_ref_get(&ctx->reqs);\n\n\treq->ki_ctx = ctx;\n\treturn req;\nout_put:\n\tput_reqs_available(ctx, 1);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*kiocb_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_reqs_available",
          "args": [
            "ctx",
            "1"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "put_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "838-853",
          "snippet": "static void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_get",
          "args": [
            "&ctx->reqs"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "kiocb_cachep",
            "GFP_KERNEL|__GFP_ZERO"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_reqs_available",
          "args": [
            "ctx"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "get_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "855-883",
          "snippet": "static bool get_reqs_available(struct kioctx *ctx)\n{\n\tstruct kioctx_cpu *kcpu;\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tif (!kcpu->reqs_available) {\n\t\tint old, avail = atomic_read(&ctx->reqs_available);\n\n\t\tdo {\n\t\t\tif (avail < ctx->req_batch)\n\t\t\t\tgoto out;\n\n\t\t\told = avail;\n\t\t\tavail = atomic_cmpxchg(&ctx->reqs_available,\n\t\t\t\t\t       avail, avail - ctx->req_batch);\n\t\t} while (avail != old);\n\n\t\tkcpu->reqs_available += ctx->req_batch;\n\t}\n\n\tret = true;\n\tkcpu->reqs_available--;\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic bool get_reqs_available(struct kioctx *ctx)\n{\n\tstruct kioctx_cpu *kcpu;\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tif (!kcpu->reqs_available) {\n\t\tint old, avail = atomic_read(&ctx->reqs_available);\n\n\t\tdo {\n\t\t\tif (avail < ctx->req_batch)\n\t\t\t\tgoto out;\n\n\t\t\told = avail;\n\t\t\tavail = atomic_cmpxchg(&ctx->reqs_available,\n\t\t\t\t\t       avail, avail - ctx->req_batch);\n\t\t} while (avail != old);\n\n\t\tkcpu->reqs_available += ctx->req_batch;\n\t}\n\n\tret = true;\n\tkcpu->reqs_available--;\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_refill_reqs_available",
          "args": [
            "ctx"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "user_refill_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "921-945",
          "snippet": "static void user_refill_reqs_available(struct kioctx *ctx)\n{\n\tspin_lock_irq(&ctx->completion_lock);\n\tif (ctx->completed_events) {\n\t\tstruct aio_ring *ring;\n\t\tunsigned head;\n\n\t\t/* Access of ring->head may race with aio_read_events_ring()\n\t\t * here, but that's okay since whether we read the old version\n\t\t * or the new version, and either will be valid.  The important\n\t\t * part is that head cannot pass tail since we prevent\n\t\t * aio_complete() from updating tail by holding\n\t\t * ctx->completion_lock.  Even if head is invalid, the check\n\t\t * against ctx->completed_events below will make sure we do the\n\t\t * safe/right thing.\n\t\t */\n\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\thead = ring->head;\n\t\tkunmap_atomic(ring);\n\n\t\trefill_reqs_available(ctx, head, ctx->tail);\n\t}\n\n\tspin_unlock_irq(&ctx->completion_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void user_refill_reqs_available(struct kioctx *ctx)\n{\n\tspin_lock_irq(&ctx->completion_lock);\n\tif (ctx->completed_events) {\n\t\tstruct aio_ring *ring;\n\t\tunsigned head;\n\n\t\t/* Access of ring->head may race with aio_read_events_ring()\n\t\t * here, but that's okay since whether we read the old version\n\t\t * or the new version, and either will be valid.  The important\n\t\t * part is that head cannot pass tail since we prevent\n\t\t * aio_complete() from updating tail by holding\n\t\t * ctx->completion_lock.  Even if head is invalid, the check\n\t\t * against ctx->completed_events below will make sure we do the\n\t\t * safe/right thing.\n\t\t */\n\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\thead = ring->head;\n\t\tkunmap_atomic(ring);\n\n\t\trefill_reqs_available(ctx, head, ctx->tail);\n\t}\n\n\tspin_unlock_irq(&ctx->completion_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic inline struct kiocb *aio_get_req(struct kioctx *ctx)\n{\n\tstruct kiocb *req;\n\n\tif (!get_reqs_available(ctx)) {\n\t\tuser_refill_reqs_available(ctx);\n\t\tif (!get_reqs_available(ctx))\n\t\t\treturn NULL;\n\t}\n\n\treq = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);\n\tif (unlikely(!req))\n\t\tgoto out_put;\n\n\tpercpu_ref_get(&ctx->reqs);\n\n\treq->ki_ctx = ctx;\n\treturn req;\nout_put:\n\tput_reqs_available(ctx, 1);\n\treturn NULL;\n}"
  },
  {
    "function_name": "user_refill_reqs_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "921-945",
    "snippet": "static void user_refill_reqs_available(struct kioctx *ctx)\n{\n\tspin_lock_irq(&ctx->completion_lock);\n\tif (ctx->completed_events) {\n\t\tstruct aio_ring *ring;\n\t\tunsigned head;\n\n\t\t/* Access of ring->head may race with aio_read_events_ring()\n\t\t * here, but that's okay since whether we read the old version\n\t\t * or the new version, and either will be valid.  The important\n\t\t * part is that head cannot pass tail since we prevent\n\t\t * aio_complete() from updating tail by holding\n\t\t * ctx->completion_lock.  Even if head is invalid, the check\n\t\t * against ctx->completed_events below will make sure we do the\n\t\t * safe/right thing.\n\t\t */\n\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\thead = ring->head;\n\t\tkunmap_atomic(ring);\n\n\t\trefill_reqs_available(ctx, head, ctx->tail);\n\t}\n\n\tspin_unlock_irq(&ctx->completion_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->completion_lock"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refill_reqs_available",
          "args": [
            "ctx",
            "head",
            "ctx->tail"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "refill_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "892-915",
          "snippet": "static void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->completion_lock"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void user_refill_reqs_available(struct kioctx *ctx)\n{\n\tspin_lock_irq(&ctx->completion_lock);\n\tif (ctx->completed_events) {\n\t\tstruct aio_ring *ring;\n\t\tunsigned head;\n\n\t\t/* Access of ring->head may race with aio_read_events_ring()\n\t\t * here, but that's okay since whether we read the old version\n\t\t * or the new version, and either will be valid.  The important\n\t\t * part is that head cannot pass tail since we prevent\n\t\t * aio_complete() from updating tail by holding\n\t\t * ctx->completion_lock.  Even if head is invalid, the check\n\t\t * against ctx->completed_events below will make sure we do the\n\t\t * safe/right thing.\n\t\t */\n\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\thead = ring->head;\n\t\tkunmap_atomic(ring);\n\n\t\trefill_reqs_available(ctx, head, ctx->tail);\n\t}\n\n\tspin_unlock_irq(&ctx->completion_lock);\n}"
  },
  {
    "function_name": "refill_reqs_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "892-915",
    "snippet": "static void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_reqs_available",
          "args": [
            "ctx",
            "completed"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "put_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "838-853",
          "snippet": "static void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}"
  },
  {
    "function_name": "get_reqs_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "855-883",
    "snippet": "static bool get_reqs_available(struct kioctx *ctx)\n{\n\tstruct kioctx_cpu *kcpu;\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tif (!kcpu->reqs_available) {\n\t\tint old, avail = atomic_read(&ctx->reqs_available);\n\n\t\tdo {\n\t\t\tif (avail < ctx->req_batch)\n\t\t\t\tgoto out;\n\n\t\t\told = avail;\n\t\t\tavail = atomic_cmpxchg(&ctx->reqs_available,\n\t\t\t\t\t       avail, avail - ctx->req_batch);\n\t\t} while (avail != old);\n\n\t\tkcpu->reqs_available += ctx->req_batch;\n\t}\n\n\tret = true;\n\tkcpu->reqs_available--;\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&ctx->reqs_available",
            "avail",
            "avail - ctx->req_batch"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ctx->reqs_available"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "ctx->cpu"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic bool get_reqs_available(struct kioctx *ctx)\n{\n\tstruct kioctx_cpu *kcpu;\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tif (!kcpu->reqs_available) {\n\t\tint old, avail = atomic_read(&ctx->reqs_available);\n\n\t\tdo {\n\t\t\tif (avail < ctx->req_batch)\n\t\t\t\tgoto out;\n\n\t\t\told = avail;\n\t\t\tavail = atomic_cmpxchg(&ctx->reqs_available,\n\t\t\t\t\t       avail, avail - ctx->req_batch);\n\t\t} while (avail != old);\n\n\t\tkcpu->reqs_available += ctx->req_batch;\n\t}\n\n\tret = true;\n\tkcpu->reqs_available--;\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "put_reqs_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "838-853",
    "snippet": "static void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "ctx->req_batch",
            "&ctx->reqs_available"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "ctx->cpu"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "exit_aio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "805-836",
    "snippet": "void exit_aio(struct mm_struct *mm)\n{\n\tstruct kioctx_table *table = rcu_dereference_raw(mm->ioctx_table);\n\tint i;\n\n\tif (!table)\n\t\treturn;\n\n\tfor (i = 0; i < table->nr; ++i) {\n\t\tstruct kioctx *ctx = table->table[i];\n\t\tstruct completion requests_done =\n\t\t\tCOMPLETION_INITIALIZER_ONSTACK(requests_done);\n\n\t\tif (!ctx)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to bother with munmap() here - exit_mmap(mm)\n\t\t * is coming and it'll unmap everything. And we simply can't,\n\t\t * this is not necessarily our ->mm.\n\t\t * Since kill_ioctx() uses non-zero ->mmap_size as indicator\n\t\t * that it needs to unmap the area, just set it to 0.\n\t\t */\n\t\tctx->mmap_size = 0;\n\t\tkill_ioctx(mm, ctx, &requests_done);\n\n\t\t/* Wait until all IO for the context are done. */\n\t\twait_for_completion(&requests_done);\n\t}\n\n\tRCU_INIT_POINTER(mm->ioctx_table, NULL);\n\tkfree(table);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "mm->ioctx_table",
            "NULL"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&requests_done"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_ioctx",
          "args": [
            "mm",
            "ctx",
            "&requests_done"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "kill_ioctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "746-779",
          "snippet": "static int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\tstruct completion *requests_done)\n{\n\tstruct kioctx_table *table;\n\n\tif (atomic_xchg(&ctx->dead, 1))\n\t\treturn -EINVAL;\n\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\tWARN_ON(ctx != table->table[ctx->id]);\n\ttable->table[ctx->id] = NULL;\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* percpu_ref_kill() will do the necessary call_rcu() */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->requests_done = requests_done;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\tstruct completion *requests_done)\n{\n\tstruct kioctx_table *table;\n\n\tif (atomic_xchg(&ctx->dead, 1))\n\t\treturn -EINVAL;\n\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\tWARN_ON(ctx != table->table[ctx->id]);\n\ttable->table[ctx->id] = NULL;\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* percpu_ref_kill() will do the necessary call_rcu() */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->requests_done = requests_done;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPLETION_INITIALIZER_ONSTACK",
          "args": [
            "requests_done"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid exit_aio(struct mm_struct *mm)\n{\n\tstruct kioctx_table *table = rcu_dereference_raw(mm->ioctx_table);\n\tint i;\n\n\tif (!table)\n\t\treturn;\n\n\tfor (i = 0; i < table->nr; ++i) {\n\t\tstruct kioctx *ctx = table->table[i];\n\t\tstruct completion requests_done =\n\t\t\tCOMPLETION_INITIALIZER_ONSTACK(requests_done);\n\n\t\tif (!ctx)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to bother with munmap() here - exit_mmap(mm)\n\t\t * is coming and it'll unmap everything. And we simply can't,\n\t\t * this is not necessarily our ->mm.\n\t\t * Since kill_ioctx() uses non-zero ->mmap_size as indicator\n\t\t * that it needs to unmap the area, just set it to 0.\n\t\t */\n\t\tctx->mmap_size = 0;\n\t\tkill_ioctx(mm, ctx, &requests_done);\n\n\t\t/* Wait until all IO for the context are done. */\n\t\twait_for_completion(&requests_done);\n\t}\n\n\tRCU_INIT_POINTER(mm->ioctx_table, NULL);\n\tkfree(table);\n}"
  },
  {
    "function_name": "wait_on_sync_kiocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "784-794",
    "snippet": "ssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nssize_t wait_on_sync_kiocb(struct kiocb *req)\n{\n\twhile (!req->ki_ctx) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (req->ki_ctx)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn req->ki_user_data;\n}"
  },
  {
    "function_name": "kill_ioctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "746-779",
    "snippet": "static int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\tstruct completion *requests_done)\n{\n\tstruct kioctx_table *table;\n\n\tif (atomic_xchg(&ctx->dead, 1))\n\t\treturn -EINVAL;\n\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\tWARN_ON(ctx != table->table[ctx->id]);\n\ttable->table[ctx->id] = NULL;\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* percpu_ref_kill() will do the necessary call_rcu() */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->requests_done = requests_done;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&ctx->users"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "ctx->mmap_base",
            "ctx->mmap_size"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_nr_sub",
          "args": [
            "ctx->max_reqs"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "aio_nr_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "626-634",
          "snippet": "static void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(aio_nr_lock);",
            "unsigned long aio_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(aio_nr_lock);\nunsigned long aio_nr;\n\nstatic void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ctx->wait"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ctx != table->table[ctx->id]"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&ctx->dead",
            "1"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\tstruct completion *requests_done)\n{\n\tstruct kioctx_table *table;\n\n\tif (atomic_xchg(&ctx->dead, 1))\n\t\treturn -EINVAL;\n\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\tWARN_ON(ctx != table->table[ctx->id]);\n\ttable->table[ctx->id] = NULL;\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* percpu_ref_kill() will do the necessary call_rcu() */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->requests_done = requests_done;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}"
  },
  {
    "function_name": "ioctx_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "639-739",
    "snippet": "static struct kioctx *ioctx_alloc(unsigned nr_events)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx;\n\tint err = -ENOMEM;\n\n\t/*\n\t * We keep track of the number of available ringbuffer slots, to prevent\n\t * overflow (reqs_available), and we also use percpu counters for this.\n\t *\n\t * So since up to half the slots might be on other cpu's percpu counters\n\t * and unavailable, double nr_events so userspace sees what they\n\t * expected: additionally, we move req_batch slots to/from percpu\n\t * counters at a time, so make sure that isn't 0:\n\t */\n\tnr_events = max(nr_events, num_possible_cpus() * 4);\n\tnr_events *= 2;\n\n\t/* Prevent overflows */\n\tif ((nr_events > (0x10000000U / sizeof(struct io_event))) ||\n\t    (nr_events > (0x10000000U / sizeof(struct kiocb)))) {\n\t\tpr_debug(\"ENOMEM: nr_events too high\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_events || (unsigned long)nr_events > (aio_max_nr * 2UL))\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tctx = kmem_cache_zalloc(kioctx_cachep, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->max_reqs = nr_events;\n\n\tspin_lock_init(&ctx->ctx_lock);\n\tspin_lock_init(&ctx->completion_lock);\n\tmutex_init(&ctx->ring_lock);\n\t/* Protect against page migration throughout kiotx setup by keeping\n\t * the ring_lock mutex held until setup is complete. */\n\tmutex_lock(&ctx->ring_lock);\n\tinit_waitqueue_head(&ctx->wait);\n\n\tINIT_LIST_HEAD(&ctx->active_reqs);\n\n\tif (percpu_ref_init(&ctx->users, free_ioctx_users, 0, GFP_KERNEL))\n\t\tgoto err;\n\n\tif (percpu_ref_init(&ctx->reqs, free_ioctx_reqs, 0, GFP_KERNEL))\n\t\tgoto err;\n\n\tctx->cpu = alloc_percpu(struct kioctx_cpu);\n\tif (!ctx->cpu)\n\t\tgoto err;\n\n\terr = aio_setup_ring(ctx);\n\tif (err < 0)\n\t\tgoto err;\n\n\tatomic_set(&ctx->reqs_available, ctx->nr_events - 1);\n\tctx->req_batch = (ctx->nr_events - 1) / (num_possible_cpus() * 4);\n\tif (ctx->req_batch < 1)\n\t\tctx->req_batch = 1;\n\n\t/* limit the number of system wide aios */\n\tspin_lock(&aio_nr_lock);\n\tif (aio_nr + nr_events > (aio_max_nr * 2UL) ||\n\t    aio_nr + nr_events < aio_nr) {\n\t\tspin_unlock(&aio_nr_lock);\n\t\terr = -EAGAIN;\n\t\tgoto err_ctx;\n\t}\n\taio_nr += ctx->max_reqs;\n\tspin_unlock(&aio_nr_lock);\n\n\tpercpu_ref_get(&ctx->users);\t/* io_setup() will drop this ref */\n\tpercpu_ref_get(&ctx->reqs);\t/* free_ioctx_users() will drop this */\n\n\terr = ioctx_add_table(ctx, mm);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\t/* Release the ring_lock mutex now that all setup is complete. */\n\tmutex_unlock(&ctx->ring_lock);\n\n\tpr_debug(\"allocated ioctx %p[%ld]: mm=%p mask=0x%x\\n\",\n\t\t ctx, ctx->user_id, mm, ctx->nr_events);\n\treturn ctx;\n\nerr_cleanup:\n\taio_nr_sub(ctx->max_reqs);\nerr_ctx:\n\taio_free_ring(ctx);\nerr:\n\tmutex_unlock(&ctx->ring_lock);\n\tfree_percpu(ctx->cpu);\n\tpercpu_ref_exit(&ctx->reqs);\n\tpercpu_ref_exit(&ctx->users);\n\tkmem_cache_free(kioctx_cachep, ctx);\n\tpr_debug(\"error allocating ioctx %d\\n\", err);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(aio_nr_lock);",
      "unsigned long aio_nr;",
      "unsigned long aio_max_nr = 0x10000;",
      "static struct kmem_cache\t*kioctx_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"error allocating ioctx %d\\n\"",
            "err"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kioctx_cachep",
            "ctx"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&ctx->users"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&ctx->reqs"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "ctx->cpu"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_free_ring",
          "args": [
            "ctx"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "aio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "248-272",
          "snippet": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_nr_sub",
          "args": [
            "ctx->max_reqs"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "aio_nr_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "626-634",
          "snippet": "static void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(aio_nr_lock);",
            "unsigned long aio_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(aio_nr_lock);\nunsigned long aio_nr;\n\nstatic void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"allocated ioctx %p[%ld]: mm=%p mask=0x%x\\n\"",
            "ctx",
            "ctx->user_id",
            "mm",
            "ctx->nr_events"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctx_add_table",
          "args": [
            "ctx",
            "mm"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "ioctx_add_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "571-624",
          "snippet": "static int ioctx_add_table(struct kioctx *ctx, struct mm_struct *mm)\n{\n\tunsigned i, new_nr;\n\tstruct kioctx_table *table, *old;\n\tstruct aio_ring *ring;\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\n\twhile (1) {\n\t\tif (table)\n\t\t\tfor (i = 0; i < table->nr; i++)\n\t\t\t\tif (!table->table[i]) {\n\t\t\t\t\tctx->id = i;\n\t\t\t\t\ttable->table[i] = ctx;\n\t\t\t\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\t\t\t\t/* While kioctx setup is in progress,\n\t\t\t\t\t * we are protected from page migration\n\t\t\t\t\t * changes ring_pages by ->ring_lock.\n\t\t\t\t\t */\n\t\t\t\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\t\t\t\tring->id = ctx->id;\n\t\t\t\t\tkunmap_atomic(ring);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\tnew_nr = (table ? table->nr : 1) * 4;\n\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\ttable = kzalloc(sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\ttable->nr = new_nr;\n\n\t\tspin_lock(&mm->ioctx_lock);\n\t\told = rcu_dereference_raw(mm->ioctx_table);\n\n\t\tif (!old) {\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t} else if (table->nr > old->nr) {\n\t\t\tmemcpy(table->table, old->table,\n\t\t\t       old->nr * sizeof(struct kioctx *));\n\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t\tkfree_rcu(old, rcu);\n\t\t} else {\n\t\t\tkfree(table);\n\t\t\ttable = old;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int ioctx_add_table(struct kioctx *ctx, struct mm_struct *mm)\n{\n\tunsigned i, new_nr;\n\tstruct kioctx_table *table, *old;\n\tstruct aio_ring *ring;\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\n\twhile (1) {\n\t\tif (table)\n\t\t\tfor (i = 0; i < table->nr; i++)\n\t\t\t\tif (!table->table[i]) {\n\t\t\t\t\tctx->id = i;\n\t\t\t\t\ttable->table[i] = ctx;\n\t\t\t\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\t\t\t\t/* While kioctx setup is in progress,\n\t\t\t\t\t * we are protected from page migration\n\t\t\t\t\t * changes ring_pages by ->ring_lock.\n\t\t\t\t\t */\n\t\t\t\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\t\t\t\tring->id = ctx->id;\n\t\t\t\t\tkunmap_atomic(ring);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\tnew_nr = (table ? table->nr : 1) * 4;\n\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\ttable = kzalloc(sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\ttable->nr = new_nr;\n\n\t\tspin_lock(&mm->ioctx_lock);\n\t\told = rcu_dereference_raw(mm->ioctx_table);\n\n\t\tif (!old) {\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t} else if (table->nr > old->nr) {\n\t\t\tmemcpy(table->table, old->table,\n\t\t\t       old->nr * sizeof(struct kioctx *));\n\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t\tkfree_rcu(old, rcu);\n\t\t} else {\n\t\t\tkfree(table);\n\t\t\ttable = old;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_get",
          "args": [
            "&ctx->reqs"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_get",
          "args": [
            "&ctx->users"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&aio_nr_lock"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&aio_nr_lock"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ctx->reqs_available",
            "ctx->nr_events - 1"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_setup_ring",
          "args": [
            "ctx"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "aio_setup_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "386-477",
          "snippet": "static int aio_setup_ring(struct kioctx *ctx)\n{\n\tstruct aio_ring *ring;\n\tunsigned nr_events = ctx->max_reqs;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size, unused;\n\tint nr_pages;\n\tint i;\n\tstruct file *file;\n\n\t/* Compensate for the ring buffer's head/tail overlap entry */\n\tnr_events += 2;\t/* 1 is required, 2 for good luck */\n\n\tsize = sizeof(struct aio_ring);\n\tsize += sizeof(struct io_event) * nr_events;\n\n\tnr_pages = PFN_UP(size);\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tfile = aio_private_file(ctx, nr_pages);\n\tif (IS_ERR(file)) {\n\t\tctx->aio_ring_file = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->aio_ring_file = file;\n\tnr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring))\n\t\t\t/ sizeof(struct io_event);\n\n\tctx->ring_pages = ctx->internal_pages;\n\tif (nr_pages > AIO_RING_PAGES) {\n\t\tctx->ring_pages = kcalloc(nr_pages, sizeof(struct page *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->ring_pages) {\n\t\t\tput_aio_ring_file(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpage = find_or_create_page(file->f_inode->i_mapping,\n\t\t\t\t\t   i, GFP_HIGHUSER | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpr_debug(\"pid(%d) page[%d]->count=%d\\n\",\n\t\t\t current->pid, i, page_count(page));\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tctx->ring_pages[i] = page;\n\t}\n\tctx->nr_pages = i;\n\n\tif (unlikely(i != nr_pages)) {\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mmap_size = nr_pages * PAGE_SIZE;\n\tpr_debug(\"attempting mmap of %lu bytes\\n\", ctx->mmap_size);\n\n\tdown_write(&mm->mmap_sem);\n\tctx->mmap_base = do_mmap_pgoff(ctx->aio_ring_file, 0, ctx->mmap_size,\n\t\t\t\t       PROT_READ | PROT_WRITE,\n\t\t\t\t       MAP_SHARED, 0, &unused);\n\tup_write(&mm->mmap_sem);\n\tif (IS_ERR((void *)ctx->mmap_base)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"mmap address: 0x%08lx\\n\", ctx->mmap_base);\n\n\tctx->user_id = ctx->mmap_base;\n\tctx->nr_events = nr_events; /* trusted copy */\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->nr = nr_events;\t/* user copy */\n\tring->id = ~0U;\n\tring->head = ring->tail = 0;\n\tring->magic = AIO_RING_MAGIC;\n\tring->compat_features = AIO_RING_COMPAT_FEATURES;\n\tring->incompat_features = AIO_RING_INCOMPAT_FEATURES;\n\tring->header_length = sizeof(struct aio_ring);\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AIO_RING_PAGES\t8",
            "#define AIO_RING_INCOMPAT_FEATURES\t0",
            "#define AIO_RING_COMPAT_FEATURES\t1",
            "#define AIO_RING_MAGIC\t\t\t0xa10a10a1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_RING_PAGES\t8\n#define AIO_RING_INCOMPAT_FEATURES\t0\n#define AIO_RING_COMPAT_FEATURES\t1\n#define AIO_RING_MAGIC\t\t\t0xa10a10a1\n\nstatic int aio_setup_ring(struct kioctx *ctx)\n{\n\tstruct aio_ring *ring;\n\tunsigned nr_events = ctx->max_reqs;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size, unused;\n\tint nr_pages;\n\tint i;\n\tstruct file *file;\n\n\t/* Compensate for the ring buffer's head/tail overlap entry */\n\tnr_events += 2;\t/* 1 is required, 2 for good luck */\n\n\tsize = sizeof(struct aio_ring);\n\tsize += sizeof(struct io_event) * nr_events;\n\n\tnr_pages = PFN_UP(size);\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tfile = aio_private_file(ctx, nr_pages);\n\tif (IS_ERR(file)) {\n\t\tctx->aio_ring_file = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->aio_ring_file = file;\n\tnr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring))\n\t\t\t/ sizeof(struct io_event);\n\n\tctx->ring_pages = ctx->internal_pages;\n\tif (nr_pages > AIO_RING_PAGES) {\n\t\tctx->ring_pages = kcalloc(nr_pages, sizeof(struct page *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->ring_pages) {\n\t\t\tput_aio_ring_file(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpage = find_or_create_page(file->f_inode->i_mapping,\n\t\t\t\t\t   i, GFP_HIGHUSER | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpr_debug(\"pid(%d) page[%d]->count=%d\\n\",\n\t\t\t current->pid, i, page_count(page));\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tctx->ring_pages[i] = page;\n\t}\n\tctx->nr_pages = i;\n\n\tif (unlikely(i != nr_pages)) {\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mmap_size = nr_pages * PAGE_SIZE;\n\tpr_debug(\"attempting mmap of %lu bytes\\n\", ctx->mmap_size);\n\n\tdown_write(&mm->mmap_sem);\n\tctx->mmap_base = do_mmap_pgoff(ctx->aio_ring_file, 0, ctx->mmap_size,\n\t\t\t\t       PROT_READ | PROT_WRITE,\n\t\t\t\t       MAP_SHARED, 0, &unused);\n\tup_write(&mm->mmap_sem);\n\tif (IS_ERR((void *)ctx->mmap_base)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"mmap address: 0x%08lx\\n\", ctx->mmap_base);\n\n\tctx->user_id = ctx->mmap_base;\n\tctx->nr_events = nr_events; /* trusted copy */\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->nr = nr_events;\t/* user copy */\n\tring->id = ~0U;\n\tring->head = ring->tail = 0;\n\tring->magic = AIO_RING_MAGIC;\n\tring->compat_features = AIO_RING_COMPAT_FEATURES;\n\tring->incompat_features = AIO_RING_INCOMPAT_FEATURES;\n\tring->header_length = sizeof(struct aio_ring);\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structkioctx_cpu"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&ctx->reqs",
            "free_ioctx_reqs",
            "0",
            "GFP_KERNEL"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&ctx->users",
            "free_ioctx_users",
            "0",
            "GFP_KERNEL"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctx->active_reqs"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ctx->wait"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ctx->completion_lock"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "kioctx_cachep",
            "GFP_KERNEL"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ENOMEM: nr_events too high\\n\""
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nr_events",
            "num_possible_cpus() * 4"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(aio_nr_lock);\nunsigned long aio_nr;\nunsigned long aio_max_nr = 0x10000;\nstatic struct kmem_cache\t*kioctx_cachep;\n\nstatic struct kioctx *ioctx_alloc(unsigned nr_events)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx;\n\tint err = -ENOMEM;\n\n\t/*\n\t * We keep track of the number of available ringbuffer slots, to prevent\n\t * overflow (reqs_available), and we also use percpu counters for this.\n\t *\n\t * So since up to half the slots might be on other cpu's percpu counters\n\t * and unavailable, double nr_events so userspace sees what they\n\t * expected: additionally, we move req_batch slots to/from percpu\n\t * counters at a time, so make sure that isn't 0:\n\t */\n\tnr_events = max(nr_events, num_possible_cpus() * 4);\n\tnr_events *= 2;\n\n\t/* Prevent overflows */\n\tif ((nr_events > (0x10000000U / sizeof(struct io_event))) ||\n\t    (nr_events > (0x10000000U / sizeof(struct kiocb)))) {\n\t\tpr_debug(\"ENOMEM: nr_events too high\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_events || (unsigned long)nr_events > (aio_max_nr * 2UL))\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tctx = kmem_cache_zalloc(kioctx_cachep, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->max_reqs = nr_events;\n\n\tspin_lock_init(&ctx->ctx_lock);\n\tspin_lock_init(&ctx->completion_lock);\n\tmutex_init(&ctx->ring_lock);\n\t/* Protect against page migration throughout kiotx setup by keeping\n\t * the ring_lock mutex held until setup is complete. */\n\tmutex_lock(&ctx->ring_lock);\n\tinit_waitqueue_head(&ctx->wait);\n\n\tINIT_LIST_HEAD(&ctx->active_reqs);\n\n\tif (percpu_ref_init(&ctx->users, free_ioctx_users, 0, GFP_KERNEL))\n\t\tgoto err;\n\n\tif (percpu_ref_init(&ctx->reqs, free_ioctx_reqs, 0, GFP_KERNEL))\n\t\tgoto err;\n\n\tctx->cpu = alloc_percpu(struct kioctx_cpu);\n\tif (!ctx->cpu)\n\t\tgoto err;\n\n\terr = aio_setup_ring(ctx);\n\tif (err < 0)\n\t\tgoto err;\n\n\tatomic_set(&ctx->reqs_available, ctx->nr_events - 1);\n\tctx->req_batch = (ctx->nr_events - 1) / (num_possible_cpus() * 4);\n\tif (ctx->req_batch < 1)\n\t\tctx->req_batch = 1;\n\n\t/* limit the number of system wide aios */\n\tspin_lock(&aio_nr_lock);\n\tif (aio_nr + nr_events > (aio_max_nr * 2UL) ||\n\t    aio_nr + nr_events < aio_nr) {\n\t\tspin_unlock(&aio_nr_lock);\n\t\terr = -EAGAIN;\n\t\tgoto err_ctx;\n\t}\n\taio_nr += ctx->max_reqs;\n\tspin_unlock(&aio_nr_lock);\n\n\tpercpu_ref_get(&ctx->users);\t/* io_setup() will drop this ref */\n\tpercpu_ref_get(&ctx->reqs);\t/* free_ioctx_users() will drop this */\n\n\terr = ioctx_add_table(ctx, mm);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\t/* Release the ring_lock mutex now that all setup is complete. */\n\tmutex_unlock(&ctx->ring_lock);\n\n\tpr_debug(\"allocated ioctx %p[%ld]: mm=%p mask=0x%x\\n\",\n\t\t ctx, ctx->user_id, mm, ctx->nr_events);\n\treturn ctx;\n\nerr_cleanup:\n\taio_nr_sub(ctx->max_reqs);\nerr_ctx:\n\taio_free_ring(ctx);\nerr:\n\tmutex_unlock(&ctx->ring_lock);\n\tfree_percpu(ctx->cpu);\n\tpercpu_ref_exit(&ctx->reqs);\n\tpercpu_ref_exit(&ctx->users);\n\tkmem_cache_free(kioctx_cachep, ctx);\n\tpr_debug(\"error allocating ioctx %d\\n\", err);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "aio_nr_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "626-634",
    "snippet": "static void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(aio_nr_lock);",
      "unsigned long aio_nr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&aio_nr_lock"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "aio_nr - nr > aio_nr"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&aio_nr_lock"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(aio_nr_lock);\nunsigned long aio_nr;\n\nstatic void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}"
  },
  {
    "function_name": "ioctx_add_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "571-624",
    "snippet": "static int ioctx_add_table(struct kioctx *ctx, struct mm_struct *mm)\n{\n\tunsigned i, new_nr;\n\tstruct kioctx_table *table, *old;\n\tstruct aio_ring *ring;\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\n\twhile (1) {\n\t\tif (table)\n\t\t\tfor (i = 0; i < table->nr; i++)\n\t\t\t\tif (!table->table[i]) {\n\t\t\t\t\tctx->id = i;\n\t\t\t\t\ttable->table[i] = ctx;\n\t\t\t\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\t\t\t\t/* While kioctx setup is in progress,\n\t\t\t\t\t * we are protected from page migration\n\t\t\t\t\t * changes ring_pages by ->ring_lock.\n\t\t\t\t\t */\n\t\t\t\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\t\t\t\tring->id = ctx->id;\n\t\t\t\t\tkunmap_atomic(ring);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\tnew_nr = (table ? table->nr : 1) * 4;\n\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\ttable = kzalloc(sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\ttable->nr = new_nr;\n\n\t\tspin_lock(&mm->ioctx_lock);\n\t\told = rcu_dereference_raw(mm->ioctx_table);\n\n\t\tif (!old) {\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t} else if (table->nr > old->nr) {\n\t\t\tmemcpy(table->table, old->table,\n\t\t\t       old->nr * sizeof(struct kioctx *));\n\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t\tkfree_rcu(old, rcu);\n\t\t} else {\n\t\t\tkfree(table);\n\t\t\ttable = old;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "old",
            "rcu"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "mm->ioctx_table",
            "table"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "table->table",
            "old->table",
            "old->nr * sizeof(struct kioctx *)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "mm->ioctx_table",
            "table"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr",
            "GFP_KERNEL"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int ioctx_add_table(struct kioctx *ctx, struct mm_struct *mm)\n{\n\tunsigned i, new_nr;\n\tstruct kioctx_table *table, *old;\n\tstruct aio_ring *ring;\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\n\twhile (1) {\n\t\tif (table)\n\t\t\tfor (i = 0; i < table->nr; i++)\n\t\t\t\tif (!table->table[i]) {\n\t\t\t\t\tctx->id = i;\n\t\t\t\t\ttable->table[i] = ctx;\n\t\t\t\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\t\t\t\t/* While kioctx setup is in progress,\n\t\t\t\t\t * we are protected from page migration\n\t\t\t\t\t * changes ring_pages by ->ring_lock.\n\t\t\t\t\t */\n\t\t\t\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\t\t\t\tring->id = ctx->id;\n\t\t\t\t\tkunmap_atomic(ring);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\tnew_nr = (table ? table->nr : 1) * 4;\n\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\ttable = kzalloc(sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\ttable->nr = new_nr;\n\n\t\tspin_lock(&mm->ioctx_lock);\n\t\told = rcu_dereference_raw(mm->ioctx_table);\n\n\t\tif (!old) {\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t} else if (table->nr > old->nr) {\n\t\t\tmemcpy(table->table, old->table,\n\t\t\t       old->nr * sizeof(struct kioctx *));\n\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t\tkfree_rcu(old, rcu);\n\t\t} else {\n\t\t\tkfree(table);\n\t\t\ttable = old;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "free_ioctx_users",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "550-569",
    "snippet": "static void free_ioctx_users(struct percpu_ref *ref)\n{\n\tstruct kioctx *ctx = container_of(ref, struct kioctx, users);\n\tstruct kiocb *req;\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\n\twhile (!list_empty(&ctx->active_reqs)) {\n\t\treq = list_first_entry(&ctx->active_reqs,\n\t\t\t\t       struct kiocb, ki_list);\n\n\t\tlist_del_init(&req->ki_list);\n\t\tkiocb_cancel(req);\n\t}\n\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\tpercpu_ref_kill(&ctx->reqs);\n\tpercpu_ref_put(&ctx->reqs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&ctx->reqs"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&ctx->reqs"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kiocb_cancel",
          "args": [
            "req"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "kiocb_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "499-518",
          "snippet": "static int kiocb_cancel(struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int kiocb_cancel(struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->ki_list"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ctx->active_reqs",
            "structkiocb",
            "ki_list"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->active_reqs"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structkioctx",
            "users"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void free_ioctx_users(struct percpu_ref *ref)\n{\n\tstruct kioctx *ctx = container_of(ref, struct kioctx, users);\n\tstruct kiocb *req;\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\n\twhile (!list_empty(&ctx->active_reqs)) {\n\t\treq = list_first_entry(&ctx->active_reqs,\n\t\t\t\t       struct kiocb, ki_list);\n\n\t\tlist_del_init(&req->ki_list);\n\t\tkiocb_cancel(req);\n\t}\n\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\tpercpu_ref_kill(&ctx->reqs);\n\tpercpu_ref_put(&ctx->reqs);\n}"
  },
  {
    "function_name": "free_ioctx_reqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "533-543",
    "snippet": "static void free_ioctx_reqs(struct percpu_ref *ref)\n{\n\tstruct kioctx *ctx = container_of(ref, struct kioctx, reqs);\n\n\t/* At this point we know that there are no any in-flight requests */\n\tif (ctx->requests_done)\n\t\tcomplete(ctx->requests_done);\n\n\tINIT_WORK(&ctx->free_work, free_ioctx);\n\tschedule_work(&ctx->free_work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&ctx->free_work"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ctx->free_work",
            "free_ioctx"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "ctx->requests_done"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structkioctx",
            "reqs"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void free_ioctx_reqs(struct percpu_ref *ref)\n{\n\tstruct kioctx *ctx = container_of(ref, struct kioctx, reqs);\n\n\t/* At this point we know that there are no any in-flight requests */\n\tif (ctx->requests_done)\n\t\tcomplete(ctx->requests_done);\n\n\tINIT_WORK(&ctx->free_work, free_ioctx);\n\tschedule_work(&ctx->free_work);\n}"
  },
  {
    "function_name": "free_ioctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "520-531",
    "snippet": "static void free_ioctx(struct work_struct *work)\n{\n\tstruct kioctx *ctx = container_of(work, struct kioctx, free_work);\n\n\tpr_debug(\"freeing %p\\n\", ctx);\n\n\taio_free_ring(ctx);\n\tfree_percpu(ctx->cpu);\n\tpercpu_ref_exit(&ctx->reqs);\n\tpercpu_ref_exit(&ctx->users);\n\tkmem_cache_free(kioctx_cachep, ctx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*kioctx_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kioctx_cachep",
            "ctx"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&ctx->users"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&ctx->reqs"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "ctx->cpu"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_free_ring",
          "args": [
            "ctx"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "aio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "248-272",
          "snippet": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"freeing %p\\n\"",
            "ctx"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkioctx",
            "free_work"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kioctx_cachep;\n\nstatic void free_ioctx(struct work_struct *work)\n{\n\tstruct kioctx *ctx = container_of(work, struct kioctx, free_work);\n\n\tpr_debug(\"freeing %p\\n\", ctx);\n\n\taio_free_ring(ctx);\n\tfree_percpu(ctx->cpu);\n\tpercpu_ref_exit(&ctx->reqs);\n\tpercpu_ref_exit(&ctx->users);\n\tkmem_cache_free(kioctx_cachep, ctx);\n}"
  },
  {
    "function_name": "kiocb_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "499-518",
    "snippet": "static int kiocb_cancel(struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel",
          "args": [
            "kiocb"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "kiocb_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "499-518",
          "snippet": "static int kiocb_cancel(struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&kiocb->ki_cancel",
            "old",
            "KIOCB_CANCELLED"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "kiocb->ki_cancel"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int kiocb_cancel(struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}"
  },
  {
    "function_name": "kiocb_set_cancel_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "483-496",
    "snippet": "void kiocb_set_cancel_fn(struct kiocb *req, kiocb_cancel_fn *cancel)\n{\n\tstruct kioctx *ctx = req->ki_ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\n\tif (!req->ki_list.next)\n\t\tlist_add(&req->ki_list, &ctx->active_reqs);\n\n\treq->ki_cancel = cancel;\n\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->ctx_lock",
            "flags"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&req->ki_list",
            "&ctx->active_reqs"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->ctx_lock",
            "flags"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid kiocb_set_cancel_fn(struct kiocb *req, kiocb_cancel_fn *cancel)\n{\n\tstruct kioctx *ctx = req->ki_ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\n\tif (!req->ki_list.next)\n\t\tlist_add(&req->ki_list, &ctx->active_reqs);\n\n\treq->ki_cancel = cancel;\n\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}"
  },
  {
    "function_name": "aio_setup_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "386-477",
    "snippet": "static int aio_setup_ring(struct kioctx *ctx)\n{\n\tstruct aio_ring *ring;\n\tunsigned nr_events = ctx->max_reqs;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size, unused;\n\tint nr_pages;\n\tint i;\n\tstruct file *file;\n\n\t/* Compensate for the ring buffer's head/tail overlap entry */\n\tnr_events += 2;\t/* 1 is required, 2 for good luck */\n\n\tsize = sizeof(struct aio_ring);\n\tsize += sizeof(struct io_event) * nr_events;\n\n\tnr_pages = PFN_UP(size);\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tfile = aio_private_file(ctx, nr_pages);\n\tif (IS_ERR(file)) {\n\t\tctx->aio_ring_file = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->aio_ring_file = file;\n\tnr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring))\n\t\t\t/ sizeof(struct io_event);\n\n\tctx->ring_pages = ctx->internal_pages;\n\tif (nr_pages > AIO_RING_PAGES) {\n\t\tctx->ring_pages = kcalloc(nr_pages, sizeof(struct page *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->ring_pages) {\n\t\t\tput_aio_ring_file(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpage = find_or_create_page(file->f_inode->i_mapping,\n\t\t\t\t\t   i, GFP_HIGHUSER | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpr_debug(\"pid(%d) page[%d]->count=%d\\n\",\n\t\t\t current->pid, i, page_count(page));\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tctx->ring_pages[i] = page;\n\t}\n\tctx->nr_pages = i;\n\n\tif (unlikely(i != nr_pages)) {\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mmap_size = nr_pages * PAGE_SIZE;\n\tpr_debug(\"attempting mmap of %lu bytes\\n\", ctx->mmap_size);\n\n\tdown_write(&mm->mmap_sem);\n\tctx->mmap_base = do_mmap_pgoff(ctx->aio_ring_file, 0, ctx->mmap_size,\n\t\t\t\t       PROT_READ | PROT_WRITE,\n\t\t\t\t       MAP_SHARED, 0, &unused);\n\tup_write(&mm->mmap_sem);\n\tif (IS_ERR((void *)ctx->mmap_base)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"mmap address: 0x%08lx\\n\", ctx->mmap_base);\n\n\tctx->user_id = ctx->mmap_base;\n\tctx->nr_events = nr_events; /* trusted copy */\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->nr = nr_events;\t/* user copy */\n\tring->id = ~0U;\n\tring->head = ring->tail = 0;\n\tring->magic = AIO_RING_MAGIC;\n\tring->compat_features = AIO_RING_COMPAT_FEATURES;\n\tring->incompat_features = AIO_RING_INCOMPAT_FEATURES;\n\tring->header_length = sizeof(struct aio_ring);\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AIO_RING_PAGES\t8",
      "#define AIO_RING_INCOMPAT_FEATURES\t0",
      "#define AIO_RING_COMPAT_FEATURES\t1",
      "#define AIO_RING_MAGIC\t\t\t0xa10a10a1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"mmap address: 0x%08lx\\n\"",
            "ctx->mmap_base"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_free_ring",
          "args": [
            "ctx"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "aio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "248-272",
          "snippet": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)ctx->mmap_base"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mmap_pgoff",
          "args": [
            "ctx->aio_ring_file",
            "0",
            "ctx->mmap_size",
            "PROT_READ | PROT_WRITE",
            "MAP_SHARED",
            "0",
            "&unused"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"attempting mmap of %lu bytes\\n\"",
            "ctx->mmap_size"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i != nr_pages"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"pid(%d) page[%d]->count=%d\\n\"",
            "current->pid",
            "i",
            "page_count(page)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "file->f_inode->i_mapping",
            "i",
            "GFP_HIGHUSER | __GFP_ZERO"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_aio_ring_file",
          "args": [
            "ctx"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "put_aio_ring_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "232-246",
          "snippet": "static void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(aio_ring_file->f_inode, 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\tspin_lock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\t\taio_ring_file->f_inode->i_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(aio_ring_file->f_inode, 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\tspin_lock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\t\taio_ring_file->f_inode->i_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_pages",
            "sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_private_file",
          "args": [
            "ctx",
            "nr_pages"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "aio_private_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "168-197",
          "snippet": "static struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)\n{\n\tstruct qstr this = QSTR_INIT(\"[aio]\", 5);\n\tstruct file *file;\n\tstruct path path;\n\tstruct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_mapping->a_ops = &aio_ctx_aops;\n\tinode->i_mapping->private_data = ctx;\n\tinode->i_size = PAGE_SIZE * nr_pages;\n\n\tpath.dentry = d_alloc_pseudo(aio_mnt->mnt_sb, &this);\n\tif (!path.dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpath.mnt = mntget(aio_mnt);\n\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, FMODE_READ | FMODE_WRITE, &aio_ring_fops);\n\tif (IS_ERR(file)) {\n\t\tpath_put(&path);\n\t\treturn file;\n\t}\n\n\tfile->f_flags = O_RDWR;\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aio_mnt;",
            "static const struct file_operations aio_ring_fops;",
            "static const struct address_space_operations aio_ctx_aops;",
            "static const struct file_operations aio_ring_fops = {\n\t.mmap = aio_ring_mmap,\n\t.mremap = aio_ring_remap,\n};",
            "static const struct address_space_operations aio_ctx_aops = {\n\t.set_page_dirty = __set_page_dirty_no_writeback,\n#if IS_ENABLED(CONFIG_MIGRATION)\n\t.migratepage\t= aio_migratepage,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct vfsmount *aio_mnt;\nstatic const struct file_operations aio_ring_fops;\nstatic const struct address_space_operations aio_ctx_aops;\nstatic const struct file_operations aio_ring_fops = {\n\t.mmap = aio_ring_mmap,\n\t.mremap = aio_ring_remap,\n};\nstatic const struct address_space_operations aio_ctx_aops = {\n\t.set_page_dirty = __set_page_dirty_no_writeback,\n#if IS_ENABLED(CONFIG_MIGRATION)\n\t.migratepage\t= aio_migratepage,\n#endif\n};\n\nstatic struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)\n{\n\tstruct qstr this = QSTR_INIT(\"[aio]\", 5);\n\tstruct file *file;\n\tstruct path path;\n\tstruct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_mapping->a_ops = &aio_ctx_aops;\n\tinode->i_mapping->private_data = ctx;\n\tinode->i_size = PAGE_SIZE * nr_pages;\n\n\tpath.dentry = d_alloc_pseudo(aio_mnt->mnt_sb, &this);\n\tif (!path.dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpath.mnt = mntget(aio_mnt);\n\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, FMODE_READ | FMODE_WRITE, &aio_ring_fops);\n\tif (IS_ERR(file)) {\n\t\tpath_put(&path);\n\t\treturn file;\n\t}\n\n\tfile->f_flags = O_RDWR;\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "size"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_RING_PAGES\t8\n#define AIO_RING_INCOMPAT_FEATURES\t0\n#define AIO_RING_COMPAT_FEATURES\t1\n#define AIO_RING_MAGIC\t\t\t0xa10a10a1\n\nstatic int aio_setup_ring(struct kioctx *ctx)\n{\n\tstruct aio_ring *ring;\n\tunsigned nr_events = ctx->max_reqs;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size, unused;\n\tint nr_pages;\n\tint i;\n\tstruct file *file;\n\n\t/* Compensate for the ring buffer's head/tail overlap entry */\n\tnr_events += 2;\t/* 1 is required, 2 for good luck */\n\n\tsize = sizeof(struct aio_ring);\n\tsize += sizeof(struct io_event) * nr_events;\n\n\tnr_pages = PFN_UP(size);\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tfile = aio_private_file(ctx, nr_pages);\n\tif (IS_ERR(file)) {\n\t\tctx->aio_ring_file = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->aio_ring_file = file;\n\tnr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring))\n\t\t\t/ sizeof(struct io_event);\n\n\tctx->ring_pages = ctx->internal_pages;\n\tif (nr_pages > AIO_RING_PAGES) {\n\t\tctx->ring_pages = kcalloc(nr_pages, sizeof(struct page *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->ring_pages) {\n\t\t\tput_aio_ring_file(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpage = find_or_create_page(file->f_inode->i_mapping,\n\t\t\t\t\t   i, GFP_HIGHUSER | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpr_debug(\"pid(%d) page[%d]->count=%d\\n\",\n\t\t\t current->pid, i, page_count(page));\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tctx->ring_pages[i] = page;\n\t}\n\tctx->nr_pages = i;\n\n\tif (unlikely(i != nr_pages)) {\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mmap_size = nr_pages * PAGE_SIZE;\n\tpr_debug(\"attempting mmap of %lu bytes\\n\", ctx->mmap_size);\n\n\tdown_write(&mm->mmap_sem);\n\tctx->mmap_base = do_mmap_pgoff(ctx->aio_ring_file, 0, ctx->mmap_size,\n\t\t\t\t       PROT_READ | PROT_WRITE,\n\t\t\t\t       MAP_SHARED, 0, &unused);\n\tup_write(&mm->mmap_sem);\n\tif (IS_ERR((void *)ctx->mmap_base)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"mmap address: 0x%08lx\\n\", ctx->mmap_base);\n\n\tctx->user_id = ctx->mmap_base;\n\tctx->nr_events = nr_events; /* trusted copy */\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->nr = nr_events;\t/* user copy */\n\tring->id = ~0U;\n\tring->head = ring->tail = 0;\n\tring->magic = AIO_RING_MAGIC;\n\tring->compat_features = AIO_RING_COMPAT_FEATURES;\n\tring->incompat_features = AIO_RING_INCOMPAT_FEATURES;\n\tring->header_length = sizeof(struct aio_ring);\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_migratepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "310-376",
    "snippet": "static int aio_migratepage(struct address_space *mapping, struct page *new,\n\t\t\tstruct page *old, enum migrate_mode mode)\n{\n\tstruct kioctx *ctx;\n\tunsigned long flags;\n\tpgoff_t idx;\n\tint rc;\n\n\trc = 0;\n\n\t/* mapping->private_lock here protects against the kioctx teardown.  */\n\tspin_lock(&mapping->private_lock);\n\tctx = mapping->private_data;\n\tif (!ctx) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* The ring_lock mutex.  The prevents aio_read_events() from writing\n\t * to the ring's head, and prevents page migration from mucking in\n\t * a partially initialized kiotx.\n\t */\n\tif (!mutex_trylock(&ctx->ring_lock)) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tidx = old->index;\n\tif (idx < (pgoff_t)ctx->nr_pages) {\n\t\t/* Make sure the old page hasn't already been changed */\n\t\tif (ctx->ring_pages[idx] != old)\n\t\t\trc = -EAGAIN;\n\t} else\n\t\trc = -EINVAL;\n\n\tif (rc != 0)\n\t\tgoto out_unlock;\n\n\t/* Writeback must be complete */\n\tBUG_ON(PageWriteback(old));\n\tget_page(new);\n\n\trc = migrate_page_move_mapping(mapping, new, old, NULL, mode, 1);\n\tif (rc != MIGRATEPAGE_SUCCESS) {\n\t\tput_page(new);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Take completion_lock to prevent other writes to the ring buffer\n\t * while the old page is copied to the new.  This prevents new\n\t * events from being lost.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\tmigrate_page_copy(new, old);\n\tBUG_ON(ctx->ring_pages[idx] != old);\n\tctx->ring_pages[idx] = new;\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\t/* The old page is no longer accessible. */\n\tput_page(old);\n\nout_unlock:\n\tmutex_unlock(&ctx->ring_lock);\nout:\n\tspin_unlock(&mapping->private_lock);\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->completion_lock",
            "flags"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ctx->ring_pages[idx] != old"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_copy",
          "args": [
            "new",
            "old"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->completion_lock",
            "flags"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_move_mapping",
          "args": [
            "mapping",
            "new",
            "old",
            "NULL",
            "mode",
            "1"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "new"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(old)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "old"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_migratepage(struct address_space *mapping, struct page *new,\n\t\t\tstruct page *old, enum migrate_mode mode)\n{\n\tstruct kioctx *ctx;\n\tunsigned long flags;\n\tpgoff_t idx;\n\tint rc;\n\n\trc = 0;\n\n\t/* mapping->private_lock here protects against the kioctx teardown.  */\n\tspin_lock(&mapping->private_lock);\n\tctx = mapping->private_data;\n\tif (!ctx) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* The ring_lock mutex.  The prevents aio_read_events() from writing\n\t * to the ring's head, and prevents page migration from mucking in\n\t * a partially initialized kiotx.\n\t */\n\tif (!mutex_trylock(&ctx->ring_lock)) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tidx = old->index;\n\tif (idx < (pgoff_t)ctx->nr_pages) {\n\t\t/* Make sure the old page hasn't already been changed */\n\t\tif (ctx->ring_pages[idx] != old)\n\t\t\trc = -EAGAIN;\n\t} else\n\t\trc = -EINVAL;\n\n\tif (rc != 0)\n\t\tgoto out_unlock;\n\n\t/* Writeback must be complete */\n\tBUG_ON(PageWriteback(old));\n\tget_page(new);\n\n\trc = migrate_page_move_mapping(mapping, new, old, NULL, mode, 1);\n\tif (rc != MIGRATEPAGE_SUCCESS) {\n\t\tput_page(new);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Take completion_lock to prevent other writes to the ring buffer\n\t * while the old page is copied to the new.  This prevents new\n\t * events from being lost.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\tmigrate_page_copy(new, old);\n\tBUG_ON(ctx->ring_pages[idx] != old);\n\tctx->ring_pages[idx] = new;\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\t/* The old page is no longer accessible. */\n\tput_page(old);\n\nout_unlock:\n\tmutex_unlock(&ctx->ring_lock);\nout:\n\tspin_unlock(&mapping->private_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "aio_ring_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "281-302",
    "snippet": "static void aio_ring_remap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct kioctx_table *table;\n\tint i;\n\n\tspin_lock(&mm->ioctx_lock);\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\tfor (i = 0; i < table->nr; i++) {\n\t\tstruct kioctx *ctx;\n\n\t\tctx = table->table[i];\n\t\tif (ctx && ctx->aio_ring_file == file) {\n\t\t\tctx->user_id = ctx->mmap_base = vma->vm_start;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\tspin_unlock(&mm->ioctx_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_ring_remap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct kioctx_table *table;\n\tint i;\n\n\tspin_lock(&mm->ioctx_lock);\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\tfor (i = 0; i < table->nr; i++) {\n\t\tstruct kioctx *ctx;\n\n\t\tctx = table->table[i];\n\t\tif (ctx && ctx->aio_ring_file == file) {\n\t\t\tctx->user_id = ctx->mmap_base = vma->vm_start;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\tspin_unlock(&mm->ioctx_lock);\n}"
  },
  {
    "function_name": "aio_ring_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "274-279",
    "snippet": "static int aio_ring_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tvma->vm_flags |= VM_DONTEXPAND;\n\tvma->vm_ops = &generic_file_vm_ops;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_ring_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tvma->vm_flags |= VM_DONTEXPAND;\n\tvma->vm_ops = &generic_file_vm_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_free_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "248-272",
    "snippet": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx->ring_pages"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"pid(%d) [%d] page->count=%d\\n\"",
            "current->pid",
            "i",
            "page_count(ctx->ring_pages[i])"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "ctx->ring_pages[i]"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_aio_ring_file",
          "args": [
            "ctx"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "put_aio_ring_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "232-246",
          "snippet": "static void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(aio_ring_file->f_inode, 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\tspin_lock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\t\taio_ring_file->f_inode->i_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(aio_ring_file->f_inode, 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\tspin_lock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\t\taio_ring_file->f_inode->i_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}"
  },
  {
    "function_name": "put_aio_ring_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "232-246",
    "snippet": "static void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(aio_ring_file->f_inode, 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\tspin_lock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\t\taio_ring_file->f_inode->i_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "aio_ring_file"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&aio_ring_file->f_inode->i_mapping->private_lock"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&aio_ring_file->f_inode->i_mapping->private_lock"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "aio_ring_file->f_inode",
            "0"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(aio_ring_file->f_inode, 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\tspin_lock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\t\taio_ring_file->f_inode->i_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&aio_ring_file->f_inode->i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}"
  },
  {
    "function_name": "aio_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "212-229",
    "snippet": "static int __init aio_setup(void)\n{\n\tstatic struct file_system_type aio_fs = {\n\t\t.name\t\t= \"aio\",\n\t\t.mount\t\t= aio_mount,\n\t\t.kill_sb\t= kill_anon_super,\n\t};\n\taio_mnt = kern_mount(&aio_fs);\n\tif (IS_ERR(aio_mnt))\n\t\tpanic(\"Failed to create aio fs mount.\");\n\n\tkiocb_cachep = KMEM_CACHE(kiocb, SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\tkioctx_cachep = KMEM_CACHE(kioctx,SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\n\tpr_debug(\"sizeof(struct page) = %zu\\n\", sizeof(struct page));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*kiocb_cachep;",
      "static struct kmem_cache\t*kioctx_cachep;",
      "static struct vfsmount *aio_mnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"sizeof(struct page) = %zu\\n\"",
            "sizeof(struct page)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "kioctx",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "kiocb",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to create aio fs mount.\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "aio_mnt"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&aio_fs"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\nstatic struct kmem_cache\t*kioctx_cachep;\nstatic struct vfsmount *aio_mnt;\n\nstatic int __init aio_setup(void)\n{\n\tstatic struct file_system_type aio_fs = {\n\t\t.name\t\t= \"aio\",\n\t\t.mount\t\t= aio_mount,\n\t\t.kill_sb\t= kill_anon_super,\n\t};\n\taio_mnt = kern_mount(&aio_fs);\n\tif (IS_ERR(aio_mnt))\n\t\tpanic(\"Failed to create aio fs mount.\");\n\n\tkiocb_cachep = KMEM_CACHE(kiocb, SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\tkioctx_cachep = KMEM_CACHE(kioctx,SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\n\tpr_debug(\"sizeof(struct page) = %zu\\n\", sizeof(struct page));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "199-206",
    "snippet": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AIO_RING_MAGIC\t\t\t0xa10a10a1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"aio:\"",
            "NULL",
            "&ops",
            "AIO_RING_MAGIC"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "mount_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "216-260",
          "snippet": "struct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nstruct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_RING_MAGIC\t\t\t0xa10a10a1\n\nstatic struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n}"
  },
  {
    "function_name": "aio_private_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
    "lines": "168-197",
    "snippet": "static struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)\n{\n\tstruct qstr this = QSTR_INIT(\"[aio]\", 5);\n\tstruct file *file;\n\tstruct path path;\n\tstruct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_mapping->a_ops = &aio_ctx_aops;\n\tinode->i_mapping->private_data = ctx;\n\tinode->i_size = PAGE_SIZE * nr_pages;\n\n\tpath.dentry = d_alloc_pseudo(aio_mnt->mnt_sb, &this);\n\tif (!path.dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpath.mnt = mntget(aio_mnt);\n\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, FMODE_READ | FMODE_WRITE, &aio_ring_fops);\n\tif (IS_ERR(file)) {\n\t\tpath_put(&path);\n\t\treturn file;\n\t}\n\n\tfile->f_flags = O_RDWR;\n\treturn file;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *aio_mnt;",
      "static const struct file_operations aio_ring_fops;",
      "static const struct address_space_operations aio_ctx_aops;",
      "static const struct file_operations aio_ring_fops = {\n\t.mmap = aio_ring_mmap,\n\t.mremap = aio_ring_remap,\n};",
      "static const struct address_space_operations aio_ctx_aops = {\n\t.set_page_dirty = __set_page_dirty_no_writeback,\n#if IS_ENABLED(CONFIG_MIGRATION)\n\t.migratepage\t= aio_migratepage,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file",
          "args": [
            "&path",
            "FMODE_READ | FMODE_WRITE",
            "&aio_ring_fops"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "158-181",
          "snippet": "struct file *alloc_file(struct path *path, fmode_t mode,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tif ((mode & FMODE_READ) &&\n\t     likely(fop->read || fop->aio_read || fop->read_iter))\n\t\tmode |= FMODE_CAN_READ;\n\tif ((mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->aio_write || fop->write_iter))\n\t\tmode |= FMODE_CAN_WRITE;\n\tfile->f_mode = mode;\n\tfile->f_op = fop;\n\tif ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file(struct path *path, fmode_t mode,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tif ((mode & FMODE_READ) &&\n\t     likely(fop->read || fop->aio_read || fop->read_iter))\n\t\tmode |= FMODE_CAN_READ;\n\tif ((mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->aio_write || fop->write_iter))\n\t\tmode |= FMODE_CAN_WRITE;\n\tfile->f_mode = mode;\n\tfile->f_op = fop;\n\tif ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "path.dentry",
            "inode"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "aio_mnt"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1130-1135",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_pseudo",
          "args": [
            "aio_mnt->mnt_sb",
            "&this"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1618-1621",
          "snippet": "struct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_anon_inode",
          "args": [
            "aio_mnt->mnt_sb"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_anon_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1050-1076",
          "snippet": "struct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.set_page_dirty = anon_set_page_dirty,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because mark_inode_dirty() will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.set_page_dirty = anon_set_page_dirty,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because mark_inode_dirty() will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "\"[aio]\"",
            "5"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct vfsmount *aio_mnt;\nstatic const struct file_operations aio_ring_fops;\nstatic const struct address_space_operations aio_ctx_aops;\nstatic const struct file_operations aio_ring_fops = {\n\t.mmap = aio_ring_mmap,\n\t.mremap = aio_ring_remap,\n};\nstatic const struct address_space_operations aio_ctx_aops = {\n\t.set_page_dirty = __set_page_dirty_no_writeback,\n#if IS_ENABLED(CONFIG_MIGRATION)\n\t.migratepage\t= aio_migratepage,\n#endif\n};\n\nstatic struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)\n{\n\tstruct qstr this = QSTR_INIT(\"[aio]\", 5);\n\tstruct file *file;\n\tstruct path path;\n\tstruct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_mapping->a_ops = &aio_ctx_aops;\n\tinode->i_mapping->private_data = ctx;\n\tinode->i_size = PAGE_SIZE * nr_pages;\n\n\tpath.dentry = d_alloc_pseudo(aio_mnt->mnt_sb, &this);\n\tif (!path.dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpath.mnt = mntget(aio_mnt);\n\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, FMODE_READ | FMODE_WRITE, &aio_ring_fops);\n\tif (IS_ERR(file)) {\n\t\tpath_put(&path);\n\t\treturn file;\n\t}\n\n\tfile->f_flags = O_RDWR;\n\treturn file;\n}"
  }
]