[
  {
    "function_name": "xlog_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "550-559",
    "snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "wq",
            "&wait"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue_exclusive",
          "args": [
            "wq",
            "&wait"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}"
  },
  {
    "function_name": "xlog_cil_force",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "533-537",
    "snippet": "static inline void\nxlog_cil_force(struct xlog *log)\n{\n\txlog_cil_force_lsn(log, log->l_cilp->xc_current_sequence);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_cil_force_lsn",
          "args": [
            "log",
            "log->l_cilp->xc_current_sequence"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_force_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "829-913",
          "snippet": "xfs_lsn_t\nxlog_cil_force_lsn(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tsequence)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx;\n\txfs_lsn_t\t\tcommit_lsn = NULLCOMMITLSN;\n\n\tASSERT(sequence <= cil->xc_current_sequence);\n\n\t/*\n\t * check to see if we need to force out the current context.\n\t * xlog_cil_push() handles racing pushes for the same sequence,\n\t * so no need to deal with it here.\n\t */\nrestart:\n\txlog_cil_push_now(log, sequence);\n\n\t/*\n\t * See if we can find a previous sequence still committing.\n\t * We need to wait for all previous sequence commits to complete\n\t * before allowing the force of push_seq to go ahead. Hence block\n\t * on commits for those as well.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(ctx, &cil->xc_committing, committing) {\n\t\t/*\n\t\t * Avoid getting stuck in this loop because we were woken by the\n\t\t * shutdown, but then went back to sleep once already in the\n\t\t * shutdown state.\n\t\t */\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto out_shutdown;\n\t\tif (ctx->sequence > sequence)\n\t\t\tcontinue;\n\t\tif (!ctx->commit_lsn) {\n\t\t\t/*\n\t\t\t * It is still being pushed! Wait for the push to\n\t\t\t * complete, then start again from the beginning.\n\t\t\t */\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (ctx->sequence != sequence)\n\t\t\tcontinue;\n\t\t/* found it! */\n\t\tcommit_lsn = ctx->commit_lsn;\n\t}\n\n\t/*\n\t * The call to xlog_cil_push_now() executes the push in the background.\n\t * Hence by the time we have got here it our sequence may not have been\n\t * pushed yet. This is true if the current sequence still matches the\n\t * push sequence after the above wait loop and the CIL still contains\n\t * dirty objects. This is guaranteed by the push code first adding the\n\t * context to the committing list before emptying the CIL.\n\t *\n\t * Hence if we don't find the context in the committing list and the\n\t * current sequence number is unchanged then the CIL contents are\n\t * significant.  If the CIL is empty, if means there was nothing to push\n\t * and that means there is nothing to wait for. If the CIL is not empty,\n\t * it means we haven't yet started the push, because if it had started\n\t * we would have found the context on the committing list.\n\t */\n\tif (sequence == cil->xc_current_sequence &&\n\t    !list_empty(&cil->xc_cil)) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto restart;\n\t}\n\n\tspin_unlock(&cil->xc_push_lock);\n\treturn commit_lsn;\n\n\t/*\n\t * We detected a shutdown in progress. We need to trigger the log force\n\t * to pass through it's iclog state machine error handling, even though\n\t * we are already in a shutdown state. Hence we can't return\n\t * NULLCOMMITLSN here as that has special meaning to log forces (i.e.\n\t * LSN is already stable), so we return a zero LSN instead.\n\t */\nout_shutdown:\n\tspin_unlock(&cil->xc_push_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxlog_cil_force_lsn(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tsequence)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx;\n\txfs_lsn_t\t\tcommit_lsn = NULLCOMMITLSN;\n\n\tASSERT(sequence <= cil->xc_current_sequence);\n\n\t/*\n\t * check to see if we need to force out the current context.\n\t * xlog_cil_push() handles racing pushes for the same sequence,\n\t * so no need to deal with it here.\n\t */\nrestart:\n\txlog_cil_push_now(log, sequence);\n\n\t/*\n\t * See if we can find a previous sequence still committing.\n\t * We need to wait for all previous sequence commits to complete\n\t * before allowing the force of push_seq to go ahead. Hence block\n\t * on commits for those as well.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(ctx, &cil->xc_committing, committing) {\n\t\t/*\n\t\t * Avoid getting stuck in this loop because we were woken by the\n\t\t * shutdown, but then went back to sleep once already in the\n\t\t * shutdown state.\n\t\t */\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto out_shutdown;\n\t\tif (ctx->sequence > sequence)\n\t\t\tcontinue;\n\t\tif (!ctx->commit_lsn) {\n\t\t\t/*\n\t\t\t * It is still being pushed! Wait for the push to\n\t\t\t * complete, then start again from the beginning.\n\t\t\t */\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (ctx->sequence != sequence)\n\t\t\tcontinue;\n\t\t/* found it! */\n\t\tcommit_lsn = ctx->commit_lsn;\n\t}\n\n\t/*\n\t * The call to xlog_cil_push_now() executes the push in the background.\n\t * Hence by the time we have got here it our sequence may not have been\n\t * pushed yet. This is true if the current sequence still matches the\n\t * push sequence after the above wait loop and the CIL still contains\n\t * dirty objects. This is guaranteed by the push code first adding the\n\t * context to the committing list before emptying the CIL.\n\t *\n\t * Hence if we don't find the context in the committing list and the\n\t * current sequence number is unchanged then the CIL contents are\n\t * significant.  If the CIL is empty, if means there was nothing to push\n\t * and that means there is nothing to wait for. If the CIL is not empty,\n\t * it means we haven't yet started the push, because if it had started\n\t * we would have found the context on the committing list.\n\t */\n\tif (sequence == cil->xc_current_sequence &&\n\t    !list_empty(&cil->xc_cil)) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto restart;\n\t}\n\n\tspin_unlock(&cil->xc_push_lock);\n\treturn commit_lsn;\n\n\t/*\n\t * We detected a shutdown in progress. We need to trigger the log force\n\t * to pass through it's iclog state machine error handling, even though\n\t * we are already in a shutdown state. Hence we can't return\n\t * NULLCOMMITLSN here as that has special meaning to log forces (i.e.\n\t * LSN is already stable), so we return a zero LSN instead.\n\t */\nout_shutdown:\n\tspin_unlock(&cil->xc_push_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void\nxlog_cil_force(struct xlog *log)\n{\n\txlog_cil_force_lsn(log, log->l_cilp->xc_current_sequence);\n}"
  },
  {
    "function_name": "xlog_assign_grant_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "511-515",
    "snippet": "static inline void\nxlog_assign_grant_head(atomic64_t *head, int cycle, int space)\n{\n\tatomic64_set(head, xlog_assign_grant_head_val(cycle, space));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "head",
            "xlog_assign_grant_head_val(cycle, space)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_grant_head_val",
          "args": [
            "cycle",
            "space"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_grant_head_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "505-509",
          "snippet": "static inline int64_t\nxlog_assign_grant_head_val(int cycle, int space)\n{\n\treturn ((int64_t)cycle << 32) | space;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int64_t\nxlog_assign_grant_head_val(int cycle, int space)\n{\n\treturn ((int64_t)cycle << 32) | space;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void\nxlog_assign_grant_head(atomic64_t *head, int cycle, int space)\n{\n\tatomic64_set(head, xlog_assign_grant_head_val(cycle, space));\n}"
  },
  {
    "function_name": "xlog_assign_grant_head_val",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "505-509",
    "snippet": "static inline int64_t\nxlog_assign_grant_head_val(int cycle, int space)\n{\n\treturn ((int64_t)cycle << 32) | space;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int64_t\nxlog_assign_grant_head_val(int cycle, int space)\n{\n\treturn ((int64_t)cycle << 32) | space;\n}"
  },
  {
    "function_name": "xlog_crack_grant_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "499-503",
    "snippet": "static inline void\nxlog_crack_grant_head(atomic64_t *head, int *cycle, int *space)\n{\n\txlog_crack_grant_head_val(atomic64_read(head), cycle, space);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_crack_grant_head_val",
          "args": [
            "atomic64_read(head)",
            "cycle",
            "space"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_crack_grant_head_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "492-497",
          "snippet": "static inline void\nxlog_crack_grant_head_val(int64_t val, int *cycle, int *space)\n{\n\t*cycle = val >> 32;\n\t*space = val & 0xffffffff;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_crack_grant_head_val(int64_t val, int *cycle, int *space)\n{\n\t*cycle = val >> 32;\n\t*space = val & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "head"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline void\nxlog_crack_grant_head(atomic64_t *head, int *cycle, int *space)\n{\n\txlog_crack_grant_head_val(atomic64_read(head), cycle, space);\n}"
  },
  {
    "function_name": "xlog_crack_grant_head_val",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "492-497",
    "snippet": "static inline void\nxlog_crack_grant_head_val(int64_t val, int *cycle, int *space)\n{\n\t*cycle = val >> 32;\n\t*space = val & 0xffffffff;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void\nxlog_crack_grant_head_val(int64_t val, int *cycle, int *space)\n{\n\t*cycle = val >> 32;\n\t*space = val & 0xffffffff;\n}"
  },
  {
    "function_name": "xlog_assign_atomic_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "481-485",
    "snippet": "static inline void\nxlog_assign_atomic_lsn(atomic64_t *lsn, uint cycle, uint block)\n{\n\tatomic64_set(lsn, xlog_assign_lsn(cycle, block));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "lsn",
            "xlog_assign_lsn(cycle, block)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_assign_lsn",
          "args": [
            "cycle",
            "block"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "72-75",
          "snippet": "static inline xfs_lsn_t xlog_assign_lsn(uint cycle, uint block)\n{\n\treturn ((xfs_lsn_t)cycle << 32) | block;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_lsn_t xlog_assign_lsn(uint cycle, uint block)\n{\n\treturn ((xfs_lsn_t)cycle << 32) | block;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void\nxlog_assign_atomic_lsn(atomic64_t *lsn, uint cycle, uint block)\n{\n\tatomic64_set(lsn, xlog_assign_lsn(cycle, block));\n}"
  },
  {
    "function_name": "xlog_crack_atomic_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "469-476",
    "snippet": "static inline void\nxlog_crack_atomic_lsn(atomic64_t *lsn, uint *cycle, uint *block)\n{\n\txfs_lsn_t val = atomic64_read(lsn);\n\n\t*cycle = CYCLE_LSN(val);\n\t*block = BLOCK_LSN(val);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "val"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN",
          "args": [
            "val"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "lsn"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline void\nxlog_crack_atomic_lsn(atomic64_t *lsn, uint *cycle, uint *block)\n{\n\txfs_lsn_t val = atomic64_read(lsn);\n\n\t*cycle = CYCLE_LSN(val);\n\t*block = BLOCK_LSN(val);\n}"
  },
  {
    "function_name": "xlog_write_adv_cnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "444-450",
    "snippet": "static inline void\nxlog_write_adv_cnt(void **ptr, int *len, int *off, size_t bytes)\n{\n\t*ptr += bytes;\n\t*len -= bytes;\n\t*off += bytes;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void\nxlog_write_adv_cnt(void **ptr, int *len, int *off, size_t bytes)\n{\n\t*ptr += bytes;\n\t*len -= bytes;\n\t*off += bytes;\n}"
  },
  {
    "function_name": "xlog_get_client_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
    "lines": "48-51",
    "snippet": "static inline uint xlog_get_client_id(__be32 i)\n{\n\treturn be32_to_cpu(i) >> 24;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "i"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline uint xlog_get_client_id(__be32 i)\n{\n\treturn be32_to_cpu(i) >> 24;\n}"
  }
]