[
  {
    "function_name": "do_utimes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/utimes.c",
    "lines": "136-183",
    "snippet": "long do_utimes(int dfd, const char __user *filename, struct timespec *times,\n\t       int flags)\n{\n\tint error = -EINVAL;\n\n\tif (times && (!nsec_valid(times[0].tv_nsec) ||\n\t\t      !nsec_valid(times[1].tv_nsec))) {\n\t\tgoto out;\n\t}\n\n\tif (flags & ~AT_SYMLINK_NOFOLLOW)\n\t\tgoto out;\n\n\tif (filename == NULL && dfd != AT_FDCWD) {\n\t\tstruct fd f;\n\n\t\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\t\tgoto out;\n\n\t\tf = fdget(dfd);\n\t\terror = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&f.file->f_path, times);\n\t\tfdput(f);\n\t} else {\n\t\tstruct path path;\n\t\tint lookup_flags = 0;\n\n\t\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\nretry:\n\t\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&path, times);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/linkage.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utimes_common",
          "args": [
            "&path",
            "times"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "utimes_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/utimes.c",
          "lines": "51-119",
          "snippet": "static int utimes_common(struct path *path, struct timespec *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tif (times && times[0].tv_nsec == UTIME_NOW &&\n\t\t     times[1].tv_nsec == UTIME_NOW)\n\t\ttimes = NULL;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime.tv_sec = times[0].tv_sec;\n\t\t\tnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\n\t\t\tnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t/*\n\t\t * Tell inode_change_ok(), that this is an explicit time\n\t\t * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET\n\t\t * were used.\n\t\t */\n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\t/*\n\t\t * If times is NULL (or both times are UTIME_NOW),\n\t\t * then we need to check permissions, because\n\t\t * inode_change_ok() won't do it.\n\t\t */\n\t\terror = -EACCES;\n                if (IS_IMMUTABLE(inode))\n\t\t\tgoto mnt_drop_write_and_out;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\tgoto mnt_drop_write_and_out;\n\t\t}\n\t}\nretry_deleg:\n\tmutex_lock(&inode->i_mutex);\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tmutex_unlock(&inode->i_mutex);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/utime.h>",
            "#include <linux/stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/linkage.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/linkage.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/compiler.h>\n\nstatic int utimes_common(struct path *path, struct timespec *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tif (times && times[0].tv_nsec == UTIME_NOW &&\n\t\t     times[1].tv_nsec == UTIME_NOW)\n\t\ttimes = NULL;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime.tv_sec = times[0].tv_sec;\n\t\t\tnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\n\t\t\tnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t/*\n\t\t * Tell inode_change_ok(), that this is an explicit time\n\t\t * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET\n\t\t * were used.\n\t\t */\n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\t/*\n\t\t * If times is NULL (or both times are UTIME_NOW),\n\t\t * then we need to check permissions, because\n\t\t * inode_change_ok() won't do it.\n\t\t */\n\t\terror = -EACCES;\n                if (IS_IMMUTABLE(inode))\n\t\t\tgoto mnt_drop_write_and_out;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\tgoto mnt_drop_write_and_out;\n\t\t}\n\t}\nretry_deleg:\n\tmutex_lock(&inode->i_mutex);\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tmutex_unlock(&inode->i_mutex);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "dfd",
            "filename",
            "lookup_flags",
            "&path"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "dfd"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsec_valid",
          "args": [
            "times[1].tv_nsec"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/utimes.c",
          "lines": "43-49",
          "snippet": "static bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/utime.h>",
            "#include <linux/stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/linkage.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/linkage.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/compiler.h>\n\nstatic bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/linkage.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/compiler.h>\n\nlong do_utimes(int dfd, const char __user *filename, struct timespec *times,\n\t       int flags)\n{\n\tint error = -EINVAL;\n\n\tif (times && (!nsec_valid(times[0].tv_nsec) ||\n\t\t      !nsec_valid(times[1].tv_nsec))) {\n\t\tgoto out;\n\t}\n\n\tif (flags & ~AT_SYMLINK_NOFOLLOW)\n\t\tgoto out;\n\n\tif (filename == NULL && dfd != AT_FDCWD) {\n\t\tstruct fd f;\n\n\t\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\t\tgoto out;\n\n\t\tf = fdget(dfd);\n\t\terror = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&f.file->f_path, times);\n\t\tfdput(f);\n\t} else {\n\t\tstruct path path;\n\t\tint lookup_flags = 0;\n\n\t\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\nretry:\n\t\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&path, times);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "utimes_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/utimes.c",
    "lines": "51-119",
    "snippet": "static int utimes_common(struct path *path, struct timespec *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tif (times && times[0].tv_nsec == UTIME_NOW &&\n\t\t     times[1].tv_nsec == UTIME_NOW)\n\t\ttimes = NULL;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime.tv_sec = times[0].tv_sec;\n\t\t\tnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\n\t\t\tnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t/*\n\t\t * Tell inode_change_ok(), that this is an explicit time\n\t\t * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET\n\t\t * were used.\n\t\t */\n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\t/*\n\t\t * If times is NULL (or both times are UTIME_NOW),\n\t\t * then we need to check permissions, because\n\t\t * inode_change_ok() won't do it.\n\t\t */\n\t\terror = -EACCES;\n                if (IS_IMMUTABLE(inode))\n\t\t\tgoto mnt_drop_write_and_out;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\tgoto mnt_drop_write_and_out;\n\t\t}\n\t}\nretry_deleg:\n\tmutex_lock(&inode->i_mutex);\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tmutex_unlock(&inode->i_mutex);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/linkage.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path->mnt"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "break_deleg_wait",
          "args": [
            "&delegated_inode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "path->dentry",
            "&newattrs",
            "&delegated_inode"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_WRITE"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path->mnt"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/linkage.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/compiler.h>\n\nstatic int utimes_common(struct path *path, struct timespec *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tif (times && times[0].tv_nsec == UTIME_NOW &&\n\t\t     times[1].tv_nsec == UTIME_NOW)\n\t\ttimes = NULL;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime.tv_sec = times[0].tv_sec;\n\t\t\tnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\n\t\t\tnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t/*\n\t\t * Tell inode_change_ok(), that this is an explicit time\n\t\t * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET\n\t\t * were used.\n\t\t */\n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\t/*\n\t\t * If times is NULL (or both times are UTIME_NOW),\n\t\t * then we need to check permissions, because\n\t\t * inode_change_ok() won't do it.\n\t\t */\n\t\terror = -EACCES;\n                if (IS_IMMUTABLE(inode))\n\t\t\tgoto mnt_drop_write_and_out;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\tgoto mnt_drop_write_and_out;\n\t\t}\n\t}\nretry_deleg:\n\tmutex_lock(&inode->i_mutex);\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tmutex_unlock(&inode->i_mutex);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "nsec_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/utimes.c",
    "lines": "43-49",
    "snippet": "static bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/linkage.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/compiler.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/linkage.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/compiler.h>\n\nstatic bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}"
  }
]