[
  {
    "function_name": "fanotify_user_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "929-939",
    "snippet": "static int __init fanotify_user_setup(void)\n{\n\tfanotify_mark_cache = KMEM_CACHE(fsnotify_mark, SLAB_PANIC);\n\tfanotify_event_cachep = KMEM_CACHE(fanotify_event_info, SLAB_PANIC);\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tfanotify_perm_event_cachep = KMEM_CACHE(fanotify_perm_event_info,\n\t\t\t\t\t\tSLAB_PANIC);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fanotify_mark_cache",
      "struct kmem_cache *fanotify_event_cachep",
      "struct kmem_cache *fanotify_perm_event_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "fanotify_perm_event_info",
            "SLAB_PANIC"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "fanotify_event_info",
            "SLAB_PANIC"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "fsnotify_mark",
            "SLAB_PANIC"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct kmem_cache *fanotify_mark_cache;\nstruct kmem_cache *fanotify_event_cachep;\nstruct kmem_cache *fanotify_perm_event_cachep;\n\nstatic int __init fanotify_user_setup(void)\n{\n\tfanotify_mark_cache = KMEM_CACHE(fsnotify_mark, SLAB_PANIC);\n\tfanotify_event_cachep = KMEM_CACHE(fanotify_event_info, SLAB_PANIC);\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tfanotify_perm_event_cachep = KMEM_CACHE(fanotify_perm_event_info,\n\t\t\t\t\t\tSLAB_PANIC);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fanotify_add_inode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "651-687",
    "snippet": "static int fanotify_add_inode_mark(struct fsnotify_group *group,\n\t\t\t\t   struct inode *inode, __u32 mask,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\t__u32 added;\n\n\tpr_debug(\"%s: group=%p inode=%p\\n\", __func__, group, inode);\n\n\t/*\n\t * If some other task has this inode open for write we should not add\n\t * an ignored mark, unless that ignored mark is supposed to survive\n\t * modification changes anyway.\n\t */\n\tif ((flags & FAN_MARK_IGNORED_MASK) &&\n\t    !(flags & FAN_MARK_IGNORED_SURV_MODIFY) &&\n\t    (atomic_read(&inode->i_writecount) > 0))\n\t\treturn 0;\n\n\tmutex_lock(&group->mark_mutex);\n\tfsn_mark = fsnotify_find_inode_mark(group, inode);\n\tif (!fsn_mark) {\n\t\tfsn_mark = fanotify_add_new_mark(group, inode, NULL);\n\t\tif (IS_ERR(fsn_mark)) {\n\t\t\tmutex_unlock(&group->mark_mutex);\n\t\t\treturn PTR_ERR(fsn_mark);\n\t\t}\n\t}\n\tadded = fanotify_mark_add_to_mask(fsn_mark, mask, flags);\n\tmutex_unlock(&group->mark_mutex);\n\n\tif (added & ~inode->i_fsnotify_mask)\n\t\tfsnotify_recalc_inode_mask(inode);\n\n\tfsnotify_put_mark(fsn_mark);\n\treturn 0;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "fsn_mark"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_recalc_inode_mask",
          "args": [
            "inode"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_recalc_inode_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "37-44",
          "snippet": "void fsnotify_recalc_inode_mask(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\t__fsnotify_update_child_dentry_flags(inode);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_recalc_inode_mask(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\t__fsnotify_update_child_dentry_flags(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fanotify_mark_add_to_mask",
          "args": [
            "fsn_mark",
            "mask",
            "flags"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_mark_add_to_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "571-598",
          "snippet": "static __u32 fanotify_mark_add_to_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t       __u32 mask,\n\t\t\t\t       unsigned int flags)\n{\n\t__u32 oldmask = -1;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask | mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask | mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t\tif (flags & FAN_MARK_IGNORED_SURV_MODIFY)\n\t\t\tfsn_mark->flags |= FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY;\n\t}\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & ~oldmask;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic __u32 fanotify_mark_add_to_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t       __u32 mask,\n\t\t\t\t       unsigned int flags)\n{\n\t__u32 oldmask = -1;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask | mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask | mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t\tif (flags & FAN_MARK_IGNORED_SURV_MODIFY)\n\t\t\tfsn_mark->flags |= FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY;\n\t}\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & ~oldmask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fsn_mark"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fsn_mark"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fanotify_add_new_mark",
          "args": [
            "group",
            "inode",
            "NULL"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_add_new_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "600-622",
          "snippet": "static struct fsnotify_mark *fanotify_add_new_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t\t   struct vfsmount *mnt)\n{\n\tstruct fsnotify_mark *mark;\n\tint ret;\n\n\tif (atomic_read(&group->num_marks) > group->fanotify_data.max_marks)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tmark = kmem_cache_alloc(fanotify_mark_cache, GFP_KERNEL);\n\tif (!mark)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsnotify_init_mark(mark, fanotify_free_mark);\n\tret = fsnotify_add_mark_locked(mark, group, inode, mnt, 0);\n\tif (ret) {\n\t\tfsnotify_put_mark(mark);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mark;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fanotify_mark_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct kmem_cache *fanotify_mark_cache;\n\nstatic struct fsnotify_mark *fanotify_add_new_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t\t   struct vfsmount *mnt)\n{\n\tstruct fsnotify_mark *mark;\n\tint ret;\n\n\tif (atomic_read(&group->num_marks) > group->fanotify_data.max_marks)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tmark = kmem_cache_alloc(fanotify_mark_cache, GFP_KERNEL);\n\tif (!mark)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsnotify_init_mark(mark, fanotify_free_mark);\n\tret = fsnotify_add_mark_locked(mark, group, inode, mnt, 0);\n\tif (ret) {\n\t\tfsnotify_put_mark(mark);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_find_inode_mark",
          "args": [
            "group",
            "inode"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_find_inode_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "99-109",
          "snippet": "struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,\n\t\t\t\t\t       struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&inode->i_lock);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tspin_unlock(&inode->i_lock);\n\n\treturn mark;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,\n\t\t\t\t\t       struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&inode->i_lock);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tspin_unlock(&inode->i_lock);\n\n\treturn mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_writecount"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p inode=%p\\n\"",
            "__func__",
            "group",
            "inode"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_add_inode_mark(struct fsnotify_group *group,\n\t\t\t\t   struct inode *inode, __u32 mask,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\t__u32 added;\n\n\tpr_debug(\"%s: group=%p inode=%p\\n\", __func__, group, inode);\n\n\t/*\n\t * If some other task has this inode open for write we should not add\n\t * an ignored mark, unless that ignored mark is supposed to survive\n\t * modification changes anyway.\n\t */\n\tif ((flags & FAN_MARK_IGNORED_MASK) &&\n\t    !(flags & FAN_MARK_IGNORED_SURV_MODIFY) &&\n\t    (atomic_read(&inode->i_writecount) > 0))\n\t\treturn 0;\n\n\tmutex_lock(&group->mark_mutex);\n\tfsn_mark = fsnotify_find_inode_mark(group, inode);\n\tif (!fsn_mark) {\n\t\tfsn_mark = fanotify_add_new_mark(group, inode, NULL);\n\t\tif (IS_ERR(fsn_mark)) {\n\t\t\tmutex_unlock(&group->mark_mutex);\n\t\t\treturn PTR_ERR(fsn_mark);\n\t\t}\n\t}\n\tadded = fanotify_mark_add_to_mask(fsn_mark, mask, flags);\n\tmutex_unlock(&group->mark_mutex);\n\n\tif (added & ~inode->i_fsnotify_mask)\n\t\tfsnotify_recalc_inode_mask(inode);\n\n\tfsnotify_put_mark(fsn_mark);\n\treturn 0;\n}"
  },
  {
    "function_name": "fanotify_add_vfsmount_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "625-649",
    "snippet": "static int fanotify_add_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t      struct vfsmount *mnt, __u32 mask,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\t__u32 added;\n\n\tmutex_lock(&group->mark_mutex);\n\tfsn_mark = fsnotify_find_vfsmount_mark(group, mnt);\n\tif (!fsn_mark) {\n\t\tfsn_mark = fanotify_add_new_mark(group, NULL, mnt);\n\t\tif (IS_ERR(fsn_mark)) {\n\t\t\tmutex_unlock(&group->mark_mutex);\n\t\t\treturn PTR_ERR(fsn_mark);\n\t\t}\n\t}\n\tadded = fanotify_mark_add_to_mask(fsn_mark, mask, flags);\n\tmutex_unlock(&group->mark_mutex);\n\n\tif (added & ~real_mount(mnt)->mnt_fsnotify_mask)\n\t\tfsnotify_recalc_vfsmount_mask(mnt);\n\n\tfsnotify_put_mark(fsn_mark);\n\treturn 0;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "fsn_mark"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_recalc_vfsmount_mask",
          "args": [
            "mnt"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_recalc_vfsmount_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/vfsmount_mark.c",
          "lines": "60-67",
          "snippet": "void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)\n{\n\tstruct mount *m = real_mount(mnt);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tm->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)\n{\n\tstruct mount *m = real_mount(mnt);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tm->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fanotify_mark_add_to_mask",
          "args": [
            "fsn_mark",
            "mask",
            "flags"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_mark_add_to_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "571-598",
          "snippet": "static __u32 fanotify_mark_add_to_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t       __u32 mask,\n\t\t\t\t       unsigned int flags)\n{\n\t__u32 oldmask = -1;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask | mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask | mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t\tif (flags & FAN_MARK_IGNORED_SURV_MODIFY)\n\t\t\tfsn_mark->flags |= FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY;\n\t}\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & ~oldmask;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic __u32 fanotify_mark_add_to_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t       __u32 mask,\n\t\t\t\t       unsigned int flags)\n{\n\t__u32 oldmask = -1;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask | mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask | mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t\tif (flags & FAN_MARK_IGNORED_SURV_MODIFY)\n\t\t\tfsn_mark->flags |= FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY;\n\t}\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & ~oldmask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fsn_mark"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fsn_mark"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fanotify_add_new_mark",
          "args": [
            "group",
            "NULL",
            "mnt"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_add_new_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "600-622",
          "snippet": "static struct fsnotify_mark *fanotify_add_new_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t\t   struct vfsmount *mnt)\n{\n\tstruct fsnotify_mark *mark;\n\tint ret;\n\n\tif (atomic_read(&group->num_marks) > group->fanotify_data.max_marks)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tmark = kmem_cache_alloc(fanotify_mark_cache, GFP_KERNEL);\n\tif (!mark)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsnotify_init_mark(mark, fanotify_free_mark);\n\tret = fsnotify_add_mark_locked(mark, group, inode, mnt, 0);\n\tif (ret) {\n\t\tfsnotify_put_mark(mark);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mark;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fanotify_mark_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct kmem_cache *fanotify_mark_cache;\n\nstatic struct fsnotify_mark *fanotify_add_new_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t\t   struct vfsmount *mnt)\n{\n\tstruct fsnotify_mark *mark;\n\tint ret;\n\n\tif (atomic_read(&group->num_marks) > group->fanotify_data.max_marks)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tmark = kmem_cache_alloc(fanotify_mark_cache, GFP_KERNEL);\n\tif (!mark)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsnotify_init_mark(mark, fanotify_free_mark);\n\tret = fsnotify_add_mark_locked(mark, group, inode, mnt, 0);\n\tif (ret) {\n\t\tfsnotify_put_mark(mark);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_find_vfsmount_mark",
          "args": [
            "group",
            "mnt"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_find_vfsmount_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/vfsmount_mark.c",
          "lines": "90-101",
          "snippet": "struct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t  struct vfsmount *mnt)\n{\n\tstruct mount *m = real_mount(mnt);\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tmark = fsnotify_find_mark(&m->mnt_fsnotify_marks, group);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n\n\treturn mark;\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t  struct vfsmount *mnt)\n{\n\tstruct mount *m = real_mount(mnt);\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tmark = fsnotify_find_mark(&m->mnt_fsnotify_marks, group);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n\n\treturn mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_add_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t      struct vfsmount *mnt, __u32 mask,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\t__u32 added;\n\n\tmutex_lock(&group->mark_mutex);\n\tfsn_mark = fsnotify_find_vfsmount_mark(group, mnt);\n\tif (!fsn_mark) {\n\t\tfsn_mark = fanotify_add_new_mark(group, NULL, mnt);\n\t\tif (IS_ERR(fsn_mark)) {\n\t\t\tmutex_unlock(&group->mark_mutex);\n\t\t\treturn PTR_ERR(fsn_mark);\n\t\t}\n\t}\n\tadded = fanotify_mark_add_to_mask(fsn_mark, mask, flags);\n\tmutex_unlock(&group->mark_mutex);\n\n\tif (added & ~real_mount(mnt)->mnt_fsnotify_mask)\n\t\tfsnotify_recalc_vfsmount_mask(mnt);\n\n\tfsnotify_put_mark(fsn_mark);\n\treturn 0;\n}"
  },
  {
    "function_name": "fanotify_add_new_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "600-622",
    "snippet": "static struct fsnotify_mark *fanotify_add_new_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t\t   struct vfsmount *mnt)\n{\n\tstruct fsnotify_mark *mark;\n\tint ret;\n\n\tif (atomic_read(&group->num_marks) > group->fanotify_data.max_marks)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tmark = kmem_cache_alloc(fanotify_mark_cache, GFP_KERNEL);\n\tif (!mark)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsnotify_init_mark(mark, fanotify_free_mark);\n\tret = fsnotify_add_mark_locked(mark, group, inode, mnt, 0);\n\tif (ret) {\n\t\tfsnotify_put_mark(mark);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mark;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fanotify_mark_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_add_mark_locked",
          "args": [
            "mark",
            "group",
            "inode",
            "mnt",
            "0"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_add_mark_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "318-378",
          "snippet": "int fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     struct fsnotify_group *group, struct inode *inode,\n\t\t\t     struct vfsmount *mnt, int allow_dups)\n{\n\tint ret = 0;\n\n\tBUG_ON(inode && mnt);\n\tBUG_ON(!inode && !mnt);\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\t/*\n\t * LOCKING ORDER!!!!\n\t * group->mark_mutex\n\t * mark->lock\n\t * inode->i_lock\n\t */\n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tlist_add(&mark->g_list, &group->marks_list);\n\tatomic_inc(&group->num_marks);\n\tfsnotify_get_mark(mark); /* for i_list and g_list */\n\n\tif (inode) {\n\t\tret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (mnt) {\n\t\tret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* this will pin the object if appropriate */\n\tfsnotify_set_mark_mask_locked(mark, mark->mask);\n\tspin_unlock(&mark->lock);\n\n\tif (inode)\n\t\t__fsnotify_update_child_dentry_flags(inode);\n\n\treturn ret;\nerr:\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tlist_del_init(&mark->g_list);\n\tfsnotify_put_group(group);\n\tmark->group = NULL;\n\tatomic_dec(&group->num_marks);\n\n\tspin_unlock(&mark->lock);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(destroy_lock);",
            "static LIST_HEAD(destroy_list);",
            "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nint fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     struct fsnotify_group *group, struct inode *inode,\n\t\t\t     struct vfsmount *mnt, int allow_dups)\n{\n\tint ret = 0;\n\n\tBUG_ON(inode && mnt);\n\tBUG_ON(!inode && !mnt);\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\t/*\n\t * LOCKING ORDER!!!!\n\t * group->mark_mutex\n\t * mark->lock\n\t * inode->i_lock\n\t */\n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tlist_add(&mark->g_list, &group->marks_list);\n\tatomic_inc(&group->num_marks);\n\tfsnotify_get_mark(mark); /* for i_list and g_list */\n\n\tif (inode) {\n\t\tret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (mnt) {\n\t\tret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* this will pin the object if appropriate */\n\tfsnotify_set_mark_mask_locked(mark, mark->mask);\n\tspin_unlock(&mark->lock);\n\n\tif (inode)\n\t\t__fsnotify_update_child_dentry_flags(inode);\n\n\treturn ret;\nerr:\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tlist_del_init(&mark->g_list);\n\tfsnotify_put_group(group);\n\tmark->group = NULL;\n\tatomic_dec(&group->num_marks);\n\n\tspin_unlock(&mark->lock);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_init_mark",
          "args": [
            "mark",
            "fanotify_free_mark"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_init_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "450-457",
          "snippet": "void fsnotify_init_mark(struct fsnotify_mark *mark,\n\t\t\tvoid (*free_mark)(struct fsnotify_mark *mark))\n{\n\tmemset(mark, 0, sizeof(*mark));\n\tspin_lock_init(&mark->lock);\n\tatomic_set(&mark->refcnt, 1);\n\tmark->free_mark = free_mark;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_init_mark(struct fsnotify_mark *mark,\n\t\t\tvoid (*free_mark)(struct fsnotify_mark *mark))\n{\n\tmemset(mark, 0, sizeof(*mark));\n\tspin_lock_init(&mark->lock);\n\tatomic_set(&mark->refcnt, 1);\n\tmark->free_mark = free_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "fanotify_mark_cache",
            "GFP_KERNEL"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&group->num_marks"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct kmem_cache *fanotify_mark_cache;\n\nstatic struct fsnotify_mark *fanotify_add_new_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t\t   struct vfsmount *mnt)\n{\n\tstruct fsnotify_mark *mark;\n\tint ret;\n\n\tif (atomic_read(&group->num_marks) > group->fanotify_data.max_marks)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tmark = kmem_cache_alloc(fanotify_mark_cache, GFP_KERNEL);\n\tif (!mark)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfsnotify_init_mark(mark, fanotify_free_mark);\n\tret = fsnotify_add_mark_locked(mark, group, inode, mnt, 0);\n\tif (ret) {\n\t\tfsnotify_put_mark(mark);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mark;\n}"
  },
  {
    "function_name": "fanotify_mark_add_to_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "571-598",
    "snippet": "static __u32 fanotify_mark_add_to_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t       __u32 mask,\n\t\t\t\t       unsigned int flags)\n{\n\t__u32 oldmask = -1;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask | mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask | mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t\tif (flags & FAN_MARK_IGNORED_SURV_MODIFY)\n\t\t\tfsn_mark->flags |= FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY;\n\t}\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & ~oldmask;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fsn_mark->lock"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_set_mark_ignored_mask_locked",
          "args": [
            "fsn_mark",
            "tmask"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_set_mark_ignored_mask_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "237-242",
          "snippet": "void fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->ignored_mask = mask;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->ignored_mask = mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_set_mark_mask_locked",
          "args": [
            "fsn_mark",
            "tmask"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_set_mark_mask_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "227-235",
          "snippet": "void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fsn_mark->lock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic __u32 fanotify_mark_add_to_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t       __u32 mask,\n\t\t\t\t       unsigned int flags)\n{\n\t__u32 oldmask = -1;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask | mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask | mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask |= FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t\tif (flags & FAN_MARK_IGNORED_SURV_MODIFY)\n\t\t\tfsn_mark->flags |= FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY;\n\t}\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & ~oldmask;\n}"
  },
  {
    "function_name": "fanotify_remove_inode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "542-569",
    "snippet": "static int fanotify_remove_inode_mark(struct fsnotify_group *group,\n\t\t\t\t      struct inode *inode, __u32 mask,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct fsnotify_mark *fsn_mark = NULL;\n\t__u32 removed;\n\tint destroy_mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tfsn_mark = fsnotify_find_inode_mark(group, inode);\n\tif (!fsn_mark) {\n\t\tmutex_unlock(&group->mark_mutex);\n\t\treturn -ENOENT;\n\t}\n\n\tremoved = fanotify_mark_remove_from_mask(fsn_mark, mask, flags,\n\t\t\t\t\t\t &destroy_mark);\n\tif (destroy_mark)\n\t\tfsnotify_destroy_mark_locked(fsn_mark, group);\n\tmutex_unlock(&group->mark_mutex);\n\n\t/* matches the fsnotify_find_inode_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\tif (removed & inode->i_fsnotify_mask)\n\t\tfsnotify_recalc_inode_mask(inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_recalc_inode_mask",
          "args": [
            "inode"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_recalc_inode_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "37-44",
          "snippet": "void fsnotify_recalc_inode_mask(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\t__fsnotify_update_child_dentry_flags(inode);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_recalc_inode_mask(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\t__fsnotify_update_child_dentry_flags(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "fsn_mark"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark_locked",
          "args": [
            "fsn_mark",
            "group"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_mark_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "129-196",
          "snippet": "void fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(destroy_lock);",
            "static LIST_HEAD(destroy_list);",
            "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nvoid fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fanotify_mark_remove_from_mask",
          "args": [
            "fsn_mark",
            "mask",
            "flags",
            "&destroy_mark"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_mark_remove_from_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "485-512",
          "snippet": "static __u32 fanotify_mark_remove_from_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t\t    __u32 mask,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    int *destroy)\n{\n\t__u32 oldmask = 0;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask & ~mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask & ~mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t}\n\t*destroy = !(fsn_mark->mask | fsn_mark->ignored_mask);\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & oldmask;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic __u32 fanotify_mark_remove_from_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t\t    __u32 mask,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    int *destroy)\n{\n\t__u32 oldmask = 0;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask & ~mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask & ~mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t}\n\t*destroy = !(fsn_mark->mask | fsn_mark->ignored_mask);\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & oldmask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_find_inode_mark",
          "args": [
            "group",
            "inode"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_find_inode_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "99-109",
          "snippet": "struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,\n\t\t\t\t\t       struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&inode->i_lock);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tspin_unlock(&inode->i_lock);\n\n\treturn mark;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,\n\t\t\t\t\t       struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&inode->i_lock);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tspin_unlock(&inode->i_lock);\n\n\treturn mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_remove_inode_mark(struct fsnotify_group *group,\n\t\t\t\t      struct inode *inode, __u32 mask,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct fsnotify_mark *fsn_mark = NULL;\n\t__u32 removed;\n\tint destroy_mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tfsn_mark = fsnotify_find_inode_mark(group, inode);\n\tif (!fsn_mark) {\n\t\tmutex_unlock(&group->mark_mutex);\n\t\treturn -ENOENT;\n\t}\n\n\tremoved = fanotify_mark_remove_from_mask(fsn_mark, mask, flags,\n\t\t\t\t\t\t &destroy_mark);\n\tif (destroy_mark)\n\t\tfsnotify_destroy_mark_locked(fsn_mark, group);\n\tmutex_unlock(&group->mark_mutex);\n\n\t/* matches the fsnotify_find_inode_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\tif (removed & inode->i_fsnotify_mask)\n\t\tfsnotify_recalc_inode_mask(inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fanotify_remove_vfsmount_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "514-540",
    "snippet": "static int fanotify_remove_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t\t struct vfsmount *mnt, __u32 mask,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct fsnotify_mark *fsn_mark = NULL;\n\t__u32 removed;\n\tint destroy_mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tfsn_mark = fsnotify_find_vfsmount_mark(group, mnt);\n\tif (!fsn_mark) {\n\t\tmutex_unlock(&group->mark_mutex);\n\t\treturn -ENOENT;\n\t}\n\n\tremoved = fanotify_mark_remove_from_mask(fsn_mark, mask, flags,\n\t\t\t\t\t\t &destroy_mark);\n\tif (destroy_mark)\n\t\tfsnotify_destroy_mark_locked(fsn_mark, group);\n\tmutex_unlock(&group->mark_mutex);\n\n\tfsnotify_put_mark(fsn_mark);\n\tif (removed & real_mount(mnt)->mnt_fsnotify_mask)\n\t\tfsnotify_recalc_vfsmount_mask(mnt);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_recalc_vfsmount_mask",
          "args": [
            "mnt"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_recalc_vfsmount_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/vfsmount_mark.c",
          "lines": "60-67",
          "snippet": "void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)\n{\n\tstruct mount *m = real_mount(mnt);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tm->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)\n{\n\tstruct mount *m = real_mount(mnt);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tm->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "fsn_mark"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark_locked",
          "args": [
            "fsn_mark",
            "group"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_mark_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "129-196",
          "snippet": "void fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(destroy_lock);",
            "static LIST_HEAD(destroy_list);",
            "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nvoid fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fanotify_mark_remove_from_mask",
          "args": [
            "fsn_mark",
            "mask",
            "flags",
            "&destroy_mark"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_mark_remove_from_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "485-512",
          "snippet": "static __u32 fanotify_mark_remove_from_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t\t    __u32 mask,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    int *destroy)\n{\n\t__u32 oldmask = 0;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask & ~mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask & ~mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t}\n\t*destroy = !(fsn_mark->mask | fsn_mark->ignored_mask);\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & oldmask;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic __u32 fanotify_mark_remove_from_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t\t    __u32 mask,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    int *destroy)\n{\n\t__u32 oldmask = 0;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask & ~mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask & ~mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t}\n\t*destroy = !(fsn_mark->mask | fsn_mark->ignored_mask);\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & oldmask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_find_vfsmount_mark",
          "args": [
            "group",
            "mnt"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_find_vfsmount_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/vfsmount_mark.c",
          "lines": "90-101",
          "snippet": "struct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t  struct vfsmount *mnt)\n{\n\tstruct mount *m = real_mount(mnt);\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tmark = fsnotify_find_mark(&m->mnt_fsnotify_marks, group);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n\n\treturn mark;\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t\t\t  struct vfsmount *mnt)\n{\n\tstruct mount *m = real_mount(mnt);\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tmark = fsnotify_find_mark(&m->mnt_fsnotify_marks, group);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n\n\treturn mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_remove_vfsmount_mark(struct fsnotify_group *group,\n\t\t\t\t\t struct vfsmount *mnt, __u32 mask,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct fsnotify_mark *fsn_mark = NULL;\n\t__u32 removed;\n\tint destroy_mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tfsn_mark = fsnotify_find_vfsmount_mark(group, mnt);\n\tif (!fsn_mark) {\n\t\tmutex_unlock(&group->mark_mutex);\n\t\treturn -ENOENT;\n\t}\n\n\tremoved = fanotify_mark_remove_from_mask(fsn_mark, mask, flags,\n\t\t\t\t\t\t &destroy_mark);\n\tif (destroy_mark)\n\t\tfsnotify_destroy_mark_locked(fsn_mark, group);\n\tmutex_unlock(&group->mark_mutex);\n\n\tfsnotify_put_mark(fsn_mark);\n\tif (removed & real_mount(mnt)->mnt_fsnotify_mask)\n\t\tfsnotify_recalc_vfsmount_mask(mnt);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fanotify_mark_remove_from_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "485-512",
    "snippet": "static __u32 fanotify_mark_remove_from_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t\t    __u32 mask,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    int *destroy)\n{\n\t__u32 oldmask = 0;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask & ~mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask & ~mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t}\n\t*destroy = !(fsn_mark->mask | fsn_mark->ignored_mask);\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & oldmask;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fsn_mark->lock"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_set_mark_ignored_mask_locked",
          "args": [
            "fsn_mark",
            "tmask"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_set_mark_ignored_mask_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "237-242",
          "snippet": "void fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->ignored_mask = mask;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->ignored_mask = mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_set_mark_mask_locked",
          "args": [
            "fsn_mark",
            "tmask"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_set_mark_mask_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "227-235",
          "snippet": "void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fsn_mark->lock"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic __u32 fanotify_mark_remove_from_mask(struct fsnotify_mark *fsn_mark,\n\t\t\t\t\t    __u32 mask,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    int *destroy)\n{\n\t__u32 oldmask = 0;\n\n\tspin_lock(&fsn_mark->lock);\n\tif (!(flags & FAN_MARK_IGNORED_MASK)) {\n\t\t__u32 tmask = fsn_mark->mask & ~mask;\n\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\toldmask = fsn_mark->mask;\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, tmask);\n\t} else {\n\t\t__u32 tmask = fsn_mark->ignored_mask & ~mask;\n\t\tif (flags & FAN_MARK_ONDIR)\n\t\t\ttmask &= ~FAN_ONDIR;\n\n\t\tfsnotify_set_mark_ignored_mask_locked(fsn_mark, tmask);\n\t}\n\t*destroy = !(fsn_mark->mask | fsn_mark->ignored_mask);\n\tspin_unlock(&fsn_mark->lock);\n\n\treturn mask & oldmask;\n}"
  },
  {
    "function_name": "fanotify_find_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "439-483",
    "snippet": "static int fanotify_find_path(int dfd, const char __user *filename,\n\t\t\t      struct path *path, unsigned int flags)\n{\n\tint ret;\n\n\tpr_debug(\"%s: dfd=%d filename=%p flags=%x\\n\", __func__,\n\t\t dfd, filename, flags);\n\n\tif (filename == NULL) {\n\t\tstruct fd f = fdget(dfd);\n\n\t\tret = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\tret = -ENOTDIR;\n\t\tif ((flags & FAN_MARK_ONLYDIR) &&\n\t\t    !(S_ISDIR(file_inode(f.file)->i_mode))) {\n\t\t\tfdput(f);\n\t\t\tgoto out;\n\t\t}\n\n\t\t*path = f.file->f_path;\n\t\tpath_get(path);\n\t\tfdput(f);\n\t} else {\n\t\tunsigned int lookup_flags = 0;\n\n\t\tif (!(flags & FAN_MARK_DONT_FOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\n\t\tif (flags & FAN_MARK_ONLYDIR)\n\t\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\n\t\tret = user_path_at(dfd, filename, lookup_flags, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* you can only watch an inode if you have read permissions on it */\n\tret = inode_permission(path->dentry->d_inode, MAY_READ);\n\tif (ret)\n\t\tpath_put(path);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "path"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "path->dentry->d_inode",
            "MAY_READ"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "dfd",
            "filename",
            "lookup_flags",
            "path"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "path"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "file_inode(f.file)->i_mode"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f.file"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "dfd"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: dfd=%d filename=%p flags=%x\\n\"",
            "__func__",
            "dfd",
            "filename",
            "flags"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_find_path(int dfd, const char __user *filename,\n\t\t\t      struct path *path, unsigned int flags)\n{\n\tint ret;\n\n\tpr_debug(\"%s: dfd=%d filename=%p flags=%x\\n\", __func__,\n\t\t dfd, filename, flags);\n\n\tif (filename == NULL) {\n\t\tstruct fd f = fdget(dfd);\n\n\t\tret = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\tret = -ENOTDIR;\n\t\tif ((flags & FAN_MARK_ONLYDIR) &&\n\t\t    !(S_ISDIR(file_inode(f.file)->i_mode))) {\n\t\t\tfdput(f);\n\t\t\tgoto out;\n\t\t}\n\n\t\t*path = f.file->f_path;\n\t\tpath_get(path);\n\t\tfdput(f);\n\t} else {\n\t\tunsigned int lookup_flags = 0;\n\n\t\tif (!(flags & FAN_MARK_DONT_FOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\n\t\tif (flags & FAN_MARK_ONLYDIR)\n\t\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\n\t\tret = user_path_at(dfd, filename, lookup_flags, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* you can only watch an inode if you have read permissions on it */\n\tret = inode_permission(path->dentry->d_inode, MAY_READ);\n\tif (ret)\n\t\tpath_put(path);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "fanotify_free_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "434-437",
    "snippet": "static void fanotify_free_mark(struct fsnotify_mark *fsn_mark)\n{\n\tkmem_cache_free(fanotify_mark_cache, fsn_mark);\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fanotify_mark_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fanotify_mark_cache",
            "fsn_mark"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct kmem_cache *fanotify_mark_cache;\n\nstatic void fanotify_free_mark(struct fsnotify_mark *fsn_mark)\n{\n\tkmem_cache_free(fanotify_mark_cache, fsn_mark);\n}"
  },
  {
    "function_name": "fanotify_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "397-420",
    "snippet": "static long fanotify_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *fsn_event;\n\tvoid __user *p;\n\tint ret = -ENOTTY;\n\tsize_t send_len = 0;\n\n\tgroup = file->private_data;\n\n\tp = (void __user *) arg;\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\t\tmutex_lock(&group->notification_mutex);\n\t\tlist_for_each_entry(fsn_event, &group->notification_list, list)\n\t\t\tsend_len += FAN_EVENT_METADATA_LEN;\n\t\tmutex_unlock(&group->notification_mutex);\n\t\tret = put_user(send_len, (int __user *) p);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "send_len",
            "(int __user *) p"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fsn_event",
            "&group->notification_list",
            "list"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic long fanotify_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *fsn_event;\n\tvoid __user *p;\n\tint ret = -ENOTTY;\n\tsize_t send_len = 0;\n\n\tgroup = file->private_data;\n\n\tp = (void __user *) arg;\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\t\tmutex_lock(&group->notification_mutex);\n\t\tlist_for_each_entry(fsn_event, &group->notification_list, list)\n\t\t\tsend_len += FAN_EVENT_METADATA_LEN;\n\t\tmutex_unlock(&group->notification_mutex);\n\t\tret = put_user(send_len, (int __user *) p);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fanotify_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "355-395",
    "snippet": "static int fanotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tstruct fanotify_perm_event_info *event, *next;\n\n\t/*\n\t * There may be still new events arriving in the notification queue\n\t * but since userspace cannot use fanotify fd anymore, no event can\n\t * enter or leave access_list by now.\n\t */\n\tspin_lock(&group->fanotify_data.access_lock);\n\n\tatomic_inc(&group->fanotify_data.bypass_perm);\n\n\tlist_for_each_entry_safe(event, next, &group->fanotify_data.access_list,\n\t\t\t\t fae.fse.list) {\n\t\tpr_debug(\"%s: found group=%p event=%p\\n\", __func__, group,\n\t\t\t event);\n\n\t\tlist_del_init(&event->fae.fse.list);\n\t\tevent->response = FAN_ALLOW;\n\t}\n\tspin_unlock(&group->fanotify_data.access_lock);\n\n\t/*\n\t * Since bypass_perm is set, newly queued events will not wait for\n\t * access response. Wake up the already sleeping ones now.\n\t * synchronize_srcu() in fsnotify_destroy_group() will wait for all\n\t * processes sleeping in fanotify_handle_event() waiting for access\n\t * response and thus also for all permission events to be freed.\n\t */\n\twake_up(&group->fanotify_data.access_waitq);\n#endif\n\n\t/* matches the fanotify_init->fsnotify_alloc_group */\n\tfsnotify_destroy_group(group);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_destroy_group",
          "args": [
            "group"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "48-66",
          "snippet": "void fsnotify_destroy_group(struct fsnotify_group *group)\n{\n\t/* clear all inode marks for this group */\n\tfsnotify_clear_marks_by_group(group);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\t/* clear the notification queue of all events */\n\tfsnotify_flush_notify(group);\n\n\t/*\n\t * Destroy overflow event (we cannot use fsnotify_destroy_event() as\n\t * that deliberately ignores overflow events.\n\t */\n\tif (group->overflow_event)\n\t\tgroup->ops->free_event(group->overflow_event);\n\n\tfsnotify_put_group(group);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_destroy_group(struct fsnotify_group *group)\n{\n\t/* clear all inode marks for this group */\n\tfsnotify_clear_marks_by_group(group);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\t/* clear the notification queue of all events */\n\tfsnotify_flush_notify(group);\n\n\t/*\n\t * Destroy overflow event (we cannot use fsnotify_destroy_event() as\n\t * that deliberately ignores overflow events.\n\t */\n\tif (group->overflow_event)\n\t\tgroup->ops->free_event(group->overflow_event);\n\n\tfsnotify_put_group(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&group->fanotify_data.access_waitq"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&group->fanotify_data.access_lock"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&event->fae.fse.list"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: found group=%p event=%p\\n\"",
            "__func__",
            "group",
            "event"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "event",
            "next",
            "&group->fanotify_data.access_list",
            "fae.fse.list"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&group->fanotify_data.bypass_perm"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&group->fanotify_data.access_lock"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tstruct fanotify_perm_event_info *event, *next;\n\n\t/*\n\t * There may be still new events arriving in the notification queue\n\t * but since userspace cannot use fanotify fd anymore, no event can\n\t * enter or leave access_list by now.\n\t */\n\tspin_lock(&group->fanotify_data.access_lock);\n\n\tatomic_inc(&group->fanotify_data.bypass_perm);\n\n\tlist_for_each_entry_safe(event, next, &group->fanotify_data.access_list,\n\t\t\t\t fae.fse.list) {\n\t\tpr_debug(\"%s: found group=%p event=%p\\n\", __func__, group,\n\t\t\t event);\n\n\t\tlist_del_init(&event->fae.fse.list);\n\t\tevent->response = FAN_ALLOW;\n\t}\n\tspin_unlock(&group->fanotify_data.access_lock);\n\n\t/*\n\t * Since bypass_perm is set, newly queued events will not wait for\n\t * access response. Wake up the already sleeping ones now.\n\t * synchronize_srcu() in fsnotify_destroy_group() will wait for all\n\t * processes sleeping in fanotify_handle_event() waiting for access\n\t * response and thus also for all permission events to be freed.\n\t */\n\twake_up(&group->fanotify_data.access_waitq);\n#endif\n\n\t/* matches the fanotify_init->fsnotify_alloc_group */\n\tfsnotify_destroy_group(group);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fanotify_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "328-353",
    "snippet": "static ssize_t fanotify_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tstruct fanotify_response response = { .fd = -1, .response = -1 };\n\tstruct fsnotify_group *group;\n\tint ret;\n\n\tgroup = file->private_data;\n\n\tif (count > sizeof(response))\n\t\tcount = sizeof(response);\n\n\tpr_debug(\"%s: group=%p count=%zu\\n\", __func__, group, count);\n\n\tif (copy_from_user(&response, buf, count))\n\t\treturn -EFAULT;\n\n\tret = process_access_response(group, &response);\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n#else\n\treturn -EINVAL;\n#endif\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_access_response",
          "args": [
            "group",
            "&response"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "process_access_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "167-200",
          "snippet": "static int process_access_response(struct fsnotify_group *group,\n\t\t\t\t   struct fanotify_response *response_struct)\n{\n\tstruct fanotify_perm_event_info *event;\n\tint fd = response_struct->fd;\n\tint response = response_struct->response;\n\n\tpr_debug(\"%s: group=%p fd=%d response=%d\\n\", __func__, group,\n\t\t fd, response);\n\t/*\n\t * make sure the response is valid, if invalid we do nothing and either\n\t * userspace can send a valid response or we will clean it up after the\n\t * timeout\n\t */\n\tswitch (response) {\n\tcase FAN_ALLOW:\n\tcase FAN_DENY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fd < 0)\n\t\treturn -EINVAL;\n\n\tevent = dequeue_event(group, fd);\n\tif (!event)\n\t\treturn -ENOENT;\n\n\tevent->response = response;\n\twake_up(&group->fanotify_data.access_waitq);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int process_access_response(struct fsnotify_group *group,\n\t\t\t\t   struct fanotify_response *response_struct)\n{\n\tstruct fanotify_perm_event_info *event;\n\tint fd = response_struct->fd;\n\tint response = response_struct->response;\n\n\tpr_debug(\"%s: group=%p fd=%d response=%d\\n\", __func__, group,\n\t\t fd, response);\n\t/*\n\t * make sure the response is valid, if invalid we do nothing and either\n\t * userspace can send a valid response or we will clean it up after the\n\t * timeout\n\t */\n\tswitch (response) {\n\tcase FAN_ALLOW:\n\tcase FAN_DENY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fd < 0)\n\t\treturn -EINVAL;\n\n\tevent = dequeue_event(group, fd);\n\tif (!event)\n\t\treturn -ENOENT;\n\n\tevent->response = response;\n\twake_up(&group->fanotify_data.access_waitq);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&response",
            "buf",
            "count"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p count=%zu\\n\"",
            "__func__",
            "group",
            "count"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic ssize_t fanotify_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tstruct fanotify_response response = { .fd = -1, .response = -1 };\n\tstruct fsnotify_group *group;\n\tint ret;\n\n\tgroup = file->private_data;\n\n\tif (count > sizeof(response))\n\t\tcount = sizeof(response);\n\n\tpr_debug(\"%s: group=%p count=%zu\\n\", __func__, group, count);\n\n\tif (copy_from_user(&response, buf, count))\n\t\treturn -EFAULT;\n\n\tret = process_access_response(group, &response);\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n#else\n\treturn -EINVAL;\n#endif\n}"
  },
  {
    "function_name": "fanotify_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "255-326",
    "snippet": "static ssize_t fanotify_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *kevent;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tstart = buf;\n\tgroup = file->private_data;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tadd_wait_queue(&group->notification_waitq, &wait);\n\twhile (1) {\n\t\tmutex_lock(&group->notification_mutex);\n\t\tkevent = get_one_event(group, count);\n\t\tmutex_unlock(&group->notification_mutex);\n\n\t\tif (IS_ERR(kevent)) {\n\t\t\tret = PTR_ERR(kevent);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!kevent) {\n\t\t\tret = -EAGAIN;\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\tbreak;\n\n\t\t\tret = -ERESTARTSYS;\n\t\t\tif (signal_pending(current))\n\t\t\t\tbreak;\n\n\t\t\tif (start != buf)\n\t\t\t\tbreak;\n\n\t\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = copy_event_to_user(group, kevent, buf);\n\t\t/*\n\t\t * Permission events get queued to wait for response.  Other\n\t\t * events can be destroyed now.\n\t\t */\n\t\tif (!(kevent->mask & FAN_ALL_PERM_EVENTS)) {\n\t\t\tfsnotify_destroy_event(group, kevent);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else {\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\t\t\tif (ret < 0) {\n\t\t\t\tFANOTIFY_PE(kevent)->response = FAN_DENY;\n\t\t\t\twake_up(&group->fanotify_data.access_waitq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_lock(&group->fanotify_data.access_lock);\n\t\t\tlist_add_tail(&kevent->list,\n\t\t\t\t      &group->fanotify_data.access_list);\n\t\t\tspin_unlock(&group->fanotify_data.access_lock);\n#endif\n\t\t}\n\t\tbuf += ret;\n\t\tcount -= ret;\n\t}\n\tremove_wait_queue(&group->notification_waitq, &wait);\n\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\treturn ret;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&group->notification_waitq",
            "&wait"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&group->fanotify_data.access_lock"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&kevent->list",
            "&group->fanotify_data.access_list"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&group->fanotify_data.access_lock"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&group->fanotify_data.access_waitq"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FANOTIFY_PE",
          "args": [
            "kevent"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "FANOTIFY_PE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.h",
          "lines": "37-41",
          "snippet": "static inline struct fanotify_perm_event_info *\nFANOTIFY_PE(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_perm_event_info, fae.fse);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct fanotify_perm_event_info *\nFANOTIFY_PE(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_perm_event_info, fae.fse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_event",
          "args": [
            "group",
            "kevent"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "70-79",
          "snippet": "void fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t/* Overflow events are per-group and we don't want to free them */\n\tif (!event || event->mask == FS_Q_OVERFLOW)\n\t\treturn;\n\t/* If the event is still queued, we have a problem... */\n\tWARN_ON(!list_empty(&event->list));\n\tgroup->ops->free_event(event);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t/* Overflow events are per-group and we don't want to free them */\n\tif (!event || event->mask == FS_Q_OVERFLOW)\n\t\treturn;\n\t/* If the event is still queued, we have a problem... */\n\tWARN_ON(!list_empty(&event->list));\n\tgroup->ops->free_event(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_event_to_user",
          "args": [
            "group",
            "kevent",
            "buf"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "copy_event_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "203-238",
          "snippet": "static ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct fanotify_event_metadata fanotify_event_metadata;\n\tstruct file *f;\n\tint fd, ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tret = fill_event_metadata(group, &fanotify_event_metadata, event, &f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfd = fanotify_event_metadata.fd;\n\tret = -EFAULT;\n\tif (copy_to_user(buf, &fanotify_event_metadata,\n\t\t\t fanotify_event_metadata.event_len))\n\t\tgoto out_close_fd;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (event->mask & FAN_ALL_PERM_EVENTS)\n\t\tFANOTIFY_PE(event)->fd = fd;\n#endif\n\n\tif (fd != FAN_NOFD)\n\t\tfd_install(fd, f);\n\treturn fanotify_event_metadata.event_len;\n\nout_close_fd:\n\tif (fd != FAN_NOFD) {\n\t\tput_unused_fd(fd);\n\t\tfput(f);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct fanotify_event_metadata fanotify_event_metadata;\n\tstruct file *f;\n\tint fd, ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tret = fill_event_metadata(group, &fanotify_event_metadata, event, &f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfd = fanotify_event_metadata.fd;\n\tret = -EFAULT;\n\tif (copy_to_user(buf, &fanotify_event_metadata,\n\t\t\t fanotify_event_metadata.event_len))\n\t\tgoto out_close_fd;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (event->mask & FAN_ALL_PERM_EVENTS)\n\t\tFANOTIFY_PE(event)->fd = fd;\n#endif\n\n\tif (fd != FAN_NOFD)\n\t\tfd_install(fd, f);\n\treturn fanotify_event_metadata.event_len;\n\nout_close_fd:\n\tif (fd != FAN_NOFD) {\n\t\tput_unused_fd(fd);\n\t\tfput(f);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_woken",
          "args": [
            "&wait",
            "TASK_INTERRUPTIBLE",
            "MAX_SCHEDULE_TIMEOUT"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kevent"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kevent"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_one_event",
          "args": [
            "group",
            "count"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "get_one_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "54-70",
          "snippet": "static struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\tpr_debug(\"%s: group=%p count=%zd\\n\", __func__, group, count);\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\tif (FAN_EVENT_METADATA_LEN > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* held the notification_mutex the whole time, so this is the\n\t * same event we peeked above */\n\treturn fsnotify_remove_first_event(group);\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\tpr_debug(\"%s: group=%p count=%zd\\n\", __func__, group, count);\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\tif (FAN_EVENT_METADATA_LEN > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* held the notification_mutex the whole time, so this is the\n\t * same event we peeked above */\n\treturn fsnotify_remove_first_event(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&group->notification_waitq",
            "&wait"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p\\n\"",
            "__func__",
            "group"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_FUNC",
          "args": [
            "wait",
            "woken_wake_function"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic ssize_t fanotify_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *kevent;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tstart = buf;\n\tgroup = file->private_data;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tadd_wait_queue(&group->notification_waitq, &wait);\n\twhile (1) {\n\t\tmutex_lock(&group->notification_mutex);\n\t\tkevent = get_one_event(group, count);\n\t\tmutex_unlock(&group->notification_mutex);\n\n\t\tif (IS_ERR(kevent)) {\n\t\t\tret = PTR_ERR(kevent);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!kevent) {\n\t\t\tret = -EAGAIN;\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\tbreak;\n\n\t\t\tret = -ERESTARTSYS;\n\t\t\tif (signal_pending(current))\n\t\t\t\tbreak;\n\n\t\t\tif (start != buf)\n\t\t\t\tbreak;\n\n\t\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = copy_event_to_user(group, kevent, buf);\n\t\t/*\n\t\t * Permission events get queued to wait for response.  Other\n\t\t * events can be destroyed now.\n\t\t */\n\t\tif (!(kevent->mask & FAN_ALL_PERM_EVENTS)) {\n\t\t\tfsnotify_destroy_event(group, kevent);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else {\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\t\t\tif (ret < 0) {\n\t\t\t\tFANOTIFY_PE(kevent)->response = FAN_DENY;\n\t\t\t\twake_up(&group->fanotify_data.access_waitq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_lock(&group->fanotify_data.access_lock);\n\t\t\tlist_add_tail(&kevent->list,\n\t\t\t\t      &group->fanotify_data.access_list);\n\t\t\tspin_unlock(&group->fanotify_data.access_lock);\n#endif\n\t\t}\n\t\tbuf += ret;\n\t\tcount -= ret;\n\t}\n\tremove_wait_queue(&group->notification_waitq, &wait);\n\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\treturn ret;\n}"
  },
  {
    "function_name": "fanotify_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "241-253",
    "snippet": "static unsigned int fanotify_poll(struct file *file, poll_table *wait)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tint ret = 0;\n\n\tpoll_wait(file, &group->notification_waitq, wait);\n\tmutex_lock(&group->notification_mutex);\n\tif (!fsnotify_notify_queue_is_empty(group))\n\t\tret = POLLIN | POLLRDNORM;\n\tmutex_unlock(&group->notification_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_notify_queue_is_empty",
          "args": [
            "group"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_notify_queue_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "64-68",
          "snippet": "bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\treturn list_empty(&group->notification_list) ? true : false;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\treturn list_empty(&group->notification_list) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&group->notification_waitq",
            "wait"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic unsigned int fanotify_poll(struct file *file, poll_table *wait)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tint ret = 0;\n\n\tpoll_wait(file, &group->notification_waitq, wait);\n\tmutex_lock(&group->notification_mutex);\n\tif (!fsnotify_notify_queue_is_empty(group))\n\t\tret = POLLIN | POLLRDNORM;\n\tmutex_unlock(&group->notification_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "copy_event_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "203-238",
    "snippet": "static ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct fanotify_event_metadata fanotify_event_metadata;\n\tstruct file *f;\n\tint fd, ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tret = fill_event_metadata(group, &fanotify_event_metadata, event, &f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfd = fanotify_event_metadata.fd;\n\tret = -EFAULT;\n\tif (copy_to_user(buf, &fanotify_event_metadata,\n\t\t\t fanotify_event_metadata.event_len))\n\t\tgoto out_close_fd;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (event->mask & FAN_ALL_PERM_EVENTS)\n\t\tFANOTIFY_PE(event)->fd = fd;\n#endif\n\n\tif (fd != FAN_NOFD)\n\t\tfd_install(fd, f);\n\treturn fanotify_event_metadata.event_len;\n\nout_close_fd:\n\tif (fd != FAN_NOFD) {\n\t\tput_unused_fd(fd);\n\t\tfput(f);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "522-528",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "f"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "563-566",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FANOTIFY_PE",
          "args": [
            "event"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "FANOTIFY_PE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.h",
          "lines": "37-41",
          "snippet": "static inline struct fanotify_perm_event_info *\nFANOTIFY_PE(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_perm_event_info, fae.fse);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct fanotify_perm_event_info *\nFANOTIFY_PE(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_perm_event_info, fae.fse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "&fanotify_event_metadata",
            "fanotify_event_metadata.event_len"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_event_metadata",
          "args": [
            "group",
            "&fanotify_event_metadata",
            "event",
            "&f"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "fill_event_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "114-142",
          "snippet": "static int fill_event_metadata(struct fsnotify_group *group,\n\t\t\t       struct fanotify_event_metadata *metadata,\n\t\t\t       struct fsnotify_event *fsn_event,\n\t\t\t       struct file **file)\n{\n\tint ret = 0;\n\tstruct fanotify_event_info *event;\n\n\tpr_debug(\"%s: group=%p metadata=%p event=%p\\n\", __func__,\n\t\t group, metadata, fsn_event);\n\n\t*file = NULL;\n\tevent = container_of(fsn_event, struct fanotify_event_info, fse);\n\tmetadata->event_len = FAN_EVENT_METADATA_LEN;\n\tmetadata->metadata_len = FAN_EVENT_METADATA_LEN;\n\tmetadata->vers = FANOTIFY_METADATA_VERSION;\n\tmetadata->reserved = 0;\n\tmetadata->mask = fsn_event->mask & FAN_ALL_OUTGOING_EVENTS;\n\tmetadata->pid = pid_vnr(event->tgid);\n\tif (unlikely(fsn_event->mask & FAN_Q_OVERFLOW))\n\t\tmetadata->fd = FAN_NOFD;\n\telse {\n\t\tmetadata->fd = create_fd(group, event, file);\n\t\tif (metadata->fd < 0)\n\t\t\tret = metadata->fd;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int fill_event_metadata(struct fsnotify_group *group,\n\t\t\t       struct fanotify_event_metadata *metadata,\n\t\t\t       struct fsnotify_event *fsn_event,\n\t\t\t       struct file **file)\n{\n\tint ret = 0;\n\tstruct fanotify_event_info *event;\n\n\tpr_debug(\"%s: group=%p metadata=%p event=%p\\n\", __func__,\n\t\t group, metadata, fsn_event);\n\n\t*file = NULL;\n\tevent = container_of(fsn_event, struct fanotify_event_info, fse);\n\tmetadata->event_len = FAN_EVENT_METADATA_LEN;\n\tmetadata->metadata_len = FAN_EVENT_METADATA_LEN;\n\tmetadata->vers = FANOTIFY_METADATA_VERSION;\n\tmetadata->reserved = 0;\n\tmetadata->mask = fsn_event->mask & FAN_ALL_OUTGOING_EVENTS;\n\tmetadata->pid = pid_vnr(event->tgid);\n\tif (unlikely(fsn_event->mask & FAN_Q_OVERFLOW))\n\t\tmetadata->fd = FAN_NOFD;\n\telse {\n\t\tmetadata->fd = create_fd(group, event, file);\n\t\tif (metadata->fd < 0)\n\t\t\tret = metadata->fd;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p event=%p\\n\"",
            "__func__",
            "group",
            "event"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct fanotify_event_metadata fanotify_event_metadata;\n\tstruct file *f;\n\tint fd, ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tret = fill_event_metadata(group, &fanotify_event_metadata, event, &f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfd = fanotify_event_metadata.fd;\n\tret = -EFAULT;\n\tif (copy_to_user(buf, &fanotify_event_metadata,\n\t\t\t fanotify_event_metadata.event_len))\n\t\tgoto out_close_fd;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (event->mask & FAN_ALL_PERM_EVENTS)\n\t\tFANOTIFY_PE(event)->fd = fd;\n#endif\n\n\tif (fd != FAN_NOFD)\n\t\tfd_install(fd, f);\n\treturn fanotify_event_metadata.event_len;\n\nout_close_fd:\n\tif (fd != FAN_NOFD) {\n\t\tput_unused_fd(fd);\n\t\tfput(f);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "process_access_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "167-200",
    "snippet": "static int process_access_response(struct fsnotify_group *group,\n\t\t\t\t   struct fanotify_response *response_struct)\n{\n\tstruct fanotify_perm_event_info *event;\n\tint fd = response_struct->fd;\n\tint response = response_struct->response;\n\n\tpr_debug(\"%s: group=%p fd=%d response=%d\\n\", __func__, group,\n\t\t fd, response);\n\t/*\n\t * make sure the response is valid, if invalid we do nothing and either\n\t * userspace can send a valid response or we will clean it up after the\n\t * timeout\n\t */\n\tswitch (response) {\n\tcase FAN_ALLOW:\n\tcase FAN_DENY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fd < 0)\n\t\treturn -EINVAL;\n\n\tevent = dequeue_event(group, fd);\n\tif (!event)\n\t\treturn -ENOENT;\n\n\tevent->response = response;\n\twake_up(&group->fanotify_data.access_waitq);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&group->fanotify_data.access_waitq"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_event",
          "args": [
            "group",
            "fd"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "145-165",
          "snippet": "static struct fanotify_perm_event_info *dequeue_event(\n\t\t\t\tstruct fsnotify_group *group, int fd)\n{\n\tstruct fanotify_perm_event_info *event, *return_e = NULL;\n\n\tspin_lock(&group->fanotify_data.access_lock);\n\tlist_for_each_entry(event, &group->fanotify_data.access_list,\n\t\t\t    fae.fse.list) {\n\t\tif (event->fd != fd)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&event->fae.fse.list);\n\t\treturn_e = event;\n\t\tbreak;\n\t}\n\tspin_unlock(&group->fanotify_data.access_lock);\n\n\tpr_debug(\"%s: found return_re=%p\\n\", __func__, return_e);\n\n\treturn return_e;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct fanotify_perm_event_info *dequeue_event(\n\t\t\t\tstruct fsnotify_group *group, int fd)\n{\n\tstruct fanotify_perm_event_info *event, *return_e = NULL;\n\n\tspin_lock(&group->fanotify_data.access_lock);\n\tlist_for_each_entry(event, &group->fanotify_data.access_list,\n\t\t\t    fae.fse.list) {\n\t\tif (event->fd != fd)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&event->fae.fse.list);\n\t\treturn_e = event;\n\t\tbreak;\n\t}\n\tspin_unlock(&group->fanotify_data.access_lock);\n\n\tpr_debug(\"%s: found return_re=%p\\n\", __func__, return_e);\n\n\treturn return_e;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p fd=%d response=%d\\n\"",
            "__func__",
            "group",
            "fd",
            "response"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int process_access_response(struct fsnotify_group *group,\n\t\t\t\t   struct fanotify_response *response_struct)\n{\n\tstruct fanotify_perm_event_info *event;\n\tint fd = response_struct->fd;\n\tint response = response_struct->response;\n\n\tpr_debug(\"%s: group=%p fd=%d response=%d\\n\", __func__, group,\n\t\t fd, response);\n\t/*\n\t * make sure the response is valid, if invalid we do nothing and either\n\t * userspace can send a valid response or we will clean it up after the\n\t * timeout\n\t */\n\tswitch (response) {\n\tcase FAN_ALLOW:\n\tcase FAN_DENY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fd < 0)\n\t\treturn -EINVAL;\n\n\tevent = dequeue_event(group, fd);\n\tif (!event)\n\t\treturn -ENOENT;\n\n\tevent->response = response;\n\twake_up(&group->fanotify_data.access_waitq);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dequeue_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "145-165",
    "snippet": "static struct fanotify_perm_event_info *dequeue_event(\n\t\t\t\tstruct fsnotify_group *group, int fd)\n{\n\tstruct fanotify_perm_event_info *event, *return_e = NULL;\n\n\tspin_lock(&group->fanotify_data.access_lock);\n\tlist_for_each_entry(event, &group->fanotify_data.access_list,\n\t\t\t    fae.fse.list) {\n\t\tif (event->fd != fd)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&event->fae.fse.list);\n\t\treturn_e = event;\n\t\tbreak;\n\t}\n\tspin_unlock(&group->fanotify_data.access_lock);\n\n\tpr_debug(\"%s: found return_re=%p\\n\", __func__, return_e);\n\n\treturn return_e;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: found return_re=%p\\n\"",
            "__func__",
            "return_e"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&group->fanotify_data.access_lock"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&event->fae.fse.list"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "event",
            "&group->fanotify_data.access_list",
            "fae.fse.list"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&group->fanotify_data.access_lock"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct fanotify_perm_event_info *dequeue_event(\n\t\t\t\tstruct fsnotify_group *group, int fd)\n{\n\tstruct fanotify_perm_event_info *event, *return_e = NULL;\n\n\tspin_lock(&group->fanotify_data.access_lock);\n\tlist_for_each_entry(event, &group->fanotify_data.access_list,\n\t\t\t    fae.fse.list) {\n\t\tif (event->fd != fd)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&event->fae.fse.list);\n\t\treturn_e = event;\n\t\tbreak;\n\t}\n\tspin_unlock(&group->fanotify_data.access_lock);\n\n\tpr_debug(\"%s: found return_re=%p\\n\", __func__, return_e);\n\n\treturn return_e;\n}"
  },
  {
    "function_name": "fill_event_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "114-142",
    "snippet": "static int fill_event_metadata(struct fsnotify_group *group,\n\t\t\t       struct fanotify_event_metadata *metadata,\n\t\t\t       struct fsnotify_event *fsn_event,\n\t\t\t       struct file **file)\n{\n\tint ret = 0;\n\tstruct fanotify_event_info *event;\n\n\tpr_debug(\"%s: group=%p metadata=%p event=%p\\n\", __func__,\n\t\t group, metadata, fsn_event);\n\n\t*file = NULL;\n\tevent = container_of(fsn_event, struct fanotify_event_info, fse);\n\tmetadata->event_len = FAN_EVENT_METADATA_LEN;\n\tmetadata->metadata_len = FAN_EVENT_METADATA_LEN;\n\tmetadata->vers = FANOTIFY_METADATA_VERSION;\n\tmetadata->reserved = 0;\n\tmetadata->mask = fsn_event->mask & FAN_ALL_OUTGOING_EVENTS;\n\tmetadata->pid = pid_vnr(event->tgid);\n\tif (unlikely(fsn_event->mask & FAN_Q_OVERFLOW))\n\t\tmetadata->fd = FAN_NOFD;\n\telse {\n\t\tmetadata->fd = create_fd(group, event, file);\n\t\tif (metadata->fd < 0)\n\t\t\tret = metadata->fd;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_fd",
          "args": [
            "group",
            "event",
            "file"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "create_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
          "lines": "72-112",
          "snippet": "static int create_fd(struct fsnotify_group *group,\n\t\t     struct fanotify_event_info *event,\n\t\t     struct file **file)\n{\n\tint client_fd;\n\tstruct file *new_file;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tclient_fd = get_unused_fd_flags(group->fanotify_data.f_flags);\n\tif (client_fd < 0)\n\t\treturn client_fd;\n\n\t/*\n\t * we need a new file handle for the userspace program so it can read even if it was\n\t * originally opened O_WRONLY.\n\t */\n\t/* it's possible this event was an overflow event.  in that case dentry and mnt\n\t * are NULL;  That's fine, just don't call dentry open */\n\tif (event->path.dentry && event->path.mnt)\n\t\tnew_file = dentry_open(&event->path,\n\t\t\t\t       group->fanotify_data.f_flags | FMODE_NONOTIFY,\n\t\t\t\t       current_cred());\n\telse\n\t\tnew_file = ERR_PTR(-EOVERFLOW);\n\tif (IS_ERR(new_file)) {\n\t\t/*\n\t\t * we still send an event even if we can't open the file.  this\n\t\t * can happen when say tasks are gone and we try to open their\n\t\t * /proc files or we try to open a WRONLY file like in sysfs\n\t\t * we just send the errno to userspace since there isn't much\n\t\t * else we can do.\n\t\t */\n\t\tput_unused_fd(client_fd);\n\t\tclient_fd = PTR_ERR(new_file);\n\t} else {\n\t\t*file = new_file;\n\t}\n\n\treturn client_fd;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include \"../fdinfo.h\"",
            "#include \"../../mount.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int create_fd(struct fsnotify_group *group,\n\t\t     struct fanotify_event_info *event,\n\t\t     struct file **file)\n{\n\tint client_fd;\n\tstruct file *new_file;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tclient_fd = get_unused_fd_flags(group->fanotify_data.f_flags);\n\tif (client_fd < 0)\n\t\treturn client_fd;\n\n\t/*\n\t * we need a new file handle for the userspace program so it can read even if it was\n\t * originally opened O_WRONLY.\n\t */\n\t/* it's possible this event was an overflow event.  in that case dentry and mnt\n\t * are NULL;  That's fine, just don't call dentry open */\n\tif (event->path.dentry && event->path.mnt)\n\t\tnew_file = dentry_open(&event->path,\n\t\t\t\t       group->fanotify_data.f_flags | FMODE_NONOTIFY,\n\t\t\t\t       current_cred());\n\telse\n\t\tnew_file = ERR_PTR(-EOVERFLOW);\n\tif (IS_ERR(new_file)) {\n\t\t/*\n\t\t * we still send an event even if we can't open the file.  this\n\t\t * can happen when say tasks are gone and we try to open their\n\t\t * /proc files or we try to open a WRONLY file like in sysfs\n\t\t * we just send the errno to userspace since there isn't much\n\t\t * else we can do.\n\t\t */\n\t\tput_unused_fd(client_fd);\n\t\tclient_fd = PTR_ERR(new_file);\n\t} else {\n\t\t*file = new_file;\n\t}\n\n\treturn client_fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fsn_event->mask & FAN_Q_OVERFLOW"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "event->tgid"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fsn_event",
            "structfanotify_event_info",
            "fse"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p metadata=%p event=%p\\n\"",
            "__func__",
            "group",
            "metadata",
            "fsn_event"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int fill_event_metadata(struct fsnotify_group *group,\n\t\t\t       struct fanotify_event_metadata *metadata,\n\t\t\t       struct fsnotify_event *fsn_event,\n\t\t\t       struct file **file)\n{\n\tint ret = 0;\n\tstruct fanotify_event_info *event;\n\n\tpr_debug(\"%s: group=%p metadata=%p event=%p\\n\", __func__,\n\t\t group, metadata, fsn_event);\n\n\t*file = NULL;\n\tevent = container_of(fsn_event, struct fanotify_event_info, fse);\n\tmetadata->event_len = FAN_EVENT_METADATA_LEN;\n\tmetadata->metadata_len = FAN_EVENT_METADATA_LEN;\n\tmetadata->vers = FANOTIFY_METADATA_VERSION;\n\tmetadata->reserved = 0;\n\tmetadata->mask = fsn_event->mask & FAN_ALL_OUTGOING_EVENTS;\n\tmetadata->pid = pid_vnr(event->tgid);\n\tif (unlikely(fsn_event->mask & FAN_Q_OVERFLOW))\n\t\tmetadata->fd = FAN_NOFD;\n\telse {\n\t\tmetadata->fd = create_fd(group, event, file);\n\t\tif (metadata->fd < 0)\n\t\t\tret = metadata->fd;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "create_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "72-112",
    "snippet": "static int create_fd(struct fsnotify_group *group,\n\t\t     struct fanotify_event_info *event,\n\t\t     struct file **file)\n{\n\tint client_fd;\n\tstruct file *new_file;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tclient_fd = get_unused_fd_flags(group->fanotify_data.f_flags);\n\tif (client_fd < 0)\n\t\treturn client_fd;\n\n\t/*\n\t * we need a new file handle for the userspace program so it can read even if it was\n\t * originally opened O_WRONLY.\n\t */\n\t/* it's possible this event was an overflow event.  in that case dentry and mnt\n\t * are NULL;  That's fine, just don't call dentry open */\n\tif (event->path.dentry && event->path.mnt)\n\t\tnew_file = dentry_open(&event->path,\n\t\t\t\t       group->fanotify_data.f_flags | FMODE_NONOTIFY,\n\t\t\t\t       current_cred());\n\telse\n\t\tnew_file = ERR_PTR(-EOVERFLOW);\n\tif (IS_ERR(new_file)) {\n\t\t/*\n\t\t * we still send an event even if we can't open the file.  this\n\t\t * can happen when say tasks are gone and we try to open their\n\t\t * /proc files or we try to open a WRONLY file like in sysfs\n\t\t * we just send the errno to userspace since there isn't much\n\t\t * else we can do.\n\t\t */\n\t\tput_unused_fd(client_fd);\n\t\tclient_fd = PTR_ERR(new_file);\n\t} else {\n\t\t*file = new_file;\n\t}\n\n\treturn client_fd;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_file"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "client_fd"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "522-528",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_file"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOVERFLOW"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "&event->path",
            "group->fanotify_data.f_flags | FMODE_NONOTIFY",
            "current_cred()"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "821-849",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "group->fanotify_data.f_flags"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "508-511",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p event=%p\\n\"",
            "__func__",
            "group",
            "event"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic int create_fd(struct fsnotify_group *group,\n\t\t     struct fanotify_event_info *event,\n\t\t     struct file **file)\n{\n\tint client_fd;\n\tstruct file *new_file;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tclient_fd = get_unused_fd_flags(group->fanotify_data.f_flags);\n\tif (client_fd < 0)\n\t\treturn client_fd;\n\n\t/*\n\t * we need a new file handle for the userspace program so it can read even if it was\n\t * originally opened O_WRONLY.\n\t */\n\t/* it's possible this event was an overflow event.  in that case dentry and mnt\n\t * are NULL;  That's fine, just don't call dentry open */\n\tif (event->path.dentry && event->path.mnt)\n\t\tnew_file = dentry_open(&event->path,\n\t\t\t\t       group->fanotify_data.f_flags | FMODE_NONOTIFY,\n\t\t\t\t       current_cred());\n\telse\n\t\tnew_file = ERR_PTR(-EOVERFLOW);\n\tif (IS_ERR(new_file)) {\n\t\t/*\n\t\t * we still send an event even if we can't open the file.  this\n\t\t * can happen when say tasks are gone and we try to open their\n\t\t * /proc files or we try to open a WRONLY file like in sysfs\n\t\t * we just send the errno to userspace since there isn't much\n\t\t * else we can do.\n\t\t */\n\t\tput_unused_fd(client_fd);\n\t\tclient_fd = PTR_ERR(new_file);\n\t} else {\n\t\t*file = new_file;\n\t}\n\n\treturn client_fd;\n}"
  },
  {
    "function_name": "get_one_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify_user.c",
    "lines": "54-70",
    "snippet": "static struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\tpr_debug(\"%s: group=%p count=%zd\\n\", __func__, group, count);\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\tif (FAN_EVENT_METADATA_LEN > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* held the notification_mutex the whole time, so this is the\n\t * same event we peeked above */\n\treturn fsnotify_remove_first_event(group);\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include \"../fdinfo.h\"",
      "#include \"../../mount.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/poll.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_remove_first_event",
          "args": [
            "group"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_remove_first_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "147-165",
          "snippet": "struct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group *group)\n{\n\tstruct fsnotify_event *event;\n\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tevent = list_first_entry(&group->notification_list,\n\t\t\t\t struct fsnotify_event, list);\n\t/*\n\t * We need to init list head for the case of overflow event so that\n\t * check in fsnotify_add_event() works\n\t */\n\tlist_del_init(&event->list);\n\tgroup->q_len--;\n\n\treturn event;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group *group)\n{\n\tstruct fsnotify_event *event;\n\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tevent = list_first_entry(&group->notification_list,\n\t\t\t\t struct fsnotify_event, list);\n\t/*\n\t * We need to init list head for the case of overflow event so that\n\t * check in fsnotify_add_event() works\n\t */\n\tlist_del_init(&event->list);\n\tgroup->q_len--;\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_notify_queue_is_empty",
          "args": [
            "group"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_notify_queue_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "64-68",
          "snippet": "bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\treturn list_empty(&group->notification_list) ? true : false;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\treturn list_empty(&group->notification_list) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p count=%zd\\n\"",
            "__func__",
            "group",
            "count"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&group->notification_mutex)"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include \"../fdinfo.h\"\n#include \"../../mount.h\"\n#include <asm/ioctls.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fanotify.h>\n\nstatic struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\tpr_debug(\"%s: group=%p count=%zd\\n\", __func__, group, count);\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\tif (FAN_EVENT_METADATA_LEN > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* held the notification_mutex the whole time, so this is the\n\t * same event we peeked above */\n\treturn fsnotify_remove_first_event(group);\n}"
  }
]