[
  {
    "function_name": "xfs_qm_qoff_logitem_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "427-443",
    "snippet": "struct xfs_qoff_logitem *\nxfs_qm_qoff_logitem_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_qoff_logitem\t*start,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_qoff_logitem\t*qf;\n\n\tqf = kmem_zalloc(sizeof(struct xfs_qoff_logitem), KM_SLEEP);\n\n\txfs_log_item_init(mp, &qf->qql_item, XFS_LI_QUOTAOFF, start ?\n\t\t\t&xfs_qm_qoffend_logitem_ops : &xfs_qm_qoff_logitem_ops);\n\tqf->qql_item.li_mountp = mp;\n\tqf->qql_start_lip = start;\n\tqf->qql_flags = flags;\n\treturn qf;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xfs_item_ops xfs_qm_qoffend_logitem_ops = {\n\t.iop_size\t= xfs_qm_qoff_logitem_size,\n\t.iop_format\t= xfs_qm_qoff_logitem_format,\n\t.iop_pin\t= xfs_qm_qoff_logitem_pin,\n\t.iop_unpin\t= xfs_qm_qoff_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_qoff_logitem_unlock,\n\t.iop_committed\t= xfs_qm_qoffend_logitem_committed,\n\t.iop_push\t= xfs_qm_qoff_logitem_push,\n\t.iop_committing = xfs_qm_qoff_logitem_committing\n};",
      "static const struct xfs_item_ops xfs_qm_qoff_logitem_ops = {\n\t.iop_size\t= xfs_qm_qoff_logitem_size,\n\t.iop_format\t= xfs_qm_qoff_logitem_format,\n\t.iop_pin\t= xfs_qm_qoff_logitem_pin,\n\t.iop_unpin\t= xfs_qm_qoff_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_qoff_logitem_unlock,\n\t.iop_committed\t= xfs_qm_qoff_logitem_committed,\n\t.iop_push\t= xfs_qm_qoff_logitem_push,\n\t.iop_committing = xfs_qm_qoff_logitem_committing\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_item_init",
          "args": [
            "mp",
            "&qf->qql_item",
            "XFS_LI_QUOTAOFF",
            "start ?\n\t\t\t&xfs_qm_qoffend_logitem_ops : &xfs_qm_qoff_logitem_ops"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_item_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "961-976",
          "snippet": "void\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(struct xfs_qoff_logitem)",
            "KM_SLEEP"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_item_ops xfs_qm_qoffend_logitem_ops = {\n\t.iop_size\t= xfs_qm_qoff_logitem_size,\n\t.iop_format\t= xfs_qm_qoff_logitem_format,\n\t.iop_pin\t= xfs_qm_qoff_logitem_pin,\n\t.iop_unpin\t= xfs_qm_qoff_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_qoff_logitem_unlock,\n\t.iop_committed\t= xfs_qm_qoffend_logitem_committed,\n\t.iop_push\t= xfs_qm_qoff_logitem_push,\n\t.iop_committing = xfs_qm_qoff_logitem_committing\n};\nstatic const struct xfs_item_ops xfs_qm_qoff_logitem_ops = {\n\t.iop_size\t= xfs_qm_qoff_logitem_size,\n\t.iop_format\t= xfs_qm_qoff_logitem_format,\n\t.iop_pin\t= xfs_qm_qoff_logitem_pin,\n\t.iop_unpin\t= xfs_qm_qoff_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_qoff_logitem_unlock,\n\t.iop_committed\t= xfs_qm_qoff_logitem_committed,\n\t.iop_push\t= xfs_qm_qoff_logitem_push,\n\t.iop_committing = xfs_qm_qoff_logitem_committing\n};\n\nstruct xfs_qoff_logitem *\nxfs_qm_qoff_logitem_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_qoff_logitem\t*start,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_qoff_logitem\t*qf;\n\n\tqf = kmem_zalloc(sizeof(struct xfs_qoff_logitem), KM_SLEEP);\n\n\txfs_log_item_init(mp, &qf->qql_item, XFS_LI_QUOTAOFF, start ?\n\t\t\t&xfs_qm_qoffend_logitem_ops : &xfs_qm_qoff_logitem_ops);\n\tqf->qql_item.li_mountp = mp;\n\tqf->qql_start_lip = start;\n\tqf->qql_flags = flags;\n\treturn qf;\n}"
  },
  {
    "function_name": "xfs_qm_qoff_logitem_committing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "392-397",
    "snippet": "STATIC void\nxfs_qm_qoff_logitem_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_qoff_logitem_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n}"
  },
  {
    "function_name": "xfs_qm_qoffend_logitem_committed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "357-376",
    "snippet": "STATIC xfs_lsn_t\nxfs_qm_qoffend_logitem_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_qoff_logitem\t*qfe = QOFF_ITEM(lip);\n\tstruct xfs_qoff_logitem\t*qfs = qfe->qql_start_lip;\n\tstruct xfs_ail\t\t*ailp = qfs->qql_item.li_ailp;\n\n\t/*\n\t * Delete the qoff-start logitem from the AIL.\n\t * xfs_trans_ail_delete() drops the AIL lock.\n\t */\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_delete(ailp, &qfs->qql_item, SHUTDOWN_LOG_IO_ERROR);\n\n\tkmem_free(qfs);\n\tkmem_free(qfe);\n\treturn (xfs_lsn_t)-1;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "qfe"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete",
          "args": [
            "ailp",
            "&qfs->qql_item",
            "SHUTDOWN_LOG_IO_ERROR"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "113-120",
          "snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "QOFF_ITEM",
          "args": [
            "lip"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "QOFF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "266-269",
          "snippet": "static inline struct xfs_qoff_logitem *QOFF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_qoff_logitem, qql_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_qoff_logitem *QOFF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_qoff_logitem, qql_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_lsn_t\nxfs_qm_qoffend_logitem_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_qoff_logitem\t*qfe = QOFF_ITEM(lip);\n\tstruct xfs_qoff_logitem\t*qfs = qfe->qql_start_lip;\n\tstruct xfs_ail\t\t*ailp = qfs->qql_item.li_ailp;\n\n\t/*\n\t * Delete the qoff-start logitem from the AIL.\n\t * xfs_trans_ail_delete() drops the AIL lock.\n\t */\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_delete(ailp, &qfs->qql_item, SHUTDOWN_LOG_IO_ERROR);\n\n\tkmem_free(qfs);\n\tkmem_free(qfe);\n\treturn (xfs_lsn_t)-1;\n}"
  },
  {
    "function_name": "xfs_qm_qoff_logitem_committed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "349-355",
    "snippet": "STATIC xfs_lsn_t\nxfs_qm_qoff_logitem_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\treturn lsn;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_lsn_t\nxfs_qm_qoff_logitem_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\treturn lsn;\n}"
  },
  {
    "function_name": "xfs_qm_qoff_logitem_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "339-343",
    "snippet": "STATIC void\nxfs_qm_qoff_logitem_unlock(\n\tstruct xfs_log_item\t*lip)\n{\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_qoff_logitem_unlock(\n\tstruct xfs_log_item\t*lip)\n{\n}"
  },
  {
    "function_name": "xfs_qm_qoff_logitem_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "327-333",
    "snippet": "STATIC uint\nxfs_qm_qoff_logitem_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n{\n\treturn XFS_ITEM_LOCKED;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC uint\nxfs_qm_qoff_logitem_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list)\n{\n\treturn XFS_ITEM_LOCKED;\n}"
  },
  {
    "function_name": "xfs_qm_qoff_logitem_unpin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "316-321",
    "snippet": "STATIC void\nxfs_qm_qoff_logitem_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_qoff_logitem_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n}"
  },
  {
    "function_name": "xfs_qm_qoff_logitem_pin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "306-310",
    "snippet": "STATIC void\nxfs_qm_qoff_logitem_pin(\n\tstruct xfs_log_item\t*lip)\n{\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_qoff_logitem_pin(\n\tstruct xfs_log_item\t*lip)\n{\n}"
  },
  {
    "function_name": "xfs_qm_qoff_logitem_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "287-301",
    "snippet": "STATIC void\nxfs_qm_qoff_logitem_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_qoff_logitem\t*qflip = QOFF_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\tstruct xfs_qoff_logformat *qlf;\n\n\tqlf = xlog_prepare_iovec(lv, &vecp, XLOG_REG_TYPE_QUOTAOFF);\n\tqlf->qf_type = XFS_LI_QUOTAOFF;\n\tqlf->qf_size = 1;\n\tqlf->qf_flags = qflip->qql_flags;\n\txlog_finish_iovec(lv, vecp, sizeof(struct xfs_qoff_logitem));\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_finish_iovec",
          "args": [
            "lv",
            "vecp",
            "sizeof(struct xfs_qoff_logitem)"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_finish_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "66-72",
          "snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_prepare_iovec",
          "args": [
            "lv",
            "&vecp",
            "XLOG_REG_TYPE_QUOTAOFF"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_prepare_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "34-54",
          "snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QOFF_ITEM",
          "args": [
            "lip"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "QOFF_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "266-269",
          "snippet": "static inline struct xfs_qoff_logitem *QOFF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_qoff_logitem, qql_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_qoff_logitem *QOFF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_qoff_logitem, qql_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_qoff_logitem_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_qoff_logitem\t*qflip = QOFF_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\tstruct xfs_qoff_logformat *qlf;\n\n\tqlf = xlog_prepare_iovec(lv, &vecp, XLOG_REG_TYPE_QUOTAOFF);\n\tqlf->qf_type = XFS_LI_QUOTAOFF;\n\tqlf->qf_size = 1;\n\tqlf->qf_flags = qflip->qql_flags;\n\txlog_finish_iovec(lv, vecp, sizeof(struct xfs_qoff_logitem));\n}"
  },
  {
    "function_name": "xfs_qm_qoff_logitem_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "277-285",
    "snippet": "STATIC void\nxfs_qm_qoff_logitem_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\t*nvecs += 1;\n\t*nbytes += sizeof(struct xfs_qoff_logitem);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_qoff_logitem_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\t*nvecs += 1;\n\t*nbytes += sizeof(struct xfs_qoff_logitem);\n}"
  },
  {
    "function_name": "QOFF_ITEM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "266-269",
    "snippet": "static inline struct xfs_qoff_logitem *QOFF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_qoff_logitem, qql_item);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lip",
            "structxfs_qoff_logitem",
            "qql_item"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_qoff_logitem *QOFF_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_qoff_logitem, qql_item);\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "253-262",
    "snippet": "void\nxfs_qm_dquot_logitem_init(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_dq_logitem\t*lp = &dqp->q_logitem;\n\n\txfs_log_item_init(dqp->q_mount, &lp->qli_item, XFS_LI_DQUOT,\n\t\t\t\t\t&xfs_dquot_item_ops);\n\tlp->qli_dquot = dqp;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xfs_item_ops xfs_dquot_item_ops = {\n\t.iop_size\t= xfs_qm_dquot_logitem_size,\n\t.iop_format\t= xfs_qm_dquot_logitem_format,\n\t.iop_pin\t= xfs_qm_dquot_logitem_pin,\n\t.iop_unpin\t= xfs_qm_dquot_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_dquot_logitem_unlock,\n\t.iop_committed\t= xfs_qm_dquot_logitem_committed,\n\t.iop_push\t= xfs_qm_dquot_logitem_push,\n\t.iop_committing = xfs_qm_dquot_logitem_committing\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_log_item_init",
          "args": [
            "dqp->q_mount",
            "&lp->qli_item",
            "XFS_LI_DQUOT",
            "&xfs_dquot_item_ops"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_item_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "961-976",
          "snippet": "void\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_log_item_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_log_item\t*item,\n\tint\t\t\ttype,\n\tconst struct xfs_item_ops *ops)\n{\n\titem->li_mountp = mp;\n\titem->li_ailp = mp->m_ail;\n\titem->li_type = type;\n\titem->li_ops = ops;\n\titem->li_lv = NULL;\n\n\tINIT_LIST_HEAD(&item->li_ail);\n\tINIT_LIST_HEAD(&item->li_cil);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_item_ops xfs_dquot_item_ops = {\n\t.iop_size\t= xfs_qm_dquot_logitem_size,\n\t.iop_format\t= xfs_qm_dquot_logitem_format,\n\t.iop_pin\t= xfs_qm_dquot_logitem_pin,\n\t.iop_unpin\t= xfs_qm_dquot_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_dquot_logitem_unlock,\n\t.iop_committed\t= xfs_qm_dquot_logitem_committed,\n\t.iop_push\t= xfs_qm_dquot_logitem_push,\n\t.iop_committing = xfs_qm_dquot_logitem_committing\n};\n\nvoid\nxfs_qm_dquot_logitem_init(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_dq_logitem\t*lp = &dqp->q_logitem;\n\n\txfs_log_item_init(dqp->q_mount, &lp->qli_item, XFS_LI_DQUOT,\n\t\t\t\t\t&xfs_dquot_item_ops);\n\tlp->qli_dquot = dqp;\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_committing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "227-232",
    "snippet": "STATIC void\nxfs_qm_dquot_logitem_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_dquot_logitem_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "200-220",
    "snippet": "STATIC void\nxfs_qm_dquot_logitem_unlock(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_dquot\t*dqp = DQUOT_ITEM(lip)->qli_dquot;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\t/*\n\t * Clear the transaction pointer in the dquot\n\t */\n\tdqp->q_transp = NULL;\n\n\t/*\n\t * dquots are never 'held' from getting unlocked at the end of\n\t * a transaction.  Their locking and unlocking is hidden inside the\n\t * transaction layer, within trans_commit. Hence, no LI_HOLD flag\n\t * for the logitem.\n\t */\n\txfs_dqunlock(dqp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_DQ_IS_LOCKED(dqp)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_LOCKED",
          "args": [
            "dqp"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DQUOT_ITEM",
          "args": [
            "lip"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "DQUOT_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "33-36",
          "snippet": "static inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_dquot_logitem_unlock(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_dquot\t*dqp = DQUOT_ITEM(lip)->qli_dquot;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\t/*\n\t * Clear the transaction pointer in the dquot\n\t */\n\tdqp->q_transp = NULL;\n\n\t/*\n\t * dquots are never 'held' from getting unlocked at the end of\n\t * a transaction.  Their locking and unlocking is hidden inside the\n\t * transaction layer, within trans_commit. Hence, no LI_HOLD flag\n\t * for the logitem.\n\t */\n\txfs_dqunlock(dqp);\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "140-192",
    "snippet": "STATIC uint\nxfs_qm_dquot_logitem_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list) __releases(&lip->li_ailp->xa_lock)\n\t\t\t\t\t      __acquires(&lip->li_ailp->xa_lock)\n{\n\tstruct xfs_dquot\t*dqp = DQUOT_ITEM(lip)->qli_dquot;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tuint\t\t\trval = XFS_ITEM_SUCCESS;\n\tint\t\t\terror;\n\n\tif (atomic_read(&dqp->q_pincount) > 0)\n\t\treturn XFS_ITEM_PINNED;\n\n\tif (!xfs_dqlock_nowait(dqp))\n\t\treturn XFS_ITEM_LOCKED;\n\n\t/*\n\t * Re-check the pincount now that we stabilized the value by\n\t * taking the quota lock.\n\t */\n\tif (atomic_read(&dqp->q_pincount) > 0) {\n\t\trval = XFS_ITEM_PINNED;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Someone else is already flushing the dquot.  Nothing we can do\n\t * here but wait for the flush to finish and remove the item from\n\t * the AIL.\n\t */\n\tif (!xfs_dqflock_nowait(dqp)) {\n\t\trval = XFS_ITEM_FLUSHING;\n\t\tgoto out_unlock;\n\t}\n\n\tspin_unlock(&lip->li_ailp->xa_lock);\n\n\terror = xfs_qm_dqflush(dqp, &bp);\n\tif (error) {\n\t\txfs_warn(dqp->q_mount, \"%s: push error %d on dqp %p\",\n\t\t\t__func__, error, dqp);\n\t} else {\n\t\tif (!xfs_buf_delwri_queue(bp, buffer_list))\n\t\t\trval = XFS_ITEM_FLUSHING;\n\t\txfs_buf_relse(bp);\n\t}\n\n\tspin_lock(&lip->li_ailp->xa_lock);\nout_unlock:\n\txfs_dqunlock(dqp);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lip->li_ailp->xa_lock"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "dqp->q_mount",
            "\"%s: push error %d on dqp %p\"",
            "__func__",
            "error",
            "dqp"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqflush",
          "args": [
            "dqp",
            "&bp"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "930-1048",
          "snippet": "int\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lip->li_ailp->xa_lock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqflock_nowait",
          "args": [
            "dqp"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqflock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "89-92",
          "snippet": "static inline bool xfs_dqflock_nowait(xfs_dquot_t *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool xfs_dqflock_nowait(xfs_dquot_t *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dqp->q_pincount"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqlock_nowait",
          "args": [
            "dqp"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "99-102",
          "snippet": "static inline int xfs_dqlock_nowait(struct xfs_dquot *dqp)\n{\n\treturn mutex_trylock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dqlock_nowait(struct xfs_dquot *dqp)\n{\n\treturn mutex_trylock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dqp->q_pincount"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DQUOT_ITEM",
          "args": [
            "lip"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "DQUOT_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "33-36",
          "snippet": "static inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&lip->li_ailp->xa_lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&lip->li_ailp->xa_lock"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC uint\nxfs_qm_dquot_logitem_push(\n\tstruct xfs_log_item\t*lip,\n\tstruct list_head\t*buffer_list) __releases(&lip->li_ailp->xa_lock)\n\t\t\t\t\t      __acquires(&lip->li_ailp->xa_lock)\n{\n\tstruct xfs_dquot\t*dqp = DQUOT_ITEM(lip)->qli_dquot;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tuint\t\t\trval = XFS_ITEM_SUCCESS;\n\tint\t\t\terror;\n\n\tif (atomic_read(&dqp->q_pincount) > 0)\n\t\treturn XFS_ITEM_PINNED;\n\n\tif (!xfs_dqlock_nowait(dqp))\n\t\treturn XFS_ITEM_LOCKED;\n\n\t/*\n\t * Re-check the pincount now that we stabilized the value by\n\t * taking the quota lock.\n\t */\n\tif (atomic_read(&dqp->q_pincount) > 0) {\n\t\trval = XFS_ITEM_PINNED;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Someone else is already flushing the dquot.  Nothing we can do\n\t * here but wait for the flush to finish and remove the item from\n\t * the AIL.\n\t */\n\tif (!xfs_dqflock_nowait(dqp)) {\n\t\trval = XFS_ITEM_FLUSHING;\n\t\tgoto out_unlock;\n\t}\n\n\tspin_unlock(&lip->li_ailp->xa_lock);\n\n\terror = xfs_qm_dqflush(dqp, &bp);\n\tif (error) {\n\t\txfs_warn(dqp->q_mount, \"%s: push error %d on dqp %p\",\n\t\t\t__func__, error, dqp);\n\t} else {\n\t\tif (!xfs_buf_delwri_queue(bp, buffer_list))\n\t\t\trval = XFS_ITEM_FLUSHING;\n\t\txfs_buf_relse(bp);\n\t}\n\n\tspin_lock(&lip->li_ailp->xa_lock);\nout_unlock:\n\txfs_dqunlock(dqp);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_qm_dqunpin_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "125-138",
    "snippet": "void\nxfs_qm_dqunpin_wait(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tif (atomic_read(&dqp->q_pincount) == 0)\n\t\treturn;\n\n\t/*\n\t * Give the log a push so we don't wait here too long.\n\t */\n\txfs_log_force(dqp->q_mount, 0);\n\twait_event(dqp->q_pinwait, (atomic_read(&dqp->q_pincount) == 0));\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "dqp->q_pinwait",
            "(atomic_read(&dqp->q_pincount) == 0)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dqp->q_pincount"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "dqp->q_mount",
            "0"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dqp->q_pincount"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_DQ_IS_LOCKED(dqp)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_LOCKED",
          "args": [
            "dqp"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqunpin_wait(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tif (atomic_read(&dqp->q_pincount) == 0)\n\t\treturn;\n\n\t/*\n\t * Give the log a push so we don't wait here too long.\n\t */\n\txfs_log_force(dqp->q_mount, 0);\n\twait_event(dqp->q_pinwait, (atomic_read(&dqp->q_pincount) == 0));\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_committed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "109-119",
    "snippet": "STATIC xfs_lsn_t\nxfs_qm_dquot_logitem_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\t/*\n\t * We always re-log the entire dquot when it becomes dirty,\n\t * so, the latest copy _is_ the only one that matters.\n\t */\n\treturn lsn;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_lsn_t\nxfs_qm_dquot_logitem_committed(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n\t/*\n\t * We always re-log the entire dquot when it becomes dirty,\n\t * so, the latest copy _is_ the only one that matters.\n\t */\n\treturn lsn;\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_unpin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "97-107",
    "snippet": "STATIC void\nxfs_qm_dquot_logitem_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_dquot\t*dqp = DQUOT_ITEM(lip)->qli_dquot;\n\n\tASSERT(atomic_read(&dqp->q_pincount) > 0);\n\tif (atomic_dec_and_test(&dqp->q_pincount))\n\t\twake_up(&dqp->q_pinwait);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dqp->q_pinwait"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&dqp->q_pincount"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&dqp->q_pincount) > 0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dqp->q_pincount"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DQUOT_ITEM",
          "args": [
            "lip"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "DQUOT_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "33-36",
          "snippet": "static inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_dquot_logitem_unpin(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\tremove)\n{\n\tstruct xfs_dquot\t*dqp = DQUOT_ITEM(lip)->qli_dquot;\n\n\tASSERT(atomic_read(&dqp->q_pincount) > 0);\n\tif (atomic_dec_and_test(&dqp->q_pincount))\n\t\twake_up(&dqp->q_pinwait);\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_pin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "81-89",
    "snippet": "STATIC void\nxfs_qm_dquot_logitem_pin(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_dquot\t*dqp = DQUOT_ITEM(lip)->qli_dquot;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tatomic_inc(&dqp->q_pincount);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dqp->q_pincount"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_DQ_IS_LOCKED(dqp)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_LOCKED",
          "args": [
            "dqp"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DQUOT_ITEM",
          "args": [
            "lip"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "DQUOT_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "33-36",
          "snippet": "static inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_dquot_logitem_pin(\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_dquot\t*dqp = DQUOT_ITEM(lip)->qli_dquot;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tatomic_inc(&dqp->q_pincount);\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "55-76",
    "snippet": "STATIC void\nxfs_qm_dquot_logitem_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_dq_logitem\t*qlip = DQUOT_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\tstruct xfs_dq_logformat\t*qlf;\n\n\tqlf = xlog_prepare_iovec(lv, &vecp, XLOG_REG_TYPE_QFORMAT);\n\tqlf->qlf_type = XFS_LI_DQUOT;\n\tqlf->qlf_size = 2;\n\tqlf->qlf_id = be32_to_cpu(qlip->qli_dquot->q_core.d_id);\n\tqlf->qlf_blkno = qlip->qli_dquot->q_blkno;\n\tqlf->qlf_len = 1;\n\tqlf->qlf_boffset = qlip->qli_dquot->q_bufoffset;\n\txlog_finish_iovec(lv, vecp, sizeof(struct xfs_dq_logformat));\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_DQUOT,\n\t\t\t&qlip->qli_dquot->q_core,\n\t\t\tsizeof(struct xfs_disk_dquot));\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_copy_iovec",
          "args": [
            "lv",
            "&vecp",
            "XLOG_REG_TYPE_DQUOT",
            "&qlip->qli_dquot->q_core",
            "sizeof(struct xfs_disk_dquot)"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_copy_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "74-84",
          "snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_finish_iovec",
          "args": [
            "lv",
            "vecp",
            "sizeof(struct xfs_dq_logformat)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_finish_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "66-72",
          "snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "qlip->qli_dquot->q_core.d_id"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_prepare_iovec",
          "args": [
            "lv",
            "&vecp",
            "XLOG_REG_TYPE_QFORMAT"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_prepare_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "34-54",
          "snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DQUOT_ITEM",
          "args": [
            "lip"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "DQUOT_ITEM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "33-36",
          "snippet": "static inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_dquot_logitem_format(\n\tstruct xfs_log_item\t*lip,\n\tstruct xfs_log_vec\t*lv)\n{\n\tstruct xfs_dq_logitem\t*qlip = DQUOT_ITEM(lip);\n\tstruct xfs_log_iovec\t*vecp = NULL;\n\tstruct xfs_dq_logformat\t*qlf;\n\n\tqlf = xlog_prepare_iovec(lv, &vecp, XLOG_REG_TYPE_QFORMAT);\n\tqlf->qlf_type = XFS_LI_DQUOT;\n\tqlf->qlf_size = 2;\n\tqlf->qlf_id = be32_to_cpu(qlip->qli_dquot->q_core.d_id);\n\tqlf->qlf_blkno = qlip->qli_dquot->q_blkno;\n\tqlf->qlf_len = 1;\n\tqlf->qlf_boffset = qlip->qli_dquot->q_bufoffset;\n\txlog_finish_iovec(lv, vecp, sizeof(struct xfs_dq_logformat));\n\n\txlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_DQUOT,\n\t\t\t&qlip->qli_dquot->q_core,\n\t\t\tsizeof(struct xfs_disk_dquot));\n}"
  },
  {
    "function_name": "xfs_qm_dquot_logitem_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "41-50",
    "snippet": "STATIC void\nxfs_qm_dquot_logitem_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\t*nvecs += 2;\n\t*nbytes += sizeof(struct xfs_dq_logformat) +\n\t\t   sizeof(struct xfs_disk_dquot);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_dquot_logitem_size(\n\tstruct xfs_log_item\t*lip,\n\tint\t\t\t*nvecs,\n\tint\t\t\t*nbytes)\n{\n\t*nvecs += 2;\n\t*nbytes += sizeof(struct xfs_dq_logformat) +\n\t\t   sizeof(struct xfs_disk_dquot);\n}"
  },
  {
    "function_name": "DQUOT_ITEM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
    "lines": "33-36",
    "snippet": "static inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lip",
            "structxfs_dq_logitem",
            "qli_item"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline struct xfs_dq_logitem *DQUOT_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_dq_logitem, qli_item);\n}"
  }
]