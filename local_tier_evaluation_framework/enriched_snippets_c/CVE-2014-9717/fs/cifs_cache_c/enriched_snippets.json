[
  {
    "function_name": "cifs_fscache_inode_now_uncached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "295-323",
    "snippet": "static void cifs_fscache_inode_now_uncached(void *cookie_netfs_data)\n{\n\tstruct cifsInodeInfo *cifsi = cookie_netfs_data;\n\tstruct pagevec pvec;\n\tpgoff_t first;\n\tint loop, nr_pages;\n\n\tpagevec_init(&pvec, 0);\n\tfirst = 0;\n\n\tcifs_dbg(FYI, \"%s: cifs inode 0x%p now uncached\\n\", __func__, cifsi);\n\n\tfor (;;) {\n\t\tnr_pages = pagevec_lookup(&pvec,\n\t\t\t\t\t  cifsi->vfs_inode.i_mapping, first,\n\t\t\t\t\t  PAGEVEC_SIZE - pagevec_count(&pvec));\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (loop = 0; loop < nr_pages; loop++)\n\t\t\tClearPageFsCache(pvec.pages[loop]);\n\n\t\tfirst = pvec.pages[nr_pages - 1]->index + 1;\n\n\t\tpvec.nr = nr_pages;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageFsCache",
          "args": [
            "pvec.pages[loop]"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "cifsi->vfs_inode.i_mapping",
            "first",
            "PAGEVEC_SIZE - pagevec_count(&pvec)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: cifs inode 0x%p now uncached\\n\"",
            "__func__",
            "cifsi"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic void cifs_fscache_inode_now_uncached(void *cookie_netfs_data)\n{\n\tstruct cifsInodeInfo *cifsi = cookie_netfs_data;\n\tstruct pagevec pvec;\n\tpgoff_t first;\n\tint loop, nr_pages;\n\n\tpagevec_init(&pvec, 0);\n\tfirst = 0;\n\n\tcifs_dbg(FYI, \"%s: cifs inode 0x%p now uncached\\n\", __func__, cifsi);\n\n\tfor (;;) {\n\t\tnr_pages = pagevec_lookup(&pvec,\n\t\t\t\t\t  cifsi->vfs_inode.i_mapping, first,\n\t\t\t\t\t  PAGEVEC_SIZE - pagevec_count(&pvec));\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (loop = 0; loop < nr_pages; loop++)\n\t\t\tClearPageFsCache(pvec.pages[loop]);\n\n\t\tfirst = pvec.pages[nr_pages - 1]->index + 1;\n\n\t\tpvec.nr = nr_pages;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "cifs_fscache_inode_check_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "273-293",
    "snippet": "static enum\nfscache_checkaux cifs_fscache_inode_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t      const void *data,\n\t\t\t\t\t      uint16_t datalen)\n{\n\tstruct cifs_fscache_inode_auxdata auxdata;\n\tstruct cifsInodeInfo *cifsi = cookie_netfs_data;\n\n\tif (datalen != sizeof(auxdata))\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tmemset(&auxdata, 0, sizeof(auxdata));\n\tauxdata.eof = cifsi->server_eof;\n\tauxdata.last_write_time = cifsi->vfs_inode.i_mtime;\n\tauxdata.last_change_time = cifsi->vfs_inode.i_ctime;\n\n\tif (memcmp(data, &auxdata, datalen) != 0)\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "data",
            "&auxdata",
            "datalen"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&auxdata",
            "0",
            "sizeof(auxdata)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic enum\nfscache_checkaux cifs_fscache_inode_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t      const void *data,\n\t\t\t\t\t      uint16_t datalen)\n{\n\tstruct cifs_fscache_inode_auxdata auxdata;\n\tstruct cifsInodeInfo *cifsi = cookie_netfs_data;\n\n\tif (datalen != sizeof(auxdata))\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tmemset(&auxdata, 0, sizeof(auxdata));\n\tauxdata.eof = cifsi->server_eof;\n\tauxdata.last_write_time = cifsi->vfs_inode.i_mtime;\n\tauxdata.last_change_time = cifsi->vfs_inode.i_ctime;\n\n\tif (memcmp(data, &auxdata, datalen) != 0)\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
  },
  {
    "function_name": "cifs_fscache_inode_get_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "253-271",
    "snippet": "static uint16_t\ncifs_fscache_inode_get_aux(const void *cookie_netfs_data, void *buffer,\n\t\t\t   uint16_t maxbuf)\n{\n\tstruct cifs_fscache_inode_auxdata auxdata;\n\tconst struct cifsInodeInfo *cifsi = cookie_netfs_data;\n\n\tmemset(&auxdata, 0, sizeof(auxdata));\n\tauxdata.eof = cifsi->server_eof;\n\tauxdata.last_write_time = cifsi->vfs_inode.i_mtime;\n\tauxdata.last_change_time = cifsi->vfs_inode.i_ctime;\n\n\tif (maxbuf > sizeof(auxdata))\n\t\tmaxbuf = sizeof(auxdata);\n\n\tmemcpy(buffer, &auxdata, maxbuf);\n\n\treturn maxbuf;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&auxdata",
            "maxbuf"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&auxdata",
            "0",
            "sizeof(auxdata)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic uint16_t\ncifs_fscache_inode_get_aux(const void *cookie_netfs_data, void *buffer,\n\t\t\t   uint16_t maxbuf)\n{\n\tstruct cifs_fscache_inode_auxdata auxdata;\n\tconst struct cifsInodeInfo *cifsi = cookie_netfs_data;\n\n\tmemset(&auxdata, 0, sizeof(auxdata));\n\tauxdata.eof = cifsi->server_eof;\n\tauxdata.last_write_time = cifsi->vfs_inode.i_mtime;\n\tauxdata.last_change_time = cifsi->vfs_inode.i_ctime;\n\n\tif (maxbuf > sizeof(auxdata))\n\t\tmaxbuf = sizeof(auxdata);\n\n\tmemcpy(buffer, &auxdata, maxbuf);\n\n\treturn maxbuf;\n}"
  },
  {
    "function_name": "cifs_fscache_inode_get_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "245-251",
    "snippet": "static void\ncifs_fscache_inode_get_attr(const void *cookie_netfs_data, uint64_t *size)\n{\n\tconst struct cifsInodeInfo *cifsi = cookie_netfs_data;\n\n\t*size = cifsi->vfs_inode.i_size;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic void\ncifs_fscache_inode_get_attr(const void *cookie_netfs_data, uint64_t *size)\n{\n\tconst struct cifsInodeInfo *cifsi = cookie_netfs_data;\n\n\t*size = cifsi->vfs_inode.i_size;\n}"
  },
  {
    "function_name": "cifs_fscache_inode_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "229-243",
    "snippet": "static uint16_t cifs_fscache_inode_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t   void *buffer, uint16_t maxbuf)\n{\n\tconst struct cifsInodeInfo *cifsi = cookie_netfs_data;\n\tuint16_t keylen;\n\n\t/* use the UniqueId as the key */\n\tkeylen = sizeof(cifsi->uniqueid);\n\tif (keylen > maxbuf)\n\t\tkeylen = 0;\n\telse\n\t\tmemcpy(buffer, &cifsi->uniqueid, keylen);\n\n\treturn keylen;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&cifsi->uniqueid",
            "keylen"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic uint16_t cifs_fscache_inode_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t   void *buffer, uint16_t maxbuf)\n{\n\tconst struct cifsInodeInfo *cifsi = cookie_netfs_data;\n\tuint16_t keylen;\n\n\t/* use the UniqueId as the key */\n\tkeylen = sizeof(cifsi->uniqueid);\n\tif (keylen > maxbuf)\n\t\tkeylen = 0;\n\telse\n\t\tmemcpy(buffer, &cifsi->uniqueid, keylen);\n\n\treturn keylen;\n}"
  },
  {
    "function_name": "cifs_fscache_super_check_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "189-207",
    "snippet": "static enum\nfscache_checkaux cifs_fscache_super_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t      const void *data,\n\t\t\t\t\t      uint16_t datalen)\n{\n\tstruct cifs_fscache_super_auxdata auxdata;\n\tconst struct cifs_tcon *tcon = cookie_netfs_data;\n\n\tif (datalen != sizeof(auxdata))\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tmemset(&auxdata, 0, sizeof(auxdata));\n\tauxdata.resource_id = tcon->resource_id;\n\n\tif (memcmp(data, &auxdata, datalen) != 0)\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "data",
            "&auxdata",
            "datalen"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&auxdata",
            "0",
            "sizeof(auxdata)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic enum\nfscache_checkaux cifs_fscache_super_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t      const void *data,\n\t\t\t\t\t      uint16_t datalen)\n{\n\tstruct cifs_fscache_super_auxdata auxdata;\n\tconst struct cifs_tcon *tcon = cookie_netfs_data;\n\n\tif (datalen != sizeof(auxdata))\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tmemset(&auxdata, 0, sizeof(auxdata));\n\tauxdata.resource_id = tcon->resource_id;\n\n\tif (memcmp(data, &auxdata, datalen) != 0)\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
  },
  {
    "function_name": "cifs_fscache_super_get_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "171-187",
    "snippet": "static uint16_t\ncifs_fscache_super_get_aux(const void *cookie_netfs_data, void *buffer,\n\t\t\t   uint16_t maxbuf)\n{\n\tstruct cifs_fscache_super_auxdata auxdata;\n\tconst struct cifs_tcon *tcon = cookie_netfs_data;\n\n\tmemset(&auxdata, 0, sizeof(auxdata));\n\tauxdata.resource_id = tcon->resource_id;\n\n\tif (maxbuf > sizeof(auxdata))\n\t\tmaxbuf = sizeof(auxdata);\n\n\tmemcpy(buffer, &auxdata, maxbuf);\n\n\treturn maxbuf;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&auxdata",
            "maxbuf"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&auxdata",
            "0",
            "sizeof(auxdata)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic uint16_t\ncifs_fscache_super_get_aux(const void *cookie_netfs_data, void *buffer,\n\t\t\t   uint16_t maxbuf)\n{\n\tstruct cifs_fscache_super_auxdata auxdata;\n\tconst struct cifs_tcon *tcon = cookie_netfs_data;\n\n\tmemset(&auxdata, 0, sizeof(auxdata));\n\tauxdata.resource_id = tcon->resource_id;\n\n\tif (maxbuf > sizeof(auxdata))\n\t\tmaxbuf = sizeof(auxdata);\n\n\tmemcpy(buffer, &auxdata, maxbuf);\n\n\treturn maxbuf;\n}"
  },
  {
    "function_name": "cifs_super_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "146-169",
    "snippet": "static uint16_t cifs_super_get_key(const void *cookie_netfs_data, void *buffer,\n\t\t\t\t   uint16_t maxbuf)\n{\n\tconst struct cifs_tcon *tcon = cookie_netfs_data;\n\tchar *sharename;\n\tuint16_t len;\n\n\tsharename = extract_sharename(tcon->treeName);\n\tif (IS_ERR(sharename)) {\n\t\tcifs_dbg(FYI, \"%s: couldn't extract sharename\\n\", __func__);\n\t\tsharename = NULL;\n\t\treturn 0;\n\t}\n\n\tlen = strlen(sharename);\n\tif (len > maxbuf)\n\t\treturn 0;\n\n\tmemcpy(buffer, sharename, len);\n\n\tkfree(sharename);\n\n\treturn len;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sharename"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "sharename",
            "len"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sharename"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: couldn't extract sharename\\n\"",
            "__func__"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sharename"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_sharename",
          "args": [
            "tcon->treeName"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "extract_sharename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
          "lines": "119-141",
          "snippet": "static char *extract_sharename(const char *treename)\n{\n\tconst char *src;\n\tchar *delim, *dst;\n\tint len;\n\n\t/* skip double chars at the beginning */\n\tsrc = treename + 2;\n\n\t/* share name is always preceded by '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\tdelim++;\n\tlen = strlen(delim);\n\n\t/* caller has to free the memory */\n\tdst = kstrndup(delim, len, GFP_KERNEL);\n\tif (!dst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn dst;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic char *extract_sharename(const char *treename)\n{\n\tconst char *src;\n\tchar *delim, *dst;\n\tint len;\n\n\t/* skip double chars at the beginning */\n\tsrc = treename + 2;\n\n\t/* share name is always preceded by '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\tdelim++;\n\tlen = strlen(delim);\n\n\t/* caller has to free the memory */\n\tdst = kstrndup(delim, len, GFP_KERNEL);\n\tif (!dst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn dst;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic uint16_t cifs_super_get_key(const void *cookie_netfs_data, void *buffer,\n\t\t\t\t   uint16_t maxbuf)\n{\n\tconst struct cifs_tcon *tcon = cookie_netfs_data;\n\tchar *sharename;\n\tuint16_t len;\n\n\tsharename = extract_sharename(tcon->treeName);\n\tif (IS_ERR(sharename)) {\n\t\tcifs_dbg(FYI, \"%s: couldn't extract sharename\\n\", __func__);\n\t\tsharename = NULL;\n\t\treturn 0;\n\t}\n\n\tlen = strlen(sharename);\n\tif (len > maxbuf)\n\t\treturn 0;\n\n\tmemcpy(buffer, sharename, len);\n\n\tkfree(sharename);\n\n\treturn len;\n}"
  },
  {
    "function_name": "extract_sharename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "119-141",
    "snippet": "static char *extract_sharename(const char *treename)\n{\n\tconst char *src;\n\tchar *delim, *dst;\n\tint len;\n\n\t/* skip double chars at the beginning */\n\tsrc = treename + 2;\n\n\t/* share name is always preceded by '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\tdelim++;\n\tlen = strlen(delim);\n\n\t/* caller has to free the memory */\n\tdst = kstrndup(delim, len, GFP_KERNEL);\n\tif (!dst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn dst;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "delim",
            "len",
            "GFP_KERNEL"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "delim"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src",
            "'\\\\'"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic char *extract_sharename(const char *treename)\n{\n\tconst char *src;\n\tchar *delim, *dst;\n\tint len;\n\n\t/* skip double chars at the beginning */\n\tsrc = treename + 2;\n\n\t/* share name is always preceded by '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\tdelim++;\n\tlen = strlen(delim);\n\n\t/* caller has to free the memory */\n\tdst = kstrndup(delim, len, GFP_KERNEL);\n\tif (!dst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn dst;\n}"
  },
  {
    "function_name": "cifs_server_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "63-101",
    "snippet": "static uint16_t cifs_server_get_key(const void *cookie_netfs_data,\n\t\t\t\t   void *buffer, uint16_t maxbuf)\n{\n\tconst struct TCP_Server_Info *server = cookie_netfs_data;\n\tconst struct sockaddr *sa = (struct sockaddr *) &server->dstaddr;\n\tconst struct sockaddr_in *addr = (struct sockaddr_in *) sa;\n\tconst struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) sa;\n\tstruct cifs_server_key *key = buffer;\n\tuint16_t key_len = sizeof(struct cifs_server_key);\n\n\tmemset(key, 0, key_len);\n\n\t/*\n\t * Should not be a problem as sin_family/sin6_family overlays\n\t * sa_family field\n\t */\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tkey->family = sa->sa_family;\n\t\tkey->port = addr->sin_port;\n\t\tkey->addr[0].ipv4_addr = addr->sin_addr;\n\t\tkey_len += sizeof(key->addr[0].ipv4_addr);\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tkey->family = sa->sa_family;\n\t\tkey->port = addr6->sin6_port;\n\t\tkey->addr[0].ipv6_addr = addr6->sin6_addr;\n\t\tkey_len += sizeof(key->addr[0].ipv6_addr);\n\t\tbreak;\n\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown network family '%d'\\n\", sa->sa_family);\n\t\tkey_len = 0;\n\t\tbreak;\n\t}\n\n\treturn key_len;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Unknown network family '%d'\\n\"",
            "sa->sa_family"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "key_len"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstatic uint16_t cifs_server_get_key(const void *cookie_netfs_data,\n\t\t\t\t   void *buffer, uint16_t maxbuf)\n{\n\tconst struct TCP_Server_Info *server = cookie_netfs_data;\n\tconst struct sockaddr *sa = (struct sockaddr *) &server->dstaddr;\n\tconst struct sockaddr_in *addr = (struct sockaddr_in *) sa;\n\tconst struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) sa;\n\tstruct cifs_server_key *key = buffer;\n\tuint16_t key_len = sizeof(struct cifs_server_key);\n\n\tmemset(key, 0, key_len);\n\n\t/*\n\t * Should not be a problem as sin_family/sin6_family overlays\n\t * sa_family field\n\t */\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tkey->family = sa->sa_family;\n\t\tkey->port = addr->sin_port;\n\t\tkey->addr[0].ipv4_addr = addr->sin_addr;\n\t\tkey_len += sizeof(key->addr[0].ipv4_addr);\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tkey->family = sa->sa_family;\n\t\tkey->port = addr6->sin6_port;\n\t\tkey->addr[0].ipv6_addr = addr6->sin6_addr;\n\t\tkey_len += sizeof(key->addr[0].ipv6_addr);\n\t\tbreak;\n\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown network family '%d'\\n\", sa->sa_family);\n\t\tkey_len = 0;\n\t\tbreak;\n\t}\n\n\treturn key_len;\n}"
  },
  {
    "function_name": "cifs_fscache_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "43-46",
    "snippet": "void cifs_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&cifs_fscache_netfs);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_unregister_netfs",
          "args": [
            "&cifs_fscache_netfs"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_unregister_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "88-103",
          "snippet": "void __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstruct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};\n\nvoid cifs_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&cifs_fscache_netfs);\n}"
  },
  {
    "function_name": "cifs_fscache_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
    "lines": "35-38",
    "snippet": "int cifs_fscache_register(void)\n{\n\treturn fscache_register_netfs(&cifs_fscache_netfs);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"fscache.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_register_netfs",
          "args": [
            "&cifs_fscache_netfs"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_register_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "22-81",
          "snippet": "int __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fscache_netfs_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(fscache_netfs_list);\n\nint __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstruct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};\n\nint cifs_fscache_register(void)\n{\n\treturn fscache_register_netfs(&cifs_fscache_netfs);\n}"
  }
]