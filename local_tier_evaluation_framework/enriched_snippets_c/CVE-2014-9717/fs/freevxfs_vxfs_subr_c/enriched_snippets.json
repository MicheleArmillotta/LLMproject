[
  {
    "function_name": "vxfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
    "lines": "179-183",
    "snippet": "static sector_t\nvxfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, vxfs_getblk);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sector_t\t\tvxfs_bmap(struct address_space *, sector_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "vxfs_getblk"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic sector_t\t\tvxfs_bmap(struct address_space *, sector_t);\n\nstatic sector_t\nvxfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, vxfs_getblk);\n}"
  },
  {
    "function_name": "vxfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
    "lines": "158-162",
    "snippet": "static int\nvxfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, vxfs_getblk);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\tvxfs_readpage(struct file *, struct page *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "vxfs_getblk"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\nstatic int\nvxfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, vxfs_getblk);\n}"
  },
  {
    "function_name": "vxfs_getblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
    "lines": "128-141",
    "snippet": "static int\nvxfs_getblk(struct inode *ip, sector_t iblock,\n\t    struct buffer_head *bp, int create)\n{\n\tdaddr_t\t\t\tpblock;\n\n\tpblock = vxfs_bmap1(ip, iblock);\n\tif (pblock != 0) {\n\t\tmap_bh(bp, ip->i_sb, pblock);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sector_t\t\tvxfs_bmap(struct address_space *, sector_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bp",
            "ip->i_sb",
            "pblock"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_bmap1",
          "args": [
            "ip",
            "iblock"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_bmap1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_bmap.c",
          "lines": "259-281",
          "snippet": "daddr_t\nvxfs_bmap1(struct inode *ip, long iblock)\n{\n\tstruct vxfs_inode_info\t\t*vip = VXFS_INO(ip);\n\n\tif (VXFS_ISEXT4(vip))\n\t\treturn vxfs_bmap_ext4(ip, iblock);\n\tif (VXFS_ISTYPED(vip))\n\t\treturn vxfs_bmap_typed(ip, iblock);\n\tif (VXFS_ISNONE(vip))\n\t\tgoto unsupp;\n\tif (VXFS_ISIMMED(vip))\n\t\tgoto unsupp;\n\n\tprintk(KERN_WARNING \"vxfs: inode %ld has no valid orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\tBUG();\n\nunsupp:\n\tprintk(KERN_WARNING \"vxfs: inode %ld has an unsupported orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\treturn 0;\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\ndaddr_t\nvxfs_bmap1(struct inode *ip, long iblock)\n{\n\tstruct vxfs_inode_info\t\t*vip = VXFS_INO(ip);\n\n\tif (VXFS_ISEXT4(vip))\n\t\treturn vxfs_bmap_ext4(ip, iblock);\n\tif (VXFS_ISTYPED(vip))\n\t\treturn vxfs_bmap_typed(ip, iblock);\n\tif (VXFS_ISNONE(vip))\n\t\tgoto unsupp;\n\tif (VXFS_ISIMMED(vip))\n\t\tgoto unsupp;\n\n\tprintk(KERN_WARNING \"vxfs: inode %ld has no valid orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\tBUG();\n\nunsupp:\n\tprintk(KERN_WARNING \"vxfs: inode %ld has an unsupported orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic sector_t\t\tvxfs_bmap(struct address_space *, sector_t);\n\nstatic int\nvxfs_getblk(struct inode *ip, sector_t iblock,\n\t    struct buffer_head *bp, int create)\n{\n\tdaddr_t\t\t\tpblock;\n\n\tpblock = vxfs_bmap1(ip, iblock);\n\tif (pblock != 0) {\n\t\tmap_bh(bp, ip->i_sb, pblock);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
  },
  {
    "function_name": "vxfs_bread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
    "lines": "101-111",
    "snippet": "struct buffer_head *\nvxfs_bread(struct inode *ip, int block)\n{\n\tstruct buffer_head\t*bp;\n\tdaddr_t\t\t\tpblock;\n\n\tpblock = vxfs_bmap1(ip, block);\n\tbp = sb_bread(ip->i_sb, pblock);\n\n\treturn (bp);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "ip->i_sb",
            "pblock"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_bmap1",
          "args": [
            "ip",
            "block"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_bmap1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_bmap.c",
          "lines": "259-281",
          "snippet": "daddr_t\nvxfs_bmap1(struct inode *ip, long iblock)\n{\n\tstruct vxfs_inode_info\t\t*vip = VXFS_INO(ip);\n\n\tif (VXFS_ISEXT4(vip))\n\t\treturn vxfs_bmap_ext4(ip, iblock);\n\tif (VXFS_ISTYPED(vip))\n\t\treturn vxfs_bmap_typed(ip, iblock);\n\tif (VXFS_ISNONE(vip))\n\t\tgoto unsupp;\n\tif (VXFS_ISIMMED(vip))\n\t\tgoto unsupp;\n\n\tprintk(KERN_WARNING \"vxfs: inode %ld has no valid orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\tBUG();\n\nunsupp:\n\tprintk(KERN_WARNING \"vxfs: inode %ld has an unsupported orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\treturn 0;\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\ndaddr_t\nvxfs_bmap1(struct inode *ip, long iblock)\n{\n\tstruct vxfs_inode_info\t\t*vip = VXFS_INO(ip);\n\n\tif (VXFS_ISEXT4(vip))\n\t\treturn vxfs_bmap_ext4(ip, iblock);\n\tif (VXFS_ISTYPED(vip))\n\t\treturn vxfs_bmap_typed(ip, iblock);\n\tif (VXFS_ISNONE(vip))\n\t\tgoto unsupp;\n\tif (VXFS_ISIMMED(vip))\n\t\tgoto unsupp;\n\n\tprintk(KERN_WARNING \"vxfs: inode %ld has no valid orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\tBUG();\n\nunsupp:\n\tprintk(KERN_WARNING \"vxfs: inode %ld has an unsupported orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct buffer_head *\nvxfs_bread(struct inode *ip, int block)\n{\n\tstruct buffer_head\t*bp;\n\tdaddr_t\t\t\tpblock;\n\n\tpblock = vxfs_bmap1(ip, block);\n\tbp = sb_bread(ip->i_sb, pblock);\n\n\treturn (bp);\n}"
  },
  {
    "function_name": "vxfs_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
    "lines": "67-87",
    "snippet": "struct page *\nvxfs_get_page(struct address_space *mapping, u_long n)\n{\n\tstruct page *\t\t\tpp;\n\n\tpp = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(pp)) {\n\t\tkmap(pp);\n\t\t/** if (!PageChecked(pp)) **/\n\t\t\t/** vxfs_check_page(pp); **/\n\t\tif (PageError(pp))\n\t\t\tgoto fail;\n\t}\n\t\n\treturn (pp);\n\t\t \nfail:\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\tvxfs_readpage(struct file *, struct page *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_put_page",
          "args": [
            "pp"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
          "lines": "49-54",
          "snippet": "inline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tvxfs_readpage(struct file *, struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\ninline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "pp"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "pp"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pp"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "n",
            "NULL"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\nstruct page *\nvxfs_get_page(struct address_space *mapping, u_long n)\n{\n\tstruct page *\t\t\tpp;\n\n\tpp = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(pp)) {\n\t\tkmap(pp);\n\t\t/** if (!PageChecked(pp)) **/\n\t\t\t/** vxfs_check_page(pp); **/\n\t\tif (PageError(pp))\n\t\t\tgoto fail;\n\t}\n\t\n\treturn (pp);\n\t\t \nfail:\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "vxfs_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
    "lines": "49-54",
    "snippet": "inline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\tvxfs_readpage(struct file *, struct page *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pp"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "pp"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\ninline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}"
  }
]