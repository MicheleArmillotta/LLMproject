[
  {
    "function_name": "xfs_qm_newmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_bhv.c",
    "lines": "81-149",
    "snippet": "int\nxfs_qm_newmount(\n\txfs_mount_t\t*mp,\n\tuint\t\t*needquotamount,\n\tuint\t\t*quotaflags)\n{\n\tuint\t\tquotaondisk;\n\tuint\t\tuquotaondisk = 0, gquotaondisk = 0, pquotaondisk = 0;\n\n\tquotaondisk = xfs_sb_version_hasquota(&mp->m_sb) &&\n\t\t\t\t(mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT);\n\n\tif (quotaondisk) {\n\t\tuquotaondisk = mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT;\n\t\tpquotaondisk = mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT;\n\t\tgquotaondisk = mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT;\n\t}\n\n\t/*\n\t * If the device itself is read-only, we can't allow\n\t * the user to change the state of quota on the mount -\n\t * this would generate a transaction on the ro device,\n\t * which would lead to an I/O error and shutdown\n\t */\n\n\tif (((uquotaondisk && !XFS_IS_UQUOTA_ON(mp)) ||\n\t    (!uquotaondisk &&  XFS_IS_UQUOTA_ON(mp)) ||\n\t     (gquotaondisk && !XFS_IS_GQUOTA_ON(mp)) ||\n\t    (!gquotaondisk &&  XFS_IS_GQUOTA_ON(mp)) ||\n\t     (pquotaondisk && !XFS_IS_PQUOTA_ON(mp)) ||\n\t    (!pquotaondisk &&  XFS_IS_PQUOTA_ON(mp)))  &&\n\t    xfs_dev_is_read_only(mp, \"changing quota state\")) {\n\t\txfs_warn(mp, \"please mount with%s%s%s%s.\",\n\t\t\t(!quotaondisk ? \"out quota\" : \"\"),\n\t\t\t(uquotaondisk ? \" usrquota\" : \"\"),\n\t\t\t(gquotaondisk ? \" grpquota\" : \"\"),\n\t\t\t(pquotaondisk ? \" prjquota\" : \"\"));\n\t\treturn -EPERM;\n\t}\n\n\tif (XFS_IS_QUOTA_ON(mp) || quotaondisk) {\n\t\t/*\n\t\t * Call mount_quotas at this point only if we won't have to do\n\t\t * a quotacheck.\n\t\t */\n\t\tif (quotaondisk && !XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\t\t/*\n\t\t\t * If an error occurred, qm_mount_quotas code\n\t\t\t * has already disabled quotas. So, just finish\n\t\t\t * mounting, and get on with the boring life\n\t\t\t * without disk quotas.\n\t\t\t */\n\t\t\txfs_qm_mount_quotas(mp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Clear the quota flags, but remember them. This\n\t\t\t * is so that the quota code doesn't get invoked\n\t\t\t * before we're ready. This can happen when an\n\t\t\t * inode goes inactive and wants to free blocks,\n\t\t\t * or via xfs_log_mount_finish.\n\t\t\t */\n\t\t\t*needquotamount = true;\n\t\t\t*quotaflags = mp->m_qflags;\n\t\t\tmp->m_qflags = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_mount_quotas",
          "args": [
            "mp"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_mount_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1388-1470",
          "snippet": "void\nxfs_qm_mount_quotas(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\tuint\t\t\tsbf;\n\n\t/*\n\t * If quotas on realtime volumes is not supported, we disable\n\t * quotas immediately.\n\t */\n\tif (mp->m_sb.sb_rextents) {\n\t\txfs_notice(mp, \"Cannot turn on quotas for realtime filesystem\");\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * Allocate the quotainfo structure inside the mount struct, and\n\t * create quotainode(s), and change/rev superblock if necessary.\n\t */\n\terror = xfs_qm_init_quotainfo(mp);\n\tif (error) {\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo == NULL);\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\t/*\n\t * If any of the quotas are not consistent, do a quotacheck.\n\t */\n\tif (XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\terror = xfs_qm_quotacheck(mp);\n\t\tif (error) {\n\t\t\t/* Quotacheck failed and disabled quotas. */\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tif (!XFS_IS_UQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_UQUOTA_CHKD;\n\tif (!XFS_IS_GQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_GQUOTA_CHKD;\n\tif (!XFS_IS_PQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_PQUOTA_CHKD;\n\n write_changes:\n\t/*\n\t * We actually don't have to acquire the m_sb_lock at all.\n\t * This can only be called from mount, and that's single threaded. XXX\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\n\t\tif (xfs_sync_sb(mp, false)) {\n\t\t\t/*\n\t\t\t * We could only have been turning quotas off.\n\t\t\t * We aren't in very good shape actually because\n\t\t\t * the incore structures are convinced that quotas are\n\t\t\t * off, but the on disk superblock doesn't know that !\n\t\t\t */\n\t\t\tASSERT(!(XFS_IS_QUOTA_RUNNING(mp)));\n\t\t\txfs_alert(mp, \"%s: Superblock update failed!\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp, \"Failed to initialize disk quotas.\");\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_mount_quotas(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\tuint\t\t\tsbf;\n\n\t/*\n\t * If quotas on realtime volumes is not supported, we disable\n\t * quotas immediately.\n\t */\n\tif (mp->m_sb.sb_rextents) {\n\t\txfs_notice(mp, \"Cannot turn on quotas for realtime filesystem\");\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * Allocate the quotainfo structure inside the mount struct, and\n\t * create quotainode(s), and change/rev superblock if necessary.\n\t */\n\terror = xfs_qm_init_quotainfo(mp);\n\tif (error) {\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo == NULL);\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\t/*\n\t * If any of the quotas are not consistent, do a quotacheck.\n\t */\n\tif (XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\terror = xfs_qm_quotacheck(mp);\n\t\tif (error) {\n\t\t\t/* Quotacheck failed and disabled quotas. */\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tif (!XFS_IS_UQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_UQUOTA_CHKD;\n\tif (!XFS_IS_GQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_GQUOTA_CHKD;\n\tif (!XFS_IS_PQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_PQUOTA_CHKD;\n\n write_changes:\n\t/*\n\t * We actually don't have to acquire the m_sb_lock at all.\n\t * This can only be called from mount, and that's single threaded. XXX\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\n\t\tif (xfs_sync_sb(mp, false)) {\n\t\t\t/*\n\t\t\t * We could only have been turning quotas off.\n\t\t\t * We aren't in very good shape actually because\n\t\t\t * the incore structures are convinced that quotas are\n\t\t\t * off, but the on disk superblock doesn't know that !\n\t\t\t */\n\t\t\tASSERT(!(XFS_IS_QUOTA_RUNNING(mp)));\n\t\t\txfs_alert(mp, \"%s: Superblock update failed!\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp, \"Failed to initialize disk quotas.\");\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_QM_NEED_QUOTACHECK",
          "args": [
            "mp"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"please mount with%s%s%s%s.\"",
            "(!quotaondisk ? \"out quota\" : \"\")",
            "(uquotaondisk ? \" usrquota\" : \"\")",
            "(gquotaondisk ? \" grpquota\" : \"\")",
            "(pquotaondisk ? \" prjquota\" : \"\")"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dev_is_read_only",
          "args": [
            "mp",
            "\"changing quota state\""
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dev_is_read_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1396-1409",
          "snippet": "int\nxfs_dev_is_read_only(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*message)\n{\n\tif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\n\t    xfs_readonly_buftarg(mp->m_logdev_targp) ||\n\t    (mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\n\t\txfs_notice(mp, \"%s required on read-only device.\", message);\n\t\txfs_notice(mp, \"write access unavailable, cannot proceed.\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dev_is_read_only(\n\tstruct xfs_mount\t*mp,\n\tchar\t\t\t*message)\n{\n\tif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\n\t    xfs_readonly_buftarg(mp->m_logdev_targp) ||\n\t    (mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\n\t\txfs_notice(mp, \"%s required on read-only device.\", message);\n\t\txfs_notice(mp, \"write access unavailable, cannot proceed.\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasquota",
          "args": [
            "&mp->m_sb"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasquota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "389-392",
          "snippet": "static inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n\nstatic inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_newmount(\n\txfs_mount_t\t*mp,\n\tuint\t\t*needquotamount,\n\tuint\t\t*quotaflags)\n{\n\tuint\t\tquotaondisk;\n\tuint\t\tuquotaondisk = 0, gquotaondisk = 0, pquotaondisk = 0;\n\n\tquotaondisk = xfs_sb_version_hasquota(&mp->m_sb) &&\n\t\t\t\t(mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT);\n\n\tif (quotaondisk) {\n\t\tuquotaondisk = mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT;\n\t\tpquotaondisk = mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT;\n\t\tgquotaondisk = mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT;\n\t}\n\n\t/*\n\t * If the device itself is read-only, we can't allow\n\t * the user to change the state of quota on the mount -\n\t * this would generate a transaction on the ro device,\n\t * which would lead to an I/O error and shutdown\n\t */\n\n\tif (((uquotaondisk && !XFS_IS_UQUOTA_ON(mp)) ||\n\t    (!uquotaondisk &&  XFS_IS_UQUOTA_ON(mp)) ||\n\t     (gquotaondisk && !XFS_IS_GQUOTA_ON(mp)) ||\n\t    (!gquotaondisk &&  XFS_IS_GQUOTA_ON(mp)) ||\n\t     (pquotaondisk && !XFS_IS_PQUOTA_ON(mp)) ||\n\t    (!pquotaondisk &&  XFS_IS_PQUOTA_ON(mp)))  &&\n\t    xfs_dev_is_read_only(mp, \"changing quota state\")) {\n\t\txfs_warn(mp, \"please mount with%s%s%s%s.\",\n\t\t\t(!quotaondisk ? \"out quota\" : \"\"),\n\t\t\t(uquotaondisk ? \" usrquota\" : \"\"),\n\t\t\t(gquotaondisk ? \" grpquota\" : \"\"),\n\t\t\t(pquotaondisk ? \" prjquota\" : \"\"));\n\t\treturn -EPERM;\n\t}\n\n\tif (XFS_IS_QUOTA_ON(mp) || quotaondisk) {\n\t\t/*\n\t\t * Call mount_quotas at this point only if we won't have to do\n\t\t * a quotacheck.\n\t\t */\n\t\tif (quotaondisk && !XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\t\t/*\n\t\t\t * If an error occurred, qm_mount_quotas code\n\t\t\t * has already disabled quotas. So, just finish\n\t\t\t * mounting, and get on with the boring life\n\t\t\t * without disk quotas.\n\t\t\t */\n\t\t\txfs_qm_mount_quotas(mp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Clear the quota flags, but remember them. This\n\t\t\t * is so that the quota code doesn't get invoked\n\t\t\t * before we're ready. This can happen when an\n\t\t\t * inode goes inactive and wants to free blocks,\n\t\t\t * or via xfs_log_mount_finish.\n\t\t\t */\n\t\t\t*needquotamount = true;\n\t\t\t*quotaflags = mp->m_qflags;\n\t\t\tmp->m_qflags = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_statvfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_bhv.c",
    "lines": "67-79",
    "snippet": "void\nxfs_qm_statvfs(\n\txfs_inode_t\t\t*ip,\n\tstruct kstatfs\t\t*statp)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_dquot_t\t\t*dqp;\n\n\tif (!xfs_qm_dqget(mp, NULL, xfs_get_projid(ip), XFS_DQ_PROJ, 0, &dqp)) {\n\t\txfs_fill_statvfs_from_dquot(statp, dqp);\n\t\txfs_qm_dqput(dqp);\n\t}\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqput",
          "args": [
            "dqp"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "839-856",
          "snippet": "void\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fill_statvfs_from_dquot",
          "args": [
            "statp",
            "dqp"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fill_statvfs_from_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_bhv.c",
          "lines": "31-57",
          "snippet": "STATIC void\nxfs_fill_statvfs_from_dquot(\n\tstruct kstatfs\t\t*statp,\n\tstruct xfs_dquot\t*dqp)\n{\n\t__uint64_t\t\tlimit;\n\n\tlimit = dqp->q_core.d_blk_softlimit ?\n\t\tbe64_to_cpu(dqp->q_core.d_blk_softlimit) :\n\t\tbe64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tif (limit && statp->f_blocks > limit) {\n\t\tstatp->f_blocks = limit;\n\t\tstatp->f_bfree = statp->f_bavail =\n\t\t\t(statp->f_blocks > dqp->q_res_bcount) ?\n\t\t\t (statp->f_blocks - dqp->q_res_bcount) : 0;\n\t}\n\n\tlimit = dqp->q_core.d_ino_softlimit ?\n\t\tbe64_to_cpu(dqp->q_core.d_ino_softlimit) :\n\t\tbe64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\tif (limit && statp->f_files > limit) {\n\t\tstatp->f_files = limit;\n\t\tstatp->f_ffree =\n\t\t\t(statp->f_files > dqp->q_res_icount) ?\n\t\t\t (statp->f_ffree - dqp->q_res_icount) : 0;\n\t}\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_fill_statvfs_from_dquot(\n\tstruct kstatfs\t\t*statp,\n\tstruct xfs_dquot\t*dqp)\n{\n\t__uint64_t\t\tlimit;\n\n\tlimit = dqp->q_core.d_blk_softlimit ?\n\t\tbe64_to_cpu(dqp->q_core.d_blk_softlimit) :\n\t\tbe64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tif (limit && statp->f_blocks > limit) {\n\t\tstatp->f_blocks = limit;\n\t\tstatp->f_bfree = statp->f_bavail =\n\t\t\t(statp->f_blocks > dqp->q_res_bcount) ?\n\t\t\t (statp->f_blocks - dqp->q_res_bcount) : 0;\n\t}\n\n\tlimit = dqp->q_core.d_ino_softlimit ?\n\t\tbe64_to_cpu(dqp->q_core.d_ino_softlimit) :\n\t\tbe64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\tif (limit && statp->f_files > limit) {\n\t\tstatp->f_files = limit;\n\t\tstatp->f_ffree =\n\t\t\t(statp->f_files > dqp->q_res_icount) ?\n\t\t\t (statp->f_ffree - dqp->q_res_icount) : 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqget",
          "args": [
            "mp",
            "NULL",
            "xfs_get_projid(ip)",
            "XFS_DQ_PROJ",
            "0",
            "&dqp"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "698-831",
          "snippet": "int\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_statvfs(\n\txfs_inode_t\t\t*ip,\n\tstruct kstatfs\t\t*statp)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_dquot_t\t\t*dqp;\n\n\tif (!xfs_qm_dqget(mp, NULL, xfs_get_projid(ip), XFS_DQ_PROJ, 0, &dqp)) {\n\t\txfs_fill_statvfs_from_dquot(statp, dqp);\n\t\txfs_qm_dqput(dqp);\n\t}\n}"
  },
  {
    "function_name": "xfs_fill_statvfs_from_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_bhv.c",
    "lines": "31-57",
    "snippet": "STATIC void\nxfs_fill_statvfs_from_dquot(\n\tstruct kstatfs\t\t*statp,\n\tstruct xfs_dquot\t*dqp)\n{\n\t__uint64_t\t\tlimit;\n\n\tlimit = dqp->q_core.d_blk_softlimit ?\n\t\tbe64_to_cpu(dqp->q_core.d_blk_softlimit) :\n\t\tbe64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tif (limit && statp->f_blocks > limit) {\n\t\tstatp->f_blocks = limit;\n\t\tstatp->f_bfree = statp->f_bavail =\n\t\t\t(statp->f_blocks > dqp->q_res_bcount) ?\n\t\t\t (statp->f_blocks - dqp->q_res_bcount) : 0;\n\t}\n\n\tlimit = dqp->q_core.d_ino_softlimit ?\n\t\tbe64_to_cpu(dqp->q_core.d_ino_softlimit) :\n\t\tbe64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\tif (limit && statp->f_files > limit) {\n\t\tstatp->f_files = limit;\n\t\tstatp->f_ffree =\n\t\t\t(statp->f_files > dqp->q_res_icount) ?\n\t\t\t (statp->f_ffree - dqp->q_res_icount) : 0;\n\t}\n}",
    "includes": [
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_ino_hardlimit"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_ino_softlimit"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_blk_hardlimit"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_blk_softlimit"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_fill_statvfs_from_dquot(\n\tstruct kstatfs\t\t*statp,\n\tstruct xfs_dquot\t*dqp)\n{\n\t__uint64_t\t\tlimit;\n\n\tlimit = dqp->q_core.d_blk_softlimit ?\n\t\tbe64_to_cpu(dqp->q_core.d_blk_softlimit) :\n\t\tbe64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tif (limit && statp->f_blocks > limit) {\n\t\tstatp->f_blocks = limit;\n\t\tstatp->f_bfree = statp->f_bavail =\n\t\t\t(statp->f_blocks > dqp->q_res_bcount) ?\n\t\t\t (statp->f_blocks - dqp->q_res_bcount) : 0;\n\t}\n\n\tlimit = dqp->q_core.d_ino_softlimit ?\n\t\tbe64_to_cpu(dqp->q_core.d_ino_softlimit) :\n\t\tbe64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\tif (limit && statp->f_files > limit) {\n\t\tstatp->f_files = limit;\n\t\tstatp->f_ffree =\n\t\t\t(statp->f_files > dqp->q_res_icount) ?\n\t\t\t (statp->f_ffree - dqp->q_res_icount) : 0;\n\t}\n}"
  }
]