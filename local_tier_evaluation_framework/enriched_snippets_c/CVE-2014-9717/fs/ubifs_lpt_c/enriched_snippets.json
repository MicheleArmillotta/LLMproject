[
  {
    "function_name": "_nodes(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "2222-2277",
    "snippet": "_lpt_nodes(struct ubifs_info *c, struct ubifs_cnode *cnode,\n\t\t\tint row, int col)\n{\n\tstruct ubifs_nnode *nnode, *nn;\n\tstruct ubifs_cnode *cn;\n\tint num, iip = 0, err;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\twhile (cnode) {\n\t\tubifs_assert(row >= 0);\n\t\tnnode = cnode->parent;\n\t\tif (cnode->level) {\n\t\t\t/* cnode is a nnode */\n\t\t\tnum = calc_nnode_num(row, col);\n\t\t\tif (cnode->num != num) {\n\t\t\t\tubifs_err(\"nnode num %d expected %d parent num %d iip %d\",\n\t\t\t\t\t  cnode->num, num,\n\t\t\t\t\t  (nnode ? nnode->num : 0), cnode->iip);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnn = (struct ubifs_nnode *)cnode;\n\t\t\twhile (iip < UBIFS_LPT_FANOUT) {\n\t\t\t\tcn = nn->nbranch[iip].cnode;\n\t\t\t\tif (cn) {\n\t\t\t\t\t/* Go down */\n\t\t\t\t\trow += 1;\n\t\t\t\t\tcol <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\t\t\t\tcol += iip;\n\t\t\t\t\tiip = 0;\n\t\t\t\t\tcnode = cn;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* Go right */\n\t\t\t\tiip += 1;\n\t\t\t}\n\t\t\tif (iip < UBIFS_LPT_FANOUT)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct ubifs_pnode *pnode;\n\n\t\t\t/* cnode is a pnode */\n\t\t\tpnode = (struct ubifs_pnode *)cnode;\n\t\t\terr = dbg_chk_pnode(c, pnode, col);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\t/* Go up and to the right */\n\t\trow -= 1;\n\t\tcol >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tiip = cnode->iip + 1;\n\t\tcnode = (struct ubifs_cnode *)nnode;\n\t}\n\treturn 0;\n}",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(c, pnode, co",
          "args": [
            ")",
            "if",
            "err"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode num %",
          "args": [
            "expected %d parent num %d iip %d\",\n\t\t\t\t\t  cnod",
            "um,",
            "nno",
            "e->num : 0), cnode->iip)",
            "return"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m(row, col);",
          "args": [
            "if",
            "cno"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "row >= 0);",
          "args": [
            "nnode ="
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_lpt_nodes(struct ubifs_info *c, struct ubifs_cnode *cnode,\n\t\t\tint row, int col)\n{\n\tstruct ubifs_nnode *nnode, *nn;\n\tstruct ubifs_cnode *cn;\n\tint num, iip = 0, err;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\twhile (cnode) {\n\t\tubifs_assert(row >= 0);\n\t\tnnode = cnode->parent;\n\t\tif (cnode->level) {\n\t\t\t/* cnode is a nnode */\n\t\t\tnum = calc_nnode_num(row, col);\n\t\t\tif (cnode->num != num) {\n\t\t\t\tubifs_err(\"nnode num %d expected %d parent num %d iip %d\",\n\t\t\t\t\t  cnode->num, num,\n\t\t\t\t\t  (nnode ? nnode->num : 0), cnode->iip);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnn = (struct ubifs_nnode *)cnode;\n\t\t\twhile (iip < UBIFS_LPT_FANOUT) {\n\t\t\t\tcn = nn->nbranch[iip].cnode;\n\t\t\t\tif (cn) {\n\t\t\t\t\t/* Go down */\n\t\t\t\t\trow += 1;\n\t\t\t\t\tcol <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\t\t\t\tcol += iip;\n\t\t\t\t\tiip = 0;\n\t\t\t\t\tcnode = cn;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* Go right */\n\t\t\t\tiip += 1;\n\t\t\t}\n\t\t\tif (iip < UBIFS_LPT_FANOUT)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct ubifs_pnode *pnode;\n\n\t\t\t/* cnode is a pnode */\n\t\t\tpnode = (struct ubifs_pnode *)cnode;\n\t\t\terr = dbg_chk_pnode(c, pnode, col);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\t/* Go up and to the right */\n\t\trow -= 1;\n\t\tcol >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tiip = cnode->iip + 1;\n\t\tcnode = (struct ubifs_cnode *)nnode;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "2092-2211",
    "snippet": "g_chk_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t\t int col)\n{\n\tint i;\n\n\tif (pnode->num != col) {\n\t\tubifs_err(\"pnode num %d expected %d parent num %d iip %d\",\n\t\t\t  pnode->num, col, pnode->parent->num, pnode->iip);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops *lp, *lprops = &pnode->lprops[i];\n\t\tint lnum = (pnode->num << UBIFS_LPT_FANOUT_SHIFT) + i +\n\t\t\t   c->main_first;\n\t\tint found, cat = lprops->flags & LPROPS_CAT_MASK;\n\t\tstruct ubifs_lpt_heap *heap;\n\t\tstruct list_head *list = NULL;\n\n\t\tif (lnum >= c->leb_cnt)\n\t\t\tcontinue;\n\t\tif (lprops->lnum != lnum) {\n\t\t\tubifs_err(\"bad LEB number %d expected %d\",\n\t\t\t\t  lprops->lnum, lnum);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tif (cat != LPROPS_UNCAT) {\n\t\t\t\tubifs_err(\"LEB %d taken but not uncat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (lprops->flags & LPROPS_INDEX) {\n\t\t\tswitch (cat) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\tcase LPROPS_DIRTY_IDX:\n\t\t\tcase LPROPS_FRDI_IDX:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tubifs_err(\"LEB %d index but cat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (cat) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\tcase LPROPS_DIRTY:\n\t\t\tcase LPROPS_FREE:\n\t\t\tcase LPROPS_EMPTY:\n\t\t\tcase LPROPS_FREEABLE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tubifs_err(\"LEB %d not index but cat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tswitch (cat) {\n\t\tcase LPROPS_UNCAT:\n\t\t\tlist = &c->uncat_list;\n\t\t\tbreak;\n\t\tcase LPROPS_EMPTY:\n\t\t\tlist = &c->empty_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\t\tlist = &c->freeable_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist = &c->frdi_idx_list;\n\t\t\tbreak;\n\t\t}\n\t\tfound = 0;\n\t\tswitch (cat) {\n\t\tcase LPROPS_DIRTY:\n\t\tcase LPROPS_DIRTY_IDX:\n\t\tcase LPROPS_FREE:\n\t\t\theap = &c->lpt_heap[cat - 1];\n\t\t\tif (lprops->hpos < heap->cnt &&\n\t\t\t    heap->arr[lprops->hpos] == lprops)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase LPROPS_UNCAT:\n\t\tcase LPROPS_EMPTY:\n\t\tcase LPROPS_FREEABLE:\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist_for_each_entry(lp, list, list)\n\t\t\t\tif (lprops == lp) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\tubifs_err(\"LEB %d cat %d not found in cat heap/list\",\n\t\t\t\t  lprops->lnum, cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (cat) {\n\t\tcase LPROPS_EMPTY:\n\t\t\tif (lprops->free != c->leb_size) {\n\t\t\t\tubifs_err(\"LEB %d cat %d free %d dirty %d\",\n\t\t\t\t\t  lprops->lnum, cat, lprops->free,\n\t\t\t\t\t  lprops->dirty);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\t\tubifs_err(\"LEB %d cat %d free %d dirty %d\",\n\t\t\t\t\t  lprops->lnum, cat, lprops->free,\n\t\t\t\t\t  lprops->dirty);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * dbg_",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "B %d cat",
          "args": [
            "d free %d dirty %d\",\n\t\t\t\t\t  lpro",
            "cat, lprops",
            "fre",
            "lpro",
            ");\n\t\t\t\treturn"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d cat",
          "args": [
            "d free %d dirty %d\",\n\t\t\t\t\t  lpro",
            "cat, lprops",
            "fre",
            "lpro",
            ");\n\t\t\t\treturn"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d cat",
          "args": [
            "d not found in cat heap/list\",\n\t\t\t\t  lprop",
            "cat);\n\t\t\tre",
            "rn"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lp, list, li",
          "args": [
            "t)",
            "i",
            "(lpr"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d not",
          "args": [
            "ndex but cat %d\",\n\t\t\t\t\t  lpro",
            "cat);\n\t\t\t\tr",
            "urn"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d inde",
          "args": [
            "but cat %d\",\n\t\t\t\t\t  lpro",
            "cat);\n\t\t\t\tr",
            "urn"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d take",
          "args": [
            "but not uncat %d\",\n\t\t\t\t\t  lpro",
            "cat);\n\t\t\t\tr",
            "urn"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d LEB num",
          "args": [
            "er %d expected %d\",\n\t\t\t\t  lprop",
            "lnum);\n\t\t\tr",
            "urn"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode num %",
          "args": [
            "expected %d parent num %d iip %d\",\n\t\t\t  pnode-",
            "ol, pnode-",
            "are",
            "->num, pnode->iip)",
            "return -"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\ng_chk_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t\t int col)\n{\n\tint i;\n\n\tif (pnode->num != col) {\n\t\tubifs_err(\"pnode num %d expected %d parent num %d iip %d\",\n\t\t\t  pnode->num, col, pnode->parent->num, pnode->iip);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops *lp, *lprops = &pnode->lprops[i];\n\t\tint lnum = (pnode->num << UBIFS_LPT_FANOUT_SHIFT) + i +\n\t\t\t   c->main_first;\n\t\tint found, cat = lprops->flags & LPROPS_CAT_MASK;\n\t\tstruct ubifs_lpt_heap *heap;\n\t\tstruct list_head *list = NULL;\n\n\t\tif (lnum >= c->leb_cnt)\n\t\t\tcontinue;\n\t\tif (lprops->lnum != lnum) {\n\t\t\tubifs_err(\"bad LEB number %d expected %d\",\n\t\t\t\t  lprops->lnum, lnum);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lprops->flags & LPROPS_TAKEN) {\n\t\t\tif (cat != LPROPS_UNCAT) {\n\t\t\t\tubifs_err(\"LEB %d taken but not uncat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (lprops->flags & LPROPS_INDEX) {\n\t\t\tswitch (cat) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\tcase LPROPS_DIRTY_IDX:\n\t\t\tcase LPROPS_FRDI_IDX:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tubifs_err(\"LEB %d index but cat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (cat) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\tcase LPROPS_DIRTY:\n\t\t\tcase LPROPS_FREE:\n\t\t\tcase LPROPS_EMPTY:\n\t\t\tcase LPROPS_FREEABLE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tubifs_err(\"LEB %d not index but cat %d\",\n\t\t\t\t\t  lprops->lnum, cat);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tswitch (cat) {\n\t\tcase LPROPS_UNCAT:\n\t\t\tlist = &c->uncat_list;\n\t\t\tbreak;\n\t\tcase LPROPS_EMPTY:\n\t\t\tlist = &c->empty_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\t\tlist = &c->freeable_list;\n\t\t\tbreak;\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist = &c->frdi_idx_list;\n\t\t\tbreak;\n\t\t}\n\t\tfound = 0;\n\t\tswitch (cat) {\n\t\tcase LPROPS_DIRTY:\n\t\tcase LPROPS_DIRTY_IDX:\n\t\tcase LPROPS_FREE:\n\t\t\theap = &c->lpt_heap[cat - 1];\n\t\t\tif (lprops->hpos < heap->cnt &&\n\t\t\t    heap->arr[lprops->hpos] == lprops)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase LPROPS_UNCAT:\n\t\tcase LPROPS_EMPTY:\n\t\tcase LPROPS_FREEABLE:\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tlist_for_each_entry(lp, list, list)\n\t\t\t\tif (lprops == lp) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\tubifs_err(\"LEB %d cat %d not found in cat heap/list\",\n\t\t\t\t  lprops->lnum, cat);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (cat) {\n\t\tcase LPROPS_EMPTY:\n\t\t\tif (lprops->free != c->leb_size) {\n\t\t\t\tubifs_err(\"LEB %d cat %d free %d dirty %d\",\n\t\t\t\t\t  lprops->lnum, cat, lprops->free,\n\t\t\t\t\t  lprops->dirty);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LPROPS_FREEABLE:\n\t\tcase LPROPS_FRDI_IDX:\n\t\t\tif (lprops->free + lprops->dirty != c->leb_size) {\n\t\t\t\tubifs_err(\"LEB %d cat %d free %d dirty %d\",\n\t\t\t\t\t  lprops->lnum, cat, lprops->free,\n\t\t\t\t\t  lprops->dirty);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "n_nolock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1920-2082",
    "snippet": "_scan_nolock(struct ubifs_info *c, int start_lnum, int end_lnum,\n\t\t\t  ubifs_lpt_scan_callback scan_cb, void *data)\n{\n\tint err = 0, i, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\tstruct ubifs_pnode *pnode;\n\tstruct lpt_scan_node *path;\n\n\tif (start_lnum == -1) {\n\t\tstart_lnum = end_lnum + 1;\n\t\tif (start_lnum >= c->leb_cnt)\n\t\t\tstart_lnum = c->main_first;\n\t}\n\n\tubifs_assert(start_lnum >= c->main_first && start_lnum < c->leb_cnt);\n\tubifs_assert(end_lnum >= c->main_first && end_lnum < c->leb_cnt);\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpath = kmalloc(sizeof(struct lpt_scan_node) * (c->lpt_hght + 1),\n\t\t       GFP_NOFS);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath[0].ptr.nnode = c->nroot;\n\tpath[0].in_tree = 1;\nagain:\n\t/* Descend to the pnode containing start_lnum */\n\tnnode = c->nroot;\n\ti = start_lnum - c->main_first;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = scan_get_nnode(c, path + h, nnode, iip);\n\t\tif (IS_ERR(nnode)) {\n\t\t\terr = PTR_ERR(nnode);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\tpnode = scan_get_pnode(c, path + h, nnode, iip);\n\tif (IS_ERR(pnode)) {\n\t\terr = PTR_ERR(pnode);\n\t\tgoto out;\n\t}\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\n\t/* Loop for each lprops */\n\twhile (1) {\n\t\tstruct ubifs_lprops *lprops = &pnode->lprops[iip];\n\t\tint ret, lnum = lprops->lnum;\n\n\t\tret = scan_cb(c, lprops, path[h].in_tree, data);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret & LPT_SCAN_ADD) {\n\t\t\t/* Add all the nodes in path to the tree in memory */\n\t\t\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\t\t\tconst size_t sz = sizeof(struct ubifs_nnode);\n\t\t\t\tstruct ubifs_nnode *parent;\n\n\t\t\t\tif (path[h].in_tree)\n\t\t\t\t\tcontinue;\n\t\t\t\tnnode = kmemdup(&path[h].nnode, sz, GFP_NOFS);\n\t\t\t\tif (!nnode) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparent = nnode->parent;\n\t\t\t\tparent->nbranch[nnode->iip].nnode = nnode;\n\t\t\t\tpath[h].ptr.nnode = nnode;\n\t\t\t\tpath[h].in_tree = 1;\n\t\t\t\tpath[h + 1].cnode.parent = nnode;\n\t\t\t}\n\t\t\tif (path[h].in_tree)\n\t\t\t\tubifs_ensure_cat(c, lprops);\n\t\t\telse {\n\t\t\t\tconst size_t sz = sizeof(struct ubifs_pnode);\n\t\t\t\tstruct ubifs_nnode *parent;\n\n\t\t\t\tpnode = kmemdup(&path[h].pnode, sz, GFP_NOFS);\n\t\t\t\tif (!pnode) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparent = pnode->parent;\n\t\t\t\tparent->nbranch[pnode->iip].pnode = pnode;\n\t\t\t\tpath[h].ptr.pnode = pnode;\n\t\t\t\tpath[h].in_tree = 1;\n\t\t\t\tupdate_cats(c, pnode);\n\t\t\t\tc->pnodes_have += 1;\n\t\t\t}\n\t\t\terr = dbg_check_lpt_nodes(c, (struct ubifs_cnode *)\n\t\t\t\t\t\t  c->nroot, 0, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = dbg_check_cats(c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (ret & LPT_SCAN_STOP) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\t/* Get the next lprops */\n\t\tif (lnum == end_lnum) {\n\t\t\t/*\n\t\t\t * We got to the end without finding what we were\n\t\t\t * looking for\n\t\t\t */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lnum + 1 >= c->leb_cnt) {\n\t\t\t/* Wrap-around to the beginning */\n\t\t\tstart_lnum = c->main_first;\n\t\t\tgoto again;\n\t\t}\n\t\tif (iip + 1 < UBIFS_LPT_FANOUT) {\n\t\t\t/* Next lprops is in the same pnode */\n\t\t\tiip += 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* We need to get the next pnode. Go up until we can go right */\n\t\tiip = pnode->iip;\n\t\twhile (1) {\n\t\t\th -= 1;\n\t\t\tubifs_assert(h >= 0);\n\t\t\tnnode = path[h].ptr.nnode;\n\t\t\tif (iip + 1 < UBIFS_LPT_FANOUT)\n\t\t\t\tbreak;\n\t\t\tiip = nnode->iip;\n\t\t}\n\t\t/* Go right */\n\t\tiip += 1;\n\t\t/* Descend to the pnode */\n\t\th += 1;\n\t\tfor (; h < c->lpt_hght; h++) {\n\t\t\tnnode = scan_get_nnode(c, path + h, nnode, iip);\n\t\t\tif (IS_ERR(nnode)) {\n\t\t\t\terr = PTR_ERR(nnode);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tiip = 0;\n\t\t}\n\t\tpnode = scan_get_pnode(c, path + h, nnode, iip);\n\t\tif (IS_ERR(pnode)) {\n\t\t\terr = PTR_ERR(pnode);\n\t\t\tgoto out;\n\t\t}\n\t\tiip = 0;\n\t}\nout:\n\tkfree(path);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tg",
          "args": [
            "to ou"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err ="
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, path + h,",
          "args": [
            "n",
            "de, iip)",
            "if",
            "S_E"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "oto o"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, path + h,",
          "args": [
            "n",
            "de, iip)",
            "if",
            "IS_"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h >= 0);",
          "args": [
            "node ="
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s(c);\n\t\t\tif (e",
          "args": [
            "r"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nodes(c, (struct u",
          "args": [
            "i",
            "_cnode *)\n\t\t\t\t\t\t  c->nroot, 0, 0);\n\t\t\ti",
            "(",
            "r"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", pnode);",
          "args": [
            "->pno"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[h].pno",
          "args": [
            "e, sz, GFP_NOF",
            ";",
            "if (!p"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cat(c, lprops);",
          "args": [
            "lse {"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[h].nno",
          "args": [
            "e, sz, GFP_NOF",
            ";",
            "if (!n"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops, p",
          "args": [
            "t",
            "h].in_",
            "ee, data);\n\t\tif",
            "ret"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o out"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "rr ="
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, path + h,",
          "args": [
            "n",
            "de, iip)",
            "if (",
            "_ER"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tg",
          "args": [
            "to ou"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err ="
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, path + h,",
          "args": [
            "n",
            "de, iip)",
            "if",
            "S_E"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "lpt_scan_node) * (c->lpt_hght + 1),\n\t\t       GF",
            "f (!path"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "ode(c, NULL, 0);",
          "args": [
            "f (e",
            ")"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_lnum >=",
          "args": [
            "->main_first && end_lnum < c->leb_cnt);\n\n\tif (!c->"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_lnum >",
          "args": [
            "c->main_first && start_lnum < c->leb_cnt);\n\tubifs_ass"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_scan_nolock(struct ubifs_info *c, int start_lnum, int end_lnum,\n\t\t\t  ubifs_lpt_scan_callback scan_cb, void *data)\n{\n\tint err = 0, i, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\tstruct ubifs_pnode *pnode;\n\tstruct lpt_scan_node *path;\n\n\tif (start_lnum == -1) {\n\t\tstart_lnum = end_lnum + 1;\n\t\tif (start_lnum >= c->leb_cnt)\n\t\t\tstart_lnum = c->main_first;\n\t}\n\n\tubifs_assert(start_lnum >= c->main_first && start_lnum < c->leb_cnt);\n\tubifs_assert(end_lnum >= c->main_first && end_lnum < c->leb_cnt);\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpath = kmalloc(sizeof(struct lpt_scan_node) * (c->lpt_hght + 1),\n\t\t       GFP_NOFS);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath[0].ptr.nnode = c->nroot;\n\tpath[0].in_tree = 1;\nagain:\n\t/* Descend to the pnode containing start_lnum */\n\tnnode = c->nroot;\n\ti = start_lnum - c->main_first;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = scan_get_nnode(c, path + h, nnode, iip);\n\t\tif (IS_ERR(nnode)) {\n\t\t\terr = PTR_ERR(nnode);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\tpnode = scan_get_pnode(c, path + h, nnode, iip);\n\tif (IS_ERR(pnode)) {\n\t\terr = PTR_ERR(pnode);\n\t\tgoto out;\n\t}\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\n\t/* Loop for each lprops */\n\twhile (1) {\n\t\tstruct ubifs_lprops *lprops = &pnode->lprops[iip];\n\t\tint ret, lnum = lprops->lnum;\n\n\t\tret = scan_cb(c, lprops, path[h].in_tree, data);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret & LPT_SCAN_ADD) {\n\t\t\t/* Add all the nodes in path to the tree in memory */\n\t\t\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\t\t\tconst size_t sz = sizeof(struct ubifs_nnode);\n\t\t\t\tstruct ubifs_nnode *parent;\n\n\t\t\t\tif (path[h].in_tree)\n\t\t\t\t\tcontinue;\n\t\t\t\tnnode = kmemdup(&path[h].nnode, sz, GFP_NOFS);\n\t\t\t\tif (!nnode) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparent = nnode->parent;\n\t\t\t\tparent->nbranch[nnode->iip].nnode = nnode;\n\t\t\t\tpath[h].ptr.nnode = nnode;\n\t\t\t\tpath[h].in_tree = 1;\n\t\t\t\tpath[h + 1].cnode.parent = nnode;\n\t\t\t}\n\t\t\tif (path[h].in_tree)\n\t\t\t\tubifs_ensure_cat(c, lprops);\n\t\t\telse {\n\t\t\t\tconst size_t sz = sizeof(struct ubifs_pnode);\n\t\t\t\tstruct ubifs_nnode *parent;\n\n\t\t\t\tpnode = kmemdup(&path[h].pnode, sz, GFP_NOFS);\n\t\t\t\tif (!pnode) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparent = pnode->parent;\n\t\t\t\tparent->nbranch[pnode->iip].pnode = pnode;\n\t\t\t\tpath[h].ptr.pnode = pnode;\n\t\t\t\tpath[h].in_tree = 1;\n\t\t\t\tupdate_cats(c, pnode);\n\t\t\t\tc->pnodes_have += 1;\n\t\t\t}\n\t\t\terr = dbg_check_lpt_nodes(c, (struct ubifs_cnode *)\n\t\t\t\t\t\t  c->nroot, 0, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = dbg_check_cats(c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (ret & LPT_SCAN_STOP) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\t/* Get the next lprops */\n\t\tif (lnum == end_lnum) {\n\t\t\t/*\n\t\t\t * We got to the end without finding what we were\n\t\t\t * looking for\n\t\t\t */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t\tif (lnum + 1 >= c->leb_cnt) {\n\t\t\t/* Wrap-around to the beginning */\n\t\t\tstart_lnum = c->main_first;\n\t\t\tgoto again;\n\t\t}\n\t\tif (iip + 1 < UBIFS_LPT_FANOUT) {\n\t\t\t/* Next lprops is in the same pnode */\n\t\t\tiip += 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* We need to get the next pnode. Go up until we can go right */\n\t\tiip = pnode->iip;\n\t\twhile (1) {\n\t\t\th -= 1;\n\t\t\tubifs_assert(h >= 0);\n\t\t\tnnode = path[h].ptr.nnode;\n\t\t\tif (iip + 1 < UBIFS_LPT_FANOUT)\n\t\t\t\tbreak;\n\t\t\tiip = nnode->iip;\n\t\t}\n\t\t/* Go right */\n\t\tiip += 1;\n\t\t/* Descend to the pnode */\n\t\th += 1;\n\t\tfor (; h < c->lpt_hght; h++) {\n\t\t\tnnode = scan_get_nnode(c, path + h, nnode, iip);\n\t\t\tif (IS_ERR(nnode)) {\n\t\t\t\terr = PTR_ERR(nnode);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tiip = 0;\n\t\t}\n\t\tpnode = scan_get_pnode(c, path + h, nnode, iip);\n\t\tif (IS_ERR(pnode)) {\n\t\t\terr = PTR_ERR(pnode);\n\t\t\tgoto out;\n\t\t}\n\t\tiip = 0;\n\t}\nout:\n\tkfree(path);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "e(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1851-1908",
    "snippet": "ubifs_pnode *scan_get_pnode(struct ubifs_info *c,\n\t\t\t\t\t  struct lpt_scan_node *path,\n\t\t\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tpnode = branch->pnode;\n\tif (pnode) {\n\t\tpath->in_tree = 1;\n\t\tpath->ptr.pnode = pnode;\n\t\treturn pnode;\n\t}\n\tpnode = &path->pnode;\n\tpath->in_tree = 0;\n\tpath->ptr.pnode = pnode;\n\tmemset(pnode, 0, sizeof(struct ubifs_pnode));\n\tif (branch->lnum == 0) {\n\t\t/*\n\t\t * This pnode was not written which just means that the LEB\n\t\t * properties in it describe empty LEBs. We make the pnode as\n\t\t * though we had read it.\n\t\t */\n\t\tint i;\n\n\t\tif (c->big_lpt)\n\t\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\t\tlprops->free = c->leb_size;\n\t\t\tlprops->flags = ubifs_categorize_lprops(c, lprops);\n\t\t}\n\t} else {\n\t\tubifs_assert(branch->lnum >= c->lpt_first &&\n\t\t\t     branch->lnum <= c->lpt_last);\n\t\tubifs_assert(branch->offs >= 0 && branch->offs < c->leb_size);\n\t\terr = ubifs_leb_read(c, branch->lnum, buf, branch->offs,\n\t\t\t\t     c->pnode_sz, 1);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\terr = unpack_pnode(c, buf, pnode);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\terr = validate_pnode(c, pnode, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (!c->big_lpt)\n\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\tpnode->parent = parent;\n\tpnode->iip = iip;\n\tset_pnode_lnum(c, pnode);\n\treturn pnode;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m(c, pnode);",
          "args": [
            "e",
            "rn pn"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "pnod",
            ">pa"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (!",
          "args": [
            "->b"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, pnode, pa",
          "args": [
            "e",
            ", iip",
            "if (",
            "r)"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\ter",
          "args": [
            "="
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, buf, pnod",
          "args": [
            ")",
            "i",
            "(err)"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "un"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d(c, branch->l",
          "args": [
            "u",
            "buf, branch",
            "off",
            "c-",
            "1);\n\t\tif (e",
            ")"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "branch->offs",
          "args": [
            ">= 0 && branch->offs < c->leb_size);\n\t\terr = ub"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "branch->lnum",
          "args": [
            ">= c->lpt_first &&\n\t\t\t     branch->lnum <= c->lpt_last);\n\t\tubifs_as"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize_lprops(c, lprops);",
          "args": [
            "} els"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "for",
            "i ="
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, si",
          "args": [
            "eof(s",
            "u",
            "ubifs_pnode));\n\tif (branc"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nubifs_pnode *scan_get_pnode(struct ubifs_info *c,\n\t\t\t\t\t  struct lpt_scan_node *path,\n\t\t\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tpnode = branch->pnode;\n\tif (pnode) {\n\t\tpath->in_tree = 1;\n\t\tpath->ptr.pnode = pnode;\n\t\treturn pnode;\n\t}\n\tpnode = &path->pnode;\n\tpath->in_tree = 0;\n\tpath->ptr.pnode = pnode;\n\tmemset(pnode, 0, sizeof(struct ubifs_pnode));\n\tif (branch->lnum == 0) {\n\t\t/*\n\t\t * This pnode was not written which just means that the LEB\n\t\t * properties in it describe empty LEBs. We make the pnode as\n\t\t * though we had read it.\n\t\t */\n\t\tint i;\n\n\t\tif (c->big_lpt)\n\t\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\t\tlprops->free = c->leb_size;\n\t\t\tlprops->flags = ubifs_categorize_lprops(c, lprops);\n\t\t}\n\t} else {\n\t\tubifs_assert(branch->lnum >= c->lpt_first &&\n\t\t\t     branch->lnum <= c->lpt_last);\n\t\tubifs_assert(branch->offs >= 0 && branch->offs < c->leb_size);\n\t\terr = ubifs_leb_read(c, branch->lnum, buf, branch->offs,\n\t\t\t\t     c->pnode_sz, 1);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\terr = unpack_pnode(c, buf, pnode);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\terr = validate_pnode(c, pnode, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (!c->big_lpt)\n\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\tpnode->parent = parent;\n\tpnode->iip = iip;\n\tset_pnode_lnum(c, pnode);\n\treturn pnode;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "e(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1792-1839",
    "snippet": "ubifs_nnode *scan_get_nnode(struct ubifs_info *c,\n\t\t\t\t\t  struct lpt_scan_node *path,\n\t\t\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_nnode *nnode;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tnnode = branch->nnode;\n\tif (nnode) {\n\t\tpath->in_tree = 1;\n\t\tpath->ptr.nnode = nnode;\n\t\treturn nnode;\n\t}\n\tnnode = &path->nnode;\n\tpath->in_tree = 0;\n\tpath->ptr.nnode = nnode;\n\tmemset(nnode, 0, sizeof(struct ubifs_nnode));\n\tif (branch->lnum == 0) {\n\t\t/*\n\t\t * This nnode was not written which just means that the LEB\n\t\t * properties in the subtree below it describe empty LEBs. We\n\t\t * make the nnode as though we had read it, which in fact means\n\t\t * doing almost nothing.\n\t\t */\n\t\tif (c->big_lpt)\n\t\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\t} else {\n\t\terr = ubifs_leb_read(c, branch->lnum, buf, branch->offs,\n\t\t\t\t     c->nnode_sz, 1);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\terr = ubifs_unpack_nnode(c, buf, nnode);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\terr = validate_nnode(c, nnode, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (!c->big_lpt)\n\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\tnnode->level = parent->level - 1;\n\tnnode->parent = parent;\n\tnnode->iip = iip;\n\treturn nnode;\n}\n\n/**\n * scan",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "nnod",
            ">le"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (!",
          "args": [
            "->b"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, nnode, pa",
          "args": [
            "e",
            ", iip",
            "if (",
            "r)"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\ter",
          "args": [
            "="
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnode(c, buf, nnod",
          "args": [
            ")",
            "i",
            "(err)"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "ub"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d(c, branch->l",
          "args": [
            "u",
            "buf, branch",
            "off",
            "c-",
            "1);\n\t\tif (e",
            ")"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "} el",
            "{"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, si",
          "args": [
            "eof(s",
            "u",
            "ubifs_nnode));\n\tif (branc"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nubifs_nnode *scan_get_nnode(struct ubifs_info *c,\n\t\t\t\t\t  struct lpt_scan_node *path,\n\t\t\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_nnode *nnode;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tnnode = branch->nnode;\n\tif (nnode) {\n\t\tpath->in_tree = 1;\n\t\tpath->ptr.nnode = nnode;\n\t\treturn nnode;\n\t}\n\tnnode = &path->nnode;\n\tpath->in_tree = 0;\n\tpath->ptr.nnode = nnode;\n\tmemset(nnode, 0, sizeof(struct ubifs_nnode));\n\tif (branch->lnum == 0) {\n\t\t/*\n\t\t * This nnode was not written which just means that the LEB\n\t\t * properties in the subtree below it describe empty LEBs. We\n\t\t * make the nnode as though we had read it, which in fact means\n\t\t * doing almost nothing.\n\t\t */\n\t\tif (c->big_lpt)\n\t\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\t} else {\n\t\terr = ubifs_leb_read(c, branch->lnum, buf, branch->offs,\n\t\t\t\t     c->nnode_sz, 1);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\terr = ubifs_unpack_nnode(c, buf, nnode);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\terr = validate_nnode(c, nnode, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (!c->big_lpt)\n\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\tnnode->level = parent->level - 1;\n\tnnode->parent = parent;\n\tnnode->iip = iip;\n\treturn nnode;\n}\n\n/**\n * scan"
  },
  {
    "function_name": "t(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1731-1755",
    "snippet": "_init(struct ubifs_info *c, int rd, int wr)\n{\n\tint err;\n\n\tif (rd) {\n\t\terr = lpt_init_rd(c);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tif (wr) {\n\t\terr = lpt_init_wr(c);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tif (wr)\n\t\tubifs_lpt_free(c, 1);\n\tif (rd)\n\t\tubifs_lpt_free(c, 0);\n\treturn err;\n}\n\n/**\n * stru",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e(c, 0);\n\tretu",
          "args": [
            "n",
            "r"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, 1);\n\tif (",
          "args": [
            "d"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_init(struct ubifs_info *c, int rd, int wr)\n{\n\tint err;\n\n\tif (rd) {\n\t\terr = lpt_init_rd(c);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tif (wr) {\n\t\terr = lpt_init_wr(c);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tif (wr)\n\t\tubifs_lpt_free(c, 1);\n\tif (rd)\n\t\tubifs_lpt_free(c, 0);\n\treturn err;\n}\n\n/**\n * stru"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1688-1717",
    "snippet": "t_init_wr(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tc->ltab_cmt = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!c->ltab_cmt)\n\t\treturn -ENOMEM;\n\n\tc->lpt_buf = vmalloc(c->leb_size);\n\tif (!c->lpt_buf)\n\t\treturn -ENOMEM;\n\n\tif (c->big_lpt) {\n\t\tc->lsave = kmalloc(sizeof(int) * c->lsave_cnt, GFP_NOFS);\n\t\tif (!c->lsave)\n\t\t\treturn -ENOMEM;\n\t\terr = read_lsave(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\terr = ubifs_leb_unmap(c, i + c->lpt_first);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ap(c, i + c->lp",
          "args": [
            "_",
            "rst);\n\t\t\tif (err"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(int)",
          "args": [
            "c->lsave_cnt, GFP_NOFS);",
            "if (!c->"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_size)",
          "args": [
            "if (!c->l"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!c->l"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nt_init_wr(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tc->ltab_cmt = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!c->ltab_cmt)\n\t\treturn -ENOMEM;\n\n\tc->lpt_buf = vmalloc(c->leb_size);\n\tif (!c->lpt_buf)\n\t\treturn -ENOMEM;\n\n\tif (c->big_lpt) {\n\t\tc->lsave = kmalloc(sizeof(int) * c->lsave_cnt, GFP_NOFS);\n\t\tif (!c->lsave)\n\t\t\treturn -ENOMEM;\n\t\terr = read_lsave(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tif (c->ltab[i].free == c->leb_size) {\n\t\t\terr = ubifs_leb_unmap(c, i + c->lpt_first);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1626-1678",
    "snippet": "t_init_rd(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tc->ltab = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!c->ltab)\n\t\treturn -ENOMEM;\n\n\ti = max_t(int, c->nnode_sz, c->pnode_sz);\n\tc->lpt_nod_buf = kmalloc(i, GFP_KERNEL);\n\tif (!c->lpt_nod_buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LPROPS_HEAP_CNT; i++) {\n\t\tc->lpt_heap[i].arr = kmalloc(sizeof(void *) * LPT_HEAP_SZ,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!c->lpt_heap[i].arr)\n\t\t\treturn -ENOMEM;\n\t\tc->lpt_heap[i].cnt = 0;\n\t\tc->lpt_heap[i].max_cnt = LPT_HEAP_SZ;\n\t}\n\n\tc->dirty_idx.arr = kmalloc(sizeof(void *) * LPT_HEAP_SZ, GFP_KERNEL);\n\tif (!c->dirty_idx.arr)\n\t\treturn -ENOMEM;\n\tc->dirty_idx.cnt = 0;\n\tc->dirty_idx.max_cnt = LPT_HEAP_SZ;\n\n\terr = read_ltab(c);\n\tif (err)\n\t\treturn err;\n\n\tdbg_lp(\"space_bits %d\", c->space_bits);\n\tdbg_lp(\"lpt_lnum_bits %d\", c->lpt_lnum_bits);\n\tdbg_lp(\"lpt_offs_bits %d\", c->lpt_offs_bits);\n\tdbg_lp(\"lpt_spc_bits %d\", c->lpt_spc_bits);\n\tdbg_lp(\"pcnt_bits %d\", c->pcnt_bits);\n\tdbg_lp(\"lnum_bits %d\", c->lnum_bits);\n\tdbg_lp(\"pnode_sz %d\", c->pnode_sz);\n\tdbg_lp(\"nnode_sz %d\", c->nnode_sz);\n\tdbg_lp(\"ltab_sz %d\", c->ltab_sz);\n\tdbg_lp(\"lsave_sz %d\", c->lsave_sz);\n\tdbg_lp(\"lsave_cnt %d\", c->lsave_cnt);\n\tdbg_lp(\"lpt_hght %d\", c->lpt_hght);\n\tdbg_lp(\"big_lpt %d\", c->big_lpt);\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\n\n\treturn 0;\n}\n\n/**\n * lpt_",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save i",
          "args": [
            "at %d:%d\", c->lsave_ln",
            ", c->lsave_of",
            ");\n\n\treturn 0"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tab is",
          "args": [
            "at %d:%d\", c->ltab_lnu",
            "c->ltab_off",
            ";\n\tif (c->bi"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead is",
          "args": [
            "at %d:%d\", c->nhead_ln",
            ", c->nhead_of",
            ");\n\tdbg_lp(\"L"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oot is",
          "args": [
            "at %d:%d\", c->lpt_lnum",
            "c->lpt_offs",
            "dbg_lp(\"L"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt %d\"",
          "args": [
            "c->big_lpt)",
            "dbg_lp(\"L"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ght %d",
          "args": [
            ", c->lpt_hght",
            "dbg_lp(\"b"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cnt %",
          "args": [
            "\", c->lsave_cn",
            ";\n\tdbg_lp(\"l"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sz %d",
          "args": [
            ", c->lsave_sz",
            "dbg_lp(\"l"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sz %d\"",
          "args": [
            "c->ltab_sz)",
            "dbg_lp(\"l"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sz %d",
          "args": [
            ", c->nnode_sz",
            "dbg_lp(\"l"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sz %d",
          "args": [
            ", c->pnode_sz",
            "dbg_lp(\"n"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits %",
          "args": [
            "\", c->lnum_bit",
            ";\n\tdbg_lp(\"p"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits %",
          "args": [
            "\", c->pcnt_bit",
            ";\n\tdbg_lp(\"l"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_bit",
          "args": [
            "%d\", c->lpt_spc_",
            "ts);\n\tdbg_lp(\"p"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs_bi",
          "args": [
            "s %d\", c->lpt_offs",
            "its);\n\tdbg_lp(\"l"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_bi",
          "args": [
            "s %d\", c->lpt_lnum",
            "its);\n\tdbg_lp(\"l"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bits",
          "args": [
            "d\", c->space_bi",
            ");\n\tdbg_lp(\"l"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_window_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "52-65",
          "snippet": "static unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if (err",
          "args": [],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(void",
          "args": [
            ") * LPT_HEAP_SZ, GFP_KERNEL)",
            "if (!c->d"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(void",
          "args": [
            ") * LPT_HEAP_SZ,\n\t\t\t\t\t     G",
            "if (!c->"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_KERNE",
          "args": [
            ")",
            "if (!c->l"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">nnod",
          "args": [
            "_sz",
            "c->pnode_sz",
            "c->lpt_no"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!c->l"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nt_init_rd(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tc->ltab = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!c->ltab)\n\t\treturn -ENOMEM;\n\n\ti = max_t(int, c->nnode_sz, c->pnode_sz);\n\tc->lpt_nod_buf = kmalloc(i, GFP_KERNEL);\n\tif (!c->lpt_nod_buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LPROPS_HEAP_CNT; i++) {\n\t\tc->lpt_heap[i].arr = kmalloc(sizeof(void *) * LPT_HEAP_SZ,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!c->lpt_heap[i].arr)\n\t\t\treturn -ENOMEM;\n\t\tc->lpt_heap[i].cnt = 0;\n\t\tc->lpt_heap[i].max_cnt = LPT_HEAP_SZ;\n\t}\n\n\tc->dirty_idx.arr = kmalloc(sizeof(void *) * LPT_HEAP_SZ, GFP_KERNEL);\n\tif (!c->dirty_idx.arr)\n\t\treturn -ENOMEM;\n\tc->dirty_idx.cnt = 0;\n\tc->dirty_idx.max_cnt = LPT_HEAP_SZ;\n\n\terr = read_ltab(c);\n\tif (err)\n\t\treturn err;\n\n\tdbg_lp(\"space_bits %d\", c->space_bits);\n\tdbg_lp(\"lpt_lnum_bits %d\", c->lpt_lnum_bits);\n\tdbg_lp(\"lpt_offs_bits %d\", c->lpt_offs_bits);\n\tdbg_lp(\"lpt_spc_bits %d\", c->lpt_spc_bits);\n\tdbg_lp(\"pcnt_bits %d\", c->pcnt_bits);\n\tdbg_lp(\"lnum_bits %d\", c->lnum_bits);\n\tdbg_lp(\"pnode_sz %d\", c->pnode_sz);\n\tdbg_lp(\"nnode_sz %d\", c->nnode_sz);\n\tdbg_lp(\"ltab_sz %d\", c->ltab_sz);\n\tdbg_lp(\"lsave_sz %d\", c->lsave_sz);\n\tdbg_lp(\"lsave_cnt %d\", c->lsave_cnt);\n\tdbg_lp(\"lpt_hght %d\", c->lpt_hght);\n\tdbg_lp(\"big_lpt %d\", c->big_lpt);\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\n\n\treturn 0;\n}\n\n/**\n * lpt_"
  },
  {
    "function_name": "kup_dirty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1578-1618",
    "snippet": "lprops *ubifs_lpt_lookup_dirty(struct ubifs_info *c, int lnum)\n{\n\tint err, i, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\tstruct ubifs_pnode *pnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tnnode = c->nroot;\n\tnnode = dirty_cow_nnode(c, nnode);\n\tif (IS_ERR(nnode))\n\t\treturn ERR_CAST(nnode);\n\ti = lnum - c->main_first;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t\tnnode = dirty_cow_nnode(c, nnode);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\tpnode = ubifs_get_pnode(c, nnode, iip);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tpnode = dirty_cow_pnode(c, pnode);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\", lnum,\n\t       pnode->lprops[iip].free, pnode->lprops[iip].dirty,\n\t       pnode->lprops[iip].flags);\n\tubifs_assert(test_bit(DIRTY_CNODE, &pnode->flags));\n\treturn &pnode->lprops[iip];\n}\n\n/**\n * lpt_",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit(DIR",
          "args": [
            "Y_CNODE, &pnode->flags));\n\treturn &p"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Y_CNODE,",
          "args": [
            "&pnode->fla",
            "));\n\treturn &"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d, fre",
          "args": [
            "%d, dirty %d, flags %d\", lnum,",
            "pno",
            "[iip].free, pnode->lpro",
            "[iip].dirty,\n\t       pno",
            "[iip].flags);\n\tubifs_ass"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\tiip",
          "args": [
            "= (i"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn E"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, pnode);",
          "args": [
            "f",
            "IS_ER"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\tpno",
          "args": [
            "e = d"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn E"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "if (",
            "_ER"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\t}",
          "args": [
            "ip ="
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode);",
          "args": [
            "i",
            "(IS_E"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\t\tnn",
          "args": [
            "de ="
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "if",
            "S_E"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\ti =",
          "args": [
            "lnum"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn E"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode);",
          "args": [
            "f",
            "IS_ER"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\tnn",
          "args": [
            "de"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, NULL, 0);",
          "args": [
            "f (e",
            ")"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlprops *ubifs_lpt_lookup_dirty(struct ubifs_info *c, int lnum)\n{\n\tint err, i, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\tstruct ubifs_pnode *pnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tnnode = c->nroot;\n\tnnode = dirty_cow_nnode(c, nnode);\n\tif (IS_ERR(nnode))\n\t\treturn ERR_CAST(nnode);\n\ti = lnum - c->main_first;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t\tnnode = dirty_cow_nnode(c, nnode);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\tpnode = ubifs_get_pnode(c, nnode, iip);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tpnode = dirty_cow_pnode(c, pnode);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\", lnum,\n\t       pnode->lprops[iip].free, pnode->lprops[iip].dirty,\n\t       pnode->lprops[iip].flags);\n\tubifs_assert(test_bit(DIRTY_CNODE, &pnode->flags));\n\treturn &pnode->lprops[iip];\n}\n\n/**\n * lpt_"
  },
  {
    "function_name": "de(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1536-1568",
    "snippet": "ubifs_pnode *dirty_cow_pnode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_pnode *pnode)\n{\n\tstruct ubifs_pnode *p;\n\n\tif (!test_bit(COW_CNODE, &pnode->flags)) {\n\t\t/* pnode is not being committed */\n\t\tif (!test_and_set_bit(DIRTY_CNODE, &pnode->flags)) {\n\t\t\tc->dirty_pn_cnt += 1;\n\t\t\tadd_pnode_dirt(c, pnode);\n\t\t}\n\t\treturn pnode;\n\t}\n\n\t/* pnode is being committed, so copy it */\n\tp = kmalloc(sizeof(struct ubifs_pnode), GFP_NOFS);\n\tif (unlikely(!p))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(p, pnode, sizeof(struct ubifs_pnode));\n\tp->cnext = NULL;\n\t__set_bit(DIRTY_CNODE, &p->flags);\n\t__clear_bit(COW_CNODE, &p->flags);\n\treplace_cats(c, pnode, p);\n\n\tubifs_assert(!test_bit(OBSOLETE_CNODE, &pnode->flags));\n\t__set_bit(OBSOLETE_CNODE, &pnode->flags);\n\n\tc->dirty_pn_cnt += 1;\n\tadd_pnode_dirt(c, pnode);\n\tpnode->parent->nbranch[p->iip].pnode = p;\n\treturn p;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t(c, pnode);",
          "args": [
            "n",
            "e->pa"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OLETE_CNO",
          "args": [
            "E, &pnode->fla",
            ");\n\n\tc->dirty"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!test_bit(OB",
          "args": [
            "OLETE_CNODE, &pnode->flags));\n\t__set_bit"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LETE_CNO",
          "args": [
            "E, &pnode->fla",
            "));\n\t__set_bi"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, pnode, p)",
          "args": [
            "ubifs",
            "s"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OW_CNODE, &",
          "args": [
            "->flags);",
            "replace_c"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TY_CNODE,",
          "args": [
            "&p->flags);",
            "__clear_b"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de, si",
          "args": [
            "e",
            "(stru",
            "ubifs_pnode));\n\tp->cnext"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "emcpy(p"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "E"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_pnode), GFP_NOFS);",
            "f (unlik"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "t(c, pnode);",
          "args": [
            "}",
            "retu"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit(DIRTY_CNODE,",
          "args": [
            "&pnode->fla",
            ")) {\n\t\t\tc->di"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNODE, &",
          "args": [
            "node->fla",
            ")) {\n\t\t/* pno"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nubifs_pnode *dirty_cow_pnode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_pnode *pnode)\n{\n\tstruct ubifs_pnode *p;\n\n\tif (!test_bit(COW_CNODE, &pnode->flags)) {\n\t\t/* pnode is not being committed */\n\t\tif (!test_and_set_bit(DIRTY_CNODE, &pnode->flags)) {\n\t\t\tc->dirty_pn_cnt += 1;\n\t\t\tadd_pnode_dirt(c, pnode);\n\t\t}\n\t\treturn pnode;\n\t}\n\n\t/* pnode is being committed, so copy it */\n\tp = kmalloc(sizeof(struct ubifs_pnode), GFP_NOFS);\n\tif (unlikely(!p))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(p, pnode, sizeof(struct ubifs_pnode));\n\tp->cnext = NULL;\n\t__set_bit(DIRTY_CNODE, &p->flags);\n\t__clear_bit(COW_CNODE, &p->flags);\n\treplace_cats(c, pnode, p);\n\n\tubifs_assert(!test_bit(OBSOLETE_CNODE, &pnode->flags));\n\t__set_bit(OBSOLETE_CNODE, &pnode->flags);\n\n\tc->dirty_pn_cnt += 1;\n\tadd_pnode_dirt(c, pnode);\n\tpnode->parent->nbranch[p->iip].pnode = p;\n\treturn p;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "de(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1484-1527",
    "snippet": "ubifs_nnode *dirty_cow_nnode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_nnode *nnode)\n{\n\tstruct ubifs_nnode *n;\n\tint i;\n\n\tif (!test_bit(COW_CNODE, &nnode->flags)) {\n\t\t/* nnode is not being committed */\n\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\tc->dirty_nn_cnt += 1;\n\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t}\n\t\treturn nnode;\n\t}\n\n\t/* nnode is being committed, so copy it */\n\tn = kmalloc(sizeof(struct ubifs_nnode), GFP_NOFS);\n\tif (unlikely(!n))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(n, nnode, sizeof(struct ubifs_nnode));\n\tn->cnext = NULL;\n\t__set_bit(DIRTY_CNODE, &n->flags);\n\t__clear_bit(COW_CNODE, &n->flags);\n\n\t/* The children now have new parent */\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_nbranch *branch = &n->nbranch[i];\n\n\t\tif (branch->cnode)\n\t\t\tbranch->cnode->parent = n;\n\t}\n\n\tubifs_assert(!test_bit(OBSOLETE_CNODE, &nnode->flags));\n\t__set_bit(OBSOLETE_CNODE, &nnode->flags);\n\n\tc->dirty_nn_cnt += 1;\n\tubifs_add_nnode_dirt(c, nnode);\n\tif (nnode->parent)\n\t\tnnode->parent->nbranch[n->iip].nnode = n;\n\telse\n\t\tc->nroot = n;\n\treturn n;\n}\n\n/**\n * dirt",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de_dirt(c, nnode);",
          "args": [
            "f",
            "nnode"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OLETE_CNO",
          "args": [
            "E, &nnode->fla",
            ");\n\n\tc->dirty"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!test_bit(OB",
          "args": [
            "OLETE_CNODE, &nnode->flags));\n\t__set_bit"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LETE_CNO",
          "args": [
            "E, &nnode->fla",
            "));\n\t__set_bi"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OW_CNODE, &",
          "args": [
            "->flags);",
            "/* The c"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TY_CNODE,",
          "args": [
            "&n->flags);",
            "__clear_b"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de, si",
          "args": [
            "e",
            "(stru",
            "ubifs_nnode));\n\tn->cnext"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "emcpy(n"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "E"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_nnode), GFP_NOFS);",
            "f (unlik"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "de_dirt(c, nnode);",
          "args": [
            "}",
            "retu"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit(DIRTY_CNODE,",
          "args": [
            "&nnode->fla",
            ")) {\n\t\t\tc->di"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNODE, &",
          "args": [
            "node->fla",
            ")) {\n\t\t/* nno"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nubifs_nnode *dirty_cow_nnode(struct ubifs_info *c,\n\t\t\t\t\t   struct ubifs_nnode *nnode)\n{\n\tstruct ubifs_nnode *n;\n\tint i;\n\n\tif (!test_bit(COW_CNODE, &nnode->flags)) {\n\t\t/* nnode is not being committed */\n\t\tif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\n\t\t\tc->dirty_nn_cnt += 1;\n\t\t\tubifs_add_nnode_dirt(c, nnode);\n\t\t}\n\t\treturn nnode;\n\t}\n\n\t/* nnode is being committed, so copy it */\n\tn = kmalloc(sizeof(struct ubifs_nnode), GFP_NOFS);\n\tif (unlikely(!n))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(n, nnode, sizeof(struct ubifs_nnode));\n\tn->cnext = NULL;\n\t__set_bit(DIRTY_CNODE, &n->flags);\n\t__clear_bit(COW_CNODE, &n->flags);\n\n\t/* The children now have new parent */\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_nbranch *branch = &n->nbranch[i];\n\n\t\tif (branch->cnode)\n\t\t\tbranch->cnode->parent = n;\n\t}\n\n\tubifs_assert(!test_bit(OBSOLETE_CNODE, &nnode->flags));\n\t__set_bit(OBSOLETE_CNODE, &nnode->flags);\n\n\tc->dirty_nn_cnt += 1;\n\tubifs_add_nnode_dirt(c, nnode);\n\tif (nnode->parent)\n\t\tnnode->parent->nbranch[n->iip].nnode = n;\n\telse\n\t\tc->nroot = n;\n\treturn n;\n}\n\n/**\n * dirt"
  },
  {
    "function_name": "kup(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1445-1475",
    "snippet": "lprops *ubifs_lpt_lookup(struct ubifs_info *c, int lnum)\n{\n\tint err, i, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\tstruct ubifs_pnode *pnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tnnode = c->nroot;\n\ti = lnum - c->main_first;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\tpnode = ubifs_get_pnode(c, nnode, iip);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\", lnum,\n\t       pnode->lprops[iip].free, pnode->lprops[iip].dirty,\n\t       pnode->lprops[iip].flags);\n\treturn &pnode->lprops[iip];\n}\n\n/**\n * dirt",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d, fre",
          "args": [
            "%d, dirty %d, flags %d\", lnum,",
            "pno",
            "[iip].free, pnode->lpro",
            "[iip].dirty,\n\t       pno",
            "[iip].flags);\n\treturn &p"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\tiip",
          "args": [
            "= (i"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tre",
          "args": [
            "urn E"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "if (",
            "_ER"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\t}",
          "args": [
            "ip ="
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, nnode, ii",
          "args": [
            ")",
            "if",
            "S_E"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\tnn",
          "args": [
            "de"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, NULL, 0);",
          "args": [
            "f (e",
            ")"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlprops *ubifs_lpt_lookup(struct ubifs_info *c, int lnum)\n{\n\tint err, i, h, iip, shft;\n\tstruct ubifs_nnode *nnode;\n\tstruct ubifs_pnode *pnode;\n\n\tif (!c->nroot) {\n\t\terr = ubifs_read_nnode(c, NULL, 0);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tnnode = c->nroot;\n\ti = lnum - c->main_first;\n\tshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\n\tfor (h = 1; h < c->lpt_hght; h++) {\n\t\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\t\tshft -= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnnode = ubifs_get_nnode(c, nnode, iip);\n\t\tif (IS_ERR(nnode))\n\t\t\treturn ERR_CAST(nnode);\n\t}\n\tiip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\n\tpnode = ubifs_get_pnode(c, nnode, iip);\n\tif (IS_ERR(pnode))\n\t\treturn ERR_CAST(pnode);\n\tiip = (i & (UBIFS_LPT_FANOUT - 1));\n\tdbg_lp(\"LEB %d, free %d, dirty %d, flags %d\", lnum,\n\t       pnode->lprops[iip].free, pnode->lprops[iip].dirty,\n\t       pnode->lprops[iip].flags);\n\treturn &pnode->lprops[iip];\n}\n\n/**\n * dirt"
  },
  {
    "function_name": "de(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1419-1435",
    "snippet": "pnode *ubifs_get_pnode(struct ubifs_info *c,\n\t\t\t\t    struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tpnode = branch->pnode;\n\tif (pnode)\n\t\treturn pnode;\n\terr = read_pnode(c, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tupdate_cats(c, branch->pnode);\n\treturn branch->pnode;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ", branch->p",
          "args": [
            "o",
            ");\n\treturn br"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "updat",
          "args": [
            "_ca"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent, i",
          "args": [
            "p",
            "if (",
            "r)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\npnode *ubifs_get_pnode(struct ubifs_info *c,\n\t\t\t\t    struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tpnode = branch->pnode;\n\tif (pnode)\n\t\treturn pnode;\n\terr = read_pnode(c, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tupdate_cats(c, branch->pnode);\n\treturn branch->pnode;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "de(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1393-1408",
    "snippet": "nnode *ubifs_get_nnode(struct ubifs_info *c,\n\t\t\t\t    struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_nnode *nnode;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tnnode = branch->nnode;\n\tif (nnode)\n\t\treturn nnode;\n\terr = ubifs_read_nnode(c, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn branch->nnode;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "br"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ode(c, parent, i",
          "args": [
            "p",
            "if (",
            "r)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nnnode *ubifs_get_nnode(struct ubifs_info *c,\n\t\t\t\t    struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_nnode *nnode;\n\tint err;\n\n\tbranch = &parent->nbranch[iip];\n\tnnode = branch->nnode;\n\tif (nnode)\n\t\treturn nnode;\n\terr = ubifs_read_nnode(c, parent, iip);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn branch->nnode;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1348-1382",
    "snippet": "ad_lsave(struct ubifs_info *c)\n{\n\tint err, i;\n\tvoid *buf;\n\n\tbuf = vmalloc(c->lsave_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = ubifs_leb_read(c, c->lsave_lnum, buf, c->lsave_offs,\n\t\t\t     c->lsave_sz, 1);\n\tif (err)\n\t\tgoto out;\n\terr = unpack_lsave(c, buf);\n\tif (err)\n\t\tgoto out;\n\tfor (i = 0; i < c->lsave_cnt; i++) {\n\t\tint lnum = c->lsave[i];\n\t\tstruct ubifs_lprops *lprops;\n\n\t\t/*\n\t\t * Due to automatic resizing, the values in the lsave table\n\t\t * could be beyond the volume size - just ignore them.\n\t\t */\n\t\tif (lnum >= c->leb_cnt)\n\t\t\tcontinue;\n\t\tlprops = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lprops)) {\n\t\t\terr = PTR_ERR(lprops);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "s);",
          "args": [
            "oto ou"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, lnum);",
          "args": [
            "f",
            "IS_E"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, buf);\n\tif",
          "args": [
            "(",
            "r)"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, c->lsave_",
          "args": [
            "n",
            ", buf, c->lsa",
            "_of",
            ",\n\t\t\t     c->",
            "1);\n\tif (er"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave_sz)",
          "args": [
            "if (!buf)"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nad_lsave(struct ubifs_info *c)\n{\n\tint err, i;\n\tvoid *buf;\n\n\tbuf = vmalloc(c->lsave_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = ubifs_leb_read(c, c->lsave_lnum, buf, c->lsave_offs,\n\t\t\t     c->lsave_sz, 1);\n\tif (err)\n\t\tgoto out;\n\terr = unpack_lsave(c, buf);\n\tif (err)\n\t\tgoto out;\n\tfor (i = 0; i < c->lsave_cnt; i++) {\n\t\tint lnum = c->lsave[i];\n\t\tstruct ubifs_lprops *lprops;\n\n\t\t/*\n\t\t * Due to automatic resizing, the values in the lsave table\n\t\t * could be beyond the volume size - just ignore them.\n\t\t */\n\t\tif (lnum >= c->leb_cnt)\n\t\t\tcontinue;\n\t\tlprops = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lprops)) {\n\t\t\terr = PTR_ERR(lprops);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "uct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1325-1340",
    "snippet": "ad_ltab(struct ubifs_info *c)\n{\n\tint err;\n\tvoid *buf;\n\n\tbuf = vmalloc(c->ltab_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = ubifs_leb_read(c, c->ltab_lnum, buf, c->ltab_offs, c->ltab_sz, 1);\n\tif (err)\n\t\tgoto out;\n\terr = unpack_ltab(c, buf);\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * read",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": ", buf);\nout",
          "args": [
            "fre"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, c->ltab_l",
          "args": [
            "u",
            "buf, c->lta",
            "off",
            "c->ltab_sz,",
            ");\n\tif (er"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ab_sz);",
          "args": [
            "if (!buf)"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nad_ltab(struct ubifs_info *c)\n{\n\tint err;\n\tvoid *buf;\n\n\tbuf = vmalloc(c->ltab_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = ubifs_leb_read(c, c->ltab_lnum, buf, c->ltab_offs, c->ltab_sz, 1);\n\tif (err)\n\t\tgoto out;\n\terr = unpack_ltab(c, buf);\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * read"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1260-1317",
    "snippet": "ad_pnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode = NULL;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err, lnum, offs;\n\n\tbranch = &parent->nbranch[iip];\n\tlnum = branch->lnum;\n\toffs = branch->offs;\n\tpnode = kzalloc(sizeof(struct ubifs_pnode), GFP_NOFS);\n\tif (!pnode)\n\t\treturn -ENOMEM;\n\n\tif (lnum == 0) {\n\t\t/*\n\t\t * This pnode was not written which just means that the LEB\n\t\t * properties in it describe empty LEBs. We make the pnode as\n\t\t * though we had read it.\n\t\t */\n\t\tint i;\n\n\t\tif (c->big_lpt)\n\t\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\t\tlprops->free = c->leb_size;\n\t\t\tlprops->flags = ubifs_categorize_lprops(c, lprops);\n\t\t}\n\t} else {\n\t\terr = ubifs_leb_read(c, lnum, buf, offs, c->pnode_sz, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = unpack_pnode(c, buf, pnode);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = validate_pnode(c, pnode, parent, iip);\n\tif (err)\n\t\tgoto out;\n\tif (!c->big_lpt)\n\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\tbranch->pnode = pnode;\n\tpnode->parent = parent;\n\tpnode->iip = iip;\n\tset_pnode_lnum(c, pnode);\n\tc->pnodes_have += 1;\n\treturn 0;\n\nout:\n\tubifs_err(\"error %d reading pnode at %d:%d\", err, lnum, offs);\n\tubifs_dump_pnode(c, pnode, parent, iip);\n\tdump_stack();\n\tubifs_err(\"calc num: %d\", calc_pnode_num_from_parent(c, parent, iip));\n\tkfree(pnode);\n\treturn err;\n}\n\n/**\n * read",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn er"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lc num: %",
          "args": [
            "\", calc_pnode_",
            "m_from_parent(c, parent, iip));\n\tkfree(pno"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            ";\n\tkfr",
            "(pn"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_er",
          "args": [],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, pnode, pa",
          "args": [
            "e",
            ", iip",
            "dump",
            "tac"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d re",
          "args": [
            "ding pnode at %d:%d\", err, lnum,",
            "fs)",
            "ubi",
            "_dum"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m(c, pnode);",
          "args": [
            "-",
            "nodes"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "bran",
            "->p"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, pnode, pa",
          "args": [
            "e",
            ", iip",
            "if (",
            "r)"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, buf, pnod",
          "args": [
            ")",
            "i",
            "(err)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "fs,",
            ">pn",
            "e_sz",
            "1);\n\t\tif (e",
            ")"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize_lprops(c, lprops);",
          "args": [
            "} els"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "for",
            "i ="
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_pnode), GFP_NOFS);",
            "f (!pnod"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nad_pnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch;\n\tstruct ubifs_pnode *pnode = NULL;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err, lnum, offs;\n\n\tbranch = &parent->nbranch[iip];\n\tlnum = branch->lnum;\n\toffs = branch->offs;\n\tpnode = kzalloc(sizeof(struct ubifs_pnode), GFP_NOFS);\n\tif (!pnode)\n\t\treturn -ENOMEM;\n\n\tif (lnum == 0) {\n\t\t/*\n\t\t * This pnode was not written which just means that the LEB\n\t\t * properties in it describe empty LEBs. We make the pnode as\n\t\t * though we had read it.\n\t\t */\n\t\tint i;\n\n\t\tif (c->big_lpt)\n\t\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\t\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\t\tlprops->free = c->leb_size;\n\t\t\tlprops->flags = ubifs_categorize_lprops(c, lprops);\n\t\t}\n\t} else {\n\t\terr = ubifs_leb_read(c, lnum, buf, offs, c->pnode_sz, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = unpack_pnode(c, buf, pnode);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = validate_pnode(c, pnode, parent, iip);\n\tif (err)\n\t\tgoto out;\n\tif (!c->big_lpt)\n\t\tpnode->num = calc_pnode_num_from_parent(c, parent, iip);\n\tbranch->pnode = pnode;\n\tpnode->parent = parent;\n\tpnode->iip = iip;\n\tset_pnode_lnum(c, pnode);\n\tc->pnodes_have += 1;\n\treturn 0;\n\nout:\n\tubifs_err(\"error %d reading pnode at %d:%d\", err, lnum, offs);\n\tubifs_dump_pnode(c, pnode, parent, iip);\n\tdump_stack();\n\tubifs_err(\"calc num: %d\", calc_pnode_num_from_parent(c, parent, iip));\n\tkfree(pnode);\n\treturn err;\n}\n\n/**\n * read"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1192-1250",
    "snippet": "d_nnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch = NULL;\n\tstruct ubifs_nnode *nnode = NULL;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err, lnum, offs;\n\n\tif (parent) {\n\t\tbranch = &parent->nbranch[iip];\n\t\tlnum = branch->lnum;\n\t\toffs = branch->offs;\n\t} else {\n\t\tlnum = c->lpt_lnum;\n\t\toffs = c->lpt_offs;\n\t}\n\tnnode = kzalloc(sizeof(struct ubifs_nnode), GFP_NOFS);\n\tif (!nnode) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (lnum == 0) {\n\t\t/*\n\t\t * This nnode was not written which just means that the LEB\n\t\t * properties in the subtree below it describe empty LEBs. We\n\t\t * make the nnode as though we had read it, which in fact means\n\t\t * doing almost nothing.\n\t\t */\n\t\tif (c->big_lpt)\n\t\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\t} else {\n\t\terr = ubifs_leb_read(c, lnum, buf, offs, c->nnode_sz, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_unpack_nnode(c, buf, nnode);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = validate_nnode(c, nnode, parent, iip);\n\tif (err)\n\t\tgoto out;\n\tif (!c->big_lpt)\n\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\tif (parent) {\n\t\tbranch->nnode = nnode;\n\t\tnnode->level = parent->level - 1;\n\t} else {\n\t\tc->nroot = nnode;\n\t\tnnode->level = c->lpt_hght;\n\t}\n\tnnode->parent = parent;\n\tnnode->iip = iip;\n\treturn 0;\n\nout:\n\tubifs_err(\"error %d reading nnode at %d:%d\", err, lnum, offs);\n\tdump_stack();\n\tkfree(nnode);\n\treturn err;\n}\n\n/**\n * read",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn er"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree(nn",
          "args": [],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d re",
          "args": [
            "ding nnode at %d:%d\", err, lnum,",
            "fs)",
            "dum",
            "stac"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "if (",
            "ren"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, nnode, pa",
          "args": [
            "e",
            ", iip",
            "if (",
            "r)"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnode(c, buf, nnod",
          "args": [
            ")",
            "i",
            "(err)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "fs,",
            ">nn",
            "e_sz",
            "1);\n\t\tif (e",
            ")"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "} el",
            "{"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_nnode), GFP_NOFS);",
            "f (!nnod"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nd_nnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)\n{\n\tstruct ubifs_nbranch *branch = NULL;\n\tstruct ubifs_nnode *nnode = NULL;\n\tvoid *buf = c->lpt_nod_buf;\n\tint err, lnum, offs;\n\n\tif (parent) {\n\t\tbranch = &parent->nbranch[iip];\n\t\tlnum = branch->lnum;\n\t\toffs = branch->offs;\n\t} else {\n\t\tlnum = c->lpt_lnum;\n\t\toffs = c->lpt_offs;\n\t}\n\tnnode = kzalloc(sizeof(struct ubifs_nnode), GFP_NOFS);\n\tif (!nnode) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (lnum == 0) {\n\t\t/*\n\t\t * This nnode was not written which just means that the LEB\n\t\t * properties in the subtree below it describe empty LEBs. We\n\t\t * make the nnode as though we had read it, which in fact means\n\t\t * doing almost nothing.\n\t\t */\n\t\tif (c->big_lpt)\n\t\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\t} else {\n\t\terr = ubifs_leb_read(c, lnum, buf, offs, c->nnode_sz, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = ubifs_unpack_nnode(c, buf, nnode);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = validate_nnode(c, nnode, parent, iip);\n\tif (err)\n\t\tgoto out;\n\tif (!c->big_lpt)\n\t\tnnode->num = calc_nnode_num_from_parent(c, parent, iip);\n\tif (parent) {\n\t\tbranch->nnode = nnode;\n\t\tnnode->level = parent->level - 1;\n\t} else {\n\t\tc->nroot = nnode;\n\t\tnnode->level = c->lpt_hght;\n\t}\n\tnnode->parent = parent;\n\tnnode->iip = iip;\n\treturn 0;\n\nout:\n\tubifs_err(\"error %d reading nnode at %d:%d\", err, lnum, offs);\n\tdump_stack();\n\tkfree(nnode);\n\treturn err;\n}\n\n/**\n * read"
  },
  {
    "function_name": "m(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1171-1182",
    "snippet": "et_pnode_lnum(const struct ubifs_info *c,\n\t\t\t   struct ubifs_pnode *pnode)\n{\n\tint i, lnum;\n\n\tlnum = (pnode->num << UBIFS_LPT_FANOUT_SHIFT) + c->main_first;\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tif (lnum >= c->leb_cnt)\n\t\t\treturn;\n\t\tpnode->lprops[i].lnum = lnum++;\n\t}\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\net_pnode_lnum(const struct ubifs_info *c,\n\t\t\t   struct ubifs_pnode *pnode)\n{\n\tint i, lnum;\n\n\tlnum = (pnode->num << UBIFS_LPT_FANOUT_SHIFT) + c->main_first;\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tif (lnum >= c->leb_cnt)\n\t\t\treturn;\n\t\tpnode->lprops[i].lnum = lnum++;\n\t}\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "e(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1137-1161",
    "snippet": "lidate_pnode(const struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tint i;\n\n\tif (c->big_lpt) {\n\t\tint num = calc_pnode_num_from_parent(c, parent, iip);\n\n\t\tif (pnode->num != num)\n\t\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint free = pnode->lprops[i].free;\n\t\tint dirty = pnode->lprops[i].dirty;\n\n\t\tif (free < 0 || free > c->leb_size || free % c->min_io_size ||\n\t\t    (free & 7))\n\t\t\treturn -EINVAL;\n\t\tif (dirty < 0 || dirty > c->leb_size || (dirty & 7))\n\t\t\treturn -EINVAL;\n\t\tif (dirty + free > c->leb_size)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * set_",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "if",
            "pno"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlidate_pnode(const struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tint i;\n\n\tif (c->big_lpt) {\n\t\tint num = calc_pnode_num_from_parent(c, parent, iip);\n\n\t\tif (pnode->num != num)\n\t\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint free = pnode->lprops[i].free;\n\t\tint dirty = pnode->lprops[i].dirty;\n\n\t\tif (free < 0 || free > c->leb_size || free % c->min_io_size ||\n\t\t    (free & 7))\n\t\t\treturn -EINVAL;\n\t\tif (dirty < 0 || dirty > c->leb_size || (dirty & 7))\n\t\t\treturn -EINVAL;\n\t\tif (dirty + free > c->leb_size)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * set_"
  },
  {
    "function_name": "e(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1093-1126",
    "snippet": "lidate_nnode(const struct ubifs_info *c, struct ubifs_nnode *nnode,\n\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tint i, lvl, max_offs;\n\n\tif (c->big_lpt) {\n\t\tint num = calc_nnode_num_from_parent(c, parent, iip);\n\n\t\tif (nnode->num != num)\n\t\t\treturn -EINVAL;\n\t}\n\tlvl = parent ? parent->level - 1 : c->lpt_hght;\n\tif (lvl < 1)\n\t\treturn -EINVAL;\n\tif (lvl == 1)\n\t\tmax_offs = c->leb_size - c->pnode_sz;\n\telse\n\t\tmax_offs = c->leb_size - c->nnode_sz;\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum = nnode->nbranch[i].lnum;\n\t\tint offs = nnode->nbranch[i].offs;\n\n\t\tif (lnum == 0) {\n\t\t\tif (offs != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (lnum < c->lpt_first || lnum > c->lpt_last)\n\t\t\treturn -EINVAL;\n\t\tif (offs < 0 || offs > max_offs)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * vali",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_from_parent(c, parent, i",
          "args": [
            "p",
            "if",
            "nno"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlidate_nnode(const struct ubifs_info *c, struct ubifs_nnode *nnode,\n\t\t\t  struct ubifs_nnode *parent, int iip)\n{\n\tint i, lvl, max_offs;\n\n\tif (c->big_lpt) {\n\t\tint num = calc_nnode_num_from_parent(c, parent, iip);\n\n\t\tif (nnode->num != num)\n\t\t\treturn -EINVAL;\n\t}\n\tlvl = parent ? parent->level - 1 : c->lpt_hght;\n\tif (lvl < 1)\n\t\treturn -EINVAL;\n\tif (lvl == 1)\n\t\tmax_offs = c->leb_size - c->pnode_sz;\n\telse\n\t\tmax_offs = c->leb_size - c->nnode_sz;\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum = nnode->nbranch[i].lnum;\n\t\tint offs = nnode->nbranch[i].offs;\n\n\t\tif (lnum == 0) {\n\t\t\tif (offs != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (lnum < c->lpt_first || lnum > c->lpt_last)\n\t\t\treturn -EINVAL;\n\t\tif (offs < 0 || offs > max_offs)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * vali"
  },
  {
    "function_name": "const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1065-1082",
    "snippet": "pack_lsave(const struct ubifs_info *c, void *buf)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(&addr, &pos, UBIFS_LPT_LSAVE);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < c->lsave_cnt; i++) {\n\t\tint lnum = ubifs_unpack_bits(&addr, &pos, c->lnum_bits);\n\n\t\tif (lnum < c->main_first || lnum >= c->leb_cnt)\n\t\t\treturn -EINVAL;\n\t\tc->lsave[i] = lnum;\n\t}\n\terr = check_lpt_crc(buf, c->lsave_sz);\n\treturn err;\n}\n\n/**\n * vali",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(buf, c->lsav",
          "args": [
            "_sz",
            "return er"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->ln",
            "_bit",
            ";\n\n\t\tif (lnu"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(&addr, &pos,",
          "args": [
            "UBIFS",
            "PT_L",
            "VE);\n\tif (err)"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\npack_lsave(const struct ubifs_info *c, void *buf)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(&addr, &pos, UBIFS_LPT_LSAVE);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < c->lsave_cnt; i++) {\n\t\tint lnum = ubifs_unpack_bits(&addr, &pos, c->lnum_bits);\n\n\t\tif (lnum < c->main_first || lnum >= c->leb_cnt)\n\t\t\treturn -EINVAL;\n\t\tc->lsave[i] = lnum;\n\t}\n\terr = check_lpt_crc(buf, c->lsave_sz);\n\treturn err;\n}\n\n/**\n * vali"
  },
  {
    "function_name": "onst struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1033-1056",
    "snippet": "pack_ltab(const struct ubifs_info *c, void *buf)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(&addr, &pos, UBIFS_LPT_LTAB);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tint free = ubifs_unpack_bits(&addr, &pos, c->lpt_spc_bits);\n\t\tint dirty = ubifs_unpack_bits(&addr, &pos, c->lpt_spc_bits);\n\n\t\tif (free < 0 || free > c->leb_size || dirty < 0 ||\n\t\t    dirty > c->leb_size || free + dirty > c->leb_size)\n\t\t\treturn -EINVAL;\n\n\t\tc->ltab[i].free = free;\n\t\tc->ltab[i].dirty = dirty;\n\t\tc->ltab[i].tgc = 0;\n\t\tc->ltab[i].cmt = 0;\n\t}\n\terr = check_lpt_crc(buf, c->ltab_sz);\n\treturn err;\n}\n\n/**\n * unpa",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(buf, c->ltab",
          "args": [
            "sz)",
            "return er"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->lp",
            "spc_",
            "ts);\n\n\t\tif (fre"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->lp",
            "spc_",
            "ts);\n\t\tint dirt"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(&addr, &pos,",
          "args": [
            "UBIFS",
            "PT_L",
            "B);\n\tif (err)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\npack_ltab(const struct ubifs_info *c, void *buf)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(&addr, &pos, UBIFS_LPT_LTAB);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tint free = ubifs_unpack_bits(&addr, &pos, c->lpt_spc_bits);\n\t\tint dirty = ubifs_unpack_bits(&addr, &pos, c->lpt_spc_bits);\n\n\t\tif (free < 0 || free > c->leb_size || dirty < 0 ||\n\t\t    dirty > c->leb_size || free + dirty > c->leb_size)\n\t\t\treturn -EINVAL;\n\n\t\tc->ltab[i].free = free;\n\t\tc->ltab[i].dirty = dirty;\n\t\tc->ltab[i].tgc = 0;\n\t\tc->ltab[i].cmt = 0;\n\t}\n\terr = check_lpt_crc(buf, c->ltab_sz);\n\treturn err;\n}\n\n/**\n * unpa"
  },
  {
    "function_name": "nnode(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "1000-1024",
    "snippet": "ack_nnode(const struct ubifs_info *c, void *buf,\n\t\t       struct ubifs_nnode *nnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(&addr, &pos, UBIFS_LPT_NNODE);\n\tif (err)\n\t\treturn err;\n\tif (c->big_lpt)\n\t\tnnode->num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum;\n\n\t\tlnum = ubifs_unpack_bits(&addr, &pos, c->lpt_lnum_bits) +\n\t\t       c->lpt_first;\n\t\tif (lnum == c->lpt_last + 1)\n\t\t\tlnum = 0;\n\t\tnnode->nbranch[i].lnum = lnum;\n\t\tnnode->nbranch[i].offs = ubifs_unpack_bits(&addr, &pos,\n\t\t\t\t\t\t     c->lpt_offs_bits);\n\t}\n\terr = check_lpt_crc(buf, c->nnode_sz);\n\treturn err;\n}\n\n/**\n * unpa",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(buf, c->nnod",
          "args": [
            "_sz",
            "return er"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "its);\n\t}\n\terr ="
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->lp",
            "lnum",
            "its) +"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->pc",
            "_bit",
            ";\n\tfor (i ="
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(&addr, &pos,",
          "args": [
            "UBIFS",
            "PT_N",
            "DE);\n\tif (err)"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nack_nnode(const struct ubifs_info *c, void *buf,\n\t\t       struct ubifs_nnode *nnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(&addr, &pos, UBIFS_LPT_NNODE);\n\tif (err)\n\t\treturn err;\n\tif (c->big_lpt)\n\t\tnnode->num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum;\n\n\t\tlnum = ubifs_unpack_bits(&addr, &pos, c->lpt_lnum_bits) +\n\t\t       c->lpt_first;\n\t\tif (lnum == c->lpt_last + 1)\n\t\t\tlnum = 0;\n\t\tnnode->nbranch[i].lnum = lnum;\n\t\tnnode->nbranch[i].offs = ubifs_unpack_bits(&addr, &pos,\n\t\t\t\t\t\t     c->lpt_offs_bits);\n\t}\n\terr = check_lpt_crc(buf, c->nnode_sz);\n\treturn err;\n}\n\n/**\n * unpa"
  },
  {
    "function_name": "const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "963-990",
    "snippet": "pack_pnode(const struct ubifs_info *c, void *buf,\n\t\t\tstruct ubifs_pnode *pnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(&addr, &pos, UBIFS_LPT_PNODE);\n\tif (err)\n\t\treturn err;\n\tif (c->big_lpt)\n\t\tpnode->num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\tlprops->free = ubifs_unpack_bits(&addr, &pos, c->space_bits);\n\t\tlprops->free <<= 3;\n\t\tlprops->dirty = ubifs_unpack_bits(&addr, &pos, c->space_bits);\n\t\tlprops->dirty <<= 3;\n\n\t\tif (ubifs_unpack_bits(&addr, &pos, 1))\n\t\t\tlprops->flags = LPROPS_INDEX;\n\t\telse\n\t\t\tlprops->flags = 0;\n\t\tlprops->flags |= ubifs_categorize_lprops(c, lprops);\n\t}\n\terr = check_lpt_crc(buf, c->pnode_sz);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(buf, c->pnod",
          "args": [
            "_sz",
            "return er"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize_lprops(c, lprops);",
          "args": [
            "}",
            "err ="
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "1))",
            "lpro",
            "-"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->sp",
            "e_bi",
            ");\n\t\tlprops->"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->sp",
            "e_bi",
            ");\n\t\tlprops->"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "c->pc",
            "_bit",
            ";\n\tfor (i ="
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(&addr, &pos,",
          "args": [
            "UBIFS",
            "PT_P",
            "DE);\n\tif (err)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\npack_pnode(const struct ubifs_info *c, void *buf,\n\t\t\tstruct ubifs_pnode *pnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0, err;\n\n\terr = check_lpt_type(&addr, &pos, UBIFS_LPT_PNODE);\n\tif (err)\n\t\treturn err;\n\tif (c->big_lpt)\n\t\tpnode->num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops * const lprops = &pnode->lprops[i];\n\n\t\tlprops->free = ubifs_unpack_bits(&addr, &pos, c->space_bits);\n\t\tlprops->free <<= 3;\n\t\tlprops->dirty = ubifs_unpack_bits(&addr, &pos, c->space_bits);\n\t\tlprops->dirty <<= 3;\n\n\t\tif (ubifs_unpack_bits(&addr, &pos, 1))\n\t\t\tlprops->flags = LPROPS_INDEX;\n\t\telse\n\t\t\tlprops->flags = 0;\n\t\tlprops->flags |= ubifs_categorize_lprops(c, lprops);\n\t}\n\terr = check_lpt_crc(buf, c->pnode_sz);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "e(uint8_t **ad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "941-953",
    "snippet": "eck_lpt_type(uint8_t **addr, int *pos, int type)\n{\n\tint node_type;\n\n\tnode_type = ubifs_unpack_bits(addr, pos, UBIFS_LPT_TYPE_BITS);\n\tif (node_type != type) {\n\t\tubifs_err(\"invalid type (%d) in LPT node type %d\", node_type,\n\t\t\t  type);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * unpa",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return",
          "args": [],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid typ",
          "args": [
            "(%d) in LPT node type %d\", node_type,",
            "type);",
            "_sta"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(addr, pos, U",
          "args": [
            "IFS_",
            "T_T",
            "E_BITS);\n\tif (node_"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\neck_lpt_type(uint8_t **addr, int *pos, int type)\n{\n\tint node_type;\n\n\tnode_type = ubifs_unpack_bits(addr, pos, UBIFS_LPT_TYPE_BITS);\n\tif (node_type != type) {\n\t\tubifs_err(\"invalid type (%d) in LPT node type %d\", node_type,\n\t\t\t  type);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * unpa"
  },
  {
    "function_name": "(void *buf, i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "914-930",
    "snippet": "eck_lpt_crc(void *buf, int len)\n{\n\tint pos = 0;\n\tuint8_t *addr = buf;\n\tuint16_t crc, calc_crc;\n\n\tcrc = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_CRC_BITS);\n\tcalc_crc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t\t len - UBIFS_LPT_CRC_BYTES);\n\tif (crc != calc_crc) {\n\t\tubifs_err(\"invalid crc in LPT node: crc %hx calc %hx\", crc,\n\t\t\t  calc_crc);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * chec",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return",
          "args": [],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid crc",
          "args": [
            "in LPT node: crc %hx calc %hx\", crc,\n\t\t\t  c",
            "c_c",
            "dump_sta"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ UB",
          "args": [
            "FS",
            "PT_CRC_BYTES,\n\t\t\t len - U",
            "PT_CRC_BYTES);\n\tif (crc !"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits(&addr, &pos,",
          "args": [
            "UBIFS",
            "PT_C",
            "_BITS);\n\tcalc_crc"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\neck_lpt_crc(void *buf, int len)\n{\n\tint pos = 0;\n\tuint8_t *addr = buf;\n\tuint16_t crc, calc_crc;\n\n\tcrc = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_CRC_BITS);\n\tcalc_crc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t\t len - UBIFS_LPT_CRC_BYTES);\n\tif (crc != calc_crc) {\n\t\tubifs_err(\"invalid crc in LPT node: crc %hx calc %hx\", crc,\n\t\t\t  calc_crc);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * chec"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "893-904",
    "snippet": "eplace_cats(struct ubifs_info *c, struct ubifs_pnode *old_pnode,\n\t\t\t struct ubifs_pnode *new_pnode)\n{\n\tint i;\n\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tif (!new_pnode->lprops[i].lnum)\n\t\t\treturn;\n\t\tubifs_replace_cat(c, &old_pnode->lprops[i],\n\t\t\t\t  &new_pnode->lprops[i]);\n\t}\n}\n\n/**\n * chec",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_cat(c, &old_pnod",
          "args": [
            "-",
            "props[i],\n\t\t\t\t  &new_",
            "props[i]);\n\t}\n}\n\n/**"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\neplace_cats(struct ubifs_info *c, struct ubifs_pnode *old_pnode,\n\t\t\t struct ubifs_pnode *new_pnode)\n{\n\tint i;\n\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tif (!new_pnode->lprops[i].lnum)\n\t\t\treturn;\n\t\tubifs_replace_cat(c, &old_pnode->lprops[i],\n\t\t\t\t  &new_pnode->lprops[i]);\n\t}\n}\n\n/**\n * chec"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "869-881",
    "snippet": "pdate_cats(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tint i;\n\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint cat = pnode->lprops[i].flags & LPROPS_CAT_MASK;\n\t\tint lnum = pnode->lprops[i].lnum;\n\n\t\tif (!lnum)\n\t\t\treturn;\n\t\tubifs_add_to_cat(c, &pnode->lprops[i], cat);\n\t}\n}\n\n/**\n * repl",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cat(c, &pnode->l",
          "args": [
            "r",
            "s[i], cat);\n\t}\n}",
            "**"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\npdate_cats(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tint i;\n\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint cat = pnode->lprops[i].flags & LPROPS_CAT_MASK;\n\t\tint lnum = pnode->lprops[i].lnum;\n\n\t\tif (!lnum)\n\t\t\treturn;\n\t\tubifs_add_to_cat(c, &pnode->lprops[i], cat);\n\t}\n}\n\n/**\n * repl"
  },
  {
    "function_name": "dflt_lpt(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "608-859",
    "snippet": "ate_dflt_lpt(struct ubifs_info *c, int *main_lebs, int lpt_first,\n\t\t\t  int *lpt_lebs, int *big_lpt)\n{\n\tint lnum, err = 0, node_sz, iopos, i, j, cnt, len, alen, row;\n\tint blnum, boffs, bsz, bcnt;\n\tstruct ubifs_pnode *pnode = NULL;\n\tstruct ubifs_nnode *nnode = NULL;\n\tvoid *buf = NULL, *p;\n\tstruct ubifs_lpt_lprops *ltab = NULL;\n\tint *lsave = NULL;\n\n\terr = calc_dflt_lpt_geom(c, main_lebs, big_lpt);\n\tif (err)\n\t\treturn err;\n\t*lpt_lebs = c->lpt_lebs;\n\n\t/* Needed by 'ubifs_pack_nnode()' and 'set_ltab()' */\n\tc->lpt_first = lpt_first;\n\t/* Needed by 'set_ltab()' */\n\tc->lpt_last = lpt_first + c->lpt_lebs - 1;\n\t/* Needed by 'ubifs_pack_lsave()' */\n\tc->main_first = c->leb_cnt - *main_lebs;\n\n\tlsave = kmalloc(sizeof(int) * c->lsave_cnt, GFP_KERNEL);\n\tpnode = kzalloc(sizeof(struct ubifs_pnode), GFP_KERNEL);\n\tnnode = kzalloc(sizeof(struct ubifs_nnode), GFP_KERNEL);\n\tbuf = vmalloc(c->leb_size);\n\tltab = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!pnode || !nnode || !buf || !ltab || !lsave) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tubifs_assert(!c->ltab);\n\tc->ltab = ltab; /* Needed by set_ltab */\n\n\t/* Initialize LPT's own lprops */\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tltab[i].free = c->leb_size;\n\t\tltab[i].dirty = 0;\n\t\tltab[i].tgc = 0;\n\t\tltab[i].cmt = 0;\n\t}\n\n\tlnum = lpt_first;\n\tp = buf;\n\t/* Number of leaf nodes (pnodes) */\n\tcnt = c->pnode_cnt;\n\n\t/*\n\t * The first pnode contains the LEB properties for the LEBs that contain\n\t * the root inode node and the root index node of the index tree.\n\t */\n\tnode_sz = ALIGN(ubifs_idx_node_sz(c, 1), 8);\n\tiopos = ALIGN(node_sz, c->min_io_size);\n\tpnode->lprops[0].free = c->leb_size - iopos;\n\tpnode->lprops[0].dirty = iopos - node_sz;\n\tpnode->lprops[0].flags = LPROPS_INDEX;\n\n\tnode_sz = UBIFS_INO_NODE_SZ;\n\tiopos = ALIGN(node_sz, c->min_io_size);\n\tpnode->lprops[1].free = c->leb_size - iopos;\n\tpnode->lprops[1].dirty = iopos - node_sz;\n\n\tfor (i = 2; i < UBIFS_LPT_FANOUT; i++)\n\t\tpnode->lprops[i].free = c->leb_size;\n\n\t/* Add first pnode */\n\tubifs_pack_pnode(c, p, pnode);\n\tp += c->pnode_sz;\n\tlen = c->pnode_sz;\n\tpnode->num += 1;\n\n\t/* Reset pnode values for remaining pnodes */\n\tpnode->lprops[0].free = c->leb_size;\n\tpnode->lprops[0].dirty = 0;\n\tpnode->lprops[0].flags = 0;\n\n\tpnode->lprops[1].free = c->leb_size;\n\tpnode->lprops[1].dirty = 0;\n\n\t/*\n\t * To calculate the internal node branches, we keep information about\n\t * the level below.\n\t */\n\tblnum = lnum; /* LEB number of level below */\n\tboffs = 0; /* Offset of level below */\n\tbcnt = cnt; /* Number of nodes in level below */\n\tbsz = c->pnode_sz; /* Size of nodes in level below */\n\n\t/* Add all remaining pnodes */\n\tfor (i = 1; i < cnt; i++) {\n\t\tif (len + c->pnode_sz > c->leb_size) {\n\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\t\tmemset(p, 0xff, alen - len);\n\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tp = buf;\n\t\t\tlen = 0;\n\t\t}\n\t\tubifs_pack_pnode(c, p, pnode);\n\t\tp += c->pnode_sz;\n\t\tlen += c->pnode_sz;\n\t\t/*\n\t\t * pnodes are simply numbered left to right starting at zero,\n\t\t * which means the pnode number can be used easily to traverse\n\t\t * down the tree to the corresponding pnode.\n\t\t */\n\t\tpnode->num += 1;\n\t}\n\n\trow = 0;\n\tfor (i = UBIFS_LPT_FANOUT; cnt > i; i <<= UBIFS_LPT_FANOUT_SHIFT)\n\t\trow += 1;\n\t/* Add all nnodes, one level at a time */\n\twhile (1) {\n\t\t/* Number of internal nodes (nnodes) at next level */\n\t\tcnt = DIV_ROUND_UP(cnt, UBIFS_LPT_FANOUT);\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (len + c->nnode_sz > c->leb_size) {\n\t\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\t\tset_ltab(c, lnum, c->leb_size - alen,\n\t\t\t\t\t    alen - len);\n\t\t\t\tmemset(p, 0xff, alen - len);\n\t\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tp = buf;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\t/* Only 1 nnode at this level, so it is the root */\n\t\t\tif (cnt == 1) {\n\t\t\t\tc->lpt_lnum = lnum;\n\t\t\t\tc->lpt_offs = len;\n\t\t\t}\n\t\t\t/* Set branches to the level below */\n\t\t\tfor (j = 0; j < UBIFS_LPT_FANOUT; j++) {\n\t\t\t\tif (bcnt) {\n\t\t\t\t\tif (boffs + bsz > c->leb_size) {\n\t\t\t\t\t\tblnum += 1;\n\t\t\t\t\t\tboffs = 0;\n\t\t\t\t\t}\n\t\t\t\t\tnnode->nbranch[j].lnum = blnum;\n\t\t\t\t\tnnode->nbranch[j].offs = boffs;\n\t\t\t\t\tboffs += bsz;\n\t\t\t\t\tbcnt--;\n\t\t\t\t} else {\n\t\t\t\t\tnnode->nbranch[j].lnum = 0;\n\t\t\t\t\tnnode->nbranch[j].offs = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnnode->num = calc_nnode_num(row, i);\n\t\t\tubifs_pack_nnode(c, p, nnode);\n\t\t\tp += c->nnode_sz;\n\t\t\tlen += c->nnode_sz;\n\t\t}\n\t\t/* Only 1 nnode at this level, so it is the root */\n\t\tif (cnt == 1)\n\t\t\tbreak;\n\t\t/* Update the information about the level below */\n\t\tbcnt = cnt;\n\t\tbsz = c->nnode_sz;\n\t\trow -= 1;\n\t}\n\n\tif (*big_lpt) {\n\t\t/* Need to add LPT's save table */\n\t\tif (len + c->lsave_sz > c->leb_size) {\n\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\t\tmemset(p, 0xff, alen - len);\n\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tp = buf;\n\t\t\tlen = 0;\n\t\t}\n\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = len;\n\n\t\tfor (i = 0; i < c->lsave_cnt && i < *main_lebs; i++)\n\t\t\tlsave[i] = c->main_first + i;\n\t\tfor (; i < c->lsave_cnt; i++)\n\t\t\tlsave[i] = c->main_first;\n\n\t\tubifs_pack_lsave(c, p, lsave);\n\t\tp += c->lsave_sz;\n\t\tlen += c->lsave_sz;\n\t}\n\n\t/* Need to add LPT's own LEB properties table */\n\tif (len + c->ltab_sz > c->leb_size) {\n\t\talen = ALIGN(len, c->min_io_size);\n\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\tmemset(p, 0xff, alen - len);\n\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tp = buf;\n\t\tlen = 0;\n\t}\n\n\tc->ltab_lnum = lnum;\n\tc->ltab_offs = len;\n\n\t/* Update ltab before packing it */\n\tlen += c->ltab_sz;\n\talen = ALIGN(len, c->min_io_size);\n\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\n\tubifs_pack_ltab(c, p, ltab);\n\tp += c->ltab_sz;\n\n\t/* Write remaining buffer */\n\tmemset(p, 0xff, alen - len);\n\terr = ubifs_leb_change(c, lnum, buf, alen);\n\tif (err)\n\t\tgoto out;\n\n\tc->nhead_lnum = lnum;\n\tc->nhead_offs = ALIGN(len, c->min_io_size);\n\n\tdbg_lp(\"space_bits %d\", c->space_bits);\n\tdbg_lp(\"lpt_lnum_bits %d\", c->lpt_lnum_bits);\n\tdbg_lp(\"lpt_offs_bits %d\", c->lpt_offs_bits);\n\tdbg_lp(\"lpt_spc_bits %d\", c->lpt_spc_bits);\n\tdbg_lp(\"pcnt_bits %d\", c->pcnt_bits);\n\tdbg_lp(\"lnum_bits %d\", c->lnum_bits);\n\tdbg_lp(\"pnode_sz %d\", c->pnode_sz);\n\tdbg_lp(\"nnode_sz %d\", c->nnode_sz);\n\tdbg_lp(\"ltab_sz %d\", c->ltab_sz);\n\tdbg_lp(\"lsave_sz %d\", c->lsave_sz);\n\tdbg_lp(\"lsave_cnt %d\", c->lsave_cnt);\n\tdbg_lp(\"lpt_hght %d\", c->lpt_hght);\n\tdbg_lp(\"big_lpt %d\", c->big_lpt);\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\nout:\n\tc->ltab = NULL;\n\tkfree(lsave);\n\tvfree(ltab);\n\tvfree(buf);\n\tkfree(nnode);\n\tkfree(pnode);\n\treturn err;\n}\n\n/**\n * upda",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn er"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfr",
          "args": [
            "e(pno"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nno"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfre",
          "args": [
            "(buf"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfr",
          "args": [
            "e(lta"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save i",
          "args": [
            "at %d:%d\", c->lsave_ln",
            ", c->lsave_of",
            ");\nout:\n\tc->l"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tab is",
          "args": [
            "at %d:%d\", c->ltab_lnu",
            "c->ltab_off",
            ";\n\tif (c->bi"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead is",
          "args": [
            "at %d:%d\", c->nhead_ln",
            ", c->nhead_of",
            ");\n\tdbg_lp(\"L"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oot is",
          "args": [
            "at %d:%d\", c->lpt_lnum",
            "c->lpt_offs",
            "dbg_lp(\"L"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt %d\"",
          "args": [
            "c->big_lpt)",
            "dbg_lp(\"L"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ght %d",
          "args": [
            ", c->lpt_hght",
            "dbg_lp(\"b"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cnt %",
          "args": [
            "\", c->lsave_cn",
            ";\n\tdbg_lp(\"l"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sz %d",
          "args": [
            ", c->lsave_sz",
            "dbg_lp(\"l"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sz %d\"",
          "args": [
            "c->ltab_sz)",
            "dbg_lp(\"l"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sz %d",
          "args": [
            ", c->nnode_sz",
            "dbg_lp(\"l"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sz %d",
          "args": [
            ", c->pnode_sz",
            "dbg_lp(\"n"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits %",
          "args": [
            "\", c->lnum_bit",
            ";\n\tdbg_lp(\"p"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bits %",
          "args": [
            "\", c->pcnt_bit",
            ";\n\tdbg_lp(\"l"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_bit",
          "args": [
            "%d\", c->lpt_spc_",
            "ts);\n\tdbg_lp(\"p"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs_bi",
          "args": [
            "s %d\", c->lpt_offs",
            "its);\n\tdbg_lp(\"l"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_bi",
          "args": [
            "s %d\", c->lpt_lnum",
            "its);\n\tdbg_lp(\"l"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bits",
          "args": [
            "d\", c->space_bi",
            ");\n\tdbg_lp(\"l"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_window_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "52-65",
          "snippet": "static unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic unsigned int ocfs2_resv_window_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t\t\t   struct ocfs2_alloc_reservation *resv)\n{\n\tstruct ocfs2_super *osb = resmap->m_osb;\n\tunsigned int bits;\n\n\tif (!(resv->r_flags & OCFS2_RESV_FLAG_DIR)) {\n\t\t/* 8, 16, 32, 64, 128, 256, 512, 1024 */\n\t\tbits = 4 << osb->osb_resv_level;\n\t} else {\n\t\tbits = 4 << osb->osb_dir_resv_level;\n\t}\n\treturn bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\n\tdbg_lp(\""
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum, buf",
          "args": [
            "en);",
            "if",
            "rr)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f, ale",
          "args": [
            "len)",
            "err = ubi"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ab(c, p, ltab);",
          "args": [
            "+",
            "c->l"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen, alen - len)",
            "ubifs_pa"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\tset_ltab("
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum++, b",
          "args": [
            "f",
            "alen);",
            "if",
            "err)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f, ale",
          "args": [
            "len)",
            "err = ub"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen, alen - len)",
            "memset(p"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\t\tset_ltab"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave(c, p, lsave)",
          "args": [
            "p",
            "= c->"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum++, b",
          "args": [
            "f",
            "alen);",
            "i",
            "(err"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f, ale",
          "args": [
            "len)",
            "err = u"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen, alen - len)",
            "memset("
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\t\t\tset_lta"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, p, nnode)",
          "args": [
            "+= c-"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m(row, i);",
          "args": [
            "bif",
            "p"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum++, b",
          "args": [
            "f",
            "alen);",
            "(er"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f, ale",
          "args": [
            "len)",
            "err ="
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen,\n\t\t\t\t\t    al",
            "memset"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\t\t\t\tset_lt"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnt, UBIFS_L",
          "args": [
            "T_F",
            "OUT);\n\t\tfor (i ="
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, p, pnode)",
          "args": [
            "p",
            "= c->"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum++, b",
          "args": [
            "f",
            "alen);",
            "i",
            "(err"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f, ale",
          "args": [
            "len)",
            "err = u"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, c->",
          "args": [
            "e",
            "size",
            "alen, alen - len)",
            "memset("
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\t\t\tset_lta"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, p, pnode)",
          "args": [
            "c->p"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", c->",
          "args": [
            "in_io_s",
            "e);\n\tpnode->lp"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", c->",
          "args": [
            "in_io_s",
            "e);\n\tpnode->lp"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_no",
          "args": [
            "e_sz(c, 1), 8);\n\tiopos",
            "A"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, 1), 8);",
          "args": [
            "o",
            "s"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ltab);",
          "args": [
            "->ltab ="
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!pnod"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_size)",
          "args": [
            "ltab = vm"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_nnode), GFP_KERNEL)",
            "buf = vma"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "f(int)",
          "args": [
            "c->lsave_cnt, GFP_KERNEL)",
            "pnode = k"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_geom(c, main_lebs",
          "args": [
            "g_lpt);",
            "(err)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nate_dflt_lpt(struct ubifs_info *c, int *main_lebs, int lpt_first,\n\t\t\t  int *lpt_lebs, int *big_lpt)\n{\n\tint lnum, err = 0, node_sz, iopos, i, j, cnt, len, alen, row;\n\tint blnum, boffs, bsz, bcnt;\n\tstruct ubifs_pnode *pnode = NULL;\n\tstruct ubifs_nnode *nnode = NULL;\n\tvoid *buf = NULL, *p;\n\tstruct ubifs_lpt_lprops *ltab = NULL;\n\tint *lsave = NULL;\n\n\terr = calc_dflt_lpt_geom(c, main_lebs, big_lpt);\n\tif (err)\n\t\treturn err;\n\t*lpt_lebs = c->lpt_lebs;\n\n\t/* Needed by 'ubifs_pack_nnode()' and 'set_ltab()' */\n\tc->lpt_first = lpt_first;\n\t/* Needed by 'set_ltab()' */\n\tc->lpt_last = lpt_first + c->lpt_lebs - 1;\n\t/* Needed by 'ubifs_pack_lsave()' */\n\tc->main_first = c->leb_cnt - *main_lebs;\n\n\tlsave = kmalloc(sizeof(int) * c->lsave_cnt, GFP_KERNEL);\n\tpnode = kzalloc(sizeof(struct ubifs_pnode), GFP_KERNEL);\n\tnnode = kzalloc(sizeof(struct ubifs_nnode), GFP_KERNEL);\n\tbuf = vmalloc(c->leb_size);\n\tltab = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\n\tif (!pnode || !nnode || !buf || !ltab || !lsave) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tubifs_assert(!c->ltab);\n\tc->ltab = ltab; /* Needed by set_ltab */\n\n\t/* Initialize LPT's own lprops */\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tltab[i].free = c->leb_size;\n\t\tltab[i].dirty = 0;\n\t\tltab[i].tgc = 0;\n\t\tltab[i].cmt = 0;\n\t}\n\n\tlnum = lpt_first;\n\tp = buf;\n\t/* Number of leaf nodes (pnodes) */\n\tcnt = c->pnode_cnt;\n\n\t/*\n\t * The first pnode contains the LEB properties for the LEBs that contain\n\t * the root inode node and the root index node of the index tree.\n\t */\n\tnode_sz = ALIGN(ubifs_idx_node_sz(c, 1), 8);\n\tiopos = ALIGN(node_sz, c->min_io_size);\n\tpnode->lprops[0].free = c->leb_size - iopos;\n\tpnode->lprops[0].dirty = iopos - node_sz;\n\tpnode->lprops[0].flags = LPROPS_INDEX;\n\n\tnode_sz = UBIFS_INO_NODE_SZ;\n\tiopos = ALIGN(node_sz, c->min_io_size);\n\tpnode->lprops[1].free = c->leb_size - iopos;\n\tpnode->lprops[1].dirty = iopos - node_sz;\n\n\tfor (i = 2; i < UBIFS_LPT_FANOUT; i++)\n\t\tpnode->lprops[i].free = c->leb_size;\n\n\t/* Add first pnode */\n\tubifs_pack_pnode(c, p, pnode);\n\tp += c->pnode_sz;\n\tlen = c->pnode_sz;\n\tpnode->num += 1;\n\n\t/* Reset pnode values for remaining pnodes */\n\tpnode->lprops[0].free = c->leb_size;\n\tpnode->lprops[0].dirty = 0;\n\tpnode->lprops[0].flags = 0;\n\n\tpnode->lprops[1].free = c->leb_size;\n\tpnode->lprops[1].dirty = 0;\n\n\t/*\n\t * To calculate the internal node branches, we keep information about\n\t * the level below.\n\t */\n\tblnum = lnum; /* LEB number of level below */\n\tboffs = 0; /* Offset of level below */\n\tbcnt = cnt; /* Number of nodes in level below */\n\tbsz = c->pnode_sz; /* Size of nodes in level below */\n\n\t/* Add all remaining pnodes */\n\tfor (i = 1; i < cnt; i++) {\n\t\tif (len + c->pnode_sz > c->leb_size) {\n\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\t\tmemset(p, 0xff, alen - len);\n\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tp = buf;\n\t\t\tlen = 0;\n\t\t}\n\t\tubifs_pack_pnode(c, p, pnode);\n\t\tp += c->pnode_sz;\n\t\tlen += c->pnode_sz;\n\t\t/*\n\t\t * pnodes are simply numbered left to right starting at zero,\n\t\t * which means the pnode number can be used easily to traverse\n\t\t * down the tree to the corresponding pnode.\n\t\t */\n\t\tpnode->num += 1;\n\t}\n\n\trow = 0;\n\tfor (i = UBIFS_LPT_FANOUT; cnt > i; i <<= UBIFS_LPT_FANOUT_SHIFT)\n\t\trow += 1;\n\t/* Add all nnodes, one level at a time */\n\twhile (1) {\n\t\t/* Number of internal nodes (nnodes) at next level */\n\t\tcnt = DIV_ROUND_UP(cnt, UBIFS_LPT_FANOUT);\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (len + c->nnode_sz > c->leb_size) {\n\t\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\t\tset_ltab(c, lnum, c->leb_size - alen,\n\t\t\t\t\t    alen - len);\n\t\t\t\tmemset(p, 0xff, alen - len);\n\t\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tp = buf;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\t/* Only 1 nnode at this level, so it is the root */\n\t\t\tif (cnt == 1) {\n\t\t\t\tc->lpt_lnum = lnum;\n\t\t\t\tc->lpt_offs = len;\n\t\t\t}\n\t\t\t/* Set branches to the level below */\n\t\t\tfor (j = 0; j < UBIFS_LPT_FANOUT; j++) {\n\t\t\t\tif (bcnt) {\n\t\t\t\t\tif (boffs + bsz > c->leb_size) {\n\t\t\t\t\t\tblnum += 1;\n\t\t\t\t\t\tboffs = 0;\n\t\t\t\t\t}\n\t\t\t\t\tnnode->nbranch[j].lnum = blnum;\n\t\t\t\t\tnnode->nbranch[j].offs = boffs;\n\t\t\t\t\tboffs += bsz;\n\t\t\t\t\tbcnt--;\n\t\t\t\t} else {\n\t\t\t\t\tnnode->nbranch[j].lnum = 0;\n\t\t\t\t\tnnode->nbranch[j].offs = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnnode->num = calc_nnode_num(row, i);\n\t\t\tubifs_pack_nnode(c, p, nnode);\n\t\t\tp += c->nnode_sz;\n\t\t\tlen += c->nnode_sz;\n\t\t}\n\t\t/* Only 1 nnode at this level, so it is the root */\n\t\tif (cnt == 1)\n\t\t\tbreak;\n\t\t/* Update the information about the level below */\n\t\tbcnt = cnt;\n\t\tbsz = c->nnode_sz;\n\t\trow -= 1;\n\t}\n\n\tif (*big_lpt) {\n\t\t/* Need to add LPT's save table */\n\t\tif (len + c->lsave_sz > c->leb_size) {\n\t\t\talen = ALIGN(len, c->min_io_size);\n\t\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\t\tmemset(p, 0xff, alen - len);\n\t\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tp = buf;\n\t\t\tlen = 0;\n\t\t}\n\n\t\tc->lsave_lnum = lnum;\n\t\tc->lsave_offs = len;\n\n\t\tfor (i = 0; i < c->lsave_cnt && i < *main_lebs; i++)\n\t\t\tlsave[i] = c->main_first + i;\n\t\tfor (; i < c->lsave_cnt; i++)\n\t\t\tlsave[i] = c->main_first;\n\n\t\tubifs_pack_lsave(c, p, lsave);\n\t\tp += c->lsave_sz;\n\t\tlen += c->lsave_sz;\n\t}\n\n\t/* Need to add LPT's own LEB properties table */\n\tif (len + c->ltab_sz > c->leb_size) {\n\t\talen = ALIGN(len, c->min_io_size);\n\t\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\t\tmemset(p, 0xff, alen - len);\n\t\terr = ubifs_leb_change(c, lnum++, buf, alen);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tp = buf;\n\t\tlen = 0;\n\t}\n\n\tc->ltab_lnum = lnum;\n\tc->ltab_offs = len;\n\n\t/* Update ltab before packing it */\n\tlen += c->ltab_sz;\n\talen = ALIGN(len, c->min_io_size);\n\tset_ltab(c, lnum, c->leb_size - alen, alen - len);\n\n\tubifs_pack_ltab(c, p, ltab);\n\tp += c->ltab_sz;\n\n\t/* Write remaining buffer */\n\tmemset(p, 0xff, alen - len);\n\terr = ubifs_leb_change(c, lnum, buf, alen);\n\tif (err)\n\t\tgoto out;\n\n\tc->nhead_lnum = lnum;\n\tc->nhead_offs = ALIGN(len, c->min_io_size);\n\n\tdbg_lp(\"space_bits %d\", c->space_bits);\n\tdbg_lp(\"lpt_lnum_bits %d\", c->lpt_lnum_bits);\n\tdbg_lp(\"lpt_offs_bits %d\", c->lpt_offs_bits);\n\tdbg_lp(\"lpt_spc_bits %d\", c->lpt_spc_bits);\n\tdbg_lp(\"pcnt_bits %d\", c->pcnt_bits);\n\tdbg_lp(\"lnum_bits %d\", c->lnum_bits);\n\tdbg_lp(\"pnode_sz %d\", c->pnode_sz);\n\tdbg_lp(\"nnode_sz %d\", c->nnode_sz);\n\tdbg_lp(\"ltab_sz %d\", c->ltab_sz);\n\tdbg_lp(\"lsave_sz %d\", c->lsave_sz);\n\tdbg_lp(\"lsave_cnt %d\", c->lsave_cnt);\n\tdbg_lp(\"lpt_hght %d\", c->lpt_hght);\n\tdbg_lp(\"big_lpt %d\", c->big_lpt);\n\tdbg_lp(\"LPT root is at %d:%d\", c->lpt_lnum, c->lpt_offs);\n\tdbg_lp(\"LPT head is at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\tdbg_lp(\"LPT ltab is at %d:%d\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tdbg_lp(\"LPT lsave is at %d:%d\", c->lsave_lnum, c->lsave_offs);\nout:\n\tc->ltab = NULL;\n\tkfree(lsave);\n\tvfree(ltab);\n\tvfree(buf);\n\tkfree(nnode);\n\tkfree(pnode);\n\treturn err;\n}\n\n/**\n * upda"
  },
  {
    "function_name": "m_from_parent(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "583-596",
    "snippet": "lc_pnode_num_from_parent(const struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint i, n = c->lpt_hght - 1, pnum = parent->num, num = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum |= pnum & (UBIFS_LPT_FANOUT - 1);\n\t\tpnum >>= UBIFS_LPT_FANOUT_SHIFT;\n\t}\n\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\tnum |= iip;\n\treturn num;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlc_pnode_num_from_parent(const struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint i, n = c->lpt_hght - 1, pnum = parent->num, num = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum |= pnum & (UBIFS_LPT_FANOUT - 1);\n\t\tpnum >>= UBIFS_LPT_FANOUT_SHIFT;\n\t}\n\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\tnum |= iip;\n\treturn num;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "m_from_parent(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "558-569",
    "snippet": "lc_nnode_num_from_parent(const struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint num, shft;\n\n\tif (!parent)\n\t\treturn 1;\n\tshft = (c->lpt_hght - parent->level) * UBIFS_LPT_FANOUT_SHIFT;\n\tnum = parent->num ^ (1 << shft);\n\tnum |= (UBIFS_LPT_FANOUT + iip) << shft;\n\treturn num;\n}\n\n/**\n * calc",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlc_nnode_num_from_parent(const struct ubifs_info *c,\n\t\t\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint num, shft;\n\n\tif (!parent)\n\t\treturn 1;\n\tshft = (c->lpt_hght - parent->level) * UBIFS_LPT_FANOUT_SHIFT;\n\tnum = parent->num ^ (1 << shft);\n\tnum |= (UBIFS_LPT_FANOUT + iip) << shft;\n\treturn num;\n}\n\n/**\n * calc"
  },
  {
    "function_name": "m(int row, int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "532-544",
    "snippet": "lc_nnode_num(int row, int col)\n{\n\tint num, bits;\n\n\tnum = 1;\n\twhile (row--) {\n\t\tbits = (col & (UBIFS_LPT_FANOUT - 1));\n\t\tcol >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum |= bits;\n\t}\n\treturn num;\n}\n\n/**\n * calc",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlc_nnode_num(int row, int col)\n{\n\tint num, bits;\n\n\tnum = 1;\n\twhile (row--) {\n\t\tbits = (col & (UBIFS_LPT_FANOUT - 1));\n\t\tcol >>= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum <<= UBIFS_LPT_FANOUT_SHIFT;\n\t\tnum |= bits;\n\t}\n\treturn num;\n}\n\n/**\n * calc"
  },
  {
    "function_name": "t(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "515-519",
    "snippet": "dd_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,\n\t\t\t   c->pnode_sz);\n}\n\n/**\n * calc",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirt(c, pnode->pa",
          "args": [
            "e",
            "->nbranch[pnode->iip].lnum,\n\t\t\t   c->pn",
            "}\n\n/**\n *"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\ndd_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)\n{\n\tubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,\n\t\t\t   c->pnode_sz);\n}\n\n/**\n * calc"
  },
  {
    "function_name": "de_dirt(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "494-508",
    "snippet": "d_nnode_dirt(struct ubifs_info *c, struct ubifs_nnode *nnode)\n{\n\tstruct ubifs_nnode *np = nnode->parent;\n\n\tif (np)\n\t\tubifs_add_lpt_dirt(c, np->nbranch[nnode->iip].lnum,\n\t\t\t\t   c->nnode_sz);\n\telse {\n\t\tubifs_add_lpt_dirt(c, c->lpt_lnum, c->nnode_sz);\n\t\tif (!(c->lpt_drty_flgs & LTAB_DIRTY)) {\n\t\t\tc->lpt_drty_flgs |= LTAB_DIRTY;\n\t\t\tubifs_add_lpt_dirt(c, c->ltab_lnum, c->ltab_sz);\n\t\t}\n\t}\n}\n\n/**\n * add_",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirt(c, c->ltab_l",
          "args": [
            "u",
            "c->ltab_sz)",
            "}\n\t}\n}"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirt(c, c->lpt_ln",
          "args": [
            "m",
            "c->nnode_sz",
            "if (!(c-"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirt(c, np->nbran",
          "args": [
            "h",
            "node->iip].lnum,\n\t\t\t\t   c->n",
            "else {"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nd_nnode_dirt(struct ubifs_info *c, struct ubifs_nnode *nnode)\n{\n\tstruct ubifs_nnode *np = nnode->parent;\n\n\tif (np)\n\t\tubifs_add_lpt_dirt(c, np->nbranch[nnode->iip].lnum,\n\t\t\t\t   c->nnode_sz);\n\telse {\n\t\tubifs_add_lpt_dirt(c, c->lpt_lnum, c->nnode_sz);\n\t\tif (!(c->lpt_drty_flgs & LTAB_DIRTY)) {\n\t\t\tc->lpt_drty_flgs |= LTAB_DIRTY;\n\t\t\tubifs_add_lpt_dirt(c, c->ltab_lnum, c->ltab_sz);\n\t\t}\n\t}\n}\n\n/**\n * add_"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "479-487",
    "snippet": "et_ltab(struct ubifs_info *c, int lnum, int free, int dirty)\n{\n\tdbg_lp(\"LEB %d free %d dirty %d to %d %d\",\n\t       lnum, c->ltab[lnum - c->lpt_first].free,\n\t       c->ltab[lnum - c->lpt_first].dirty, free, dirty);\n\tubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].free = free;\n\tc->ltab[lnum - c->lpt_first].dirty = dirty;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first && lnum <= c->lpt_last);\n\tc->ltab[l"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d free",
          "args": [
            "%d dirty %d to %d %d\",\n\t       lnu",
            "[lnu",
            "- c->lpt_first].free,\n\t       c->",
            "- c->lpt_first].dirty, free, dirty",
            "ub",
            "s_ass"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\net_ltab(struct ubifs_info *c, int lnum, int free, int dirty)\n{\n\tdbg_lp(\"LEB %d free %d dirty %d to %d %d\",\n\t       lnum, c->ltab[lnum - c->lpt_first].free,\n\t       c->ltab[lnum - c->lpt_first].dirty, free, dirty);\n\tubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].free = free;\n\tc->ltab[lnum - c->lpt_first].dirty = dirty;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_dirt(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "462-470",
    "snippet": "d_lpt_dirt(struct ubifs_info *c, int lnum, int dirty)\n{\n\tif (!dirty || !lnum)\n\t\treturn;\n\tdbg_lp(\"LEB %d add %d to %d\",\n\t       lnum, dirty, c->ltab[lnum - c->lpt_first].dirty);\n\tubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].dirty += dirty;\n}\n\n/**\n * set_",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lnum >= c->l",
          "args": [
            "t_first && lnum <= c->lpt_last);\n\tc->ltab[l"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d add",
          "args": [
            "d to %d\",\n\t       lnu",
            "c->l",
            "b[lnu",
            "- c->lpt_first].dirty);\n\tubifs_ass"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nd_lpt_dirt(struct ubifs_info *c, int lnum, int dirty)\n{\n\tif (!dirty || !lnum)\n\t\treturn;\n\tdbg_lp(\"LEB %d add %d to %d\",\n\t       lnum, dirty, c->ltab[lnum - c->lpt_first].dirty);\n\tubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\n\tc->ltab[lnum - c->lpt_first].dirty += dirty;\n}\n\n/**\n * set_"
  },
  {
    "function_name": "ave(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "440-454",
    "snippet": "ck_lsave(struct ubifs_info *c, void *buf, int *lsave)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(&addr, &pos, UBIFS_LPT_LSAVE, UBIFS_LPT_TYPE_BITS);\n\tfor (i = 0; i < c->lsave_cnt; i++)\n\t\tpack_bits(&addr, &pos, lsave[i], c->lnum_bits);\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->lsave_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "crc,",
            "IFS_",
            "T_C",
            "_BITS);\n}\n\n/**\n *"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ UB",
          "args": [
            "FS",
            "PT_CRC_BYTES,\n\t\t    c->ls",
            "UBIFS_LPT_CRC_BYTES);\n\taddr = bu"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "lsave",
            "], c",
            "lnum_bit",
            ";\n\tcrc = crc"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "UBIFS",
            "PT_L",
            "VE, UBIFS_LPT_T",
            "E_BITS);\n\tfor (i ="
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nck_lsave(struct ubifs_info *c, void *buf, int *lsave)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(&addr, &pos, UBIFS_LPT_LSAVE, UBIFS_LPT_TYPE_BITS);\n\tfor (i = 0; i < c->lsave_cnt; i++)\n\t\tpack_bits(&addr, &pos, lsave[i], c->lnum_bits);\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->lsave_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ab(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "415-432",
    "snippet": "ck_ltab(struct ubifs_info *c, void *buf,\n\t\t     struct ubifs_lpt_lprops *ltab)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(&addr, &pos, UBIFS_LPT_LTAB, UBIFS_LPT_TYPE_BITS);\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tpack_bits(&addr, &pos, ltab[i].free, c->lpt_spc_bits);\n\t\tpack_bits(&addr, &pos, ltab[i].dirty, c->lpt_spc_bits);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->ltab_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "crc,",
            "IFS_",
            "T_C",
            "_BITS);\n}\n\n/**\n *"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ UB",
          "args": [
            "FS",
            "PT_CRC_BYTES,\n\t\t    c->lt",
            "UBIFS_LPT_CRC_BYTES);\n\taddr = bu"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "ltab[",
            ".dir",
            ", c->lpt_spc_",
            "ts);\n\t}\n\tcrc ="
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "ltab[",
            ".fre",
            "c->lpt_spc_",
            "ts);\n\t\tpack_bit"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "UBIFS",
            "PT_L",
            "B, UBIFS_LPT_T",
            "E_BITS);\n\tfor (i ="
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nck_ltab(struct ubifs_info *c, void *buf,\n\t\t     struct ubifs_lpt_lprops *ltab)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(&addr, &pos, UBIFS_LPT_LTAB, UBIFS_LPT_TYPE_BITS);\n\tfor (i = 0; i < c->lpt_lebs; i++) {\n\t\tpack_bits(&addr, &pos, ltab[i].free, c->lpt_spc_bits);\n\t\tpack_bits(&addr, &pos, ltab[i].dirty, c->lpt_spc_bits);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->ltab_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "383-407",
    "snippet": "ck_nnode(struct ubifs_info *c, void *buf,\n\t\t      struct ubifs_nnode *nnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(&addr, &pos, UBIFS_LPT_NNODE, UBIFS_LPT_TYPE_BITS);\n\tif (c->big_lpt)\n\t\tpack_bits(&addr, &pos, nnode->num, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum = nnode->nbranch[i].lnum;\n\n\t\tif (lnum == 0)\n\t\t\tlnum = c->lpt_last + 1;\n\t\tpack_bits(&addr, &pos, lnum - c->lpt_first, c->lpt_lnum_bits);\n\t\tpack_bits(&addr, &pos, nnode->nbranch[i].offs,\n\t\t\t  c->lpt_offs_bits);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->nnode_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "crc,",
            "IFS_",
            "T_C",
            "_BITS);\n}\n\n/**\n *"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ UB",
          "args": [
            "FS",
            "PT_CRC_BYTES,\n\t\t    c->nn",
            "UBIFS_LPT_CRC_BYTES);\n\taddr = bu"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "nnode",
            "nbra",
            "h[i].offs,\n\t\t\t  c->lpt",
            "its);\n\t}\n\tcrc ="
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "lnum",
            "c->l",
            "_first, c->lpt_lnum",
            "its);\n\t\tpack_bit"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "nnode",
            "num,",
            "->pcnt_bit",
            ";\n\tfor (i ="
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "UBIFS",
            "PT_N",
            "DE, UBIFS_LPT_T",
            "E_BITS);\n\tif (c->bi"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nck_nnode(struct ubifs_info *c, void *buf,\n\t\t      struct ubifs_nnode *nnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(&addr, &pos, UBIFS_LPT_NNODE, UBIFS_LPT_TYPE_BITS);\n\tif (c->big_lpt)\n\t\tpack_bits(&addr, &pos, nnode->num, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tint lnum = nnode->nbranch[i].lnum;\n\n\t\tif (lnum == 0)\n\t\t\tlnum = c->lpt_last + 1;\n\t\tpack_bits(&addr, &pos, lnum - c->lpt_first, c->lpt_lnum_bits);\n\t\tpack_bits(&addr, &pos, nnode->nbranch[i].offs,\n\t\t\t  c->lpt_offs_bits);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->nnode_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "350-375",
    "snippet": "ck_pnode(struct ubifs_info *c, void *buf,\n\t\t      struct ubifs_pnode *pnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(&addr, &pos, UBIFS_LPT_PNODE, UBIFS_LPT_TYPE_BITS);\n\tif (c->big_lpt)\n\t\tpack_bits(&addr, &pos, pnode->num, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tpack_bits(&addr, &pos, pnode->lprops[i].free >> 3,\n\t\t\t  c->space_bits);\n\t\tpack_bits(&addr, &pos, pnode->lprops[i].dirty >> 3,\n\t\t\t  c->space_bits);\n\t\tif (pnode->lprops[i].flags & LPROPS_INDEX)\n\t\t\tpack_bits(&addr, &pos, 1, 1);\n\t\telse\n\t\t\tpack_bits(&addr, &pos, 0, 1);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->pnode_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "crc,",
            "IFS_",
            "T_C",
            "_BITS);\n}\n\n/**\n *"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ UB",
          "args": [
            "FS",
            "PT_CRC_BYTES,\n\t\t    c->pn",
            "UBIFS_LPT_CRC_BYTES);\n\taddr = bu"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "0, 1)",
            "}",
            "c"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "1, 1)",
            "el"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "pnode",
            "lpro",
            "[i].dirty >> 3,\n\t\t\t  c->spa",
            ");\n\t\tif (pnod"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "pnode",
            "lpro",
            "[i].free >> 3,\n\t\t\t  c->spa",
            ");\n\t\tpack_bit"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "pnode",
            "num,",
            "->pcnt_bit",
            ";\n\tfor (i ="
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dr, &pos,",
          "args": [
            "UBIFS",
            "PT_P",
            "DE, UBIFS_LPT_T",
            "E_BITS);\n\tif (c->bi"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nck_pnode(struct ubifs_info *c, void *buf,\n\t\t      struct ubifs_pnode *pnode)\n{\n\tuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\n\tint i, pos = 0;\n\tuint16_t crc;\n\n\tpack_bits(&addr, &pos, UBIFS_LPT_PNODE, UBIFS_LPT_TYPE_BITS);\n\tif (c->big_lpt)\n\t\tpack_bits(&addr, &pos, pnode->num, c->pcnt_bits);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tpack_bits(&addr, &pos, pnode->lprops[i].free >> 3,\n\t\t\t  c->space_bits);\n\t\tpack_bits(&addr, &pos, pnode->lprops[i].dirty >> 3,\n\t\t\t  c->space_bits);\n\t\tif (pnode->lprops[i].flags & LPROPS_INDEX)\n\t\t\tpack_bits(&addr, &pos, 1, 1);\n\t\telse\n\t\t\tpack_bits(&addr, &pos, 0, 1);\n\t}\n\tcrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\n\t\t    c->pnode_sz - UBIFS_LPT_CRC_BYTES);\n\taddr = buf;\n\tpos = 0;\n\tpack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "bits(uint8_t **ad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "283-342",
    "snippet": "s_unpack_bits(uint8_t **addr, int *pos, int nrbits)\n{\n\tconst int k = 32 - nrbits;\n\tuint8_t *p = *addr;\n\tint b = *pos;\n\tuint32_t uninitialized_var(val);\n\tconst int bytes = (nrbits + b + 7) >> 3;\n\n\tubifs_assert(nrbits > 0);\n\tubifs_assert(nrbits <= 32);\n\tubifs_assert(*pos >= 0);\n\tubifs_assert(*pos < 8);\n\tif (b) {\n\t\tswitch (bytes) {\n\t\tcase 2:\n\t\t\tval = p[1];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8) |\n\t\t\t\t     ((uint32_t)p[3] << 16);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8) |\n\t\t\t\t     ((uint32_t)p[3] << 16) |\n\t\t\t\t     ((uint32_t)p[4] << 24);\n\t\t}\n\t\tval <<= (8 - b);\n\t\tval |= *p >> b;\n\t\tnrbits += b;\n\t} else {\n\t\tswitch (bytes) {\n\t\tcase 1:\n\t\t\tval = p[0];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8) |\n\t\t\t\t     ((uint32_t)p[2] << 16);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8) |\n\t\t\t\t     ((uint32_t)p[2] << 16) |\n\t\t\t\t     ((uint32_t)p[3] << 24);\n\t\t\tbreak;\n\t\t}\n\t}\n\tval <<= k;\n\tval >>= k;\n\tb = nrbits & 7;\n\tp += nrbits >> 3;\n\t*addr = p;\n\t*pos = b;\n\tubifs_assert((val >> nrbits) == 0 || nrbits - b == 32);\n\treturn val;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(val >> nrbi",
          "args": [
            "s) == 0 || nrbits - b == 32);\n\treturn va"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*pos < 8);",
          "args": [
            "f (b) {"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*pos >= 0);",
          "args": [
            "ubifs_ass"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nrbits <= 32",
          "args": [
            ";\n\tubifs_ass"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nrbits > 0);",
          "args": [
            "ubifs_ass"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\ns_unpack_bits(uint8_t **addr, int *pos, int nrbits)\n{\n\tconst int k = 32 - nrbits;\n\tuint8_t *p = *addr;\n\tint b = *pos;\n\tuint32_t uninitialized_var(val);\n\tconst int bytes = (nrbits + b + 7) >> 3;\n\n\tubifs_assert(nrbits > 0);\n\tubifs_assert(nrbits <= 32);\n\tubifs_assert(*pos >= 0);\n\tubifs_assert(*pos < 8);\n\tif (b) {\n\t\tswitch (bytes) {\n\t\tcase 2:\n\t\t\tval = p[1];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8) |\n\t\t\t\t     ((uint32_t)p[3] << 16);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tval = p[1] | ((uint32_t)p[2] << 8) |\n\t\t\t\t     ((uint32_t)p[3] << 16) |\n\t\t\t\t     ((uint32_t)p[4] << 24);\n\t\t}\n\t\tval <<= (8 - b);\n\t\tval |= *p >> b;\n\t\tnrbits += b;\n\t} else {\n\t\tswitch (bytes) {\n\t\tcase 1:\n\t\t\tval = p[0];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8) |\n\t\t\t\t     ((uint32_t)p[2] << 16);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = p[0] | ((uint32_t)p[1] << 8) |\n\t\t\t\t     ((uint32_t)p[2] << 16) |\n\t\t\t\t     ((uint32_t)p[3] << 24);\n\t\t\tbreak;\n\t\t}\n\t}\n\tval <<= k;\n\tval >>= k;\n\tb = nrbits & 7;\n\tp += nrbits >> 3;\n\t*addr = p;\n\t*pos = b;\n\tubifs_assert((val >> nrbits) == 0 || nrbits - b == 32);\n\treturn val;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "t8_t **ad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "233-273",
    "snippet": "ack_bits(uint8_t **addr, int *pos, uint32_t val, int nrbits)\n{\n\tuint8_t *p = *addr;\n\tint b = *pos;\n\n\tubifs_assert(nrbits > 0);\n\tubifs_assert(nrbits <= 32);\n\tubifs_assert(*pos >= 0);\n\tubifs_assert(*pos < 8);\n\tubifs_assert((val >> nrbits) == 0 || nrbits == 32);\n\tif (b) {\n\t\t*p |= ((uint8_t)val) << b;\n\t\tnrbits += b;\n\t\tif (nrbits > 8) {\n\t\t\t*++p = (uint8_t)(val >>= (8 - b));\n\t\t\tif (nrbits > 16) {\n\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\tif (nrbits > 24) {\n\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\t\tif (nrbits > 32)\n\t\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t*p = (uint8_t)val;\n\t\tif (nrbits > 8) {\n\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\tif (nrbits > 16) {\n\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\tif (nrbits > 24)\n\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t}\n\t\t}\n\t}\n\tb = nrbits & 7;\n\tif (b == 0)\n\t\tp++;\n\t*addr = p;\n\t*pos = b;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(val >> nrbi",
          "args": [
            "s) == 0 || nrbits == 32);\n\tif (b) {"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*pos < 8);",
          "args": [
            "bifs_ass"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*pos >= 0);",
          "args": [
            "ubifs_ass"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nrbits <= 32",
          "args": [
            ";\n\tubifs_ass"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nrbits > 0);",
          "args": [
            "ubifs_ass"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nack_bits(uint8_t **addr, int *pos, uint32_t val, int nrbits)\n{\n\tuint8_t *p = *addr;\n\tint b = *pos;\n\n\tubifs_assert(nrbits > 0);\n\tubifs_assert(nrbits <= 32);\n\tubifs_assert(*pos >= 0);\n\tubifs_assert(*pos < 8);\n\tubifs_assert((val >> nrbits) == 0 || nrbits == 32);\n\tif (b) {\n\t\t*p |= ((uint8_t)val) << b;\n\t\tnrbits += b;\n\t\tif (nrbits > 8) {\n\t\t\t*++p = (uint8_t)(val >>= (8 - b));\n\t\t\tif (nrbits > 16) {\n\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\tif (nrbits > 24) {\n\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\t\tif (nrbits > 32)\n\t\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t*p = (uint8_t)val;\n\t\tif (nrbits > 8) {\n\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\tif (nrbits > 16) {\n\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t\tif (nrbits > 24)\n\t\t\t\t\t*++p = (uint8_t)(val >>= 8);\n\t\t\t}\n\t\t}\n\t}\n\tb = nrbits & 7;\n\tif (b == 0)\n\t\tp++;\n\t*addr = p;\n\t*pos = b;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_geom(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "174-224",
    "snippet": "lc_dflt_lpt_geom(struct ubifs_info *c, int *main_lebs,\n\t\t\t      int *big_lpt)\n{\n\tint i, lebs_needed;\n\tlong long sz;\n\n\t/* Start by assuming the minimum number of LPT LEBs */\n\tc->lpt_lebs = UBIFS_MIN_LPT_LEBS;\n\tc->main_lebs = *main_lebs - c->lpt_lebs;\n\tif (c->main_lebs <= 0)\n\t\treturn -EINVAL;\n\n\t/* And assume we will use the small LPT model */\n\tc->big_lpt = 0;\n\n\t/*\n\t * Calculate the geometry based on assumptions above and then see if it\n\t * makes sense\n\t */\n\tdo_calc_lpt_geom(c);\n\n\t/* Small LPT model must have lpt_sz < leb_size */\n\tif (c->lpt_sz > c->leb_size) {\n\t\t/* Nope, so try again using big LPT model */\n\t\tc->big_lpt = 1;\n\t\tdo_calc_lpt_geom(c);\n\t}\n\n\t/* Now check there are enough LPT LEBs */\n\tfor (i = 0; i < 64 ; i++) {\n\t\tsz = c->lpt_sz * 4; /* Allow 4 times the size */\n\t\tlebs_needed = div_u64(sz + c->leb_size - 1, c->leb_size);\n\t\tif (lebs_needed > c->lpt_lebs) {\n\t\t\t/* Not enough LPT LEBs so try again with more */\n\t\t\tc->lpt_lebs = lebs_needed;\n\t\t\tc->main_lebs = *main_lebs - c->lpt_lebs;\n\t\t\tif (c->main_lebs <= 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tdo_calc_lpt_geom(c);\n\t\t\tcontinue;\n\t\t}\n\t\tif (c->ltab_sz > c->leb_size) {\n\t\t\tubifs_err(\"LPT ltab too big\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*main_lebs = c->main_lebs;\n\t\t*big_lpt = c->big_lpt;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * pack",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T ltab to",
          "args": [
            "big\");\n\t\t\treturn"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eom(c);\n\t\t\tconti",
          "args": [
            "u"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->leb_",
          "args": [
            "ize - 1, c->leb_size",
            "if (lebs"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eom(c);\n\t}\n\n\t/*",
          "args": [
            "o"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eom(c);\n\n\t/* Sma",
          "args": [
            "l"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlc_dflt_lpt_geom(struct ubifs_info *c, int *main_lebs,\n\t\t\t      int *big_lpt)\n{\n\tint i, lebs_needed;\n\tlong long sz;\n\n\t/* Start by assuming the minimum number of LPT LEBs */\n\tc->lpt_lebs = UBIFS_MIN_LPT_LEBS;\n\tc->main_lebs = *main_lebs - c->lpt_lebs;\n\tif (c->main_lebs <= 0)\n\t\treturn -EINVAL;\n\n\t/* And assume we will use the small LPT model */\n\tc->big_lpt = 0;\n\n\t/*\n\t * Calculate the geometry based on assumptions above and then see if it\n\t * makes sense\n\t */\n\tdo_calc_lpt_geom(c);\n\n\t/* Small LPT model must have lpt_sz < leb_size */\n\tif (c->lpt_sz > c->leb_size) {\n\t\t/* Nope, so try again using big LPT model */\n\t\tc->big_lpt = 1;\n\t\tdo_calc_lpt_geom(c);\n\t}\n\n\t/* Now check there are enough LPT LEBs */\n\tfor (i = 0; i < 64 ; i++) {\n\t\tsz = c->lpt_sz * 4; /* Allow 4 times the size */\n\t\tlebs_needed = div_u64(sz + c->leb_size - 1, c->leb_size);\n\t\tif (lebs_needed > c->lpt_lebs) {\n\t\t\t/* Not enough LPT LEBs so try again with more */\n\t\t\tc->lpt_lebs = lebs_needed;\n\t\t\tc->main_lebs = *main_lebs - c->lpt_lebs;\n\t\t\tif (c->main_lebs <= 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tdo_calc_lpt_geom(c);\n\t\t\tcontinue;\n\t\t}\n\t\tif (c->ltab_sz > c->leb_size) {\n\t\t\tubifs_err(\"LPT ltab too big\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*main_lebs = c->main_lebs;\n\t\t*big_lpt = c->big_lpt;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * pack"
  },
  {
    "function_name": "t_geom(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "137-160",
    "snippet": "c_lpt_geom(struct ubifs_info *c)\n{\n\tint lebs_needed;\n\tlong long sz;\n\n\tdo_calc_lpt_geom(c);\n\n\t/* Verify that lpt_lebs is big enough */\n\tsz = c->lpt_sz * 2; /* Must have at least 2 times the size */\n\tlebs_needed = div_u64(sz + c->leb_size - 1, c->leb_size);\n\tif (lebs_needed > c->lpt_lebs) {\n\t\tubifs_err(\"too few LPT LEBs\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Verify that ltab fits in a single LEB (since ltab is a single node */\n\tif (c->ltab_sz > c->leb_size) {\n\t\tubifs_err(\"LPT ltab too big\");\n\t\treturn -EINVAL;\n\t}\n\n\tc->check_lpt_free = c->big_lpt;\n\treturn 0;\n}\n\n/**\n * calc",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T ltab to",
          "args": [
            "big\");\n\t\treturn -"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o few LPT",
          "args": [
            "LEBs\");\n\t\treturn -"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->leb_",
          "args": [
            "ize - 1, c->leb_size",
            "if (lebs_"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eom(c);\n\n\t/* Ver",
          "args": [
            "f"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\nc_lpt_geom(struct ubifs_info *c)\n{\n\tint lebs_needed;\n\tlong long sz;\n\n\tdo_calc_lpt_geom(c);\n\n\t/* Verify that lpt_lebs is big enough */\n\tsz = c->lpt_sz * 2; /* Must have at least 2 times the size */\n\tlebs_needed = div_u64(sz + c->leb_size - 1, c->leb_size);\n\tif (lebs_needed > c->lpt_lebs) {\n\t\tubifs_err(\"too few LPT LEBs\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Verify that ltab fits in a single LEB (since ltab is a single node */\n\tif (c->ltab_sz > c->leb_size) {\n\t\tubifs_err(\"LPT ltab too big\");\n\t\treturn -EINVAL;\n\t}\n\n\tc->check_lpt_free = c->big_lpt;\n\treturn 0;\n}\n\n/**\n * calc"
  },
  {
    "function_name": "eom(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt.c",
    "lines": "58-129",
    "snippet": "o_calc_lpt_geom(struct ubifs_info *c)\n{\n\tint i, n, bits, per_leb_wastage, max_pnode_cnt;\n\tlong long sz, tot_wastage;\n\n\tn = c->main_lebs + c->max_leb_cnt - c->leb_cnt;\n\tmax_pnode_cnt = DIV_ROUND_UP(n, UBIFS_LPT_FANOUT);\n\n\tc->lpt_hght = 1;\n\tn = UBIFS_LPT_FANOUT;\n\twhile (n < max_pnode_cnt) {\n\t\tc->lpt_hght += 1;\n\t\tn <<= UBIFS_LPT_FANOUT_SHIFT;\n\t}\n\n\tc->pnode_cnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\n\tn = DIV_ROUND_UP(c->pnode_cnt, UBIFS_LPT_FANOUT);\n\tc->nnode_cnt = n;\n\tfor (i = 1; i < c->lpt_hght; i++) {\n\t\tn = DIV_ROUND_UP(n, UBIFS_LPT_FANOUT);\n\t\tc->nnode_cnt += n;\n\t}\n\n\tc->space_bits = fls(c->leb_size) - 3;\n\tc->lpt_lnum_bits = fls(c->lpt_lebs);\n\tc->lpt_offs_bits = fls(c->leb_size - 1);\n\tc->lpt_spc_bits = fls(c->leb_size);\n\n\tn = DIV_ROUND_UP(c->max_leb_cnt, UBIFS_LPT_FANOUT);\n\tc->pcnt_bits = fls(n - 1);\n\n\tc->lnum_bits = fls(c->max_leb_cnt - 1);\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       (c->big_lpt ? c->pcnt_bits : 0) +\n\t       (c->space_bits * 2 + 1) * UBIFS_LPT_FANOUT;\n\tc->pnode_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       (c->big_lpt ? c->pcnt_bits : 0) +\n\t       (c->lpt_lnum_bits + c->lpt_offs_bits) * UBIFS_LPT_FANOUT;\n\tc->nnode_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       c->lpt_lebs * c->lpt_spc_bits * 2;\n\tc->ltab_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       c->lnum_bits * c->lsave_cnt;\n\tc->lsave_sz = (bits + 7) / 8;\n\n\t/* Calculate the minimum LPT size */\n\tc->lpt_sz = (long long)c->pnode_cnt * c->pnode_sz;\n\tc->lpt_sz += (long long)c->nnode_cnt * c->nnode_sz;\n\tc->lpt_sz += c->ltab_sz;\n\tif (c->big_lpt)\n\t\tc->lpt_sz += c->lsave_sz;\n\n\t/* Add wastage */\n\tsz = c->lpt_sz;\n\tper_leb_wastage = max_t(int, c->pnode_sz, c->nnode_sz);\n\tsz += per_leb_wastage;\n\ttot_wastage = per_leb_wastage;\n\twhile (sz > c->leb_size) {\n\t\tsz += per_leb_wastage;\n\t\tsz -= c->leb_size;\n\t\ttot_wastage += per_leb_wastage;\n\t}\n\ttot_wastage += ALIGN(sz, c->min_io_size) - sz;\n\tc->lpt_sz += tot_wastage;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\n/**\n * do_ca",
      "ux/math64.h>\n#include <lin",
      "ux/crc16.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_i",
          "args": [
            "_s",
            "e) - sz;\n\tc->l"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">pnod",
          "args": [
            "_sz",
            "c->nnode_sz",
            "sz += per"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_c",
          "args": [
            "t - 1);\n\n\tbits = U"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "kiocb_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/aio.c",
          "lines": "499-518",
          "snippet": "static int kiocb_cancel(struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int kiocb_cancel(struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c-",
          "args": [
            "lnum_"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->max_leb_c",
          "args": [
            "t, UBIFS_LPT_F",
            "OUT);\n\tc->pcnt_b"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ze)",
          "args": [
            "n = DIV_"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ze",
          "args": [
            "1);\n\tc->lpt_sp"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "_size(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "1481-1553",
          "snippet": "over_size(struct ubifs_info *c)\n{\n\tstruct rb_node *this = rb_first(&c->size_tree);\n\n\twhile (this) {\n\t\tstruct size_entry *e;\n\t\tint err;\n\n\t\te = rb_entry(this, struct size_entry, rb);\n\t\tif (!e->exists) {\n\t\t\tunion ubifs_key key;\n\n\t\t\tino_key_init(c, &key, e->inum);\n\t\t\terr = ubifs_tnc_lookup(c, &key, c->sbuf);\n\t\t\tif (err && err != -ENOENT)\n\t\t\t\treturn err;\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t/* Remove data nodes that have no inode */\n\t\t\t\tdbg_rcvry(\"removing ino %lu\",\n\t\t\t\t\t  (unsigned long)e->inum);\n\t\t\t\terr = ubifs_tnc_remove_ino(c, e->inum);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tstruct ubifs_ino_node *ino = c->sbuf;\n\n\t\t\t\te->exists = 1;\n\t\t\t\te->i_size = le64_to_cpu(ino->size);\n\t\t\t}\n\t\t}\n\n\t\tif (e->exists && e->i_size < e->d_size) {\n\t\t\tif (c->ro_mount) {\n\t\t\t\t/* Fix the inode size and pin it in memory */\n\t\t\t\tstruct inode *inode;\n\t\t\t\tstruct ubifs_inode *ui;\n\n\t\t\t\tubifs_assert(!e->inode);\n\n\t\t\t\tinode = ubifs_iget(c->vfs_sb, e->inum);\n\t\t\t\tif (IS_ERR(inode))\n\t\t\t\t\treturn PTR_ERR(inode);\n\n\t\t\t\tui = ubifs_inode(inode);\n\t\t\t\tif (inode->i_size < e->d_size) {\n\t\t\t\t\tdbg_rcvry(\"ino %lu size %lld -> %lld\",\n\t\t\t\t\t\t  (unsigned long)e->inum,\n\t\t\t\t\t\t  inode->i_size, e->d_size);\n\t\t\t\t\tinode->i_size = e->d_size;\n\t\t\t\t\tui->ui_size = e->d_size;\n\t\t\t\t\tui->synced_i_size = e->d_size;\n\t\t\t\t\te->inode = inode;\n\t\t\t\t\tthis = rb_next(this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tiput(inode);\n\t\t\t} else {\n\t\t\t\t/* Fix the size in place */\n\t\t\t\terr = fix_size_in_place(c, e);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (e->inode)\n\t\t\t\t\tiput(e->inode);\n\t\t\t}\n\t\t}\n\n\t\tthis = rb_next(this);\n\t\trb_erase(&e->rb, &c->size_tree);\n\t\tkfree(e);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nover_size(struct ubifs_info *c)\n{\n\tstruct rb_node *this = rb_first(&c->size_tree);\n\n\twhile (this) {\n\t\tstruct size_entry *e;\n\t\tint err;\n\n\t\te = rb_entry(this, struct size_entry, rb);\n\t\tif (!e->exists) {\n\t\t\tunion ubifs_key key;\n\n\t\t\tino_key_init(c, &key, e->inum);\n\t\t\terr = ubifs_tnc_lookup(c, &key, c->sbuf);\n\t\t\tif (err && err != -ENOENT)\n\t\t\t\treturn err;\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t/* Remove data nodes that have no inode */\n\t\t\t\tdbg_rcvry(\"removing ino %lu\",\n\t\t\t\t\t  (unsigned long)e->inum);\n\t\t\t\terr = ubifs_tnc_remove_ino(c, e->inum);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tstruct ubifs_ino_node *ino = c->sbuf;\n\n\t\t\t\te->exists = 1;\n\t\t\t\te->i_size = le64_to_cpu(ino->size);\n\t\t\t}\n\t\t}\n\n\t\tif (e->exists && e->i_size < e->d_size) {\n\t\t\tif (c->ro_mount) {\n\t\t\t\t/* Fix the inode size and pin it in memory */\n\t\t\t\tstruct inode *inode;\n\t\t\t\tstruct ubifs_inode *ui;\n\n\t\t\t\tubifs_assert(!e->inode);\n\n\t\t\t\tinode = ubifs_iget(c->vfs_sb, e->inum);\n\t\t\t\tif (IS_ERR(inode))\n\t\t\t\t\treturn PTR_ERR(inode);\n\n\t\t\t\tui = ubifs_inode(inode);\n\t\t\t\tif (inode->i_size < e->d_size) {\n\t\t\t\t\tdbg_rcvry(\"ino %lu size %lld -> %lld\",\n\t\t\t\t\t\t  (unsigned long)e->inum,\n\t\t\t\t\t\t  inode->i_size, e->d_size);\n\t\t\t\t\tinode->i_size = e->d_size;\n\t\t\t\t\tui->ui_size = e->d_size;\n\t\t\t\t\tui->synced_i_size = e->d_size;\n\t\t\t\t\te->inode = inode;\n\t\t\t\t\tthis = rb_next(this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tiput(inode);\n\t\t\t} else {\n\t\t\t\t/* Fix the size in place */\n\t\t\t\terr = fix_size_in_place(c, e);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (e->inode)\n\t\t\t\t\tiput(e->inode);\n\t\t\t}\n\t\t}\n\n\t\tthis = rb_next(this);\n\t\trb_erase(&e->rb, &c->size_tree);\n\t\tkfree(e);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bs)",
          "args": [
            "c->lpt_of"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ze)",
          "args": [
            "- 3;\n\tc->lp"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, UBIFS_LPT",
          "args": [
            "F",
            "OUT);\n\t\tc->nnode"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->pnode_cnt",
          "args": [
            "UBIFS_LPT_F",
            "OUT);\n\tc->nnode_"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->main_lebs",
          "args": [
            "UBIFS_LPT_F",
            "OUT);\n\n\tn = DIV_"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, UBIFS_LPT",
          "args": [
            "F",
            "OUT);\n\n\tc->lpt_h"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\n/**\n * do_ca\nux/math64.h>\n#include <lin\nux/crc16.h>\n#include <lin\nfs.h\"\n#include <lin\n\no_calc_lpt_geom(struct ubifs_info *c)\n{\n\tint i, n, bits, per_leb_wastage, max_pnode_cnt;\n\tlong long sz, tot_wastage;\n\n\tn = c->main_lebs + c->max_leb_cnt - c->leb_cnt;\n\tmax_pnode_cnt = DIV_ROUND_UP(n, UBIFS_LPT_FANOUT);\n\n\tc->lpt_hght = 1;\n\tn = UBIFS_LPT_FANOUT;\n\twhile (n < max_pnode_cnt) {\n\t\tc->lpt_hght += 1;\n\t\tn <<= UBIFS_LPT_FANOUT_SHIFT;\n\t}\n\n\tc->pnode_cnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\n\n\tn = DIV_ROUND_UP(c->pnode_cnt, UBIFS_LPT_FANOUT);\n\tc->nnode_cnt = n;\n\tfor (i = 1; i < c->lpt_hght; i++) {\n\t\tn = DIV_ROUND_UP(n, UBIFS_LPT_FANOUT);\n\t\tc->nnode_cnt += n;\n\t}\n\n\tc->space_bits = fls(c->leb_size) - 3;\n\tc->lpt_lnum_bits = fls(c->lpt_lebs);\n\tc->lpt_offs_bits = fls(c->leb_size - 1);\n\tc->lpt_spc_bits = fls(c->leb_size);\n\n\tn = DIV_ROUND_UP(c->max_leb_cnt, UBIFS_LPT_FANOUT);\n\tc->pcnt_bits = fls(n - 1);\n\n\tc->lnum_bits = fls(c->max_leb_cnt - 1);\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       (c->big_lpt ? c->pcnt_bits : 0) +\n\t       (c->space_bits * 2 + 1) * UBIFS_LPT_FANOUT;\n\tc->pnode_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       (c->big_lpt ? c->pcnt_bits : 0) +\n\t       (c->lpt_lnum_bits + c->lpt_offs_bits) * UBIFS_LPT_FANOUT;\n\tc->nnode_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       c->lpt_lebs * c->lpt_spc_bits * 2;\n\tc->ltab_sz = (bits + 7) / 8;\n\n\tbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\n\t       c->lnum_bits * c->lsave_cnt;\n\tc->lsave_sz = (bits + 7) / 8;\n\n\t/* Calculate the minimum LPT size */\n\tc->lpt_sz = (long long)c->pnode_cnt * c->pnode_sz;\n\tc->lpt_sz += (long long)c->nnode_cnt * c->nnode_sz;\n\tc->lpt_sz += c->ltab_sz;\n\tif (c->big_lpt)\n\t\tc->lpt_sz += c->lsave_sz;\n\n\t/* Add wastage */\n\tsz = c->lpt_sz;\n\tper_leb_wastage = max_t(int, c->pnode_sz, c->nnode_sz);\n\tsz += per_leb_wastage;\n\ttot_wastage = per_leb_wastage;\n\twhile (sz > c->leb_size) {\n\t\tsz += per_leb_wastage;\n\t\tsz -= c->leb_size;\n\t\ttot_wastage += per_leb_wastage;\n\t}\n\ttot_wastage += ALIGN(sz, c->min_io_size) - sz;\n\tc->lpt_sz += tot_wastage;\n}\n\n/**\n * ubif"
  }
]