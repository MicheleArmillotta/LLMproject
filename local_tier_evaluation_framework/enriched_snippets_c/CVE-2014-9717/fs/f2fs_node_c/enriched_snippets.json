[
  {
    "function_name": "destroy_node_manager_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "2065-2070",
    "snippet": "void destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nat_entry_slab;",
      "static struct kmem_cache *free_nid_slab;",
      "static struct kmem_cache *nat_entry_set_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nat_entry_slab"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "free_nid_slab"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nat_entry_set_slab"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nvoid destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}"
  },
  {
    "function_name": "create_node_manager_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "2039-2063",
    "snippet": "int __init create_node_manager_caches(void)\n{\n\tnat_entry_slab = f2fs_kmem_cache_create(\"nat_entry\",\n\t\t\tsizeof(struct nat_entry));\n\tif (!nat_entry_slab)\n\t\tgoto fail;\n\n\tfree_nid_slab = f2fs_kmem_cache_create(\"free_nid\",\n\t\t\tsizeof(struct free_nid));\n\tif (!free_nid_slab)\n\t\tgoto destroy_nat_entry;\n\n\tnat_entry_set_slab = f2fs_kmem_cache_create(\"nat_entry_set\",\n\t\t\tsizeof(struct nat_entry_set));\n\tif (!nat_entry_set_slab)\n\t\tgoto destroy_free_nid;\n\treturn 0;\n\ndestroy_free_nid:\n\tkmem_cache_destroy(free_nid_slab);\ndestroy_nat_entry:\n\tkmem_cache_destroy(nat_entry_slab);\nfail:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nat_entry_slab;",
      "static struct kmem_cache *free_nid_slab;",
      "static struct kmem_cache *nat_entry_set_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nat_entry_slab"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "free_nid_slab"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_create",
          "args": [
            "\"nat_entry_set\"",
            "sizeof(struct nat_entry_set)"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1058-1062",
          "snippet": "static inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nint __init create_node_manager_caches(void)\n{\n\tnat_entry_slab = f2fs_kmem_cache_create(\"nat_entry\",\n\t\t\tsizeof(struct nat_entry));\n\tif (!nat_entry_slab)\n\t\tgoto fail;\n\n\tfree_nid_slab = f2fs_kmem_cache_create(\"free_nid\",\n\t\t\tsizeof(struct free_nid));\n\tif (!free_nid_slab)\n\t\tgoto destroy_nat_entry;\n\n\tnat_entry_set_slab = f2fs_kmem_cache_create(\"nat_entry_set\",\n\t\t\tsizeof(struct nat_entry_set));\n\tif (!nat_entry_set_slab)\n\t\tgoto destroy_free_nid;\n\treturn 0;\n\ndestroy_free_nid:\n\tkmem_cache_destroy(free_nid_slab);\ndestroy_nat_entry:\n\tkmem_cache_destroy(nat_entry_slab);\nfail:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "destroy_node_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1981-2037",
    "snippet": "void destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tstruct nat_entry *natvec[NATVEC_SIZE];\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t/* destroy free nid list */\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->free_nid_list, list) {\n\t\tf2fs_bug_on(sbi, i->state == NID_ALLOC);\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->free_nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->fcnt);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\t/* destroy nat cache */\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NATVEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt);\n\n\t/* destroy nat set cache */\n\tnid = 0;\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t/* entry_cnt is not zero, when cp_error was occurred */\n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\n\tkfree(nm_i->nat_bitmap);\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *free_nid_slab;",
      "static struct kmem_cache *nat_entry_set_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nm_i"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nm_i->nat_bitmap"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nat_entry_set_slab",
            "setvec[idx]"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&nm_i->nat_set_root",
            "setvec[idx]->set"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "!list_empty(&setvec[idx]->entry_list)"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&setvec[idx]->entry_list"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gang_lookup_nat_set",
          "args": [
            "nm_i",
            "nid",
            "SETVEC_SIZE",
            "setvec"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "__gang_lookup_nat_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "184-189",
          "snippet": "static unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "nm_i->nat_cnt"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__del_from_nat_cache",
          "args": [
            "nm_i",
            "natvec[idx]"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "__del_from_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "136-142",
          "snippet": "static void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tlist_del(&e->list);\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt--;\n\tkmem_cache_free(nat_entry_slab, e);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\n\nstatic void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tlist_del(&e->list);\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt--;\n\tkmem_cache_free(nat_entry_slab, e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nat_get_nid",
          "args": [
            "natvec[found - 1]"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gang_lookup_nat_cache",
          "args": [
            "nm_i",
            "nid",
            "NATVEC_SIZE",
            "natvec"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "__gang_lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "130-134",
          "snippet": "static unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_root, (void **)ep, start, nr);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_root, (void **)ep, start, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "nm_i->fcnt"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "free_nid_slab",
            "i"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__del_from_free_nid_list",
          "args": [
            "nm_i",
            "i"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "__del_from_free_nid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1397-1402",
          "snippet": "static void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "i->state == NID_ALLOC"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "i",
            "next_i",
            "&nm_i->free_nid_list",
            "list"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nvoid destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tstruct nat_entry *natvec[NATVEC_SIZE];\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t/* destroy free nid list */\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->free_nid_list, list) {\n\t\tf2fs_bug_on(sbi, i->state == NID_ALLOC);\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->free_nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->fcnt);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\t/* destroy nat cache */\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NATVEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt);\n\n\t/* destroy nat set cache */\n\tnid = 0;\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t/* entry_cnt is not zero, when cp_error was occurred */\n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\n\tkfree(nm_i->nat_bitmap);\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}"
  },
  {
    "function_name": "build_node_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1965-1979",
    "snippet": "int build_node_manager(struct f2fs_sb_info *sbi)\n{\n\tint err;\n\n\tsbi->nm_info = kzalloc(sizeof(struct f2fs_nm_info), GFP_KERNEL);\n\tif (!sbi->nm_info)\n\t\treturn -ENOMEM;\n\n\terr = init_node_manager(sbi);\n\tif (err)\n\t\treturn err;\n\n\tbuild_free_nids(sbi);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "build_free_nids",
          "args": [
            "sbi"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "build_free_nids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1496-1539",
          "snippet": "static void build_free_nids(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\t/* Enough entries */\n\tif (nm_i->fcnt > NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\t/* readahead nat pages to be scanned */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES, META_NAT);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\tscan_nat_page(sbi, page, nid);\n\t\tf2fs_put_page(page, 1);\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (i++ == FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* go to the next free nat pages to find free nids abundantly */\n\tnm_i->next_scan_nid = nid;\n\n\t/* find free nids from current sum_pages */\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tblock_t addr = le32_to_cpu(nat_in_journal(sum, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(sum, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(nm_i, nid);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void build_free_nids(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\t/* Enough entries */\n\tif (nm_i->fcnt > NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\t/* readahead nat pages to be scanned */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES, META_NAT);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\tscan_nat_page(sbi, page, nid);\n\t\tf2fs_put_page(page, 1);\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (i++ == FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* go to the next free nat pages to find free nids abundantly */\n\tnm_i->next_scan_nid = nid;\n\n\t/* find free nids from current sum_pages */\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tblock_t addr = le32_to_cpu(nat_in_journal(sum, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(sum, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(nm_i, nid);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_node_manager",
          "args": [
            "sbi"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "init_node_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1921-1963",
          "snippet": "static int init_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *sb_raw = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned char *version_bitmap;\n\tunsigned int nat_segs, nat_blocks;\n\n\tnm_i->nat_blkaddr = le32_to_cpu(sb_raw->nat_blkaddr);\n\n\t/* segment_count_nat includes pair segment so divide to 2. */\n\tnat_segs = le32_to_cpu(sb_raw->segment_count_nat) >> 1;\n\tnat_blocks = nat_segs << le32_to_cpu(sb_raw->log_blocks_per_seg);\n\n\tnm_i->max_nid = NAT_ENTRY_PER_BLOCK * nat_blocks;\n\n\t/* not used nids: 0, node, meta, (and root counted as valid node) */\n\tnm_i->available_nids = nm_i->max_nid - F2FS_RESERVED_NODE_NUM;\n\tnm_i->fcnt = 0;\n\tnm_i->nat_cnt = 0;\n\tnm_i->ram_thresh = DEF_RAM_THRESHOLD;\n\n\tINIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&nm_i->free_nid_list);\n\tINIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);\n\tINIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);\n\tINIT_LIST_HEAD(&nm_i->nat_entries);\n\n\tmutex_init(&nm_i->build_lock);\n\tspin_lock_init(&nm_i->free_nid_list_lock);\n\tinit_rwsem(&nm_i->nat_tree_lock);\n\n\tnm_i->next_scan_nid = le32_to_cpu(sbi->ckpt->next_free_nid);\n\tnm_i->bitmap_size = __bitmap_size(sbi, NAT_BITMAP);\n\tversion_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);\n\tif (!version_bitmap)\n\t\treturn -EFAULT;\n\n\tnm_i->nat_bitmap = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int init_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *sb_raw = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned char *version_bitmap;\n\tunsigned int nat_segs, nat_blocks;\n\n\tnm_i->nat_blkaddr = le32_to_cpu(sb_raw->nat_blkaddr);\n\n\t/* segment_count_nat includes pair segment so divide to 2. */\n\tnat_segs = le32_to_cpu(sb_raw->segment_count_nat) >> 1;\n\tnat_blocks = nat_segs << le32_to_cpu(sb_raw->log_blocks_per_seg);\n\n\tnm_i->max_nid = NAT_ENTRY_PER_BLOCK * nat_blocks;\n\n\t/* not used nids: 0, node, meta, (and root counted as valid node) */\n\tnm_i->available_nids = nm_i->max_nid - F2FS_RESERVED_NODE_NUM;\n\tnm_i->fcnt = 0;\n\tnm_i->nat_cnt = 0;\n\tnm_i->ram_thresh = DEF_RAM_THRESHOLD;\n\n\tINIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&nm_i->free_nid_list);\n\tINIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);\n\tINIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);\n\tINIT_LIST_HEAD(&nm_i->nat_entries);\n\n\tmutex_init(&nm_i->build_lock);\n\tspin_lock_init(&nm_i->free_nid_list_lock);\n\tinit_rwsem(&nm_i->nat_tree_lock);\n\n\tnm_i->next_scan_nid = le32_to_cpu(sbi->ckpt->next_free_nid);\n\tnm_i->bitmap_size = __bitmap_size(sbi, NAT_BITMAP);\n\tversion_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);\n\tif (!version_bitmap)\n\t\treturn -EFAULT;\n\n\tnm_i->nat_bitmap = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct f2fs_nm_info)",
            "GFP_KERNEL"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint build_node_manager(struct f2fs_sb_info *sbi)\n{\n\tint err;\n\n\tsbi->nm_info = kzalloc(sizeof(struct f2fs_nm_info), GFP_KERNEL);\n\tif (!sbi->nm_info)\n\t\treturn -ENOMEM;\n\n\terr = init_node_manager(sbi);\n\tif (err)\n\t\treturn err;\n\n\tbuild_free_nids(sbi);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_node_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1921-1963",
    "snippet": "static int init_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *sb_raw = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned char *version_bitmap;\n\tunsigned int nat_segs, nat_blocks;\n\n\tnm_i->nat_blkaddr = le32_to_cpu(sb_raw->nat_blkaddr);\n\n\t/* segment_count_nat includes pair segment so divide to 2. */\n\tnat_segs = le32_to_cpu(sb_raw->segment_count_nat) >> 1;\n\tnat_blocks = nat_segs << le32_to_cpu(sb_raw->log_blocks_per_seg);\n\n\tnm_i->max_nid = NAT_ENTRY_PER_BLOCK * nat_blocks;\n\n\t/* not used nids: 0, node, meta, (and root counted as valid node) */\n\tnm_i->available_nids = nm_i->max_nid - F2FS_RESERVED_NODE_NUM;\n\tnm_i->fcnt = 0;\n\tnm_i->nat_cnt = 0;\n\tnm_i->ram_thresh = DEF_RAM_THRESHOLD;\n\n\tINIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&nm_i->free_nid_list);\n\tINIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);\n\tINIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);\n\tINIT_LIST_HEAD(&nm_i->nat_entries);\n\n\tmutex_init(&nm_i->build_lock);\n\tspin_lock_init(&nm_i->free_nid_list_lock);\n\tinit_rwsem(&nm_i->nat_tree_lock);\n\n\tnm_i->next_scan_nid = le32_to_cpu(sbi->ckpt->next_free_nid);\n\tnm_i->bitmap_size = __bitmap_size(sbi, NAT_BITMAP);\n\tversion_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);\n\tif (!version_bitmap)\n\t\treturn -EFAULT;\n\n\tnm_i->nat_bitmap = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "version_bitmap",
            "nm_i->bitmap_size",
            "GFP_KERNEL"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bitmap_ptr",
          "args": [
            "sbi",
            "NAT_BITMAP"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "923-938",
          "snippet": "static inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tint offset;\n\n\tif (le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload) > 0) {\n\t\tif (flag == NAT_BITMAP)\n\t\t\treturn &ckpt->sit_nat_version_bitmap;\n\t\telse\n\t\t\treturn (unsigned char *)ckpt + F2FS_BLKSIZE;\n\t} else {\n\t\toffset = (flag == NAT_BITMAP) ?\n\t\t\tle32_to_cpu(ckpt->sit_ver_bitmap_bytesize) : 0;\n\t\treturn &ckpt->sit_nat_version_bitmap + offset;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tint offset;\n\n\tif (le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload) > 0) {\n\t\tif (flag == NAT_BITMAP)\n\t\t\treturn &ckpt->sit_nat_version_bitmap;\n\t\telse\n\t\t\treturn (unsigned char *)ckpt + F2FS_BLKSIZE;\n\t} else {\n\t\toffset = (flag == NAT_BITMAP) ?\n\t\t\tle32_to_cpu(ckpt->sit_ver_bitmap_bytesize) : 0;\n\t\treturn &ckpt->sit_nat_version_bitmap + offset;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bitmap_size",
          "args": [
            "sbi",
            "NAT_BITMAP"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "__bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "910-921",
          "snippet": "static inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\t/* return NAT or SIT bitmap */\n\tif (flag == NAT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);\n\telse if (flag == SIT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\t/* return NAT or SIT bitmap */\n\tif (flag == NAT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);\n\telse if (flag == SIT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->ckpt->next_free_nid"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&nm_i->build_lock"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nm_i->nat_entries"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&nm_i->nat_set_root",
            "GFP_NOIO"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&nm_i->nat_root",
            "GFP_NOIO"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nm_i->free_nid_list"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&nm_i->free_nid_root",
            "GFP_ATOMIC"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_RAW_SUPER",
          "args": [
            "sbi"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_RAW_SUPER",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "660-663",
          "snippet": "static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int init_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *sb_raw = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned char *version_bitmap;\n\tunsigned int nat_segs, nat_blocks;\n\n\tnm_i->nat_blkaddr = le32_to_cpu(sb_raw->nat_blkaddr);\n\n\t/* segment_count_nat includes pair segment so divide to 2. */\n\tnat_segs = le32_to_cpu(sb_raw->segment_count_nat) >> 1;\n\tnat_blocks = nat_segs << le32_to_cpu(sb_raw->log_blocks_per_seg);\n\n\tnm_i->max_nid = NAT_ENTRY_PER_BLOCK * nat_blocks;\n\n\t/* not used nids: 0, node, meta, (and root counted as valid node) */\n\tnm_i->available_nids = nm_i->max_nid - F2FS_RESERVED_NODE_NUM;\n\tnm_i->fcnt = 0;\n\tnm_i->nat_cnt = 0;\n\tnm_i->ram_thresh = DEF_RAM_THRESHOLD;\n\n\tINIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&nm_i->free_nid_list);\n\tINIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);\n\tINIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);\n\tINIT_LIST_HEAD(&nm_i->nat_entries);\n\n\tmutex_init(&nm_i->build_lock);\n\tspin_lock_init(&nm_i->free_nid_list_lock);\n\tinit_rwsem(&nm_i->nat_tree_lock);\n\n\tnm_i->next_scan_nid = le32_to_cpu(sbi->ckpt->next_free_nid);\n\tnm_i->bitmap_size = __bitmap_size(sbi, NAT_BITMAP);\n\tversion_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);\n\tif (!version_bitmap)\n\t\treturn -EFAULT;\n\n\tnm_i->nat_bitmap = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_nat_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1884-1919",
    "snippet": "void flush_nat_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tstruct nat_entry_set *set, *tmp;\n\tunsigned int found;\n\tnid_t set_idx = 0;\n\tLIST_HEAD(sets);\n\n\tif (!nm_i->dirty_nat_cnt)\n\t\treturn;\n\t/*\n\t * if there are no enough space in journal to store dirty nat\n\t * entries, remove all entries from journal and merge them\n\t * into nat entry set.\n\t */\n\tif (!__has_cursum_space(sum, nm_i->dirty_nat_cnt, NAT_JOURNAL))\n\t\tremove_nats_in_journal(sbi);\n\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tset_idx, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\t\tset_idx = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__adjust_nat_entry_set(setvec[idx], &sets,\n\t\t\t\t\t\t\tMAX_NAT_JENTRIES(sum));\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(set, tmp, &sets, set_list)\n\t\t__flush_nat_entry_set(sbi, set);\n\n\tf2fs_bug_on(sbi, nm_i->dirty_nat_cnt);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "nm_i->dirty_nat_cnt"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__flush_nat_entry_set",
          "args": [
            "sbi",
            "set"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_nat_entry_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1814-1879",
          "snippet": "static void __flush_nat_entry_set(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct nat_entry_set *set)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = set->set * NAT_ENTRY_PER_BLOCK;\n\tbool to_journal = true;\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct nat_entry *ne, *cur;\n\tstruct page *page = NULL;\n\n\t/*\n\t * there are two steps to flush nat entries:\n\t * #1, flush nat entries to journal in current hot data summary block.\n\t * #2, flush nat entries to nat page.\n\t */\n\tif (!__has_cursum_space(sum, set->entry_cnt, NAT_JOURNAL))\n\t\tto_journal = false;\n\n\tif (to_journal) {\n\t\tmutex_lock(&curseg->curseg_mutex);\n\t} else {\n\t\tpage = get_next_nat_page(sbi, start_nid);\n\t\tnat_blk = page_address(page);\n\t\tf2fs_bug_on(sbi, !nat_blk);\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(ne, cur, &set->entry_list, list) {\n\t\tstruct f2fs_nat_entry *raw_ne;\n\t\tnid_t nid = nat_get_nid(ne);\n\t\tint offset;\n\n\t\tif (nat_get_blkaddr(ne) == NEW_ADDR)\n\t\t\tcontinue;\n\n\t\tif (to_journal) {\n\t\t\toffset = lookup_journal_in_cursum(sum,\n\t\t\t\t\t\t\tNAT_JOURNAL, nid, 1);\n\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\traw_ne = &nat_in_journal(sum, offset);\n\t\t\tnid_in_journal(sum, offset) = cpu_to_le32(nid);\n\t\t} else {\n\t\t\traw_ne = &nat_blk->entries[nid - start_nid];\n\t\t}\n\t\traw_nat_from_node_info(raw_ne, &ne->ni);\n\n\t\tdown_write(&NM_I(sbi)->nat_tree_lock);\n\t\tnat_reset_flag(ne);\n\t\t__clear_nat_cache_dirty(NM_I(sbi), ne);\n\t\tup_write(&NM_I(sbi)->nat_tree_lock);\n\n\t\tif (nat_get_blkaddr(ne) == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, false);\n\t}\n\n\tif (to_journal)\n\t\tmutex_unlock(&curseg->curseg_mutex);\n\telse\n\t\tf2fs_put_page(page, 1);\n\n\tf2fs_bug_on(sbi, set->entry_cnt);\n\n\tradix_tree_delete(&NM_I(sbi)->nat_set_root, set->set);\n\tkmem_cache_free(nat_entry_set_slab, set);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_set_slab;\n\nstatic void __flush_nat_entry_set(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct nat_entry_set *set)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = set->set * NAT_ENTRY_PER_BLOCK;\n\tbool to_journal = true;\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct nat_entry *ne, *cur;\n\tstruct page *page = NULL;\n\n\t/*\n\t * there are two steps to flush nat entries:\n\t * #1, flush nat entries to journal in current hot data summary block.\n\t * #2, flush nat entries to nat page.\n\t */\n\tif (!__has_cursum_space(sum, set->entry_cnt, NAT_JOURNAL))\n\t\tto_journal = false;\n\n\tif (to_journal) {\n\t\tmutex_lock(&curseg->curseg_mutex);\n\t} else {\n\t\tpage = get_next_nat_page(sbi, start_nid);\n\t\tnat_blk = page_address(page);\n\t\tf2fs_bug_on(sbi, !nat_blk);\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(ne, cur, &set->entry_list, list) {\n\t\tstruct f2fs_nat_entry *raw_ne;\n\t\tnid_t nid = nat_get_nid(ne);\n\t\tint offset;\n\n\t\tif (nat_get_blkaddr(ne) == NEW_ADDR)\n\t\t\tcontinue;\n\n\t\tif (to_journal) {\n\t\t\toffset = lookup_journal_in_cursum(sum,\n\t\t\t\t\t\t\tNAT_JOURNAL, nid, 1);\n\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\traw_ne = &nat_in_journal(sum, offset);\n\t\t\tnid_in_journal(sum, offset) = cpu_to_le32(nid);\n\t\t} else {\n\t\t\traw_ne = &nat_blk->entries[nid - start_nid];\n\t\t}\n\t\traw_nat_from_node_info(raw_ne, &ne->ni);\n\n\t\tdown_write(&NM_I(sbi)->nat_tree_lock);\n\t\tnat_reset_flag(ne);\n\t\t__clear_nat_cache_dirty(NM_I(sbi), ne);\n\t\tup_write(&NM_I(sbi)->nat_tree_lock);\n\n\t\tif (nat_get_blkaddr(ne) == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, false);\n\t}\n\n\tif (to_journal)\n\t\tmutex_unlock(&curseg->curseg_mutex);\n\telse\n\t\tf2fs_put_page(page, 1);\n\n\tf2fs_bug_on(sbi, set->entry_cnt);\n\n\tradix_tree_delete(&NM_I(sbi)->nat_set_root, set->set);\n\tkmem_cache_free(nat_entry_set_slab, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "set",
            "tmp",
            "&sets",
            "set_list"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__adjust_nat_entry_set",
          "args": [
            "setvec[idx]",
            "&sets",
            "MAX_NAT_JENTRIES(sum)"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "__adjust_nat_entry_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1796-1812",
          "snippet": "static void __adjust_nat_entry_set(struct nat_entry_set *nes,\n\t\t\t\t\t\tstruct list_head *head, int max)\n{\n\tstruct nat_entry_set *cur;\n\n\tif (nes->entry_cnt >= max)\n\t\tgoto add_out;\n\n\tlist_for_each_entry(cur, head, set_list) {\n\t\tif (cur->entry_cnt >= nes->entry_cnt) {\n\t\t\tlist_add(&nes->set_list, cur->set_list.prev);\n\t\t\treturn;\n\t\t}\n\t}\nadd_out:\n\tlist_add_tail(&nes->set_list, head);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __adjust_nat_entry_set(struct nat_entry_set *nes,\n\t\t\t\t\t\tstruct list_head *head, int max)\n{\n\tstruct nat_entry_set *cur;\n\n\tif (nes->entry_cnt >= max)\n\t\tgoto add_out;\n\n\tlist_for_each_entry(cur, head, set_list) {\n\t\tif (cur->entry_cnt >= nes->entry_cnt) {\n\t\t\tlist_add(&nes->set_list, cur->set_list.prev);\n\t\t\treturn;\n\t\t}\n\t}\nadd_out:\n\tlist_add_tail(&nes->set_list, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_NAT_JENTRIES",
          "args": [
            "sum"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gang_lookup_nat_set",
          "args": [
            "nm_i",
            "set_idx",
            "SETVEC_SIZE",
            "setvec"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "__gang_lookup_nat_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "184-189",
          "snippet": "static unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_nats_in_journal",
          "args": [
            "sbi"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "remove_nats_in_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1768-1794",
          "snippet": "static void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i;\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(sum, i));\n\n\t\traw_ne = nat_in_journal(sum, i);\n\n\t\tdown_write(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = grab_nat_entry(nm_i, nid);\n\t\t\tnode_info_from_raw_nat(&ne->ni, &raw_ne);\n\t\t}\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t\tup_write(&nm_i->nat_tree_lock);\n\t}\n\tupdate_nats_in_cursum(sum, -i);\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i;\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(sum, i));\n\n\t\traw_ne = nat_in_journal(sum, i);\n\n\t\tdown_write(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = grab_nat_entry(nm_i, nid);\n\t\t\tnode_info_from_raw_nat(&ne->ni, &raw_ne);\n\t\t}\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t\tup_write(&nm_i->nat_tree_lock);\n\t}\n\tupdate_nats_in_cursum(sum, -i);\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__has_cursum_space",
          "args": [
            "sum",
            "nm_i->dirty_nat_cnt",
            "NAT_JOURNAL"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "__has_cursum_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "197-203",
          "snippet": "static inline bool __has_cursum_space(struct f2fs_summary_block *sum, int size,\n\t\t\t\t\t\t\t\tint type)\n{\n\tif (type == NAT_JOURNAL)\n\t\treturn size <= MAX_NAT_JENTRIES(sum);\n\treturn size <= MAX_SIT_JENTRIES(sum);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool __has_cursum_space(struct f2fs_summary_block *sum, int size,\n\t\t\t\t\t\t\t\tint type)\n{\n\tif (type == NAT_JOURNAL)\n\t\treturn size <= MAX_NAT_JENTRIES(sum);\n\treturn size <= MAX_SIT_JENTRIES(sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "sets"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_HOT_DATA"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid flush_nat_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tstruct nat_entry_set *set, *tmp;\n\tunsigned int found;\n\tnid_t set_idx = 0;\n\tLIST_HEAD(sets);\n\n\tif (!nm_i->dirty_nat_cnt)\n\t\treturn;\n\t/*\n\t * if there are no enough space in journal to store dirty nat\n\t * entries, remove all entries from journal and merge them\n\t * into nat entry set.\n\t */\n\tif (!__has_cursum_space(sum, nm_i->dirty_nat_cnt, NAT_JOURNAL))\n\t\tremove_nats_in_journal(sbi);\n\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tset_idx, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\t\tset_idx = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__adjust_nat_entry_set(setvec[idx], &sets,\n\t\t\t\t\t\t\tMAX_NAT_JENTRIES(sum));\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(set, tmp, &sets, set_list)\n\t\t__flush_nat_entry_set(sbi, set);\n\n\tf2fs_bug_on(sbi, nm_i->dirty_nat_cnt);\n}"
  },
  {
    "function_name": "__flush_nat_entry_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1814-1879",
    "snippet": "static void __flush_nat_entry_set(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct nat_entry_set *set)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = set->set * NAT_ENTRY_PER_BLOCK;\n\tbool to_journal = true;\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct nat_entry *ne, *cur;\n\tstruct page *page = NULL;\n\n\t/*\n\t * there are two steps to flush nat entries:\n\t * #1, flush nat entries to journal in current hot data summary block.\n\t * #2, flush nat entries to nat page.\n\t */\n\tif (!__has_cursum_space(sum, set->entry_cnt, NAT_JOURNAL))\n\t\tto_journal = false;\n\n\tif (to_journal) {\n\t\tmutex_lock(&curseg->curseg_mutex);\n\t} else {\n\t\tpage = get_next_nat_page(sbi, start_nid);\n\t\tnat_blk = page_address(page);\n\t\tf2fs_bug_on(sbi, !nat_blk);\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(ne, cur, &set->entry_list, list) {\n\t\tstruct f2fs_nat_entry *raw_ne;\n\t\tnid_t nid = nat_get_nid(ne);\n\t\tint offset;\n\n\t\tif (nat_get_blkaddr(ne) == NEW_ADDR)\n\t\t\tcontinue;\n\n\t\tif (to_journal) {\n\t\t\toffset = lookup_journal_in_cursum(sum,\n\t\t\t\t\t\t\tNAT_JOURNAL, nid, 1);\n\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\traw_ne = &nat_in_journal(sum, offset);\n\t\t\tnid_in_journal(sum, offset) = cpu_to_le32(nid);\n\t\t} else {\n\t\t\traw_ne = &nat_blk->entries[nid - start_nid];\n\t\t}\n\t\traw_nat_from_node_info(raw_ne, &ne->ni);\n\n\t\tdown_write(&NM_I(sbi)->nat_tree_lock);\n\t\tnat_reset_flag(ne);\n\t\t__clear_nat_cache_dirty(NM_I(sbi), ne);\n\t\tup_write(&NM_I(sbi)->nat_tree_lock);\n\n\t\tif (nat_get_blkaddr(ne) == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, false);\n\t}\n\n\tif (to_journal)\n\t\tmutex_unlock(&curseg->curseg_mutex);\n\telse\n\t\tf2fs_put_page(page, 1);\n\n\tf2fs_bug_on(sbi, set->entry_cnt);\n\n\tradix_tree_delete(&NM_I(sbi)->nat_set_root, set->set);\n\tkmem_cache_free(nat_entry_set_slab, set);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nat_entry_set_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nat_entry_set_slab",
            "set"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&NM_I(sbi)->nat_set_root",
            "set->set"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "set->entry_cnt"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_free_nid",
          "args": [
            "sbi",
            "nid",
            "false"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "add_free_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1404-1452",
          "snippet": "static int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tbool allocated = false;\n\n\tif (!available_free_memory(sbi, FREE_NIDS))\n\t\treturn -1;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn 0;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tdown_read(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne &&\n\t\t\t(!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tallocated = true;\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tif (allocated)\n\t\t\treturn 0;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tradix_tree_preload_end();\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\tnm_i->fcnt++;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\tradix_tree_preload_end();\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nstatic int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tbool allocated = false;\n\n\tif (!available_free_memory(sbi, FREE_NIDS))\n\t\treturn -1;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn 0;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tdown_read(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne &&\n\t\t\t(!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tallocated = true;\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tif (allocated)\n\t\t\treturn 0;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tradix_tree_preload_end();\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\tnm_i->fcnt++;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\tradix_tree_preload_end();\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "ne"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&NM_I(sbi)->nat_tree_lock"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_nat_cache_dirty",
          "args": [
            "NM_I(sbi)",
            "ne"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_nat_cache_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "169-182",
          "snippet": "static void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (head) {\n\t\tlist_move_tail(&ne->list, &nm_i->nat_entries);\n\t\tset_nat_flag(ne, IS_DIRTY, false);\n\t\thead->entry_cnt--;\n\t\tnm_i->dirty_nat_cnt--;\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (head) {\n\t\tlist_move_tail(&ne->list, &nm_i->nat_entries);\n\t\tset_nat_flag(ne, IS_DIRTY, false);\n\t\thead->entry_cnt--;\n\t\tnm_i->dirty_nat_cnt--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nat_reset_flag",
          "args": [
            "ne"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "nat_reset_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "94-100",
          "snippet": "static inline void nat_reset_flag(struct nat_entry *ne)\n{\n\t/* these states can be set only after checkpoint was done */\n\tset_nat_flag(ne, IS_CHECKPOINTED, true);\n\tset_nat_flag(ne, HAS_FSYNCED_INODE, false);\n\tset_nat_flag(ne, HAS_LAST_FSYNC, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void nat_reset_flag(struct nat_entry *ne)\n{\n\t/* these states can be set only after checkpoint was done */\n\tset_nat_flag(ne, IS_CHECKPOINTED, true);\n\tset_nat_flag(ne, HAS_FSYNCED_INODE, false);\n\tset_nat_flag(ne, HAS_LAST_FSYNC, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&NM_I(sbi)->nat_tree_lock"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_nat_from_node_info",
          "args": [
            "raw_ne",
            "&ne->ni"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "raw_nat_from_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "110-116",
          "snippet": "static inline void raw_nat_from_node_info(struct f2fs_nat_entry *raw_ne,\n\t\t\t\t\t\tstruct node_info *ni)\n{\n\traw_ne->ino = cpu_to_le32(ni->ino);\n\traw_ne->block_addr = cpu_to_le32(ni->blk_addr);\n\traw_ne->version = ni->version;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void raw_nat_from_node_info(struct f2fs_nat_entry *raw_ne,\n\t\t\t\t\t\tstruct node_info *ni)\n{\n\traw_ne->ino = cpu_to_le32(ni->ino);\n\traw_ne->block_addr = cpu_to_le32(ni->blk_addr);\n\traw_ne->version = ni->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nid"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nid_in_journal",
          "args": [
            "sum",
            "offset"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_in_journal",
          "args": [
            "sum",
            "offset"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "offset < 0"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_journal_in_cursum",
          "args": [
            "sum",
            "NAT_JOURNAL",
            "nid",
            "1"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_journal_in_cursum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1578-1598",
          "snippet": "int lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && nats_in_cursum(sum) < NAT_JOURNAL_ENTRIES)\n\t\t\treturn update_nats_in_cursum(sum, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(sum); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && sits_in_cursum(sum) < SIT_JOURNAL_ENTRIES)\n\t\t\treturn update_sits_in_cursum(sum, 1);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && nats_in_cursum(sum) < NAT_JOURNAL_ENTRIES)\n\t\t\treturn update_nats_in_cursum(sum, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(sum); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && sits_in_cursum(sum) < SIT_JOURNAL_ENTRIES)\n\t\t\treturn update_sits_in_cursum(sum, 1);\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "ne"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_nid",
          "args": [
            "ne"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ne",
            "cur",
            "&set->entry_list",
            "list"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "!nat_blk"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_nat_page",
          "args": [
            "sbi",
            "start_nid"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_nat_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "96-123",
          "snippet": "static struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *src_page;\n\tstruct page *dst_page;\n\tpgoff_t src_off;\n\tpgoff_t dst_off;\n\tvoid *src_addr;\n\tvoid *dst_addr;\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tsrc_off = current_nat_addr(sbi, nid);\n\tdst_off = next_nat_addr(sbi, src_off);\n\n\t/* get current nat block page with lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_CACHE_SIZE);\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_nat(nm_i, nid);\n\n\treturn dst_page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *src_page;\n\tstruct page *dst_page;\n\tpgoff_t src_off;\n\tpgoff_t dst_off;\n\tvoid *src_addr;\n\tvoid *dst_addr;\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tsrc_off = current_nat_addr(sbi, nid);\n\tdst_off = next_nat_addr(sbi, src_off);\n\n\t/* get current nat block page with lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_CACHE_SIZE);\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_nat(nm_i, nid);\n\n\treturn dst_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__has_cursum_space",
          "args": [
            "sum",
            "set->entry_cnt",
            "NAT_JOURNAL"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "__has_cursum_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "197-203",
          "snippet": "static inline bool __has_cursum_space(struct f2fs_summary_block *sum, int size,\n\t\t\t\t\t\t\t\tint type)\n{\n\tif (type == NAT_JOURNAL)\n\t\treturn size <= MAX_NAT_JENTRIES(sum);\n\treturn size <= MAX_SIT_JENTRIES(sum);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool __has_cursum_space(struct f2fs_summary_block *sum, int size,\n\t\t\t\t\t\t\t\tint type)\n{\n\tif (type == NAT_JOURNAL)\n\t\treturn size <= MAX_NAT_JENTRIES(sum);\n\treturn size <= MAX_SIT_JENTRIES(sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_HOT_DATA"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_set_slab;\n\nstatic void __flush_nat_entry_set(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct nat_entry_set *set)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = set->set * NAT_ENTRY_PER_BLOCK;\n\tbool to_journal = true;\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct nat_entry *ne, *cur;\n\tstruct page *page = NULL;\n\n\t/*\n\t * there are two steps to flush nat entries:\n\t * #1, flush nat entries to journal in current hot data summary block.\n\t * #2, flush nat entries to nat page.\n\t */\n\tif (!__has_cursum_space(sum, set->entry_cnt, NAT_JOURNAL))\n\t\tto_journal = false;\n\n\tif (to_journal) {\n\t\tmutex_lock(&curseg->curseg_mutex);\n\t} else {\n\t\tpage = get_next_nat_page(sbi, start_nid);\n\t\tnat_blk = page_address(page);\n\t\tf2fs_bug_on(sbi, !nat_blk);\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(ne, cur, &set->entry_list, list) {\n\t\tstruct f2fs_nat_entry *raw_ne;\n\t\tnid_t nid = nat_get_nid(ne);\n\t\tint offset;\n\n\t\tif (nat_get_blkaddr(ne) == NEW_ADDR)\n\t\t\tcontinue;\n\n\t\tif (to_journal) {\n\t\t\toffset = lookup_journal_in_cursum(sum,\n\t\t\t\t\t\t\tNAT_JOURNAL, nid, 1);\n\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\traw_ne = &nat_in_journal(sum, offset);\n\t\t\tnid_in_journal(sum, offset) = cpu_to_le32(nid);\n\t\t} else {\n\t\t\traw_ne = &nat_blk->entries[nid - start_nid];\n\t\t}\n\t\traw_nat_from_node_info(raw_ne, &ne->ni);\n\n\t\tdown_write(&NM_I(sbi)->nat_tree_lock);\n\t\tnat_reset_flag(ne);\n\t\t__clear_nat_cache_dirty(NM_I(sbi), ne);\n\t\tup_write(&NM_I(sbi)->nat_tree_lock);\n\n\t\tif (nat_get_blkaddr(ne) == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, false);\n\t}\n\n\tif (to_journal)\n\t\tmutex_unlock(&curseg->curseg_mutex);\n\telse\n\t\tf2fs_put_page(page, 1);\n\n\tf2fs_bug_on(sbi, set->entry_cnt);\n\n\tradix_tree_delete(&NM_I(sbi)->nat_set_root, set->set);\n\tkmem_cache_free(nat_entry_set_slab, set);\n}"
  },
  {
    "function_name": "__adjust_nat_entry_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1796-1812",
    "snippet": "static void __adjust_nat_entry_set(struct nat_entry_set *nes,\n\t\t\t\t\t\tstruct list_head *head, int max)\n{\n\tstruct nat_entry_set *cur;\n\n\tif (nes->entry_cnt >= max)\n\t\tgoto add_out;\n\n\tlist_for_each_entry(cur, head, set_list) {\n\t\tif (cur->entry_cnt >= nes->entry_cnt) {\n\t\t\tlist_add(&nes->set_list, cur->set_list.prev);\n\t\t\treturn;\n\t\t}\n\t}\nadd_out:\n\tlist_add_tail(&nes->set_list, head);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&nes->set_list",
            "head"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&nes->set_list",
            "cur->set_list.prev"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "head",
            "set_list"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __adjust_nat_entry_set(struct nat_entry_set *nes,\n\t\t\t\t\t\tstruct list_head *head, int max)\n{\n\tstruct nat_entry_set *cur;\n\n\tif (nes->entry_cnt >= max)\n\t\tgoto add_out;\n\n\tlist_for_each_entry(cur, head, set_list) {\n\t\tif (cur->entry_cnt >= nes->entry_cnt) {\n\t\t\tlist_add(&nes->set_list, cur->set_list.prev);\n\t\t\treturn;\n\t\t}\n\t}\nadd_out:\n\tlist_add_tail(&nes->set_list, head);\n}"
  },
  {
    "function_name": "remove_nats_in_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1768-1794",
    "snippet": "static void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i;\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(sum, i));\n\n\t\traw_ne = nat_in_journal(sum, i);\n\n\t\tdown_write(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = grab_nat_entry(nm_i, nid);\n\t\t\tnode_info_from_raw_nat(&ne->ni, &raw_ne);\n\t\t}\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t\tup_write(&nm_i->nat_tree_lock);\n\t}\n\tupdate_nats_in_cursum(sum, -i);\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_nats_in_cursum",
          "args": [
            "sum",
            "-i"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "update_nats_in_cursum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "183-188",
          "snippet": "static inline int update_nats_in_cursum(struct f2fs_summary_block *rs, int i)\n{\n\tint before = nats_in_cursum(rs);\n\trs->n_nats = cpu_to_le16(before + i);\n\treturn before;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int update_nats_in_cursum(struct f2fs_summary_block *rs, int i)\n{\n\tint before = nats_in_cursum(rs);\n\trs->n_nats = cpu_to_le16(before + i);\n\treturn before;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_nat_cache_dirty",
          "args": [
            "nm_i",
            "ne"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "__set_nat_cache_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "144-167",
          "snippet": "static void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\treturn;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab, GFP_ATOMIC);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\tlist_move_tail(&ne->list, &head->entry_list);\n\tnm_i->dirty_nat_cnt++;\n\thead->entry_cnt++;\n\tset_nat_flag(ne, IS_DIRTY, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_set_slab;\n\nstatic void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\treturn;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab, GFP_ATOMIC);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\tlist_move_tail(&ne->list, &head->entry_list);\n\tnm_i->dirty_nat_cnt++;\n\thead->entry_cnt++;\n\tset_nat_flag(ne, IS_DIRTY, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_info_from_raw_nat",
          "args": [
            "&ne->ni",
            "&raw_ne"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "node_info_from_raw_nat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "102-108",
          "snippet": "static inline void node_info_from_raw_nat(struct node_info *ni,\n\t\t\t\t\t\tstruct f2fs_nat_entry *raw_ne)\n{\n\tni->ino = le32_to_cpu(raw_ne->ino);\n\tni->blk_addr = le32_to_cpu(raw_ne->block_addr);\n\tni->version = raw_ne->version;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void node_info_from_raw_nat(struct node_info *ni,\n\t\t\t\t\t\tstruct f2fs_nat_entry *raw_ne)\n{\n\tni->ino = le32_to_cpu(raw_ne->ino);\n\tni->blk_addr = le32_to_cpu(raw_ne->block_addr);\n\tni->version = raw_ne->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_nat_entry",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "grab_nat_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "235-247",
          "snippet": "static struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_ATOMIC);\n\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\n\nstatic struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_ATOMIC);\n\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_nat_cache",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "125-128",
          "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nid_in_journal(sum, i)"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nid_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nats_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_HOT_DATA"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i;\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(sum, i));\n\n\t\traw_ne = nat_in_journal(sum, i);\n\n\t\tdown_write(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = grab_nat_entry(nm_i, nid);\n\t\t\tnode_info_from_raw_nat(&ne->ni, &raw_ne);\n\t\t}\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t\tup_write(&nm_i->nat_tree_lock);\n\t}\n\tupdate_nats_in_cursum(sum, -i);\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
  },
  {
    "function_name": "restore_node_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1731-1766",
    "snippet": "int restore_node_summary(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct f2fs_summary_block *sum)\n{\n\tstruct f2fs_node *rn;\n\tstruct f2fs_summary *sum_entry;\n\tblock_t addr;\n\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\tint i, idx, last_offset, nrpages;\n\n\t/* scan the node segment */\n\tlast_offset = sbi->blocks_per_seg;\n\taddr = START_BLOCK(sbi, segno);\n\tsum_entry = &sum->entries[0];\n\n\tfor (i = 0; i < last_offset; i += nrpages, addr += nrpages) {\n\t\tnrpages = min(last_offset - i, bio_blocks);\n\n\t\t/* readahead node pages */\n\t\tra_meta_pages(sbi, addr, nrpages, META_POR);\n\n\t\tfor (idx = addr; idx < addr + nrpages; idx++) {\n\t\t\tstruct page *page = get_meta_page(sbi, idx);\n\n\t\t\trn = F2FS_NODE(page);\n\t\t\tsum_entry->nid = rn->footer.nid;\n\t\t\tsum_entry->version = 0;\n\t\t\tsum_entry->ofs_in_node = 0;\n\t\t\tsum_entry++;\n\t\t\tf2fs_put_page(page, 1);\n\t\t}\n\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi), addr,\n\t\t\t\t\t\t\taddr + nrpages);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "META_MAPPING(sbi)",
            "addr",
            "addr + nrpages"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_NODE",
          "args": [
            "page"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "670-673",
          "snippet": "static inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "idx"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_meta_pages",
          "args": [
            "sbi",
            "addr",
            "nrpages",
            "META_POR"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "115-170",
          "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "last_offset - i",
            "bio_blocks"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "START_BLOCK",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_BIO_BLOCKS",
          "args": [
            "sbi"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint restore_node_summary(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct f2fs_summary_block *sum)\n{\n\tstruct f2fs_node *rn;\n\tstruct f2fs_summary *sum_entry;\n\tblock_t addr;\n\tint bio_blocks = MAX_BIO_BLOCKS(sbi);\n\tint i, idx, last_offset, nrpages;\n\n\t/* scan the node segment */\n\tlast_offset = sbi->blocks_per_seg;\n\taddr = START_BLOCK(sbi, segno);\n\tsum_entry = &sum->entries[0];\n\n\tfor (i = 0; i < last_offset; i += nrpages, addr += nrpages) {\n\t\tnrpages = min(last_offset - i, bio_blocks);\n\n\t\t/* readahead node pages */\n\t\tra_meta_pages(sbi, addr, nrpages, META_POR);\n\n\t\tfor (idx = addr; idx < addr + nrpages; idx++) {\n\t\t\tstruct page *page = get_meta_page(sbi, idx);\n\n\t\t\trn = F2FS_NODE(page);\n\t\t\tsum_entry->nid = rn->footer.nid;\n\t\t\tsum_entry->version = 0;\n\t\t\tsum_entry->ofs_in_node = 0;\n\t\t\tsum_entry++;\n\t\t\tf2fs_put_page(page, 1);\n\t\t}\n\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi), addr,\n\t\t\t\t\t\t\taddr + nrpages);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "recover_inode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1687-1729",
    "snippet": "int recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_inode *src, *dst;\n\tnid_t ino = ino_of_node(page);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *ipage;\n\n\tget_node_info(sbi, ino, &old_ni);\n\n\tif (unlikely(old_ni.blk_addr != NULL_ADDR))\n\t\treturn -EINVAL;\n\n\tipage = grab_cache_page(NODE_MAPPING(sbi), ino);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\t/* Should not use this inode from free nid list */\n\tremove_free_nid(NM_I(sbi), ino);\n\n\tSetPageUptodate(ipage);\n\tfill_node_footer(ipage, ino, ino, 0, true);\n\n\tsrc = F2FS_INODE(page);\n\tdst = F2FS_INODE(ipage);\n\n\tmemcpy(dst, src, (unsigned long)&src->i_ext - (unsigned long)src);\n\tdst->i_size = 0;\n\tdst->i_blocks = cpu_to_le64(1);\n\tdst->i_links = cpu_to_le32(1);\n\tdst->i_xattr_nid = 0;\n\tdst->i_inline = src->i_inline & F2FS_INLINE_XATTR;\n\n\tnew_ni = old_ni;\n\tnew_ni.ino = ino;\n\n\tif (unlikely(!inc_valid_node_count(sbi, NULL)))\n\t\tWARN_ON(1);\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\tinc_valid_inode_count(sbi);\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "1"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "ipage"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_valid_inode_count",
          "args": [
            "sbi"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "inc_valid_inode_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1015-1021",
          "snippet": "static inline void inc_valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, sbi->total_valid_inode_count == sbi->total_node_count);\n\tsbi->total_valid_inode_count++;\n\tspin_unlock(&sbi->stat_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inc_valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, sbi->total_valid_inode_count == sbi->total_node_count);\n\tsbi->total_valid_inode_count++;\n\tspin_unlock(&sbi->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_node_addr",
          "args": [
            "sbi",
            "&new_ni",
            "NEW_ADDR",
            "false"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "set_node_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "263-315",
          "snippet": "static void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inc_valid_node_count(sbi, NULL)"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_valid_node_count",
          "args": [
            "sbi",
            "NULL"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "inc_valid_node_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "963-992",
          "snippet": "static inline bool inc_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tblock_t\tvalid_block_count;\n\tunsigned int valid_node_count;\n\n\tspin_lock(&sbi->stat_lock);\n\n\tvalid_block_count = sbi->total_valid_block_count + 1;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tvalid_node_count = sbi->total_valid_node_count + 1;\n\tif (unlikely(valid_node_count > sbi->total_node_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tif (inode)\n\t\tinode->i_blocks++;\n\n\tsbi->alloc_valid_block_count++;\n\tsbi->total_valid_node_count++;\n\tsbi->total_valid_block_count++;\n\tspin_unlock(&sbi->stat_lock);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool inc_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tblock_t\tvalid_block_count;\n\tunsigned int valid_node_count;\n\n\tspin_lock(&sbi->stat_lock);\n\n\tvalid_block_count = sbi->total_valid_block_count + 1;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tvalid_node_count = sbi->total_valid_node_count + 1;\n\tif (unlikely(valid_node_count > sbi->total_node_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tif (inode)\n\t\tinode->i_blocks++;\n\n\tsbi->alloc_valid_block_count++;\n\tsbi->total_valid_node_count++;\n\tsbi->total_valid_block_count++;\n\tspin_unlock(&sbi->stat_lock);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "1"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "(unsigned long)&src->i_ext - (unsigned long)src"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_INODE",
          "args": [
            "ipage"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_node_footer",
          "args": [
            "ipage",
            "ino",
            "ino",
            "0",
            "true"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "fill_node_footer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "212-229",
          "snippet": "static inline void fill_node_footer(struct page *page, nid_t nid,\n\t\t\t\tnid_t ino, unsigned int ofs, bool reset)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int old_flag = 0;\n\n\tif (reset)\n\t\tmemset(rn, 0, sizeof(*rn));\n\telse\n\t\told_flag = le32_to_cpu(rn->footer.flag);\n\n\trn->footer.nid = cpu_to_le32(nid);\n\trn->footer.ino = cpu_to_le32(ino);\n\n\t/* should remain old flag bits such as COLD_BIT_SHIFT */\n\trn->footer.flag = cpu_to_le32((ofs << OFFSET_BIT_SHIFT) |\n\t\t\t\t\t(old_flag & OFFSET_BIT_MASK));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void fill_node_footer(struct page *page, nid_t nid,\n\t\t\t\tnid_t ino, unsigned int ofs, bool reset)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int old_flag = 0;\n\n\tif (reset)\n\t\tmemset(rn, 0, sizeof(*rn));\n\telse\n\t\told_flag = le32_to_cpu(rn->footer.flag);\n\n\trn->footer.nid = cpu_to_le32(nid);\n\trn->footer.ino = cpu_to_le32(ino);\n\n\t/* should remain old flag bits such as COLD_BIT_SHIFT */\n\trn->footer.flag = cpu_to_le32((ofs << OFFSET_BIT_SHIFT) |\n\t\t\t\t\t(old_flag & OFFSET_BIT_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "ipage"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_free_nid",
          "args": [
            "NM_I(sbi)",
            "ino"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "remove_free_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1454-1470",
          "snippet": "static void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nstatic void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "NODE_MAPPING(sbi)",
            "ino"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "old_ni.blk_addr != NULL_ADDR"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "ino",
            "&old_ni"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "page"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_inode *src, *dst;\n\tnid_t ino = ino_of_node(page);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *ipage;\n\n\tget_node_info(sbi, ino, &old_ni);\n\n\tif (unlikely(old_ni.blk_addr != NULL_ADDR))\n\t\treturn -EINVAL;\n\n\tipage = grab_cache_page(NODE_MAPPING(sbi), ino);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\t/* Should not use this inode from free nid list */\n\tremove_free_nid(NM_I(sbi), ino);\n\n\tSetPageUptodate(ipage);\n\tfill_node_footer(ipage, ino, ino, 0, true);\n\n\tsrc = F2FS_INODE(page);\n\tdst = F2FS_INODE(ipage);\n\n\tmemcpy(dst, src, (unsigned long)&src->i_ext - (unsigned long)src);\n\tdst->i_size = 0;\n\tdst->i_blocks = cpu_to_le64(1);\n\tdst->i_links = cpu_to_le32(1);\n\tdst->i_xattr_nid = 0;\n\tdst->i_inline = src->i_inline & F2FS_INLINE_XATTR;\n\n\tnew_ni = old_ni;\n\tnew_ni.ino = ino;\n\n\tif (unlikely(!inc_valid_node_count(sbi, NULL)))\n\t\tWARN_ON(1);\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\tinc_valid_inode_count(sbi);\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "recover_xattr_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1651-1685",
    "snippet": "void recover_xattr_data(struct inode *inode, struct page *page, block_t blkaddr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t prev_xnid = F2FS_I(inode)->i_xattr_nid;\n\tnid_t new_xnid = nid_of_node(page);\n\tstruct node_info ni;\n\n\t/* 1: invalidate the previous xattr nid */\n\tif (!prev_xnid)\n\t\tgoto recover_xnid;\n\n\t/* Deallocate node address */\n\tget_node_info(sbi, prev_xnid, &ni);\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\nrecover_xnid:\n\t/* 2: allocate new xattr nid */\n\tif (unlikely(!inc_valid_node_count(sbi, inode)))\n\t\tf2fs_bug_on(sbi, 1);\n\n\tremove_free_nid(NM_I(sbi), new_xnid);\n\tget_node_info(sbi, new_xnid, &ni);\n\tni.ino = inode->i_ino;\n\tset_node_addr(sbi, &ni, NEW_ADDR, false);\n\tF2FS_I(inode)->i_xattr_nid = new_xnid;\n\n\t/* 3: update xattr blkaddr */\n\trefresh_sit_entry(sbi, NEW_ADDR, blkaddr);\n\tset_node_addr(sbi, &ni, blkaddr, false);\n\n\tupdate_inode_page(inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "inode"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_node_addr",
          "args": [
            "sbi",
            "&ni",
            "blkaddr",
            "false"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "set_node_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "263-315",
          "snippet": "static void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refresh_sit_entry",
          "args": [
            "sbi",
            "NEW_ADDR",
            "blkaddr"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_sit_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "685-693",
          "snippet": "void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)\n{\n\tupdate_sit_entry(sbi, new, 1);\n\tif (GET_SEGNO(sbi, old) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old, -1);\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)\n{\n\tupdate_sit_entry(sbi, new, 1);\n\tif (GET_SEGNO(sbi, old) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old, -1);\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new));\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "new_xnid",
            "&ni"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_free_nid",
          "args": [
            "NM_I(sbi)",
            "new_xnid"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "remove_free_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1454-1470",
          "snippet": "static void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nstatic void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "1"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inc_valid_node_count(sbi, inode)"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_valid_node_count",
          "args": [
            "sbi",
            "inode"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "inc_valid_node_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "963-992",
          "snippet": "static inline bool inc_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tblock_t\tvalid_block_count;\n\tunsigned int valid_node_count;\n\n\tspin_lock(&sbi->stat_lock);\n\n\tvalid_block_count = sbi->total_valid_block_count + 1;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tvalid_node_count = sbi->total_valid_node_count + 1;\n\tif (unlikely(valid_node_count > sbi->total_node_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tif (inode)\n\t\tinode->i_blocks++;\n\n\tsbi->alloc_valid_block_count++;\n\tsbi->total_valid_node_count++;\n\tsbi->total_valid_block_count++;\n\tspin_unlock(&sbi->stat_lock);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool inc_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tblock_t\tvalid_block_count;\n\tunsigned int valid_node_count;\n\n\tspin_lock(&sbi->stat_lock);\n\n\tvalid_block_count = sbi->total_valid_block_count + 1;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tvalid_node_count = sbi->total_valid_node_count + 1;\n\tif (unlikely(valid_node_count > sbi->total_node_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tif (inode)\n\t\tinode->i_blocks++;\n\n\tsbi->alloc_valid_block_count++;\n\tsbi->total_valid_node_count++;\n\tsbi->total_valid_block_count++;\n\tspin_unlock(&sbi->stat_lock);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_valid_node_count",
          "args": [
            "sbi",
            "inode"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "dec_valid_node_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "994-1008",
          "snippet": "static inline void dec_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tspin_lock(&sbi->stat_lock);\n\n\tf2fs_bug_on(sbi, !sbi->total_valid_block_count);\n\tf2fs_bug_on(sbi, !sbi->total_valid_node_count);\n\tf2fs_bug_on(sbi, !inode->i_blocks);\n\n\tinode->i_blocks--;\n\tsbi->total_valid_node_count--;\n\tsbi->total_valid_block_count--;\n\n\tspin_unlock(&sbi->stat_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tspin_lock(&sbi->stat_lock);\n\n\tf2fs_bug_on(sbi, !sbi->total_valid_block_count);\n\tf2fs_bug_on(sbi, !sbi->total_valid_node_count);\n\tf2fs_bug_on(sbi, !inode->i_blocks);\n\n\tinode->i_blocks--;\n\tsbi->total_valid_node_count--;\n\tsbi->total_valid_block_count--;\n\n\tspin_unlock(&sbi->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_blocks",
          "args": [
            "sbi",
            "ni.blk_addr"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "695-713",
          "snippet": "void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR)\n\t\treturn;\n\n\t/* add it into sit main buffer */\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR)\n\t\treturn;\n\n\t/* add it into sit main buffer */\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "ni.blk_addr == NULL_ADDR"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nid_of_node",
          "args": [
            "page"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "nid_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "253-257",
          "snippet": "static inline nid_t nid_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.nid);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t nid_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid recover_xattr_data(struct inode *inode, struct page *page, block_t blkaddr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t prev_xnid = F2FS_I(inode)->i_xattr_nid;\n\tnid_t new_xnid = nid_of_node(page);\n\tstruct node_info ni;\n\n\t/* 1: invalidate the previous xattr nid */\n\tif (!prev_xnid)\n\t\tgoto recover_xnid;\n\n\t/* Deallocate node address */\n\tget_node_info(sbi, prev_xnid, &ni);\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\nrecover_xnid:\n\t/* 2: allocate new xattr nid */\n\tif (unlikely(!inc_valid_node_count(sbi, inode)))\n\t\tf2fs_bug_on(sbi, 1);\n\n\tremove_free_nid(NM_I(sbi), new_xnid);\n\tget_node_info(sbi, new_xnid, &ni);\n\tni.ino = inode->i_ino;\n\tset_node_addr(sbi, &ni, NEW_ADDR, false);\n\tF2FS_I(inode)->i_xattr_nid = new_xnid;\n\n\t/* 3: update xattr blkaddr */\n\trefresh_sit_entry(sbi, NEW_ADDR, blkaddr);\n\tset_node_addr(sbi, &ni, blkaddr, false);\n\n\tupdate_inode_page(inode);\n}"
  },
  {
    "function_name": "recover_inline_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1624-1649",
    "snippet": "void recover_inline_xattr(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tsize_t inline_size;\n\tstruct page *ipage;\n\tstruct f2fs_inode *ri;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tf2fs_bug_on(F2FS_I_SB(inode), IS_ERR(ipage));\n\n\tri = F2FS_INODE(page);\n\tif (!(ri->i_inline & F2FS_INLINE_XATTR)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_INLINE_XATTR);\n\t\tgoto update_inode;\n\t}\n\n\tdst_addr = inline_xattr_addr(ipage);\n\tsrc_addr = inline_xattr_addr(page);\n\tinline_size = inline_xattr_size(inode);\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemcpy(dst_addr, src_addr, inline_size);\nupdate_inode:\n\tupdate_inode(inode, ipage);\n\tf2fs_put_page(ipage, 1);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "1"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "inode",
            "ipage"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_addr",
            "src_addr",
            "inline_size"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "ipage",
            "NODE"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inline_xattr_size",
          "args": [
            "inode"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "inline_xattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1243-1249",
          "snippet": "static inline int inline_xattr_size(struct inode *inode)\n{\n\tif (f2fs_has_inline_xattr(inode))\n\t\treturn F2FS_INLINE_XATTR_ADDRS << 2;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int inline_xattr_size(struct inode *inode)\n{\n\tif (f2fs_has_inline_xattr(inode))\n\t\treturn F2FS_INLINE_XATTR_ADDRS << 2;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inline_xattr_addr",
          "args": [
            "page"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "inline_xattr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1236-1241",
          "snippet": "static inline void *inline_xattr_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[DEF_ADDRS_PER_INODE -\n\t\t\t\t\tF2FS_INLINE_XATTR_ADDRS]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_xattr_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[DEF_ADDRS_PER_INODE -\n\t\t\t\t\tF2FS_INLINE_XATTR_ADDRS]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INLINE_XATTR"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_I_SB(inode)",
            "IS_ERR(ipage)"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "F2FS_I_SB(inode)",
            "inode->i_ino"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid recover_inline_xattr(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tsize_t inline_size;\n\tstruct page *ipage;\n\tstruct f2fs_inode *ri;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tf2fs_bug_on(F2FS_I_SB(inode), IS_ERR(ipage));\n\n\tri = F2FS_INODE(page);\n\tif (!(ri->i_inline & F2FS_INLINE_XATTR)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_INLINE_XATTR);\n\t\tgoto update_inode;\n\t}\n\n\tdst_addr = inline_xattr_addr(ipage);\n\tsrc_addr = inline_xattr_addr(page);\n\tinline_size = inline_xattr_size(inode);\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemcpy(dst_addr, src_addr, inline_size);\nupdate_inode:\n\tupdate_inode(inode, ipage);\n\tf2fs_put_page(ipage, 1);\n}"
  },
  {
    "function_name": "alloc_nid_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1599-1622",
    "snippet": "void alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *free_nid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "free_nid_slab",
            "i"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__del_from_free_nid_list",
          "args": [
            "nm_i",
            "i"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "__del_from_free_nid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1397-1402",
          "snippet": "static void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "available_free_memory",
          "args": [
            "sbi",
            "FREE_NIDS"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "available_free_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "31-70",
          "snippet": "bool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "!i || i->state != NID_ALLOC"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_free_nid_list",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_free_nid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1391-1395",
          "snippet": "static struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
  },
  {
    "function_name": "alloc_nid_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1582-1594",
    "snippet": "void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *free_nid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "free_nid_slab",
            "i"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__del_from_free_nid_list",
          "args": [
            "nm_i",
            "i"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "__del_from_free_nid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1397-1402",
          "snippet": "static void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "!i || i->state != NID_ALLOC"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_free_nid_list",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_free_nid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1391-1395",
          "snippet": "static struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}"
  },
  {
    "function_name": "alloc_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1546-1577",
    "snippet": "bool alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i = NULL;\nretry:\n\tif (unlikely(sbi->total_valid_node_count + 1 > nm_i->available_nids))\n\t\treturn false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\n\t/* We should not use stale free nids created by build_free_nids */\n\tif (nm_i->fcnt && !on_build_free_nids(nm_i)) {\n\t\tf2fs_bug_on(sbi, list_empty(&nm_i->free_nid_list));\n\t\tlist_for_each_entry(i, &nm_i->free_nid_list, list)\n\t\t\tif (i->state == NID_NEW)\n\t\t\t\tbreak;\n\n\t\tf2fs_bug_on(sbi, i->state != NID_NEW);\n\t\t*nid = i->nid;\n\t\ti->state = NID_ALLOC;\n\t\tnm_i->fcnt--;\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\t/* Let's scan nat pages and its caches to get free nids */\n\tmutex_lock(&nm_i->build_lock);\n\tbuild_free_nids(sbi);\n\tmutex_unlock(&nm_i->build_lock);\n\tgoto retry;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nm_i->build_lock"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_free_nids",
          "args": [
            "sbi"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "build_free_nids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1496-1539",
          "snippet": "static void build_free_nids(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\t/* Enough entries */\n\tif (nm_i->fcnt > NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\t/* readahead nat pages to be scanned */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES, META_NAT);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\tscan_nat_page(sbi, page, nid);\n\t\tf2fs_put_page(page, 1);\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (i++ == FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* go to the next free nat pages to find free nids abundantly */\n\tnm_i->next_scan_nid = nid;\n\n\t/* find free nids from current sum_pages */\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tblock_t addr = le32_to_cpu(nat_in_journal(sum, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(sum, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(nm_i, nid);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void build_free_nids(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\t/* Enough entries */\n\tif (nm_i->fcnt > NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\t/* readahead nat pages to be scanned */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES, META_NAT);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\tscan_nat_page(sbi, page, nid);\n\t\tf2fs_put_page(page, 1);\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (i++ == FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* go to the next free nat pages to find free nids abundantly */\n\tnm_i->next_scan_nid = nid;\n\n\t/* find free nids from current sum_pages */\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tblock_t addr = le32_to_cpu(nat_in_journal(sum, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(sum, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(nm_i, nid);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nm_i->build_lock"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "i->state != NID_NEW"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "i",
            "&nm_i->free_nid_list",
            "list"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "list_empty(&nm_i->free_nid_list)"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nm_i->free_nid_list"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_build_free_nids",
          "args": [
            "nm_i"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sbi->total_valid_node_count + 1 > nm_i->available_nids"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i = NULL;\nretry:\n\tif (unlikely(sbi->total_valid_node_count + 1 > nm_i->available_nids))\n\t\treturn false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\n\t/* We should not use stale free nids created by build_free_nids */\n\tif (nm_i->fcnt && !on_build_free_nids(nm_i)) {\n\t\tf2fs_bug_on(sbi, list_empty(&nm_i->free_nid_list));\n\t\tlist_for_each_entry(i, &nm_i->free_nid_list, list)\n\t\t\tif (i->state == NID_NEW)\n\t\t\t\tbreak;\n\n\t\tf2fs_bug_on(sbi, i->state != NID_NEW);\n\t\t*nid = i->nid;\n\t\ti->state = NID_ALLOC;\n\t\tnm_i->fcnt--;\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\t/* Let's scan nat pages and its caches to get free nids */\n\tmutex_lock(&nm_i->build_lock);\n\tbuild_free_nids(sbi);\n\tmutex_unlock(&nm_i->build_lock);\n\tgoto retry;\n}"
  },
  {
    "function_name": "build_free_nids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1496-1539",
    "snippet": "static void build_free_nids(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\t/* Enough entries */\n\tif (nm_i->fcnt > NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\t/* readahead nat pages to be scanned */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES, META_NAT);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\tscan_nat_page(sbi, page, nid);\n\t\tf2fs_put_page(page, 1);\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (i++ == FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* go to the next free nat pages to find free nids abundantly */\n\tnm_i->next_scan_nid = nid;\n\n\t/* find free nids from current sum_pages */\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tblock_t addr = le32_to_cpu(nat_in_journal(sum, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(sum, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(nm_i, nid);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_free_nid",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "remove_free_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1454-1470",
          "snippet": "static void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nstatic void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_free_nid",
          "args": [
            "sbi",
            "nid",
            "true"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "add_free_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1404-1452",
          "snippet": "static int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tbool allocated = false;\n\n\tif (!available_free_memory(sbi, FREE_NIDS))\n\t\treturn -1;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn 0;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tdown_read(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne &&\n\t\t\t(!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tallocated = true;\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tif (allocated)\n\t\t\treturn 0;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tradix_tree_preload_end();\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\tnm_i->fcnt++;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\tradix_tree_preload_end();\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nstatic int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tbool allocated = false;\n\n\tif (!available_free_memory(sbi, FREE_NIDS))\n\t\treturn -1;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn 0;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tdown_read(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne &&\n\t\t\t(!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tallocated = true;\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tif (allocated)\n\t\t\treturn 0;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tradix_tree_preload_end();\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\tnm_i->fcnt++;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\tradix_tree_preload_end();\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nid_in_journal(sum, i)"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nid_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nats_in_cursum",
          "args": [
            "sum"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nid >= nm_i->max_nid"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_nat_page",
          "args": [
            "sbi",
            "page",
            "nid"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "scan_nat_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1472-1494",
          "snippet": "static void scan_nat_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *nat_page, nid_t start_nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct f2fs_nat_block *nat_blk = page_address(nat_page);\n\tblock_t blk_addr;\n\tint i;\n\n\ti = start_nid % NAT_ENTRY_PER_BLOCK;\n\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {\n\n\t\tif (unlikely(start_nid >= nm_i->max_nid))\n\t\t\tbreak;\n\n\t\tblk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);\n\t\tf2fs_bug_on(sbi, blk_addr == NEW_ADDR);\n\t\tif (blk_addr == NULL_ADDR) {\n\t\t\tif (add_free_nid(sbi, start_nid, true) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void scan_nat_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *nat_page, nid_t start_nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct f2fs_nat_block *nat_blk = page_address(nat_page);\n\tblock_t blk_addr;\n\tint i;\n\n\ti = start_nid % NAT_ENTRY_PER_BLOCK;\n\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {\n\n\t\tif (unlikely(start_nid >= nm_i->max_nid))\n\t\t\tbreak;\n\n\t\tblk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);\n\t\tf2fs_bug_on(sbi, blk_addr == NEW_ADDR);\n\t\tif (blk_addr == NULL_ADDR) {\n\t\t\tif (add_free_nid(sbi, start_nid, true) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_current_nat_page",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "get_current_nat_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "90-94",
          "snippet": "static struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_meta_pages",
          "args": [
            "sbi",
            "NAT_BLOCK_OFFSET(nid)",
            "FREE_NID_PAGES",
            "META_NAT"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "115-170",
          "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NAT_BLOCK_OFFSET",
          "args": [
            "nid"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_HOT_DATA"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void build_free_nids(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\t/* Enough entries */\n\tif (nm_i->fcnt > NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\t/* readahead nat pages to be scanned */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES, META_NAT);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\tscan_nat_page(sbi, page, nid);\n\t\tf2fs_put_page(page, 1);\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (i++ == FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* go to the next free nat pages to find free nids abundantly */\n\tnm_i->next_scan_nid = nid;\n\n\t/* find free nids from current sum_pages */\n\tmutex_lock(&curseg->curseg_mutex);\n\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\tblock_t addr = le32_to_cpu(nat_in_journal(sum, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(sum, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(nm_i, nid);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
  },
  {
    "function_name": "scan_nat_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1472-1494",
    "snippet": "static void scan_nat_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *nat_page, nid_t start_nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct f2fs_nat_block *nat_blk = page_address(nat_page);\n\tblock_t blk_addr;\n\tint i;\n\n\ti = start_nid % NAT_ENTRY_PER_BLOCK;\n\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {\n\n\t\tif (unlikely(start_nid >= nm_i->max_nid))\n\t\t\tbreak;\n\n\t\tblk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);\n\t\tf2fs_bug_on(sbi, blk_addr == NEW_ADDR);\n\t\tif (blk_addr == NULL_ADDR) {\n\t\t\tif (add_free_nid(sbi, start_nid, true) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_free_nid",
          "args": [
            "sbi",
            "start_nid",
            "true"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "add_free_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1404-1452",
          "snippet": "static int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tbool allocated = false;\n\n\tif (!available_free_memory(sbi, FREE_NIDS))\n\t\treturn -1;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn 0;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tdown_read(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne &&\n\t\t\t(!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tallocated = true;\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tif (allocated)\n\t\t\treturn 0;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tradix_tree_preload_end();\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\tnm_i->fcnt++;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\tradix_tree_preload_end();\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nstatic int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tbool allocated = false;\n\n\tif (!available_free_memory(sbi, FREE_NIDS))\n\t\treturn -1;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn 0;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tdown_read(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne &&\n\t\t\t(!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tallocated = true;\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tif (allocated)\n\t\t\treturn 0;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tradix_tree_preload_end();\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\tnm_i->fcnt++;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\tradix_tree_preload_end();\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "blk_addr == NEW_ADDR"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nat_blk->entries[i].block_addr"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "start_nid >= nm_i->max_nid"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "nat_page"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void scan_nat_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *nat_page, nid_t start_nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct f2fs_nat_block *nat_blk = page_address(nat_page);\n\tblock_t blk_addr;\n\tint i;\n\n\ti = start_nid % NAT_ENTRY_PER_BLOCK;\n\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {\n\n\t\tif (unlikely(start_nid >= nm_i->max_nid))\n\t\t\tbreak;\n\n\t\tblk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);\n\t\tf2fs_bug_on(sbi, blk_addr == NEW_ADDR);\n\t\tif (blk_addr == NULL_ADDR) {\n\t\t\tif (add_free_nid(sbi, start_nid, true) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "remove_free_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1454-1470",
    "snippet": "static void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *free_nid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "free_nid_slab",
            "i"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__del_from_free_nid_list",
          "args": [
            "nm_i",
            "i"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "__del_from_free_nid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1397-1402",
          "snippet": "static void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_free_nid_list",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_free_nid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1391-1395",
          "snippet": "static struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nstatic void remove_free_nid(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tnm_i->fcnt--;\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
  },
  {
    "function_name": "add_free_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1404-1452",
    "snippet": "static int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tbool allocated = false;\n\n\tif (!available_free_memory(sbi, FREE_NIDS))\n\t\treturn -1;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn 0;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tdown_read(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne &&\n\t\t\t(!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tallocated = true;\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tif (allocated)\n\t\t\treturn 0;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tradix_tree_preload_end();\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\tnm_i->fcnt++;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\tradix_tree_preload_end();\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *free_nid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&i->list",
            "&nm_i->free_nid_list"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "free_nid_slab",
            "i"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&nm_i->free_nid_root",
            "i->nid",
            "i"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nm_i->free_nid_list_lock"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "free_nid_slab",
            "i"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "free_nid_slab",
            "GFP_NOFS"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "ne"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nat_flag",
          "args": [
            "ne",
            "IS_CHECKPOINTED"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "get_nat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "88-92",
          "snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_nat_cache",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "125-128",
          "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nid == 0"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "available_free_memory",
          "args": [
            "sbi",
            "FREE_NIDS"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "available_free_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "31-70",
          "snippet": "bool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nstatic int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tbool allocated = false;\n\n\tif (!available_free_memory(sbi, FREE_NIDS))\n\t\treturn -1;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn 0;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tdown_read(&nm_i->nat_tree_lock);\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne &&\n\t\t\t(!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tallocated = true;\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tif (allocated)\n\t\t\treturn 0;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\tif (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {\n\t\tspin_unlock(&nm_i->free_nid_list_lock);\n\t\tradix_tree_preload_end();\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn 0;\n\t}\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\tnm_i->fcnt++;\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\tradix_tree_preload_end();\n\treturn 1;\n}"
  },
  {
    "function_name": "__del_from_free_nid_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1397-1402",
    "snippet": "static void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&nm_i->free_nid_root",
            "i->nid"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&i->list"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct free_nid *i)\n{\n\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}"
  },
  {
    "function_name": "__lookup_free_nid_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1391-1395",
    "snippet": "static struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&nm_i->free_nid_root",
            "n"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}"
  },
  {
    "function_name": "f2fs_set_node_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1365-1378",
    "snippet": "static int f2fs_set_node_page_dirty(struct page *page)\n{\n\ttrace_f2fs_set_page_dirty(page, NODE);\n\n\tSetPageUptodate(page);\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tinc_page_count(F2FS_P_SB(page), F2FS_DIRTY_NODES);\n\t\tSetPagePrivate(page);\n\t\tf2fs_trace_pid(page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_trace_pid",
          "args": [
            "page"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_trace_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/trace.c",
          "lines": "55-81",
          "snippet": "void f2fs_trace_pid(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tpid_t pid = task_pid_nr(current);\n\tvoid *p;\n\n\tpage->private = pid;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn;\n\n\tspin_lock(&pids_lock);\n\tp = radix_tree_lookup(&pids, pid);\n\tif (p == current)\n\t\tgoto out;\n\tif (p)\n\t\tradix_tree_delete(&pids, pid);\n\n\tf2fs_radix_tree_insert(&pids, pid, current);\n\n\ttrace_printk(\"%3x:%3x %4x %-16s\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tpid, current->comm);\nout:\n\tspin_unlock(&pids_lock);\n\tradix_tree_preload_end();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/radix-tree.h>",
            "#include <linux/sched.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t pids_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"f2fs.h\"\n#include <linux/radix-tree.h>\n#include <linux/sched.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic spinlock_t pids_lock;\n\nvoid f2fs_trace_pid(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tpid_t pid = task_pid_nr(current);\n\tvoid *p;\n\n\tpage->private = pid;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\treturn;\n\n\tspin_lock(&pids_lock);\n\tp = radix_tree_lookup(&pids, pid);\n\tif (p == current)\n\t\tgoto out;\n\tif (p)\n\t\tradix_tree_delete(&pids, pid);\n\n\tf2fs_radix_tree_insert(&pids, pid, current);\n\n\ttrace_printk(\"%3x:%3x %4x %-16s\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tpid, current->comm);\nout:\n\tspin_unlock(&pids_lock);\n\tradix_tree_preload_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_page_count",
          "args": [
            "F2FS_P_SB(page)",
            "F2FS_DIRTY_NODES"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "inc_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "858-862",
          "snippet": "static inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_set_page_dirty",
          "args": [
            "page",
            "NODE"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_set_node_page_dirty(struct page *page)\n{\n\ttrace_f2fs_set_page_dirty(page, NODE);\n\n\tSetPageUptodate(page);\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tinc_page_count(F2FS_P_SB(page), F2FS_DIRTY_NODES);\n\t\tSetPagePrivate(page);\n\t\tf2fs_trace_pid(page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_write_node_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1339-1363",
    "snippet": "static int f2fs_write_node_pages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, NODE);\n\n\t/* balancing f2fs's metadata in background */\n\tf2fs_balance_fs_bg(sbi);\n\n\t/* collect a number of dirty node pages and write together */\n\tif (get_pages(sbi, F2FS_DIRTY_NODES) < nr_pages_to_skip(sbi, NODE))\n\t\tgoto skip_write;\n\n\tdiff = nr_pages_to_write(sbi, NODE, wbc);\n\twbc->sync_mode = WB_SYNC_NONE;\n\tsync_node_pages(sbi, 0, wbc);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_NODES);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_DIRTY_NODES"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(long)0",
            "wbc->nr_to_write - diff"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "168-180",
          "snippet": "static unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_node_pages",
          "args": [
            "sbi",
            "0",
            "wbc"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "sync_node_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1131-1237",
          "snippet": "int sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_pages_to_write",
          "args": [
            "sbi",
            "NODE",
            "wbc"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "nr_pages_to_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "731-750",
          "snippet": "static inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tlong nr_to_write, desired;\n\n\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\treturn 0;\n\n\tnr_to_write = wbc->nr_to_write;\n\n\tif (type == DATA)\n\t\tdesired = 4096;\n\telse if (type == NODE)\n\t\tdesired = 3 * max_hw_blocks(sbi);\n\telse\n\t\tdesired = MAX_BIO_BLOCKS(sbi);\n\n\twbc->nr_to_write = desired;\n\treturn desired - nr_to_write;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tlong nr_to_write, desired;\n\n\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\treturn 0;\n\n\tnr_to_write = wbc->nr_to_write;\n\n\tif (type == DATA)\n\t\tdesired = 4096;\n\telse if (type == NODE)\n\t\tdesired = 3 * max_hw_blocks(sbi);\n\telse\n\t\tdesired = MAX_BIO_BLOCKS(sbi);\n\n\twbc->nr_to_write = desired;\n\treturn desired - nr_to_write;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_pages_to_skip",
          "args": [
            "sbi",
            "NODE"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "nr_pages_to_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "713-726",
          "snippet": "static inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)\n{\n\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\treturn 0;\n\n\tif (type == DATA)\n\t\treturn sbi->blocks_per_seg;\n\telse if (type == NODE)\n\t\treturn 3 * sbi->blocks_per_seg;\n\telse if (type == META)\n\t\treturn MAX_BIO_BLOCKS(sbi);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)\n{\n\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\treturn 0;\n\n\tif (type == DATA)\n\t\treturn sbi->blocks_per_seg;\n\telse if (type == NODE)\n\t\treturn 3 * sbi->blocks_per_seg;\n\telse if (type == META)\n\t\treturn MAX_BIO_BLOCKS(sbi);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs_bg",
          "args": [
            "sbi"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_writepages",
          "args": [
            "mapping->host",
            "wbc",
            "NODE"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_M_SB",
          "args": [
            "mapping"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_M_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "650-653",
          "snippet": "static inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)\n{\n\treturn F2FS_I_SB(mapping->host);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)\n{\n\treturn F2FS_I_SB(mapping->host);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_node_pages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, NODE);\n\n\t/* balancing f2fs's metadata in background */\n\tf2fs_balance_fs_bg(sbi);\n\n\t/* collect a number of dirty node pages and write together */\n\tif (get_pages(sbi, F2FS_DIRTY_NODES) < nr_pages_to_skip(sbi, NODE))\n\t\tgoto skip_write;\n\n\tdiff = nr_pages_to_write(sbi, NODE, wbc);\n\twbc->sync_mode = WB_SYNC_NONE;\n\tsync_node_pages(sbi, 0, wbc);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_NODES);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_write_node_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1281-1337",
    "snippet": "static int f2fs_write_node_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tnid_t nid;\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE,\n\t};\n\n\ttrace_f2fs_writepage(page, NODE);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto redirty_out;\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\n\t/* get old block addr of this node page */\n\tnid = nid_of_node(page);\n\tf2fs_bug_on(sbi, page->index != nid);\n\n\tget_node_info(sbi, nid, &ni);\n\n\t/* This page is already truncated */\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (wbc->for_reclaim) {\n\t\tif (!down_read_trylock(&sbi->node_write))\n\t\t\tgoto redirty_out;\n\t} else {\n\t\tdown_read(&sbi->node_write);\n\t}\n\n\tset_page_writeback(page);\n\tfio.blk_addr = ni.blk_addr;\n\twrite_node_page(sbi, page, nid, &fio);\n\tset_node_addr(sbi, &ni, fio.blk_addr, is_fsync_dnode(page));\n\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\tup_read(&sbi->node_write);\n\tunlock_page(page);\n\n\tif (wbc->for_reclaim)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "NODE",
            "WRITE"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sbi->node_write"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_page_count",
          "args": [
            "sbi",
            "F2FS_DIRTY_NODES"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "dec_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "871-874",
          "snippet": "static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_node_addr",
          "args": [
            "sbi",
            "&ni",
            "fio.blk_addr",
            "is_fsync_dnode(page)"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "set_node_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "263-315",
          "snippet": "static void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_fsync_dnode",
          "args": [
            "page"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_node_page",
          "args": [
            "sbi",
            "page",
            "nid",
            "&fio"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "write_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1226-1232",
          "snippet": "void write_node_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tunsigned int nid, struct f2fs_io_info *fio)\n{\n\tstruct f2fs_summary sum;\n\tset_summary(&sum, nid, 0, 0);\n\tdo_write_page(sbi, page, &sum, fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_node_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tunsigned int nid, struct f2fs_io_info *fio)\n{\n\tstruct f2fs_summary sum;\n\tset_summary(&sum, nid, 0, 0);\n\tdo_write_page(sbi, page, &sum, fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&sbi->node_write"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&sbi->node_write"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ni.blk_addr == NULL_ADDR"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "nid",
            "&ni"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "page->index != nid"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nid_of_node",
          "args": [
            "page"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "nid_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "253-257",
          "snippet": "static inline nid_t nid_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.nid);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t nid_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "NODE"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_sbi_flag_set(sbi, SBI_POR_DOING)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sbi_flag_set",
          "args": [
            "sbi",
            "SBI_POR_DOING"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "is_sbi_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "715-718",
          "snippet": "static inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn sbi->s_flag & (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_writepage",
          "args": [
            "page",
            "NODE"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_write_node_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tnid_t nid;\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE,\n\t};\n\n\ttrace_f2fs_writepage(page, NODE);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto redirty_out;\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\n\t/* get old block addr of this node page */\n\tnid = nid_of_node(page);\n\tf2fs_bug_on(sbi, page->index != nid);\n\n\tget_node_info(sbi, nid, &ni);\n\n\t/* This page is already truncated */\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (wbc->for_reclaim) {\n\t\tif (!down_read_trylock(&sbi->node_write))\n\t\t\tgoto redirty_out;\n\t} else {\n\t\tdown_read(&sbi->node_write);\n\t}\n\n\tset_page_writeback(page);\n\tfio.blk_addr = ni.blk_addr;\n\twrite_node_page(sbi, page, nid, &fio);\n\tset_node_addr(sbi, &ni, fio.blk_addr, is_fsync_dnode(page));\n\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\tup_read(&sbi->node_write);\n\tunlock_page(page);\n\n\tif (wbc->for_reclaim)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}"
  },
  {
    "function_name": "wait_on_node_pages_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1239-1279",
    "snippet": "int wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tint ret2 = 0, ret = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_WRITEBACK,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* until radix tree lookup accepts end_index */\n\t\t\tif (unlikely(page->index > end))\n\t\t\t\tcontinue;\n\n\t\t\tif (ino && ino_of_node(page) == ino) {\n\t\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t\t\tif (TestClearPageError(page))\n\t\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (unlikely(test_and_clear_bit(AS_ENOSPC, &NODE_MAPPING(sbi)->flags)))\n\t\tret2 = -ENOSPC;\n\tif (unlikely(test_and_clear_bit(AS_EIO, &NODE_MAPPING(sbi)->flags)))\n\t\tret2 = -EIO;\n\tif (!ret)\n\t\tret = ret2;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_and_clear_bit(AS_EIO, &NODE_MAPPING(sbi)->flags)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "AS_EIO",
            "&NODE_MAPPING(sbi)->flags"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_and_clear_bit(AS_ENOSPC, &NODE_MAPPING(sbi)->flags)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestClearPageError",
          "args": [
            "page"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "NODE"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "page"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->index > end"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "NODE_MAPPING(sbi)",
            "&index",
            "PAGECACHE_TAG_WRITEBACK",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE-1"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tint ret2 = 0, ret = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_WRITEBACK,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* until radix tree lookup accepts end_index */\n\t\t\tif (unlikely(page->index > end))\n\t\t\t\tcontinue;\n\n\t\t\tif (ino && ino_of_node(page) == ino) {\n\t\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t\t\tif (TestClearPageError(page))\n\t\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (unlikely(test_and_clear_bit(AS_ENOSPC, &NODE_MAPPING(sbi)->flags)))\n\t\tret2 = -ENOSPC;\n\tif (unlikely(test_and_clear_bit(AS_EIO, &NODE_MAPPING(sbi)->flags)))\n\t\tret2 = -EIO;\n\tif (!ret)\n\t\tret = ret2;\n\treturn ret;\n}"
  },
  {
    "function_name": "sync_node_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1131-1237",
    "snippet": "int sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "NODE",
            "WRITE"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "page",
            "wbc"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_dentry_mark",
          "args": [
            "page",
            "0"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fsync_mark",
          "args": [
            "page",
            "0"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dentry_mark",
          "args": [
            "page",
            "0"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dentry_mark",
          "args": [
            "page",
            "1"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_fsynced_inode",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "has_fsynced_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "205-217",
          "snippet": "bool has_fsynced_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool fsynced = false;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_FSYNCED_INODE))\n\t\tfsynced = true;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn fsynced;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool has_fsynced_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool fsynced = false;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_FSYNCED_INODE))\n\t\tfsynced = true;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn fsynced;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_checkpointed_node",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "is_checkpointed_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "191-203",
          "snippet": "bool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_INODE",
          "args": [
            "page"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "IS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1087-1091",
          "snippet": "static inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fsync_mark",
          "args": [
            "page",
            "1"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DNODE",
          "args": [
            "page"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "IS_DNODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "299-315",
          "snippet": "static inline bool IS_DNODE(struct page *node_page)\n{\n\tunsigned int ofs = ofs_of_node(node_page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\treturn false;\n\n\tif (ofs == 3 || ofs == 4 + NIDS_PER_BLOCK ||\n\t\t\tofs == 5 + 2 * NIDS_PER_BLOCK)\n\t\treturn false;\n\tif (ofs >= 6 + 2 * NIDS_PER_BLOCK) {\n\t\tofs -= 6 + 2 * NIDS_PER_BLOCK;\n\t\tif (!((long int)ofs % (NIDS_PER_BLOCK + 1)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool IS_DNODE(struct page *node_page)\n{\n\tunsigned int ofs = ofs_of_node(node_page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\treturn false;\n\n\tif (ofs == 3 || ofs == 4 + NIDS_PER_BLOCK ||\n\t\t\tofs == 5 + 2 * NIDS_PER_BLOCK)\n\t\treturn false;\n\tif (ofs >= 6 + 2 * NIDS_PER_BLOCK) {\n\t\tofs -= 6 + 2 * NIDS_PER_BLOCK;\n\t\tif (!((long int)ofs % (NIDS_PER_BLOCK + 1)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "page"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != NODE_MAPPING(sbi)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cold_node",
          "args": [
            "page"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cold_node",
          "args": [
            "page"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "NODE_MAPPING(sbi)",
            "&index",
            "PAGECACHE_TAG_DIRTY",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE-1"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}"
  },
  {
    "function_name": "sync_inode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1116-1129",
    "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "dn->inode"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "dn->inode_page"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "dn->inode",
            "dn->inode_page"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_INODE",
          "args": [
            "dn->node_page"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "IS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1087-1091",
          "snippet": "static inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
  },
  {
    "function_name": "get_node_page_ra",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1066-1114",
    "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != NODE_MAPPING(sbi)"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ra_node_page",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "ra_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1012-1033",
          "snippet": "void ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tapage = find_get_page(NODE_MAPPING(sbi), nid);\n\tif (apage && PageUptodate(apage)) {\n\t\tf2fs_put_page(apage, 0);\n\t\treturn;\n\t}\n\tf2fs_put_page(apage, 0);\n\n\tapage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, READA);\n\tif (err == 0)\n\t\tf2fs_put_page(apage, 0);\n\telse if (err == LOCKED_PAGE)\n\t\tf2fs_put_page(apage, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tapage = find_get_page(NODE_MAPPING(sbi), nid);\n\tif (apage && PageUptodate(apage)) {\n\t\tf2fs_put_page(apage, 0);\n\t\treturn;\n\t}\n\tf2fs_put_page(apage, 0);\n\n\tapage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, READA);\n\tif (err == 0)\n\t\tf2fs_put_page(apage, 0);\n\telse if (err == LOCKED_PAGE)\n\t\tf2fs_put_page(apage, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nid",
          "args": [
            "parent",
            "i",
            "false"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "get_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "330-337",
          "snippet": "static inline nid_t get_nid(struct page *p, int off, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tif (i)\n\t\treturn le32_to_cpu(rn->i.i_nid[off - NODE_DIR1_BLOCK]);\n\treturn le32_to_cpu(rn->in.nid[off]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t get_nid(struct page *p, int off, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tif (i)\n\t\treturn le32_to_cpu(rn->i.i_nid[off - NODE_DIR1_BLOCK]);\n\treturn le32_to_cpu(rn->in.nid[off]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "NIDS_PER_BLOCK"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_node_page",
          "args": [
            "page",
            "READ_SYNC"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "986-1007",
          "snippet": "static int read_node_page(struct page *page, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = rw,\n\t};\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn -ENOENT;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tfio.blk_addr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(sbi, page, &fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int read_node_page(struct page *page, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = rw,\n\t};\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn -ENOENT;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tfio.blk_addr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(sbi, page, &fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "NODE_MAPPING(sbi)",
            "nid"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "parent"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "get_node_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1035-1060",
    "snippet": "struct page *get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid)\n{\n\tstruct page *page;\n\tint err;\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err != LOCKED_PAGE)\n\t\tlock_page(page);\n\n\tif (unlikely(!PageUptodate(page) || nid != nid_of_node(page))) {\n\t\tClearPageUptodate(page);\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != NODE_MAPPING(sbi)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page) || nid != nid_of_node(page)"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nid_of_node",
          "args": [
            "page"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "nid_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "253-257",
          "snippet": "static inline nid_t nid_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.nid);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t nid_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_node_page",
          "args": [
            "page",
            "READ_SYNC"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "986-1007",
          "snippet": "static int read_node_page(struct page *page, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = rw,\n\t};\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn -ENOENT;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tfio.blk_addr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(sbi, page, &fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int read_node_page(struct page *page, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = rw,\n\t};\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn -ENOENT;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tfio.blk_addr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(sbi, page, &fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "NODE_MAPPING(sbi)",
            "nid"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid)\n{\n\tstruct page *page;\n\tint err;\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err != LOCKED_PAGE)\n\t\tlock_page(page);\n\n\tif (unlikely(!PageUptodate(page) || nid != nid_of_node(page))) {\n\t\tClearPageUptodate(page);\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "ra_node_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "1012-1033",
    "snippet": "void ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tapage = find_get_page(NODE_MAPPING(sbi), nid);\n\tif (apage && PageUptodate(apage)) {\n\t\tf2fs_put_page(apage, 0);\n\t\treturn;\n\t}\n\tf2fs_put_page(apage, 0);\n\n\tapage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, READA);\n\tif (err == 0)\n\t\tf2fs_put_page(apage, 0);\n\telse if (err == LOCKED_PAGE)\n\t\tf2fs_put_page(apage, 1);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "apage",
            "1"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_node_page",
          "args": [
            "apage",
            "READA"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "986-1007",
          "snippet": "static int read_node_page(struct page *page, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = rw,\n\t};\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn -ENOENT;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tfio.blk_addr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(sbi, page, &fio);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int read_node_page(struct page *page, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = rw,\n\t};\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn -ENOENT;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tfio.blk_addr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(sbi, page, &fio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "NODE_MAPPING(sbi)",
            "nid"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "apage"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "NODE_MAPPING(sbi)",
            "nid"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tapage = find_get_page(NODE_MAPPING(sbi), nid);\n\tif (apage && PageUptodate(apage)) {\n\t\tf2fs_put_page(apage, 0);\n\t\treturn;\n\t}\n\tf2fs_put_page(apage, 0);\n\n\tapage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, READA);\n\tif (err == 0)\n\t\tf2fs_put_page(apage, 0);\n\telse if (err == LOCKED_PAGE)\n\t\tf2fs_put_page(apage, 1);\n}"
  },
  {
    "function_name": "read_node_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "986-1007",
    "snippet": "static int read_node_page(struct page *page, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = rw,\n\t};\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn -ENOENT;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tfio.blk_addr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(sbi, page, &fio);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_submit_page_bio",
          "args": [
            "sbi",
            "page",
            "&fio"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_page_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "133-152",
          "snippet": "int f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_submit_page_bio(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct bio *bio;\n\n\ttrace_f2fs_submit_page_bio(page, fio);\n\tf2fs_trace_ios(page, fio, 0);\n\n\t/* Allocate a new bio */\n\tbio = __bio_alloc(sbi, fio->blk_addr, 1, is_read_io(fio->rw));\n\n\tif (bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) < PAGE_CACHE_SIZE) {\n\t\tbio_put(bio);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFAULT;\n\t}\n\n\tsubmit_bio(fio->rw, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ni.blk_addr == NULL_ADDR"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "page->index",
            "&ni"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int read_node_page(struct page *page, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.type = NODE,\n\t\t.rw = rw,\n\t};\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn -ENOENT;\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tfio.blk_addr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(sbi, page, &fio);\n}"
  },
  {
    "function_name": "new_node_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "927-978",
    "snippet": "struct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = grab_cache_page(NODE_MAPPING(sbi), dn->nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tget_node_info(sbi, dn->nid, &old_ni);\n\n\t/* Reinitialize old_ni with new node page */\n\tf2fs_bug_on(sbi, old_ni.blk_addr != NULL_ADDR);\n\tnew_ni = old_ni;\n\tnew_ni.ino = dn->inode->i_ino;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tF2FS_I(dn->inode)->i_xattr_nid = dn->nid;\n\n\tdn->node_page = page;\n\tif (ipage)\n\t\tupdate_inode(dn->inode, ipage);\n\telse\n\t\tsync_inode_page(dn);\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_node_page_dirty",
          "args": [
            "page"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "clear_node_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "72-88",
          "snippet": "static void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_valid_inode_count",
          "args": [
            "sbi"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "inc_valid_inode_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1015-1021",
          "snippet": "static inline void inc_valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, sbi->total_valid_inode_count == sbi->total_node_count);\n\tsbi->total_valid_inode_count++;\n\tspin_unlock(&sbi->stat_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inc_valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, sbi->total_valid_inode_count == sbi->total_node_count);\n\tsbi->total_valid_inode_count++;\n\tspin_unlock(&sbi->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "dn"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "dn->inode",
            "ipage"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dn->inode"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_xattr_block",
          "args": [
            "ofs"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "822-825",
          "snippet": "static inline bool f2fs_has_xattr_block(unsigned int ofs)\n{\n\treturn ofs == XATTR_NODE_OFFSET;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define XATTR_NODE_OFFSET\t((((unsigned int)-1) << OFFSET_BIT_SHIFT) \\\n\t\t\t\t>> OFFSET_BIT_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\n#define XATTR_NODE_OFFSET\t((((unsigned int)-1) << OFFSET_BIT_SHIFT) \\\n\t\t\t\t>> OFFSET_BIT_SHIFT)\n\nstatic inline bool f2fs_has_xattr_block(unsigned int ofs)\n{\n\treturn ofs == XATTR_NODE_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cold_node",
          "args": [
            "dn->inode",
            "page"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "set_cold_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "392-402",
          "snippet": "static inline void set_cold_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int flag = le32_to_cpu(rn->footer.flag);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflag &= ~(0x1 << COLD_BIT_SHIFT);\n\telse\n\t\tflag |= (0x1 << COLD_BIT_SHIFT);\n\trn->footer.flag = cpu_to_le32(flag);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_cold_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int flag = le32_to_cpu(rn->footer.flag);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflag &= ~(0x1 << COLD_BIT_SHIFT);\n\telse\n\t\tflag |= (0x1 << COLD_BIT_SHIFT);\n\trn->footer.flag = cpu_to_le32(flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_node_footer",
          "args": [
            "page",
            "dn->nid",
            "dn->inode->i_ino",
            "ofs",
            "true"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "fill_node_footer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "212-229",
          "snippet": "static inline void fill_node_footer(struct page *page, nid_t nid,\n\t\t\t\tnid_t ino, unsigned int ofs, bool reset)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int old_flag = 0;\n\n\tif (reset)\n\t\tmemset(rn, 0, sizeof(*rn));\n\telse\n\t\told_flag = le32_to_cpu(rn->footer.flag);\n\n\trn->footer.nid = cpu_to_le32(nid);\n\trn->footer.ino = cpu_to_le32(ino);\n\n\t/* should remain old flag bits such as COLD_BIT_SHIFT */\n\trn->footer.flag = cpu_to_le32((ofs << OFFSET_BIT_SHIFT) |\n\t\t\t\t\t(old_flag & OFFSET_BIT_MASK));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void fill_node_footer(struct page *page, nid_t nid,\n\t\t\t\tnid_t ino, unsigned int ofs, bool reset)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int old_flag = 0;\n\n\tif (reset)\n\t\tmemset(rn, 0, sizeof(*rn));\n\telse\n\t\told_flag = le32_to_cpu(rn->footer.flag);\n\n\trn->footer.nid = cpu_to_le32(nid);\n\trn->footer.ino = cpu_to_le32(ino);\n\n\t/* should remain old flag bits such as COLD_BIT_SHIFT */\n\trn->footer.flag = cpu_to_le32((ofs << OFFSET_BIT_SHIFT) |\n\t\t\t\t\t(old_flag & OFFSET_BIT_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "NODE"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_node_addr",
          "args": [
            "sbi",
            "&new_ni",
            "NEW_ADDR",
            "false"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "set_node_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "263-315",
          "snippet": "static void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "old_ni.blk_addr != NULL_ADDR"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "dn->nid",
            "&old_ni"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inc_valid_node_count(sbi, dn->inode)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_valid_node_count",
          "args": [
            "sbi",
            "dn->inode"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "inc_valid_node_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "963-992",
          "snippet": "static inline bool inc_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tblock_t\tvalid_block_count;\n\tunsigned int valid_node_count;\n\n\tspin_lock(&sbi->stat_lock);\n\n\tvalid_block_count = sbi->total_valid_block_count + 1;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tvalid_node_count = sbi->total_valid_node_count + 1;\n\tif (unlikely(valid_node_count > sbi->total_node_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tif (inode)\n\t\tinode->i_blocks++;\n\n\tsbi->alloc_valid_block_count++;\n\tsbi->total_valid_node_count++;\n\tsbi->total_valid_block_count++;\n\tspin_unlock(&sbi->stat_lock);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool inc_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tblock_t\tvalid_block_count;\n\tunsigned int valid_node_count;\n\n\tspin_lock(&sbi->stat_lock);\n\n\tvalid_block_count = sbi->total_valid_block_count + 1;\n\tif (unlikely(valid_block_count > sbi->user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tvalid_node_count = sbi->total_valid_node_count + 1;\n\tif (unlikely(valid_node_count > sbi->total_node_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn false;\n\t}\n\n\tif (inode)\n\t\tinode->i_blocks++;\n\n\tsbi->alloc_valid_block_count++;\n\tsbi->total_valid_node_count++;\n\tsbi->total_valid_block_count++;\n\tspin_unlock(&sbi->stat_lock);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "NODE_MAPPING(sbi)",
            "dn->nid"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(dn->inode)",
            "FI_NO_ALLOC"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = grab_cache_page(NODE_MAPPING(sbi), dn->nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tget_node_info(sbi, dn->nid, &old_ni);\n\n\t/* Reinitialize old_ni with new node page */\n\tf2fs_bug_on(sbi, old_ni.blk_addr != NULL_ADDR);\n\tnew_ni = old_ni;\n\tnew_ni.ino = dn->inode->i_ino;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tF2FS_I(dn->inode)->i_xattr_nid = dn->nid;\n\n\tdn->node_page = page;\n\tif (ipage)\n\t\tupdate_inode(dn->inode, ipage);\n\telse\n\t\tsync_inode_page(dn);\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "new_inode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "916-925",
    "snippet": "struct page *new_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\t/* allocate inode page for new inode */\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\n\t/* caller should f2fs_put_page(page, 1); */\n\treturn new_node_page(&dn, 0, NULL);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_node_page",
          "args": [
            "&dn",
            "0",
            "NULL"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "new_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "927-978",
          "snippet": "struct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = grab_cache_page(NODE_MAPPING(sbi), dn->nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tget_node_info(sbi, dn->nid, &old_ni);\n\n\t/* Reinitialize old_ni with new node page */\n\tf2fs_bug_on(sbi, old_ni.blk_addr != NULL_ADDR);\n\tnew_ni = old_ni;\n\tnew_ni.ino = dn->inode->i_ino;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tF2FS_I(dn->inode)->i_xattr_nid = dn->nid;\n\n\tdn->node_page = page;\n\tif (ipage)\n\t\tupdate_inode(dn->inode, ipage);\n\telse\n\t\tsync_inode_page(dn);\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = grab_cache_page(NODE_MAPPING(sbi), dn->nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tget_node_info(sbi, dn->nid, &old_ni);\n\n\t/* Reinitialize old_ni with new node page */\n\tf2fs_bug_on(sbi, old_ni.blk_addr != NULL_ADDR);\n\tnew_ni = old_ni;\n\tnew_ni.ino = dn->inode->i_ino;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tF2FS_I(dn->inode)->i_xattr_nid = dn->nid;\n\n\tdn->node_page = page;\n\tif (ipage)\n\t\tupdate_inode(dn->inode, ipage);\n\telse\n\t\tsync_inode_page(dn);\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "inode->i_ino"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *new_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\t/* allocate inode page for new inode */\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\n\t/* caller should f2fs_put_page(page, 1); */\n\treturn new_node_page(&dn, 0, NULL);\n}"
  },
  {
    "function_name": "remove_inode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "890-914",
    "snippet": "void remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\tif (get_dnode_of_data(&dn, 0, LOOKUP_NODE))\n\t\treturn;\n\n\tif (truncate_xattr_node(inode, dn.inode_page)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_node",
          "args": [
            "&dn"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "574-608",
          "snippet": "static void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_I_SB(inode)",
            "inode->i_blocks != 0 && inode->i_blocks != 1"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_data_blocks_range",
          "args": [
            "&dn",
            "1"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_blocks_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "420-450",
          "snippet": "int truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_xattr_node",
          "args": [
            "inode",
            "dn.inode_page"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_xattr_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "859-884",
          "snippet": "int truncate_xattr_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tF2FS_I(inode)->i_xattr_nid = 0;\n\n\t/* need to do checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\n\tset_new_dnode(&dn, inode, page, npage, nid);\n\n\tif (page)\n\t\tdn.inode_page_locked = true;\n\ttruncate_node(&dn);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_xattr_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tF2FS_I(inode)->i_xattr_nid = 0;\n\n\t/* need to do checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\n\tset_new_dnode(&dn, inode, page, npage, nid);\n\n\tif (page)\n\t\tdn.inode_page_locked = true;\n\ttruncate_node(&dn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "0",
            "LOOKUP_NODE"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "inode->i_ino"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\tif (get_dnode_of_data(&dn, 0, LOOKUP_NODE))\n\t\treturn;\n\n\tif (truncate_xattr_node(inode, dn.inode_page)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n}"
  },
  {
    "function_name": "truncate_xattr_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "859-884",
    "snippet": "int truncate_xattr_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tF2FS_I(inode)->i_xattr_nid = 0;\n\n\t/* need to do checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\n\tset_new_dnode(&dn, inode, page, npage, nid);\n\n\tif (page)\n\t\tdn.inode_page_locked = true;\n\ttruncate_node(&dn);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_node",
          "args": [
            "&dn"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "574-608",
          "snippet": "static void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "page",
            "npage",
            "nid"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_cp_version",
          "args": [
            "F2FS_CKPT(sbi)"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "cur_cp_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "730-733",
          "snippet": "static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "npage"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "npage"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_xattr_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tF2FS_I(inode)->i_xattr_nid = 0;\n\n\t/* need to do checkpoint during fsync */\n\tF2FS_I(inode)->xattr_ver = cur_cp_version(F2FS_CKPT(sbi));\n\n\tset_new_dnode(&dn, inode, page, npage, nid);\n\n\tif (page)\n\t\tdn.inode_page_locked = true;\n\ttruncate_node(&dn);\n\treturn 0;\n}"
  },
  {
    "function_name": "truncate_inode_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "763-857",
    "snippet": "int truncate_inode_blocks(struct inode *inode, pgoff_t from)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err = 0, cont = 1;\n\tint level, offset[4], noffset[4];\n\tunsigned int nofs = 0;\n\tstruct f2fs_inode *ri;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\n\ttrace_f2fs_truncate_inode_blocks_enter(inode, from);\n\n\tlevel = get_node_path(F2FS_I(inode), from, offset, noffset);\nrestart:\n\tpage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_inode_blocks_exit(inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tset_new_dnode(&dn, inode, page, NULL, 0);\n\tunlock_page(page);\n\n\tri = F2FS_INODE(page);\n\tswitch (level) {\n\tcase 0:\n\tcase 1:\n\t\tnofs = noffset[1];\n\t\tbreak;\n\tcase 2:\n\t\tnofs = noffset[1];\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tnofs += 1 + NIDS_PER_BLOCK;\n\t\tbreak;\n\tcase 3:\n\t\tnofs = 5 + 2 * NIDS_PER_BLOCK;\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nskip_partial:\n\twhile (cont) {\n\t\tdn.nid = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\t\tswitch (offset[0]) {\n\t\tcase NODE_DIR1_BLOCK:\n\t\tcase NODE_DIR2_BLOCK:\n\t\t\terr = truncate_dnode(&dn);\n\t\t\tbreak;\n\n\t\tcase NODE_IND1_BLOCK:\n\t\tcase NODE_IND2_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 2);\n\t\t\tbreak;\n\n\t\tcase NODE_DIND_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 3);\n\t\t\tcont = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tif (offset[1] == 0 &&\n\t\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK]) {\n\t\t\tlock_page(page);\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK] = 0;\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\toffset[1] = 0;\n\t\toffset[0]++;\n\t\tnofs += err;\n\t}\nfail:\n\tf2fs_put_page(page, 0);\n\ttrace_f2fs_truncate_inode_blocks_exit(inode, err);\n\treturn err > 0 ? 0 : err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_inode_blocks_exit",
          "args": [
            "inode",
            "err"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "0"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "NODE"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != NODE_MAPPING(sbi)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_nodes",
          "args": [
            "&dn",
            "nofs",
            "offset[1]",
            "3"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "632-701",
          "snippet": "static int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,\n\t\t\t\t\t\tint ofs, int depth)\n{\n\tstruct dnode_of_data rdn = *dn;\n\tstruct page *page;\n\tstruct f2fs_node *rn;\n\tnid_t child_nid;\n\tunsigned int child_nofs;\n\tint freed = 0;\n\tint i, ret;\n\n\tif (dn->nid == 0)\n\t\treturn NIDS_PER_BLOCK + 1;\n\n\ttrace_f2fs_truncate_nodes_enter(dn->inode, dn->nid, dn->data_blkaddr);\n\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_nodes_exit(dn->inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\trn = F2FS_NODE(page);\n\tif (depth < 3) {\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++, freed++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0)\n\t\t\t\tcontinue;\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_dnode(&rdn);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t\tset_nid(page, i, 0, false);\n\t\t}\n\t} else {\n\t\tchild_nofs = nofs + ofs * (NIDS_PER_BLOCK + 1) + 1;\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0) {\n\t\t\t\tchild_nofs += NIDS_PER_BLOCK + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_nodes(&rdn, child_nofs, 0, depth - 1);\n\t\t\tif (ret == (NIDS_PER_BLOCK + 1)) {\n\t\t\t\tset_nid(page, i, 0, false);\n\t\t\t\tchild_nofs += ret;\n\t\t\t} else if (ret < 0 && ret != -ENOENT) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfreed = child_nofs;\n\t}\n\n\tif (!ofs) {\n\t\t/* remove current indirect node */\n\t\tdn->node_page = page;\n\t\ttruncate_node(dn);\n\t\tfreed++;\n\t} else {\n\t\tf2fs_put_page(page, 1);\n\t}\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, freed);\n\treturn freed;\n\nout_err:\n\tf2fs_put_page(page, 1);\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,\n\t\t\t\t\t\tint ofs, int depth)\n{\n\tstruct dnode_of_data rdn = *dn;\n\tstruct page *page;\n\tstruct f2fs_node *rn;\n\tnid_t child_nid;\n\tunsigned int child_nofs;\n\tint freed = 0;\n\tint i, ret;\n\n\tif (dn->nid == 0)\n\t\treturn NIDS_PER_BLOCK + 1;\n\n\ttrace_f2fs_truncate_nodes_enter(dn->inode, dn->nid, dn->data_blkaddr);\n\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_nodes_exit(dn->inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\trn = F2FS_NODE(page);\n\tif (depth < 3) {\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++, freed++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0)\n\t\t\t\tcontinue;\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_dnode(&rdn);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t\tset_nid(page, i, 0, false);\n\t\t}\n\t} else {\n\t\tchild_nofs = nofs + ofs * (NIDS_PER_BLOCK + 1) + 1;\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0) {\n\t\t\t\tchild_nofs += NIDS_PER_BLOCK + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_nodes(&rdn, child_nofs, 0, depth - 1);\n\t\t\tif (ret == (NIDS_PER_BLOCK + 1)) {\n\t\t\t\tset_nid(page, i, 0, false);\n\t\t\t\tchild_nofs += ret;\n\t\t\t} else if (ret < 0 && ret != -ENOENT) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfreed = child_nofs;\n\t}\n\n\tif (!ofs) {\n\t\t/* remove current indirect node */\n\t\tdn->node_page = page;\n\t\ttruncate_node(dn);\n\t\tfreed++;\n\t} else {\n\t\tf2fs_put_page(page, 1);\n\t}\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, freed);\n\treturn freed;\n\nout_err:\n\tf2fs_put_page(page, 1);\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_dnode",
          "args": [
            "&dn"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "610-630",
          "snippet": "static int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ri->i_nid[offset[0] - NODE_DIR1_BLOCK]"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_partial_nodes",
          "args": [
            "&dn",
            "ri",
            "offset",
            "level"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_partial_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "703-758",
          "snippet": "static int truncate_partial_nodes(struct dnode_of_data *dn,\n\t\t\tstruct f2fs_inode *ri, int *offset, int depth)\n{\n\tstruct page *pages[2];\n\tnid_t nid[3];\n\tnid_t child_nid;\n\tint err = 0;\n\tint i;\n\tint idx = depth - 2;\n\n\tnid[0] = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\tif (!nid[0])\n\t\treturn 0;\n\n\t/* get indirect nodes in the path */\n\tfor (i = 0; i < idx + 1; i++) {\n\t\t/* reference count'll be increased */\n\t\tpages[i] = get_node_page(F2FS_I_SB(dn->inode), nid[i]);\n\t\tif (IS_ERR(pages[i])) {\n\t\t\terr = PTR_ERR(pages[i]);\n\t\t\tidx = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tnid[i + 1] = get_nid(pages[i], offset[i + 1], false);\n\t}\n\n\t/* free direct nodes linked to a partial indirect node */\n\tfor (i = offset[idx + 1]; i < NIDS_PER_BLOCK; i++) {\n\t\tchild_nid = get_nid(pages[idx], i, false);\n\t\tif (!child_nid)\n\t\t\tcontinue;\n\t\tdn->nid = child_nid;\n\t\terr = truncate_dnode(dn);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t\tset_nid(pages[idx], i, 0, false);\n\t}\n\n\tif (offset[idx + 1] == 0) {\n\t\tdn->node_page = pages[idx];\n\t\tdn->nid = nid[idx];\n\t\ttruncate_node(dn);\n\t} else {\n\t\tf2fs_put_page(pages[idx], 1);\n\t}\n\toffset[idx]++;\n\toffset[idx + 1] = 0;\n\tidx--;\nfail:\n\tfor (i = idx; i >= 0; i--)\n\t\tf2fs_put_page(pages[i], 1);\n\n\ttrace_f2fs_truncate_partial_nodes(dn->inode, nid, depth, err);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_partial_nodes(struct dnode_of_data *dn,\n\t\t\tstruct f2fs_inode *ri, int *offset, int depth)\n{\n\tstruct page *pages[2];\n\tnid_t nid[3];\n\tnid_t child_nid;\n\tint err = 0;\n\tint i;\n\tint idx = depth - 2;\n\n\tnid[0] = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\tif (!nid[0])\n\t\treturn 0;\n\n\t/* get indirect nodes in the path */\n\tfor (i = 0; i < idx + 1; i++) {\n\t\t/* reference count'll be increased */\n\t\tpages[i] = get_node_page(F2FS_I_SB(dn->inode), nid[i]);\n\t\tif (IS_ERR(pages[i])) {\n\t\t\terr = PTR_ERR(pages[i]);\n\t\t\tidx = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tnid[i + 1] = get_nid(pages[i], offset[i + 1], false);\n\t}\n\n\t/* free direct nodes linked to a partial indirect node */\n\tfor (i = offset[idx + 1]; i < NIDS_PER_BLOCK; i++) {\n\t\tchild_nid = get_nid(pages[idx], i, false);\n\t\tif (!child_nid)\n\t\t\tcontinue;\n\t\tdn->nid = child_nid;\n\t\terr = truncate_dnode(dn);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t\tset_nid(pages[idx], i, 0, false);\n\t}\n\n\tif (offset[idx + 1] == 0) {\n\t\tdn->node_page = pages[idx];\n\t\tdn->nid = nid[idx];\n\t\ttruncate_node(dn);\n\t} else {\n\t\tf2fs_put_page(pages[idx], 1);\n\t}\n\toffset[idx]++;\n\toffset[idx + 1] = 0;\n\tidx--;\nfail:\n\tfor (i = idx; i >= 0; i--)\n\t\tf2fs_put_page(pages[i], 1);\n\n\ttrace_f2fs_truncate_partial_nodes(dn->inode, nid, depth, err);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_INODE",
          "args": [
            "page"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "page",
            "NULL",
            "0"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_inode_blocks_exit",
          "args": [
            "inode",
            "PTR_ERR(page)"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_path",
          "args": [
            "F2FS_I(inode)",
            "from",
            "offset",
            "noffset"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "393-465",
          "snippet": "static int get_node_path(struct f2fs_inode_info *fi, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(fi);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\tBUG();\n\t}\ngot:\n\treturn level;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_node_path(struct f2fs_inode_info *fi, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(fi);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\tBUG();\n\t}\ngot:\n\treturn level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_inode_blocks_enter",
          "args": [
            "inode",
            "from"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_inode_blocks(struct inode *inode, pgoff_t from)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err = 0, cont = 1;\n\tint level, offset[4], noffset[4];\n\tunsigned int nofs = 0;\n\tstruct f2fs_inode *ri;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\n\ttrace_f2fs_truncate_inode_blocks_enter(inode, from);\n\n\tlevel = get_node_path(F2FS_I(inode), from, offset, noffset);\nrestart:\n\tpage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_inode_blocks_exit(inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tset_new_dnode(&dn, inode, page, NULL, 0);\n\tunlock_page(page);\n\n\tri = F2FS_INODE(page);\n\tswitch (level) {\n\tcase 0:\n\tcase 1:\n\t\tnofs = noffset[1];\n\t\tbreak;\n\tcase 2:\n\t\tnofs = noffset[1];\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tnofs += 1 + NIDS_PER_BLOCK;\n\t\tbreak;\n\tcase 3:\n\t\tnofs = 5 + 2 * NIDS_PER_BLOCK;\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nskip_partial:\n\twhile (cont) {\n\t\tdn.nid = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\t\tswitch (offset[0]) {\n\t\tcase NODE_DIR1_BLOCK:\n\t\tcase NODE_DIR2_BLOCK:\n\t\t\terr = truncate_dnode(&dn);\n\t\t\tbreak;\n\n\t\tcase NODE_IND1_BLOCK:\n\t\tcase NODE_IND2_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 2);\n\t\t\tbreak;\n\n\t\tcase NODE_DIND_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 3);\n\t\t\tcont = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tif (offset[1] == 0 &&\n\t\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK]) {\n\t\t\tlock_page(page);\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tf2fs_wait_on_page_writeback(page, NODE);\n\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK] = 0;\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\toffset[1] = 0;\n\t\toffset[0]++;\n\t\tnofs += err;\n\t}\nfail:\n\tf2fs_put_page(page, 0);\n\ttrace_f2fs_truncate_inode_blocks_exit(inode, err);\n\treturn err > 0 ? 0 : err;\n}"
  },
  {
    "function_name": "truncate_partial_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "703-758",
    "snippet": "static int truncate_partial_nodes(struct dnode_of_data *dn,\n\t\t\tstruct f2fs_inode *ri, int *offset, int depth)\n{\n\tstruct page *pages[2];\n\tnid_t nid[3];\n\tnid_t child_nid;\n\tint err = 0;\n\tint i;\n\tint idx = depth - 2;\n\n\tnid[0] = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\tif (!nid[0])\n\t\treturn 0;\n\n\t/* get indirect nodes in the path */\n\tfor (i = 0; i < idx + 1; i++) {\n\t\t/* reference count'll be increased */\n\t\tpages[i] = get_node_page(F2FS_I_SB(dn->inode), nid[i]);\n\t\tif (IS_ERR(pages[i])) {\n\t\t\terr = PTR_ERR(pages[i]);\n\t\t\tidx = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tnid[i + 1] = get_nid(pages[i], offset[i + 1], false);\n\t}\n\n\t/* free direct nodes linked to a partial indirect node */\n\tfor (i = offset[idx + 1]; i < NIDS_PER_BLOCK; i++) {\n\t\tchild_nid = get_nid(pages[idx], i, false);\n\t\tif (!child_nid)\n\t\t\tcontinue;\n\t\tdn->nid = child_nid;\n\t\terr = truncate_dnode(dn);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t\tset_nid(pages[idx], i, 0, false);\n\t}\n\n\tif (offset[idx + 1] == 0) {\n\t\tdn->node_page = pages[idx];\n\t\tdn->nid = nid[idx];\n\t\ttruncate_node(dn);\n\t} else {\n\t\tf2fs_put_page(pages[idx], 1);\n\t}\n\toffset[idx]++;\n\toffset[idx + 1] = 0;\n\tidx--;\nfail:\n\tfor (i = idx; i >= 0; i--)\n\t\tf2fs_put_page(pages[i], 1);\n\n\ttrace_f2fs_truncate_partial_nodes(dn->inode, nid, depth, err);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_partial_nodes",
          "args": [
            "dn->inode",
            "nid",
            "depth",
            "err"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "pages[i]",
            "1"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_node",
          "args": [
            "dn"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "574-608",
          "snippet": "static void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nid",
          "args": [
            "pages[idx]",
            "i",
            "0",
            "false"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "set_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "317-328",
          "snippet": "static inline void set_nid(struct page *p, int off, nid_t nid, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tf2fs_wait_on_page_writeback(p, NODE);\n\n\tif (i)\n\t\trn->i.i_nid[off - NODE_DIR1_BLOCK] = cpu_to_le32(nid);\n\telse\n\t\trn->in.nid[off] = cpu_to_le32(nid);\n\tset_page_dirty(p);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_nid(struct page *p, int off, nid_t nid, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tf2fs_wait_on_page_writeback(p, NODE);\n\n\tif (i)\n\t\trn->i.i_nid[off - NODE_DIR1_BLOCK] = cpu_to_le32(nid);\n\telse\n\t\trn->in.nid[off] = cpu_to_le32(nid);\n\tset_page_dirty(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_dnode",
          "args": [
            "dn"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "610-630",
          "snippet": "static int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nid",
          "args": [
            "pages[idx]",
            "i",
            "false"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "get_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "330-337",
          "snippet": "static inline nid_t get_nid(struct page *p, int off, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tif (i)\n\t\treturn le32_to_cpu(rn->i.i_nid[off - NODE_DIR1_BLOCK]);\n\treturn le32_to_cpu(rn->in.nid[off]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t get_nid(struct page *p, int off, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tif (i)\n\t\treturn le32_to_cpu(rn->i.i_nid[off - NODE_DIR1_BLOCK]);\n\treturn le32_to_cpu(rn->in.nid[off]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pages[i]"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pages[i]"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "F2FS_I_SB(dn->inode)",
            "nid[i]"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ri->i_nid[offset[0] - NODE_DIR1_BLOCK]"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_partial_nodes(struct dnode_of_data *dn,\n\t\t\tstruct f2fs_inode *ri, int *offset, int depth)\n{\n\tstruct page *pages[2];\n\tnid_t nid[3];\n\tnid_t child_nid;\n\tint err = 0;\n\tint i;\n\tint idx = depth - 2;\n\n\tnid[0] = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\tif (!nid[0])\n\t\treturn 0;\n\n\t/* get indirect nodes in the path */\n\tfor (i = 0; i < idx + 1; i++) {\n\t\t/* reference count'll be increased */\n\t\tpages[i] = get_node_page(F2FS_I_SB(dn->inode), nid[i]);\n\t\tif (IS_ERR(pages[i])) {\n\t\t\terr = PTR_ERR(pages[i]);\n\t\t\tidx = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tnid[i + 1] = get_nid(pages[i], offset[i + 1], false);\n\t}\n\n\t/* free direct nodes linked to a partial indirect node */\n\tfor (i = offset[idx + 1]; i < NIDS_PER_BLOCK; i++) {\n\t\tchild_nid = get_nid(pages[idx], i, false);\n\t\tif (!child_nid)\n\t\t\tcontinue;\n\t\tdn->nid = child_nid;\n\t\terr = truncate_dnode(dn);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t\tset_nid(pages[idx], i, 0, false);\n\t}\n\n\tif (offset[idx + 1] == 0) {\n\t\tdn->node_page = pages[idx];\n\t\tdn->nid = nid[idx];\n\t\ttruncate_node(dn);\n\t} else {\n\t\tf2fs_put_page(pages[idx], 1);\n\t}\n\toffset[idx]++;\n\toffset[idx + 1] = 0;\n\tidx--;\nfail:\n\tfor (i = idx; i >= 0; i--)\n\t\tf2fs_put_page(pages[i], 1);\n\n\ttrace_f2fs_truncate_partial_nodes(dn->inode, nid, depth, err);\n\n\treturn err;\n}"
  },
  {
    "function_name": "truncate_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "632-701",
    "snippet": "static int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,\n\t\t\t\t\t\tint ofs, int depth)\n{\n\tstruct dnode_of_data rdn = *dn;\n\tstruct page *page;\n\tstruct f2fs_node *rn;\n\tnid_t child_nid;\n\tunsigned int child_nofs;\n\tint freed = 0;\n\tint i, ret;\n\n\tif (dn->nid == 0)\n\t\treturn NIDS_PER_BLOCK + 1;\n\n\ttrace_f2fs_truncate_nodes_enter(dn->inode, dn->nid, dn->data_blkaddr);\n\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_nodes_exit(dn->inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\trn = F2FS_NODE(page);\n\tif (depth < 3) {\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++, freed++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0)\n\t\t\t\tcontinue;\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_dnode(&rdn);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t\tset_nid(page, i, 0, false);\n\t\t}\n\t} else {\n\t\tchild_nofs = nofs + ofs * (NIDS_PER_BLOCK + 1) + 1;\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0) {\n\t\t\t\tchild_nofs += NIDS_PER_BLOCK + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_nodes(&rdn, child_nofs, 0, depth - 1);\n\t\t\tif (ret == (NIDS_PER_BLOCK + 1)) {\n\t\t\t\tset_nid(page, i, 0, false);\n\t\t\t\tchild_nofs += ret;\n\t\t\t} else if (ret < 0 && ret != -ENOENT) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfreed = child_nofs;\n\t}\n\n\tif (!ofs) {\n\t\t/* remove current indirect node */\n\t\tdn->node_page = page;\n\t\ttruncate_node(dn);\n\t\tfreed++;\n\t} else {\n\t\tf2fs_put_page(page, 1);\n\t}\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, freed);\n\treturn freed;\n\nout_err:\n\tf2fs_put_page(page, 1);\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_nodes_exit",
          "args": [
            "dn->inode",
            "ret"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_nodes_exit",
          "args": [
            "dn->inode",
            "freed"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_node",
          "args": [
            "dn"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "574-608",
          "snippet": "static void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nid",
          "args": [
            "page",
            "i",
            "0",
            "false"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "set_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "317-328",
          "snippet": "static inline void set_nid(struct page *p, int off, nid_t nid, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tf2fs_wait_on_page_writeback(p, NODE);\n\n\tif (i)\n\t\trn->i.i_nid[off - NODE_DIR1_BLOCK] = cpu_to_le32(nid);\n\telse\n\t\trn->in.nid[off] = cpu_to_le32(nid);\n\tset_page_dirty(p);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_nid(struct page *p, int off, nid_t nid, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tf2fs_wait_on_page_writeback(p, NODE);\n\n\tif (i)\n\t\trn->i.i_nid[off - NODE_DIR1_BLOCK] = cpu_to_le32(nid);\n\telse\n\t\trn->in.nid[off] = cpu_to_le32(nid);\n\tset_page_dirty(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_nodes",
          "args": [
            "&rdn",
            "child_nofs",
            "0",
            "depth - 1"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "632-701",
          "snippet": "static int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,\n\t\t\t\t\t\tint ofs, int depth)\n{\n\tstruct dnode_of_data rdn = *dn;\n\tstruct page *page;\n\tstruct f2fs_node *rn;\n\tnid_t child_nid;\n\tunsigned int child_nofs;\n\tint freed = 0;\n\tint i, ret;\n\n\tif (dn->nid == 0)\n\t\treturn NIDS_PER_BLOCK + 1;\n\n\ttrace_f2fs_truncate_nodes_enter(dn->inode, dn->nid, dn->data_blkaddr);\n\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_nodes_exit(dn->inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\trn = F2FS_NODE(page);\n\tif (depth < 3) {\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++, freed++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0)\n\t\t\t\tcontinue;\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_dnode(&rdn);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t\tset_nid(page, i, 0, false);\n\t\t}\n\t} else {\n\t\tchild_nofs = nofs + ofs * (NIDS_PER_BLOCK + 1) + 1;\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0) {\n\t\t\t\tchild_nofs += NIDS_PER_BLOCK + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_nodes(&rdn, child_nofs, 0, depth - 1);\n\t\t\tif (ret == (NIDS_PER_BLOCK + 1)) {\n\t\t\t\tset_nid(page, i, 0, false);\n\t\t\t\tchild_nofs += ret;\n\t\t\t} else if (ret < 0 && ret != -ENOENT) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfreed = child_nofs;\n\t}\n\n\tif (!ofs) {\n\t\t/* remove current indirect node */\n\t\tdn->node_page = page;\n\t\ttruncate_node(dn);\n\t\tfreed++;\n\t} else {\n\t\tf2fs_put_page(page, 1);\n\t}\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, freed);\n\treturn freed;\n\nout_err:\n\tf2fs_put_page(page, 1);\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, ret);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rn->in.nid[i]"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_dnode",
          "args": [
            "&rdn"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "610-630",
          "snippet": "static int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_NODE",
          "args": [
            "page"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "670-673",
          "snippet": "static inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_nodes_exit",
          "args": [
            "dn->inode",
            "PTR_ERR(page)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "F2FS_I_SB(dn->inode)",
            "dn->nid"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_nodes_enter",
          "args": [
            "dn->inode",
            "dn->nid",
            "dn->data_blkaddr"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,\n\t\t\t\t\t\tint ofs, int depth)\n{\n\tstruct dnode_of_data rdn = *dn;\n\tstruct page *page;\n\tstruct f2fs_node *rn;\n\tnid_t child_nid;\n\tunsigned int child_nofs;\n\tint freed = 0;\n\tint i, ret;\n\n\tif (dn->nid == 0)\n\t\treturn NIDS_PER_BLOCK + 1;\n\n\ttrace_f2fs_truncate_nodes_enter(dn->inode, dn->nid, dn->data_blkaddr);\n\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_nodes_exit(dn->inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\trn = F2FS_NODE(page);\n\tif (depth < 3) {\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++, freed++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0)\n\t\t\t\tcontinue;\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_dnode(&rdn);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t\tset_nid(page, i, 0, false);\n\t\t}\n\t} else {\n\t\tchild_nofs = nofs + ofs * (NIDS_PER_BLOCK + 1) + 1;\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0) {\n\t\t\t\tchild_nofs += NIDS_PER_BLOCK + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_nodes(&rdn, child_nofs, 0, depth - 1);\n\t\t\tif (ret == (NIDS_PER_BLOCK + 1)) {\n\t\t\t\tset_nid(page, i, 0, false);\n\t\t\t\tchild_nofs += ret;\n\t\t\t} else if (ret < 0 && ret != -ENOENT) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfreed = child_nofs;\n\t}\n\n\tif (!ofs) {\n\t\t/* remove current indirect node */\n\t\tdn->node_page = page;\n\t\ttruncate_node(dn);\n\t\tfreed++;\n\t} else {\n\t\tf2fs_put_page(page, 1);\n\t}\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, freed);\n\treturn freed;\n\nout_err:\n\tf2fs_put_page(page, 1);\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "truncate_dnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "610-630",
    "snippet": "static int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_node",
          "args": [
            "dn"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "574-608",
          "snippet": "static void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_data_blocks",
          "args": [
            "dn"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "452-455",
          "snippet": "void truncate_data_blocks(struct dnode_of_data *dn)\n{\n\ttruncate_data_blocks_range(dn, ADDRS_PER_BLOCK);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid truncate_data_blocks(struct dnode_of_data *dn)\n{\n\ttruncate_data_blocks_range(dn, ADDRS_PER_BLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "F2FS_I_SB(dn->inode)",
            "dn->nid"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}"
  },
  {
    "function_name": "truncate_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "574-608",
    "snippet": "static void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_truncate_node",
          "args": [
            "dn->inode",
            "dn->nid",
            "ni.blk_addr"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "NODE_MAPPING(sbi)",
            "dn->node_page->index",
            "dn->node_page->index"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "dn->node_page",
            "1"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sbi_flag",
          "args": [
            "sbi",
            "SBI_IS_DIRTY"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "set_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "720-723",
          "snippet": "static inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_node_page_dirty",
          "args": [
            "dn->node_page"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "clear_node_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "72-88",
          "snippet": "static void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "dn"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_valid_inode_count",
          "args": [
            "sbi"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "dec_valid_inode_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1023-1029",
          "snippet": "static inline void dec_valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, !sbi->total_valid_inode_count);\n\tsbi->total_valid_inode_count--;\n\tspin_unlock(&sbi->stat_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, !sbi->total_valid_inode_count);\n\tsbi->total_valid_inode_count--;\n\tspin_unlock(&sbi->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_orphan_inode",
          "args": [
            "sbi",
            "dn->nid"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "remove_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "449-453",
          "snippet": "void remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* remove orphan entry from orphan list */\n\t__remove_ino_entry(sbi, ino, ORPHAN_INO);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* remove orphan entry from orphan list */\n\t__remove_ino_entry(sbi, ino, ORPHAN_INO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_node_addr",
          "args": [
            "sbi",
            "&ni",
            "NULL_ADDR",
            "false"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "set_node_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "263-315",
          "snippet": "static void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_valid_node_count",
          "args": [
            "sbi",
            "dn->inode"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "dec_valid_node_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "994-1008",
          "snippet": "static inline void dec_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tspin_lock(&sbi->stat_lock);\n\n\tf2fs_bug_on(sbi, !sbi->total_valid_block_count);\n\tf2fs_bug_on(sbi, !sbi->total_valid_node_count);\n\tf2fs_bug_on(sbi, !inode->i_blocks);\n\n\tinode->i_blocks--;\n\tsbi->total_valid_node_count--;\n\tsbi->total_valid_block_count--;\n\n\tspin_unlock(&sbi->stat_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tspin_lock(&sbi->stat_lock);\n\n\tf2fs_bug_on(sbi, !sbi->total_valid_block_count);\n\tf2fs_bug_on(sbi, !sbi->total_valid_node_count);\n\tf2fs_bug_on(sbi, !inode->i_blocks);\n\n\tinode->i_blocks--;\n\tsbi->total_valid_node_count--;\n\tsbi->total_valid_block_count--;\n\n\tspin_unlock(&sbi->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_blocks",
          "args": [
            "sbi",
            "ni.blk_addr"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "695-713",
          "snippet": "void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR)\n\t\treturn;\n\n\t/* add it into sit main buffer */\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR)\n\t\treturn;\n\n\t/* add it into sit main buffer */\n\tmutex_lock(&sit_i->sentry_lock);\n\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "ni.blk_addr == NULL_ADDR"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "ni.blk_addr != NULL_ADDR"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "dn->nid",
            "&ni"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t} else {\n\t\tsync_inode_page(dn);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}"
  },
  {
    "function_name": "get_dnode_of_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "473-572",
    "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "npage[0]",
            "0"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "datablock_addr",
          "args": [
            "dn->node_page",
            "dn->ofs_in_node"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "datablock_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1098-1106",
          "snippet": "static inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nid",
          "args": [
            "parent",
            "offset[i]",
            "false"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "get_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "330-337",
          "snippet": "static inline nid_t get_nid(struct page *p, int off, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tif (i)\n\t\treturn le32_to_cpu(rn->i.i_nid[off - NODE_DIR1_BLOCK]);\n\treturn le32_to_cpu(rn->in.nid[off]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t get_nid(struct page *p, int off, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tif (i)\n\t\treturn le32_to_cpu(rn->i.i_nid[off - NODE_DIR1_BLOCK]);\n\treturn le32_to_cpu(rn->in.nid[off]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "npage[i]"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "npage[i]"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "nids[i]"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "parent"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "npage[i]"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "npage[i]"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_nid_done",
          "args": [
            "sbi",
            "nids[i]"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1582-1594",
          "snippet": "void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nid",
          "args": [
            "parent",
            "offset[i - 1]",
            "nids[i]",
            "i == 1"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "set_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "317-328",
          "snippet": "static inline void set_nid(struct page *p, int off, nid_t nid, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tf2fs_wait_on_page_writeback(p, NODE);\n\n\tif (i)\n\t\trn->i.i_nid[off - NODE_DIR1_BLOCK] = cpu_to_le32(nid);\n\telse\n\t\trn->in.nid[off] = cpu_to_le32(nid);\n\tset_page_dirty(p);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_nid(struct page *p, int off, nid_t nid, bool i)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(p);\n\n\tf2fs_wait_on_page_writeback(p, NODE);\n\n\tif (i)\n\t\trn->i.i_nid[off - NODE_DIR1_BLOCK] = cpu_to_le32(nid);\n\telse\n\t\trn->in.nid[off] = cpu_to_le32(nid);\n\tset_page_dirty(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "npage[i]"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_nid_failed",
          "args": [
            "sbi",
            "nids[i]"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1599-1622",
          "snippet": "void alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "npage[i]"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_node_page",
          "args": [
            "dn",
            "noffset[i]",
            "NULL"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "new_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "927-978",
          "snippet": "struct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = grab_cache_page(NODE_MAPPING(sbi), dn->nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tget_node_info(sbi, dn->nid, &old_ni);\n\n\t/* Reinitialize old_ni with new node page */\n\tf2fs_bug_on(sbi, old_ni.blk_addr != NULL_ADDR);\n\tnew_ni = old_ni;\n\tnew_ni.ino = dn->inode->i_ino;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tF2FS_I(dn->inode)->i_xattr_nid = dn->nid;\n\n\tdn->node_page = page;\n\tif (ipage)\n\t\tupdate_inode(dn->inode, ipage);\n\telse\n\t\tsync_inode_page(dn);\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = grab_cache_page(NODE_MAPPING(sbi), dn->nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tget_node_info(sbi, dn->nid, &old_ni);\n\n\t/* Reinitialize old_ni with new node page */\n\tf2fs_bug_on(sbi, old_ni.blk_addr != NULL_ADDR);\n\tnew_ni = old_ni;\n\tnew_ni.ino = dn->inode->i_ino;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tF2FS_I(dn->inode)->i_xattr_nid = dn->nid;\n\n\tdn->node_page = page;\n\tif (ipage)\n\t\tupdate_inode(dn->inode, ipage);\n\telse\n\t\tsync_inode_page(dn);\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "dn->inode"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "npage[0]"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "npage[0]"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_path",
          "args": [
            "F2FS_I(dn->inode)",
            "index",
            "offset",
            "noffset"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "393-465",
          "snippet": "static int get_node_path(struct f2fs_inode_info *fi, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(fi);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\tBUG();\n\t}\ngot:\n\treturn level;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_node_path(struct f2fs_inode_info *fi, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(fi);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\tBUG();\n\t}\ngot:\n\treturn level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dn->inode"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
  },
  {
    "function_name": "get_node_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "393-465",
    "snippet": "static int get_node_path(struct f2fs_inode_info *fi, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(fi);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\tBUG();\n\t}\ngot:\n\treturn level;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDRS_PER_INODE",
          "args": [
            "fi"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int get_node_path(struct f2fs_inode_info *fi, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(fi);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\tBUG();\n\t}\ngot:\n\treturn level;\n}"
  },
  {
    "function_name": "get_node_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "339-387",
    "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_nat_entry",
          "args": [
            "NM_I(sbi)",
            "nid",
            "&ne"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "cache_nat_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "249-261",
          "snippet": "static void cache_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid,\n\t\t\t\t\t\tstruct f2fs_nat_entry *ne)\n{\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, nid);\n\t\tnode_info_from_raw_nat(&e->ni, ne);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void cache_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid,\n\t\t\t\t\t\tstruct f2fs_nat_entry *ne)\n{\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, nid);\n\t\tnode_info_from_raw_nat(&e->ni, ne);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_info_from_raw_nat",
          "args": [
            "ni",
            "&ne"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "node_info_from_raw_nat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "102-108",
          "snippet": "static inline void node_info_from_raw_nat(struct node_info *ni,\n\t\t\t\t\t\tstruct f2fs_nat_entry *raw_ne)\n{\n\tni->ino = le32_to_cpu(raw_ne->ino);\n\tni->blk_addr = le32_to_cpu(raw_ne->block_addr);\n\tni->version = raw_ne->version;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void node_info_from_raw_nat(struct node_info *ni,\n\t\t\t\t\t\tstruct f2fs_nat_entry *raw_ne)\n{\n\tni->ino = le32_to_cpu(raw_ne->ino);\n\tni->blk_addr = le32_to_cpu(raw_ne->block_addr);\n\tni->version = raw_ne->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_nat_page",
          "args": [
            "sbi",
            "start_nid"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "get_current_nat_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "90-94",
          "snippet": "static struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_in_journal",
          "args": [
            "sum",
            "i"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_journal_in_cursum",
          "args": [
            "sum",
            "NAT_JOURNAL",
            "nid",
            "0"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_journal_in_cursum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1578-1598",
          "snippet": "int lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && nats_in_cursum(sum) < NAT_JOURNAL_ENTRIES)\n\t\t\treturn update_nats_in_cursum(sum, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(sum); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && sits_in_cursum(sum) < SIT_JOURNAL_ENTRIES)\n\t\t\treturn update_sits_in_cursum(sum, 1);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint lookup_journal_in_cursum(struct f2fs_summary_block *sum, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(sum); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && nats_in_cursum(sum) < NAT_JOURNAL_ENTRIES)\n\t\t\treturn update_nats_in_cursum(sum, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(sum); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(sum, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && sits_in_cursum(sum) < SIT_JOURNAL_ENTRIES)\n\t\t\treturn update_sits_in_cursum(sum, 1);\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&curseg->curseg_mutex"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ne",
            "0",
            "sizeof(struct f2fs_nat_entry)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_version",
          "args": [
            "e"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "e"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_ino",
          "args": [
            "e"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_nat_cache",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "125-128",
          "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "START_NID",
          "args": [
            "nid"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_HOT_DATA"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
  },
  {
    "function_name": "try_to_free_nats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "317-334",
    "snippet": "int try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tif (available_free_memory(sbi, NAT_ENTRIES))\n\t\treturn 0;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile (nr_shrink && !list_empty(&nm_i->nat_entries)) {\n\t\tstruct nat_entry *ne;\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\treturn nr_shrink;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__del_from_nat_cache",
          "args": [
            "nm_i",
            "ne"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "__del_from_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "136-142",
          "snippet": "static void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tlist_del(&e->list);\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt--;\n\tkmem_cache_free(nat_entry_slab, e);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\n\nstatic void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tlist_del(&e->list);\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt--;\n\tkmem_cache_free(nat_entry_slab, e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&nm_i->nat_entries",
            "structnat_entry",
            "list"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nm_i->nat_entries"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "available_free_memory",
          "args": [
            "sbi",
            "NAT_ENTRIES"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "available_free_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "31-70",
          "snippet": "bool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tif (available_free_memory(sbi, NAT_ENTRIES))\n\t\treturn 0;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile (nr_shrink && !list_empty(&nm_i->nat_entries)) {\n\t\tstruct nat_entry *ne;\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\treturn nr_shrink;\n}"
  },
  {
    "function_name": "set_node_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "263-315",
    "snippet": "static void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nat_flag",
          "args": [
            "e",
            "HAS_LAST_FSYNC",
            "fsync_done"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "set_nat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "78-86",
          "snippet": "static inline void set_nat_flag(struct nat_entry *ne,\n\t\t\t\tunsigned int type, bool set)\n{\n\tunsigned char mask = 0x01 << type;\n\tif (set)\n\t\tne->ni.flag |= mask;\n\telse\n\t\tne->ni.flag &= ~mask;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_nat_flag(struct nat_entry *ne,\n\t\t\t\tunsigned int type, bool set)\n{\n\tunsigned char mask = 0x01 << type;\n\tif (set)\n\t\tne->ni.flag |= mask;\n\telse\n\t\tne->ni.flag &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_nat_cache",
          "args": [
            "nm_i",
            "ni->ino"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "125-128",
          "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_nat_cache_dirty",
          "args": [
            "nm_i",
            "e"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "__set_nat_cache_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "144-167",
          "snippet": "static void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\treturn;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab, GFP_ATOMIC);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\tlist_move_tail(&ne->list, &head->entry_list);\n\tnm_i->dirty_nat_cnt++;\n\thead->entry_cnt++;\n\tset_nat_flag(ne, IS_DIRTY, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_set_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_set_slab;\n\nstatic void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\treturn;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab, GFP_ATOMIC);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\tlist_move_tail(&ne->list, &head->entry_list);\n\tnm_i->dirty_nat_cnt++;\n\thead->entry_cnt++;\n\tset_nat_flag(ne, IS_DIRTY, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nat_set_blkaddr",
          "args": [
            "e",
            "new_blkaddr"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_set_version",
          "args": [
            "e",
            "inc_node_version(version)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_node_version",
          "args": [
            "version"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_version",
          "args": [
            "e"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "e"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "e"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "e"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "e"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "e"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "nat_get_blkaddr(e) != ni->blk_addr"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_blkaddr",
          "args": [
            "e"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "ni->blk_addr != NULL_ADDR"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_node_info",
          "args": [
            "&e->ni",
            "ni"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "copy_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "68-76",
          "snippet": "static inline void copy_node_info(struct node_info *dst,\n\t\t\t\t\t\tstruct node_info *src)\n{\n\tdst->nid = src->nid;\n\tdst->ino = src->ino;\n\tdst->blk_addr = src->blk_addr;\n\tdst->version = src->version;\n\t/* should not copy flag here */\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void copy_node_info(struct node_info *dst,\n\t\t\t\t\t\tstruct node_info *src)\n{\n\tdst->nid = src->nid;\n\tdst->ino = src->ino;\n\tdst->blk_addr = src->blk_addr;\n\tdst->version = src->version;\n\t/* should not copy flag here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "ni->blk_addr == NEW_ADDR"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_nat_entry",
          "args": [
            "nm_i",
            "ni->nid"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "grab_nat_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "235-247",
          "snippet": "static struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_ATOMIC);\n\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\n\nstatic struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_ATOMIC);\n\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}"
  },
  {
    "function_name": "cache_nat_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "249-261",
    "snippet": "static void cache_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid,\n\t\t\t\t\t\tstruct f2fs_nat_entry *ne)\n{\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, nid);\n\t\tnode_info_from_raw_nat(&e->ni, ne);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_info_from_raw_nat",
          "args": [
            "&e->ni",
            "ne"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "node_info_from_raw_nat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "102-108",
          "snippet": "static inline void node_info_from_raw_nat(struct node_info *ni,\n\t\t\t\t\t\tstruct f2fs_nat_entry *raw_ne)\n{\n\tni->ino = le32_to_cpu(raw_ne->ino);\n\tni->blk_addr = le32_to_cpu(raw_ne->block_addr);\n\tni->version = raw_ne->version;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void node_info_from_raw_nat(struct node_info *ni,\n\t\t\t\t\t\tstruct f2fs_nat_entry *raw_ne)\n{\n\tni->ino = le32_to_cpu(raw_ne->ino);\n\tni->blk_addr = le32_to_cpu(raw_ne->block_addr);\n\tni->version = raw_ne->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_nat_entry",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "grab_nat_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "235-247",
          "snippet": "static struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_ATOMIC);\n\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nat_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\n\nstatic struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_ATOMIC);\n\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_nat_cache",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "125-128",
          "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void cache_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid,\n\t\t\t\t\t\tstruct f2fs_nat_entry *ne)\n{\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, nid);\n\t\tnode_info_from_raw_nat(&e->ni, ne);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}"
  },
  {
    "function_name": "grab_nat_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "235-247",
    "snippet": "static struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_ATOMIC);\n\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nat_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->list",
            "&nm_i->nat_entries"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_reset_flag",
          "args": [
            "new"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "nat_reset_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "94-100",
          "snippet": "static inline void nat_reset_flag(struct nat_entry *ne)\n{\n\t/* these states can be set only after checkpoint was done */\n\tset_nat_flag(ne, IS_CHECKPOINTED, true);\n\tset_nat_flag(ne, HAS_FSYNCED_INODE, false);\n\tset_nat_flag(ne, HAS_LAST_FSYNC, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void nat_reset_flag(struct nat_entry *ne)\n{\n\t/* these states can be set only after checkpoint was done */\n\tset_nat_flag(ne, IS_CHECKPOINTED, true);\n\tset_nat_flag(ne, HAS_FSYNCED_INODE, false);\n\tset_nat_flag(ne, HAS_LAST_FSYNC, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nat_set_nid",
          "args": [
            "new",
            "nid"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new",
            "0",
            "sizeof(struct nat_entry)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_radix_tree_insert",
          "args": [
            "&nm_i->nat_root",
            "nid",
            "new"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "nat_entry_slab",
            "GFP_ATOMIC"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\n\nstatic struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_ATOMIC);\n\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}"
  },
  {
    "function_name": "need_inode_block_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "219-233",
    "snippet": "bool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nat_flag",
          "args": [
            "e",
            "HAS_FSYNCED_INODE"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "get_nat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "88-92",
          "snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_nat_cache",
          "args": [
            "nm_i",
            "ino"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "125-128",
          "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}"
  },
  {
    "function_name": "has_fsynced_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "205-217",
    "snippet": "bool has_fsynced_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool fsynced = false;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_FSYNCED_INODE))\n\t\tfsynced = true;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn fsynced;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nat_flag",
          "args": [
            "e",
            "HAS_FSYNCED_INODE"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "get_nat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "88-92",
          "snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_nat_cache",
          "args": [
            "nm_i",
            "ino"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "125-128",
          "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool has_fsynced_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool fsynced = false;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_FSYNCED_INODE))\n\t\tfsynced = true;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn fsynced;\n}"
  },
  {
    "function_name": "is_checkpointed_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "191-203",
    "snippet": "bool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nat_flag",
          "args": [
            "e",
            "IS_CHECKPOINTED"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "get_nat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "88-92",
          "snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_nat_cache",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_nat_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "125-128",
          "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nm_i->nat_tree_lock"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}"
  },
  {
    "function_name": "__gang_lookup_nat_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "184-189",
    "snippet": "static unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&nm_i->nat_set_root",
            "(void **)ep",
            "start",
            "nr"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}"
  },
  {
    "function_name": "__clear_nat_cache_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "169-182",
    "snippet": "static void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (head) {\n\t\tlist_move_tail(&ne->list, &nm_i->nat_entries);\n\t\tset_nat_flag(ne, IS_DIRTY, false);\n\t\thead->entry_cnt--;\n\t\tnm_i->dirty_nat_cnt--;\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nat_flag",
          "args": [
            "ne",
            "IS_DIRTY",
            "false"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "set_nat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "78-86",
          "snippet": "static inline void set_nat_flag(struct nat_entry *ne,\n\t\t\t\tunsigned int type, bool set)\n{\n\tunsigned char mask = 0x01 << type;\n\tif (set)\n\t\tne->ni.flag |= mask;\n\telse\n\t\tne->ni.flag &= ~mask;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_nat_flag(struct nat_entry *ne,\n\t\t\t\tunsigned int type, bool set)\n{\n\tunsigned char mask = 0x01 << type;\n\tif (set)\n\t\tne->ni.flag |= mask;\n\telse\n\t\tne->ni.flag &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ne->list",
            "&nm_i->nat_entries"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&nm_i->nat_set_root",
            "set"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NAT_BLOCK_OFFSET",
          "args": [
            "ne->ni.nid"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (head) {\n\t\tlist_move_tail(&ne->list, &nm_i->nat_entries);\n\t\tset_nat_flag(ne, IS_DIRTY, false);\n\t\thead->entry_cnt--;\n\t\tnm_i->dirty_nat_cnt--;\n\t}\n}"
  },
  {
    "function_name": "__set_nat_cache_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "144-167",
    "snippet": "static void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\treturn;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab, GFP_ATOMIC);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\tlist_move_tail(&ne->list, &head->entry_list);\n\tnm_i->dirty_nat_cnt++;\n\thead->entry_cnt++;\n\tset_nat_flag(ne, IS_DIRTY, true);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nat_entry_set_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nat_flag",
          "args": [
            "ne",
            "IS_DIRTY",
            "true"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "set_nat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "78-86",
          "snippet": "static inline void set_nat_flag(struct nat_entry *ne,\n\t\t\t\tunsigned int type, bool set)\n{\n\tunsigned char mask = 0x01 << type;\n\tif (set)\n\t\tne->ni.flag |= mask;\n\telse\n\t\tne->ni.flag &= ~mask;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_nat_flag(struct nat_entry *ne,\n\t\t\t\tunsigned int type, bool set)\n{\n\tunsigned char mask = 0x01 << type;\n\tif (set)\n\t\tne->ni.flag |= mask;\n\telse\n\t\tne->ni.flag &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ne->list",
            "&head->entry_list"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_radix_tree_insert",
          "args": [
            "&nm_i->nat_set_root",
            "set",
            "head"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&head->set_list"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&head->entry_list"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "nat_entry_set_slab",
            "GFP_ATOMIC"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&nm_i->nat_set_root",
            "set"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nat_flag",
          "args": [
            "ne",
            "IS_DIRTY"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "get_nat_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "88-92",
          "snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)\n{\n\tunsigned char mask = 0x01 << type;\n\treturn ne->ni.flag & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NAT_BLOCK_OFFSET",
          "args": [
            "ne->ni.nid"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_set_slab;\n\nstatic void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\treturn;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab, GFP_ATOMIC);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\tlist_move_tail(&ne->list, &head->entry_list);\n\tnm_i->dirty_nat_cnt++;\n\thead->entry_cnt++;\n\tset_nat_flag(ne, IS_DIRTY, true);\n}"
  },
  {
    "function_name": "__del_from_nat_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "136-142",
    "snippet": "static void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tlist_del(&e->list);\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt--;\n\tkmem_cache_free(nat_entry_slab, e);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nat_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nat_entry_slab",
            "e"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&nm_i->nat_root",
            "nat_get_nid(e)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nat_get_nid",
          "args": [
            "e"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->list"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *nat_entry_slab;\n\nstatic void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tlist_del(&e->list);\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt--;\n\tkmem_cache_free(nat_entry_slab, e);\n}"
  },
  {
    "function_name": "__gang_lookup_nat_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "130-134",
    "snippet": "static unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_root, (void **)ep, start, nr);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&nm_i->nat_root",
            "(void **)ep",
            "start",
            "nr"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_root, (void **)ep, start, nr);\n}"
  },
  {
    "function_name": "__lookup_nat_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "125-128",
    "snippet": "static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&nm_i->nat_root",
            "n"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}"
  },
  {
    "function_name": "get_next_nat_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "96-123",
    "snippet": "static struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *src_page;\n\tstruct page *dst_page;\n\tpgoff_t src_off;\n\tpgoff_t dst_off;\n\tvoid *src_addr;\n\tvoid *dst_addr;\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tsrc_off = current_nat_addr(sbi, nid);\n\tdst_off = next_nat_addr(sbi, src_off);\n\n\t/* get current nat block page with lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_CACHE_SIZE);\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_nat(nm_i, nid);\n\n\treturn dst_page;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_to_next_nat",
          "args": [
            "nm_i",
            "nid"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "set_to_next_nat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "205-210",
          "snippet": "static inline void set_to_next_nat(struct f2fs_nm_info *nm_i, nid_t start_nid)\n{\n\tunsigned int block_off = NAT_BLOCK_OFFSET(start_nid);\n\n\tf2fs_change_bit(block_off, nm_i->nat_bitmap);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_to_next_nat(struct f2fs_nm_info *nm_i, nid_t start_nid)\n{\n\tunsigned int block_off = NAT_BLOCK_OFFSET(start_nid);\n\n\tf2fs_change_bit(block_off, nm_i->nat_bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "src_page",
            "1"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "dst_page"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_addr",
            "src_addr",
            "PAGE_CACHE_SIZE"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "dst_page"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "src_page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "PageDirty(src_page)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "src_page"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_meta_page",
          "args": [
            "sbi",
            "dst_off"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "grab_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "32-45",
          "snippet": "struct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page = NULL;\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META);\n\tSetPageUptodate(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "src_off"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_nat_addr",
          "args": [
            "sbi",
            "src_off"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "next_nat_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "191-203",
          "snippet": "static inline pgoff_t next_nat_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tpgoff_t block_addr)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tblock_addr -= nm_i->nat_blkaddr;\n\tif ((block_addr >> sbi->log_blocks_per_seg) % 2)\n\t\tblock_addr -= sbi->blocks_per_seg;\n\telse\n\t\tblock_addr += sbi->blocks_per_seg;\n\n\treturn block_addr + nm_i->nat_blkaddr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline pgoff_t next_nat_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tpgoff_t block_addr)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tblock_addr -= nm_i->nat_blkaddr;\n\tif ((block_addr >> sbi->log_blocks_per_seg) % 2)\n\t\tblock_addr -= sbi->blocks_per_seg;\n\telse\n\t\tblock_addr += sbi->blocks_per_seg;\n\n\treturn block_addr + nm_i->nat_blkaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_nat_addr",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "current_nat_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "171-189",
          "snippet": "static inline pgoff_t current_nat_addr(struct f2fs_sb_info *sbi, nid_t start)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tpgoff_t block_off;\n\tpgoff_t block_addr;\n\tint seg_off;\n\n\tblock_off = NAT_BLOCK_OFFSET(start);\n\tseg_off = block_off >> sbi->log_blocks_per_seg;\n\n\tblock_addr = (pgoff_t)(nm_i->nat_blkaddr +\n\t\t(seg_off << sbi->log_blocks_per_seg << 1) +\n\t\t(block_off & ((1 << sbi->log_blocks_per_seg) - 1)));\n\n\tif (f2fs_test_bit(block_off, nm_i->nat_bitmap))\n\t\tblock_addr += sbi->blocks_per_seg;\n\n\treturn block_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline pgoff_t current_nat_addr(struct f2fs_sb_info *sbi, nid_t start)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tpgoff_t block_off;\n\tpgoff_t block_addr;\n\tint seg_off;\n\n\tblock_off = NAT_BLOCK_OFFSET(start);\n\tseg_off = block_off >> sbi->log_blocks_per_seg;\n\n\tblock_addr = (pgoff_t)(nm_i->nat_blkaddr +\n\t\t(seg_off << sbi->log_blocks_per_seg << 1) +\n\t\t(block_off & ((1 << sbi->log_blocks_per_seg) - 1)));\n\n\tif (f2fs_test_bit(block_off, nm_i->nat_bitmap))\n\t\tblock_addr += sbi->blocks_per_seg;\n\n\treturn block_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *src_page;\n\tstruct page *dst_page;\n\tpgoff_t src_off;\n\tpgoff_t dst_off;\n\tvoid *src_addr;\n\tvoid *dst_addr;\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tsrc_off = current_nat_addr(sbi, nid);\n\tdst_off = next_nat_addr(sbi, src_off);\n\n\t/* get current nat block page with lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_CACHE_SIZE);\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_nat(nm_i, nid);\n\n\treturn dst_page;\n}"
  },
  {
    "function_name": "get_current_nat_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "90-94",
    "snippet": "static struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "index"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_nat_addr",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "current_nat_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "171-189",
          "snippet": "static inline pgoff_t current_nat_addr(struct f2fs_sb_info *sbi, nid_t start)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tpgoff_t block_off;\n\tpgoff_t block_addr;\n\tint seg_off;\n\n\tblock_off = NAT_BLOCK_OFFSET(start);\n\tseg_off = block_off >> sbi->log_blocks_per_seg;\n\n\tblock_addr = (pgoff_t)(nm_i->nat_blkaddr +\n\t\t(seg_off << sbi->log_blocks_per_seg << 1) +\n\t\t(block_off & ((1 << sbi->log_blocks_per_seg) - 1)));\n\n\tif (f2fs_test_bit(block_off, nm_i->nat_bitmap))\n\t\tblock_addr += sbi->blocks_per_seg;\n\n\treturn block_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline pgoff_t current_nat_addr(struct f2fs_sb_info *sbi, nid_t start)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tpgoff_t block_off;\n\tpgoff_t block_addr;\n\tint seg_off;\n\n\tblock_off = NAT_BLOCK_OFFSET(start);\n\tseg_off = block_off >> sbi->log_blocks_per_seg;\n\n\tblock_addr = (pgoff_t)(nm_i->nat_blkaddr +\n\t\t(seg_off << sbi->log_blocks_per_seg << 1) +\n\t\t(block_off & ((1 << sbi->log_blocks_per_seg) - 1)));\n\n\tif (f2fs_test_bit(block_off, nm_i->nat_bitmap))\n\t\tblock_addr += sbi->blocks_per_seg;\n\n\treturn block_addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}"
  },
  {
    "function_name": "clear_node_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "72-88",
    "snippet": "static void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_page_count",
          "args": [
            "F2FS_M_SB(mapping)",
            "F2FS_DIRTY_NODES"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "dec_page_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "871-874",
          "snippet": "static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_M_SB",
          "args": [
            "mapping"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_M_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "650-653",
          "snippet": "static inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)\n{\n\treturn F2FS_I_SB(mapping->host);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)\n{\n\treturn F2FS_I_SB(mapping->host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mapping->tree_lock",
            "flags"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&mapping->page_tree",
            "page_index(page)",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mapping->tree_lock",
            "flags"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}"
  },
  {
    "function_name": "available_free_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
    "lines": "31-70",
    "snippet": "bool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"trace.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mpage.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_DIRTY_DENTS"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "&val"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NM_I",
          "args": [
            "sbi"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "NM_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "680-683",
          "snippet": "static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/* give 25%, 25%, 50%, 50% memory for each components respectively */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->fcnt * sizeof(struct free_nid)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += (sbi->im[i].ino_num *\n\t\t\t\tsizeof(struct ino_entry)) >> PAGE_CACHE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (sbi->sb->s_bdi->dirty_exceeded)\n\t\t\treturn false;\n\t}\n\treturn res;\n}"
  }
]