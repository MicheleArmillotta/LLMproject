[
  {
    "function_name": "build_gc_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "743-746",
    "snippet": "void build_gc_manager(struct f2fs_sb_info *sbi)\n{\n\tDIRTY_I(sbi)->v_ops = &default_v_ops;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct victim_selection default_v_ops = {\n\t.get_victim = get_victim_by_default,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic const struct victim_selection default_v_ops = {\n\t.get_victim = get_victim_by_default,\n};\n\nvoid build_gc_manager(struct f2fs_sb_info *sbi)\n{\n\tDIRTY_I(sbi)->v_ops = &default_v_ops;\n}"
  },
  {
    "function_name": "f2fs_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "689-741",
    "snippet": "int f2fs_gc(struct f2fs_sb_info *sbi)\n{\n\tunsigned int segno, i;\n\tint gc_type = BG_GC;\n\tint nfree = 0;\n\tint ret = -1;\n\tstruct cp_control cpc;\n\tstruct gc_inode_list gc_list = {\n\t\t.ilist = LIST_HEAD_INIT(gc_list.ilist),\n\t\t.iroot = RADIX_TREE_INIT(GFP_NOFS),\n\t};\n\n\tcpc.reason = __get_cp_reason(sbi);\ngc_more:\n\tif (unlikely(!(sbi->sb->s_flags & MS_ACTIVE)))\n\t\tgoto stop;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto stop;\n\n\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, nfree)) {\n\t\tgc_type = FG_GC;\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\tif (!__get_victim(sbi, &segno, gc_type))\n\t\tgoto stop;\n\tret = 0;\n\n\t/* readahead multi ssa blocks those have contiguous address */\n\tif (sbi->segs_per_sec > 1)\n\t\tra_meta_pages(sbi, GET_SUM_BLOCK(sbi, segno), sbi->segs_per_sec,\n\t\t\t\t\t\t\t\tMETA_SSA);\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tdo_garbage_collect(sbi, segno + i, &gc_list, gc_type);\n\n\tif (gc_type == FG_GC) {\n\t\tsbi->cur_victim_sec = NULL_SEGNO;\n\t\tnfree++;\n\t\tWARN_ON(get_valid_blocks(sbi, segno, sbi->segs_per_sec));\n\t}\n\n\tif (has_not_enough_free_secs(sbi, nfree))\n\t\tgoto gc_more;\n\n\tif (gc_type == FG_GC)\n\t\twrite_checkpoint(sbi, &cpc);\nstop:\n\tmutex_unlock(&sbi->gc_mutex);\n\n\tput_gc_inode(&gc_list);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_gc_inode",
          "args": [
            "&gc_list"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "put_gc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "364-373",
          "snippet": "static void put_gc_inode(struct gc_inode_list *gc_list)\n{\n\tstruct inode_entry *ie, *next_ie;\n\tlist_for_each_entry_safe(ie, next_ie, &gc_list->ilist, list) {\n\t\tradix_tree_delete(&gc_list->iroot, ie->inode->i_ino);\n\t\tiput(ie->inode);\n\t\tlist_del(&ie->list);\n\t\tkmem_cache_free(inode_entry_slab, ie);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void put_gc_inode(struct gc_inode_list *gc_list)\n{\n\tstruct inode_entry *ie, *next_ie;\n\tlist_for_each_entry_safe(ie, next_ie, &gc_list->ilist, list) {\n\t\tradix_tree_delete(&gc_list->iroot, ie->inode->i_ino);\n\t\tiput(ie->inode);\n\t\tlist_del(&ie->list);\n\t\tkmem_cache_free(inode_entry_slab, ie);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_checkpoint",
          "args": [
            "sbi",
            "&cpc"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "write_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1046-1091",
          "snippet": "void write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_not_enough_free_secs",
          "args": [
            "sbi",
            "nfree"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "has_not_enough_free_secs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "459-469",
          "snippet": "static inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "get_valid_blocks(sbi, segno, sbi->segs_per_sec)"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "sbi->segs_per_sec"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_garbage_collect",
          "args": [
            "sbi",
            "segno + i",
            "&gc_list",
            "gc_type"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "do_garbage_collect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "659-687",
          "snippet": "static void do_garbage_collect(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\t\t\tstruct gc_inode_list *gc_list, int gc_type)\n{\n\tstruct page *sum_page;\n\tstruct f2fs_summary_block *sum;\n\tstruct blk_plug plug;\n\n\t/* read segment summary of victim */\n\tsum_page = get_sum_page(sbi, segno);\n\n\tblk_start_plug(&plug);\n\n\tsum = page_address(sum_page);\n\n\tswitch (GET_SUM_TYPE((&sum->footer))) {\n\tcase SUM_TYPE_NODE:\n\t\tgc_node_segment(sbi, sum->entries, segno, gc_type);\n\t\tbreak;\n\tcase SUM_TYPE_DATA:\n\t\tgc_data_segment(sbi, sum->entries, gc_list, segno, gc_type);\n\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tstat_inc_seg_count(sbi, GET_SUM_TYPE((&sum->footer)));\n\tstat_inc_call_count(sbi->stat_info);\n\n\tf2fs_put_page(sum_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void do_garbage_collect(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\t\t\tstruct gc_inode_list *gc_list, int gc_type)\n{\n\tstruct page *sum_page;\n\tstruct f2fs_summary_block *sum;\n\tstruct blk_plug plug;\n\n\t/* read segment summary of victim */\n\tsum_page = get_sum_page(sbi, segno);\n\n\tblk_start_plug(&plug);\n\n\tsum = page_address(sum_page);\n\n\tswitch (GET_SUM_TYPE((&sum->footer))) {\n\tcase SUM_TYPE_NODE:\n\t\tgc_node_segment(sbi, sum->entries, segno, gc_type);\n\t\tbreak;\n\tcase SUM_TYPE_DATA:\n\t\tgc_data_segment(sbi, sum->entries, gc_list, segno, gc_type);\n\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tstat_inc_seg_count(sbi, GET_SUM_TYPE((&sum->footer)));\n\tstat_inc_call_count(sbi->stat_info);\n\n\tf2fs_put_page(sum_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_meta_pages",
          "args": [
            "sbi",
            "GET_SUM_BLOCK(sbi, segno)",
            "sbi->segs_per_sec",
            "META_SSA"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "115-170",
          "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SUM_BLOCK",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_victim",
          "args": [
            "sbi",
            "&segno",
            "gc_type"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__get_victim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "646-657",
          "snippet": "static int __get_victim(struct f2fs_sb_info *sbi, unsigned int *victim,\n\t\t\tint gc_type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tret = DIRTY_I(sbi)->v_ops->get_victim(sbi, victim, gc_type,\n\t\t\t\t\t      NO_CHECK_TYPE, LFS);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int __get_victim(struct f2fs_sb_info *sbi, unsigned int *victim,\n\t\t\tint gc_type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tret = DIRTY_I(sbi)->v_ops->get_victim(sbi, victim, gc_type,\n\t\t\t\t\t      NO_CHECK_TYPE, LFS);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f2fs_cp_error(sbi)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_cp_error",
          "args": [
            "sbi"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1310-1313",
          "snippet": "static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(sbi->sb->s_flags & MS_ACTIVE)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_cp_reason",
          "args": [
            "sbi"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cp_reason",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "775-784",
          "snippet": "static inline int __get_cp_reason(struct f2fs_sb_info *sbi)\n{\n\tint reason = CP_SYNC;\n\n\tif (test_opt(sbi, FASTBOOT))\n\t\treason = CP_FASTBOOT;\n\tif (is_sbi_flag_set(sbi, SBI_IS_CLOSE))\n\t\treason = CP_UMOUNT;\n\treturn reason;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int __get_cp_reason(struct f2fs_sb_info *sbi)\n{\n\tint reason = CP_SYNC;\n\n\tif (test_opt(sbi, FASTBOOT))\n\t\treason = CP_FASTBOOT;\n\tif (is_sbi_flag_set(sbi, SBI_IS_CLOSE))\n\t\treason = CP_UMOUNT;\n\treturn reason;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RADIX_TREE_INIT",
          "args": [
            "GFP_NOFS"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD_INIT",
          "args": [
            "gc_list.ilist"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint f2fs_gc(struct f2fs_sb_info *sbi)\n{\n\tunsigned int segno, i;\n\tint gc_type = BG_GC;\n\tint nfree = 0;\n\tint ret = -1;\n\tstruct cp_control cpc;\n\tstruct gc_inode_list gc_list = {\n\t\t.ilist = LIST_HEAD_INIT(gc_list.ilist),\n\t\t.iroot = RADIX_TREE_INIT(GFP_NOFS),\n\t};\n\n\tcpc.reason = __get_cp_reason(sbi);\ngc_more:\n\tif (unlikely(!(sbi->sb->s_flags & MS_ACTIVE)))\n\t\tgoto stop;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto stop;\n\n\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, nfree)) {\n\t\tgc_type = FG_GC;\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\tif (!__get_victim(sbi, &segno, gc_type))\n\t\tgoto stop;\n\tret = 0;\n\n\t/* readahead multi ssa blocks those have contiguous address */\n\tif (sbi->segs_per_sec > 1)\n\t\tra_meta_pages(sbi, GET_SUM_BLOCK(sbi, segno), sbi->segs_per_sec,\n\t\t\t\t\t\t\t\tMETA_SSA);\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tdo_garbage_collect(sbi, segno + i, &gc_list, gc_type);\n\n\tif (gc_type == FG_GC) {\n\t\tsbi->cur_victim_sec = NULL_SEGNO;\n\t\tnfree++;\n\t\tWARN_ON(get_valid_blocks(sbi, segno, sbi->segs_per_sec));\n\t}\n\n\tif (has_not_enough_free_secs(sbi, nfree))\n\t\tgoto gc_more;\n\n\tif (gc_type == FG_GC)\n\t\twrite_checkpoint(sbi, &cpc);\nstop:\n\tmutex_unlock(&sbi->gc_mutex);\n\n\tput_gc_inode(&gc_list);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_garbage_collect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "659-687",
    "snippet": "static void do_garbage_collect(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\t\t\tstruct gc_inode_list *gc_list, int gc_type)\n{\n\tstruct page *sum_page;\n\tstruct f2fs_summary_block *sum;\n\tstruct blk_plug plug;\n\n\t/* read segment summary of victim */\n\tsum_page = get_sum_page(sbi, segno);\n\n\tblk_start_plug(&plug);\n\n\tsum = page_address(sum_page);\n\n\tswitch (GET_SUM_TYPE((&sum->footer))) {\n\tcase SUM_TYPE_NODE:\n\t\tgc_node_segment(sbi, sum->entries, segno, gc_type);\n\t\tbreak;\n\tcase SUM_TYPE_DATA:\n\t\tgc_data_segment(sbi, sum->entries, gc_list, segno, gc_type);\n\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tstat_inc_seg_count(sbi, GET_SUM_TYPE((&sum->footer)));\n\tstat_inc_call_count(sbi->stat_info);\n\n\tf2fs_put_page(sum_page, 1);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "sum_page",
            "1"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_call_count",
          "args": [
            "sbi->stat_info"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat_inc_seg_count",
          "args": [
            "sbi",
            "GET_SUM_TYPE((&sum->footer))"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SUM_TYPE",
          "args": [
            "(&sum->footer)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gc_data_segment",
          "args": [
            "sbi",
            "sum->entries",
            "gc_list",
            "segno",
            "gc_type"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "gc_data_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "553-644",
          "snippet": "static void gc_data_segment(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct gc_inode_list *gc_list, unsigned int segno, int gc_type)\n{\n\tstruct super_block *sb = sbi->sb;\n\tstruct f2fs_summary *entry;\n\tblock_t start_addr;\n\tint off;\n\tint phase = 0;\n\n\tstart_addr = START_BLOCK(sbi, segno);\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n\t\tstruct page *data_page;\n\t\tstruct inode *inode;\n\t\tstruct node_info dni; /* dnode info for the data */\n\t\tunsigned int ofs_in_node, nofs;\n\t\tblock_t start_bidx;\n\n\t\t/* stop BG_GC if there is not enough free sections. */\n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0))\n\t\t\treturn;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 0) {\n\t\t\tra_node_page(sbi, le32_to_cpu(entry->nid));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get an inode by ino with checking validity */\n\t\tif (check_dnode(sbi, entry, &dni, start_addr + off, &nofs) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 1) {\n\t\t\tra_node_page(sbi, dni.ino);\n\t\t\tcontinue;\n\t\t}\n\n\t\tofs_in_node = le16_to_cpu(entry->ofs_in_node);\n\n\t\tif (phase == 2) {\n\t\t\tinode = f2fs_iget(sb, dni.ino);\n\t\t\tif (IS_ERR(inode) || is_bad_inode(inode))\n\t\t\t\tcontinue;\n\n\t\t\tstart_bidx = start_bidx_of_node(nofs, F2FS_I(inode));\n\n\t\t\tdata_page = find_data_page(inode,\n\t\t\t\t\tstart_bidx + ofs_in_node, false);\n\t\t\tif (IS_ERR(data_page)) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf2fs_put_page(data_page, 0);\n\t\t\tadd_gc_inode(gc_list, inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* phase 3 */\n\t\tinode = find_gc_inode(gc_list, dni.ino);\n\t\tif (inode) {\n\t\t\tstart_bidx = start_bidx_of_node(nofs, F2FS_I(inode));\n\t\t\tdata_page = get_lock_data_page(inode,\n\t\t\t\t\t\tstart_bidx + ofs_in_node);\n\t\t\tif (IS_ERR(data_page))\n\t\t\t\tcontinue;\n\t\t\tmove_data_page(inode, data_page, gc_type);\n\t\t\tstat_inc_data_blk_count(sbi, 1);\n\t\t}\n\t}\n\n\tif (++phase < 4)\n\t\tgoto next_step;\n\n\tif (gc_type == FG_GC) {\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\n\t\t/*\n\t\t * In the case of FG_GC, it'd be better to reclaim this victim\n\t\t * completely.\n\t\t */\n\t\tif (get_valid_blocks(sbi, segno, 1) != 0) {\n\t\t\tphase = 2;\n\t\t\tgoto next_step;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void gc_data_segment(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct gc_inode_list *gc_list, unsigned int segno, int gc_type)\n{\n\tstruct super_block *sb = sbi->sb;\n\tstruct f2fs_summary *entry;\n\tblock_t start_addr;\n\tint off;\n\tint phase = 0;\n\n\tstart_addr = START_BLOCK(sbi, segno);\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n\t\tstruct page *data_page;\n\t\tstruct inode *inode;\n\t\tstruct node_info dni; /* dnode info for the data */\n\t\tunsigned int ofs_in_node, nofs;\n\t\tblock_t start_bidx;\n\n\t\t/* stop BG_GC if there is not enough free sections. */\n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0))\n\t\t\treturn;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 0) {\n\t\t\tra_node_page(sbi, le32_to_cpu(entry->nid));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get an inode by ino with checking validity */\n\t\tif (check_dnode(sbi, entry, &dni, start_addr + off, &nofs) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 1) {\n\t\t\tra_node_page(sbi, dni.ino);\n\t\t\tcontinue;\n\t\t}\n\n\t\tofs_in_node = le16_to_cpu(entry->ofs_in_node);\n\n\t\tif (phase == 2) {\n\t\t\tinode = f2fs_iget(sb, dni.ino);\n\t\t\tif (IS_ERR(inode) || is_bad_inode(inode))\n\t\t\t\tcontinue;\n\n\t\t\tstart_bidx = start_bidx_of_node(nofs, F2FS_I(inode));\n\n\t\t\tdata_page = find_data_page(inode,\n\t\t\t\t\tstart_bidx + ofs_in_node, false);\n\t\t\tif (IS_ERR(data_page)) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf2fs_put_page(data_page, 0);\n\t\t\tadd_gc_inode(gc_list, inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* phase 3 */\n\t\tinode = find_gc_inode(gc_list, dni.ino);\n\t\tif (inode) {\n\t\t\tstart_bidx = start_bidx_of_node(nofs, F2FS_I(inode));\n\t\t\tdata_page = get_lock_data_page(inode,\n\t\t\t\t\t\tstart_bidx + ofs_in_node);\n\t\t\tif (IS_ERR(data_page))\n\t\t\t\tcontinue;\n\t\t\tmove_data_page(inode, data_page, gc_type);\n\t\t\tstat_inc_data_blk_count(sbi, 1);\n\t\t}\n\t}\n\n\tif (++phase < 4)\n\t\tgoto next_step;\n\n\tif (gc_type == FG_GC) {\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\n\t\t/*\n\t\t * In the case of FG_GC, it'd be better to reclaim this victim\n\t\t * completely.\n\t\t */\n\t\tif (get_valid_blocks(sbi, segno, 1) != 0) {\n\t\t\tphase = 2;\n\t\t\tgoto next_step;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gc_node_segment",
          "args": [
            "sbi",
            "sum->entries",
            "segno",
            "gc_type"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "gc_node_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "394-461",
          "snippet": "static void gc_node_segment(struct f2fs_sb_info *sbi,\n\t\tstruct f2fs_summary *sum, unsigned int segno, int gc_type)\n{\n\tbool initial = true;\n\tstruct f2fs_summary *entry;\n\tint off;\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n\t\tnid_t nid = le32_to_cpu(entry->nid);\n\t\tstruct page *node_page;\n\n\t\t/* stop BG_GC if there is not enough free sections. */\n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0))\n\t\t\treturn;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (initial) {\n\t\t\tra_node_page(sbi, nid);\n\t\t\tcontinue;\n\t\t}\n\t\tnode_page = get_node_page(sbi, nid);\n\t\tif (IS_ERR(node_page))\n\t\t\tcontinue;\n\n\t\t/* block may become invalid during get_node_page */\n\t\tif (check_valid_map(sbi, segno, off) == 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set page dirty and write it */\n\t\tif (gc_type == FG_GC) {\n\t\t\tf2fs_wait_on_page_writeback(node_page, NODE);\n\t\t\tset_page_dirty(node_page);\n\t\t} else {\n\t\t\tif (!PageWriteback(node_page))\n\t\t\t\tset_page_dirty(node_page);\n\t\t}\n\t\tf2fs_put_page(node_page, 1);\n\t\tstat_inc_node_blk_count(sbi, 1);\n\t}\n\n\tif (initial) {\n\t\tinitial = false;\n\t\tgoto next_step;\n\t}\n\n\tif (gc_type == FG_GC) {\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_ALL,\n\t\t\t.nr_to_write = LONG_MAX,\n\t\t\t.for_reclaim = 0,\n\t\t};\n\t\tsync_node_pages(sbi, 0, &wbc);\n\n\t\t/*\n\t\t * In the case of FG_GC, it'd be better to reclaim this victim\n\t\t * completely.\n\t\t */\n\t\tif (get_valid_blocks(sbi, segno, 1) != 0)\n\t\t\tgoto next_step;\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void gc_node_segment(struct f2fs_sb_info *sbi,\n\t\tstruct f2fs_summary *sum, unsigned int segno, int gc_type)\n{\n\tbool initial = true;\n\tstruct f2fs_summary *entry;\n\tint off;\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n\t\tnid_t nid = le32_to_cpu(entry->nid);\n\t\tstruct page *node_page;\n\n\t\t/* stop BG_GC if there is not enough free sections. */\n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0))\n\t\t\treturn;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (initial) {\n\t\t\tra_node_page(sbi, nid);\n\t\t\tcontinue;\n\t\t}\n\t\tnode_page = get_node_page(sbi, nid);\n\t\tif (IS_ERR(node_page))\n\t\t\tcontinue;\n\n\t\t/* block may become invalid during get_node_page */\n\t\tif (check_valid_map(sbi, segno, off) == 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set page dirty and write it */\n\t\tif (gc_type == FG_GC) {\n\t\t\tf2fs_wait_on_page_writeback(node_page, NODE);\n\t\t\tset_page_dirty(node_page);\n\t\t} else {\n\t\t\tif (!PageWriteback(node_page))\n\t\t\t\tset_page_dirty(node_page);\n\t\t}\n\t\tf2fs_put_page(node_page, 1);\n\t\tstat_inc_node_blk_count(sbi, 1);\n\t}\n\n\tif (initial) {\n\t\tinitial = false;\n\t\tgoto next_step;\n\t}\n\n\tif (gc_type == FG_GC) {\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_ALL,\n\t\t\t.nr_to_write = LONG_MAX,\n\t\t\t.for_reclaim = 0,\n\t\t};\n\t\tsync_node_pages(sbi, 0, &wbc);\n\n\t\t/*\n\t\t * In the case of FG_GC, it'd be better to reclaim this victim\n\t\t * completely.\n\t\t */\n\t\tif (get_valid_blocks(sbi, segno, 1) != 0)\n\t\t\tgoto next_step;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SUM_TYPE",
          "args": [
            "(&sum->footer)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sum_page"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sum_page",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "get_sum_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "760-763",
          "snippet": "struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\treturn get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\treturn get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void do_garbage_collect(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\t\t\tstruct gc_inode_list *gc_list, int gc_type)\n{\n\tstruct page *sum_page;\n\tstruct f2fs_summary_block *sum;\n\tstruct blk_plug plug;\n\n\t/* read segment summary of victim */\n\tsum_page = get_sum_page(sbi, segno);\n\n\tblk_start_plug(&plug);\n\n\tsum = page_address(sum_page);\n\n\tswitch (GET_SUM_TYPE((&sum->footer))) {\n\tcase SUM_TYPE_NODE:\n\t\tgc_node_segment(sbi, sum->entries, segno, gc_type);\n\t\tbreak;\n\tcase SUM_TYPE_DATA:\n\t\tgc_data_segment(sbi, sum->entries, gc_list, segno, gc_type);\n\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tstat_inc_seg_count(sbi, GET_SUM_TYPE((&sum->footer)));\n\tstat_inc_call_count(sbi->stat_info);\n\n\tf2fs_put_page(sum_page, 1);\n}"
  },
  {
    "function_name": "__get_victim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "646-657",
    "snippet": "static int __get_victim(struct f2fs_sb_info *sbi, unsigned int *victim,\n\t\t\tint gc_type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tret = DIRTY_I(sbi)->v_ops->get_victim(sbi, victim, gc_type,\n\t\t\t\t\t      NO_CHECK_TYPE, LFS);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi",
            "victim",
            "gc_type",
            "NO_CHECK_TYPE",
            "LFS"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int __get_victim(struct f2fs_sb_info *sbi, unsigned int *victim,\n\t\t\tint gc_type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tret = DIRTY_I(sbi)->v_ops->get_victim(sbi, victim, gc_type,\n\t\t\t\t\t      NO_CHECK_TYPE, LFS);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "gc_data_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "553-644",
    "snippet": "static void gc_data_segment(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct gc_inode_list *gc_list, unsigned int segno, int gc_type)\n{\n\tstruct super_block *sb = sbi->sb;\n\tstruct f2fs_summary *entry;\n\tblock_t start_addr;\n\tint off;\n\tint phase = 0;\n\n\tstart_addr = START_BLOCK(sbi, segno);\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n\t\tstruct page *data_page;\n\t\tstruct inode *inode;\n\t\tstruct node_info dni; /* dnode info for the data */\n\t\tunsigned int ofs_in_node, nofs;\n\t\tblock_t start_bidx;\n\n\t\t/* stop BG_GC if there is not enough free sections. */\n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0))\n\t\t\treturn;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 0) {\n\t\t\tra_node_page(sbi, le32_to_cpu(entry->nid));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get an inode by ino with checking validity */\n\t\tif (check_dnode(sbi, entry, &dni, start_addr + off, &nofs) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 1) {\n\t\t\tra_node_page(sbi, dni.ino);\n\t\t\tcontinue;\n\t\t}\n\n\t\tofs_in_node = le16_to_cpu(entry->ofs_in_node);\n\n\t\tif (phase == 2) {\n\t\t\tinode = f2fs_iget(sb, dni.ino);\n\t\t\tif (IS_ERR(inode) || is_bad_inode(inode))\n\t\t\t\tcontinue;\n\n\t\t\tstart_bidx = start_bidx_of_node(nofs, F2FS_I(inode));\n\n\t\t\tdata_page = find_data_page(inode,\n\t\t\t\t\tstart_bidx + ofs_in_node, false);\n\t\t\tif (IS_ERR(data_page)) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf2fs_put_page(data_page, 0);\n\t\t\tadd_gc_inode(gc_list, inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* phase 3 */\n\t\tinode = find_gc_inode(gc_list, dni.ino);\n\t\tif (inode) {\n\t\t\tstart_bidx = start_bidx_of_node(nofs, F2FS_I(inode));\n\t\t\tdata_page = get_lock_data_page(inode,\n\t\t\t\t\t\tstart_bidx + ofs_in_node);\n\t\t\tif (IS_ERR(data_page))\n\t\t\t\tcontinue;\n\t\t\tmove_data_page(inode, data_page, gc_type);\n\t\t\tstat_inc_data_blk_count(sbi, 1);\n\t\t}\n\t}\n\n\tif (++phase < 4)\n\t\tgoto next_step;\n\n\tif (gc_type == FG_GC) {\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\n\t\t/*\n\t\t * In the case of FG_GC, it'd be better to reclaim this victim\n\t\t * completely.\n\t\t */\n\t\tif (get_valid_blocks(sbi, segno, 1) != 0) {\n\t\t\tphase = 2;\n\t\t\tgoto next_step;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "1"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_submit_merged_bio",
          "args": [
            "sbi",
            "DATA",
            "WRITE"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_submit_merged_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "107-127",
          "snippet": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tif (test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.rw = WRITE_FLUSH | REQ_META | REQ_PRIO;\n\t\telse\n\t\t\tio->fio.rw = WRITE_FLUSH_FUA | REQ_META | REQ_PRIO;\n\t}\n\t__submit_merged_bio(io);\n\tup_write(&io->io_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_data_blk_count",
          "args": [
            "sbi",
            "1"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_data_page",
          "args": [
            "inode",
            "data_page",
            "gc_type"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "move_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "521-544",
          "snippet": "static void move_data_page(struct inode *inode, struct page *page, int gc_type)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC,\n\t};\n\n\tif (gc_type == BG_GC) {\n\t\tif (PageWriteback(page))\n\t\t\tgoto out;\n\t\tset_page_dirty(page);\n\t\tset_cold_data(page);\n\t} else {\n\t\tf2fs_wait_on_page_writeback(page, DATA);\n\n\t\tif (clear_page_dirty_for_io(page))\n\t\t\tinode_dec_dirty_pages(inode);\n\t\tset_cold_data(page);\n\t\tdo_write_data_page(page, &fio);\n\t\tclear_cold_data(page);\n\t}\nout:\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void move_data_page(struct inode *inode, struct page *page, int gc_type)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC,\n\t};\n\n\tif (gc_type == BG_GC) {\n\t\tif (PageWriteback(page))\n\t\t\tgoto out;\n\t\tset_page_dirty(page);\n\t\tset_cold_data(page);\n\t} else {\n\t\tf2fs_wait_on_page_writeback(page, DATA);\n\n\t\tif (clear_page_dirty_for_io(page))\n\t\t\tinode_dec_dirty_pages(inode);\n\t\tset_cold_data(page);\n\t\tdo_write_data_page(page, &fio);\n\t\tclear_cold_data(page);\n\t}\nout:\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data_page"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_data_page",
          "args": [
            "inode",
            "start_bidx + ofs_in_node"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "433-491",
          "snippet": "struct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_lock_data_page(struct inode *inode, pgoff_t index)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = READ_SYNC,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (PageUptodate(page))\n\t\treturn page;\n\n\t/*\n\t * A new dentry page is allocated but not able to be written, since its\n\t * new inode page couldn't be allocated due to -ENOSPC.\n\t * In such the case, its blkaddr can be remained as NEW_ADDR.\n\t * see, f2fs_add_link -> get_new_data_page -> init_inode_metadata.\n\t */\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tlock_page(page);\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_bidx_of_node",
          "args": [
            "nofs",
            "F2FS_I(inode)"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "start_bidx_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "470-488",
          "snippet": "block_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nblock_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_gc_inode",
          "args": [
            "gc_list",
            "dni.ino"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "find_gc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "339-347",
          "snippet": "static struct inode *find_gc_inode(struct gc_inode_list *gc_list, nid_t ino)\n{\n\tstruct inode_entry *ie;\n\n\tie = radix_tree_lookup(&gc_list->iroot, ino);\n\tif (ie)\n\t\treturn ie->inode;\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct inode *find_gc_inode(struct gc_inode_list *gc_list, nid_t ino)\n{\n\tstruct inode_entry *ie;\n\n\tie = radix_tree_lookup(&gc_list->iroot, ino);\n\tif (ie)\n\t\treturn ie->inode;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_gc_inode",
          "args": [
            "gc_list",
            "inode"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "add_gc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "349-362",
          "snippet": "static void add_gc_inode(struct gc_inode_list *gc_list, struct inode *inode)\n{\n\tstruct inode_entry *new_ie;\n\n\tif (inode == find_gc_inode(gc_list, inode->i_ino)) {\n\t\tiput(inode);\n\t\treturn;\n\t}\n\tnew_ie = f2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tnew_ie->inode = inode;\n\n\tf2fs_radix_tree_insert(&gc_list->iroot, inode->i_ino, new_ie);\n\tlist_add_tail(&new_ie->list, &gc_list->ilist);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void add_gc_inode(struct gc_inode_list *gc_list, struct inode *inode)\n{\n\tstruct inode_entry *new_ie;\n\n\tif (inode == find_gc_inode(gc_list, inode->i_ino)) {\n\t\tiput(inode);\n\t\treturn;\n\t}\n\tnew_ie = f2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tnew_ie->inode = inode;\n\n\tf2fs_radix_tree_insert(&gc_list->iroot, inode->i_ino, new_ie);\n\tlist_add_tail(&new_ie->list, &gc_list->ilist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "data_page",
            "0"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data_page"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_data_page",
          "args": [
            "inode",
            "start_bidx + ofs_in_node",
            "false"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "find_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "375-426",
          "snippet": "struct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = sync ? READ_SYNC : READA,\n\t};\n\n\tpage = find_get_page(mapping, index);\n\tif (page && PageUptodate(page))\n\t\treturn page;\n\tf2fs_put_page(page, 0);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tf2fs_put_dnode(&dn);\n\n\tif (dn.data_blkaddr == NULL_ADDR)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/* By fallocate(), there is no cached page, but with NEW_ADDR */\n\tif (unlikely(dn.data_blkaddr == NEW_ADDR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (sync) {\n\t\twait_on_page_locked(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 0);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *find_data_page(struct inode *inode, pgoff_t index, bool sync)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tint err;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = sync ? READ_SYNC : READA,\n\t};\n\n\tpage = find_get_page(mapping, index);\n\tif (page && PageUptodate(page))\n\t\treturn page;\n\tf2fs_put_page(page, 0);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tf2fs_put_dnode(&dn);\n\n\tif (dn.data_blkaddr == NULL_ADDR)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/* By fallocate(), there is no cached page, but with NEW_ADDR */\n\tif (unlikely(dn.data_blkaddr == NEW_ADDR))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\tfio.blk_addr = dn.data_blkaddr;\n\terr = f2fs_submit_page_bio(F2FS_I_SB(inode), page, &fio);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (sync) {\n\t\twait_on_page_locked(page);\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\tf2fs_put_page(page, 0);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "sb",
            "dni.ino"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->ofs_in_node"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_node_page",
          "args": [
            "sbi",
            "dni.ino"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "ra_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1012-1033",
          "snippet": "void ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tapage = find_get_page(NODE_MAPPING(sbi), nid);\n\tif (apage && PageUptodate(apage)) {\n\t\tf2fs_put_page(apage, 0);\n\t\treturn;\n\t}\n\tf2fs_put_page(apage, 0);\n\n\tapage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, READA);\n\tif (err == 0)\n\t\tf2fs_put_page(apage, 0);\n\telse if (err == LOCKED_PAGE)\n\t\tf2fs_put_page(apage, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tapage = find_get_page(NODE_MAPPING(sbi), nid);\n\tif (apage && PageUptodate(apage)) {\n\t\tf2fs_put_page(apage, 0);\n\t\treturn;\n\t}\n\tf2fs_put_page(apage, 0);\n\n\tapage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, READA);\n\tif (err == 0)\n\t\tf2fs_put_page(apage, 0);\n\telse if (err == LOCKED_PAGE)\n\t\tf2fs_put_page(apage, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_dnode",
          "args": [
            "sbi",
            "entry",
            "&dni",
            "start_addr + off",
            "&nofs"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "check_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "490-519",
          "snippet": "static int check_dnode(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct node_info *dni, block_t blkaddr, unsigned int *nofs)\n{\n\tstruct page *node_page;\n\tnid_t nid;\n\tunsigned int ofs_in_node;\n\tblock_t source_blkaddr;\n\n\tnid = le32_to_cpu(sum->nid);\n\tofs_in_node = le16_to_cpu(sum->ofs_in_node);\n\n\tnode_page = get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn 0;\n\n\tget_node_info(sbi, nid, dni);\n\n\tif (sum->version != dni->version) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn 0;\n\t}\n\n\t*nofs = ofs_of_node(node_page);\n\tsource_blkaddr = datablock_addr(node_page, ofs_in_node);\n\tf2fs_put_page(node_page, 1);\n\n\tif (source_blkaddr != blkaddr)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int check_dnode(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct node_info *dni, block_t blkaddr, unsigned int *nofs)\n{\n\tstruct page *node_page;\n\tnid_t nid;\n\tunsigned int ofs_in_node;\n\tblock_t source_blkaddr;\n\n\tnid = le32_to_cpu(sum->nid);\n\tofs_in_node = le16_to_cpu(sum->ofs_in_node);\n\n\tnode_page = get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn 0;\n\n\tget_node_info(sbi, nid, dni);\n\n\tif (sum->version != dni->version) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn 0;\n\t}\n\n\t*nofs = ofs_of_node(node_page);\n\tsource_blkaddr = datablock_addr(node_page, ofs_in_node);\n\tf2fs_put_page(node_page, 1);\n\n\tif (source_blkaddr != blkaddr)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->nid"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_valid_map",
          "args": [
            "sbi",
            "segno",
            "off"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "check_valid_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "375-387",
          "snippet": "static int check_valid_map(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int offset)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct seg_entry *sentry;\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tsentry = get_seg_entry(sbi, segno);\n\tret = f2fs_test_bit(offset, sentry->cur_valid_map);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int check_valid_map(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int offset)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct seg_entry *sentry;\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tsentry = get_seg_entry(sbi, segno);\n\tret = f2fs_test_bit(offset, sentry->cur_valid_map);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_not_enough_free_secs",
          "args": [
            "sbi",
            "0"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "has_not_enough_free_secs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "459-469",
          "snippet": "static inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}"
        }
      },
      {
        "call_info": {
          "callee": "START_BLOCK",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void gc_data_segment(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct gc_inode_list *gc_list, unsigned int segno, int gc_type)\n{\n\tstruct super_block *sb = sbi->sb;\n\tstruct f2fs_summary *entry;\n\tblock_t start_addr;\n\tint off;\n\tint phase = 0;\n\n\tstart_addr = START_BLOCK(sbi, segno);\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n\t\tstruct page *data_page;\n\t\tstruct inode *inode;\n\t\tstruct node_info dni; /* dnode info for the data */\n\t\tunsigned int ofs_in_node, nofs;\n\t\tblock_t start_bidx;\n\n\t\t/* stop BG_GC if there is not enough free sections. */\n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0))\n\t\t\treturn;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 0) {\n\t\t\tra_node_page(sbi, le32_to_cpu(entry->nid));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get an inode by ino with checking validity */\n\t\tif (check_dnode(sbi, entry, &dni, start_addr + off, &nofs) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 1) {\n\t\t\tra_node_page(sbi, dni.ino);\n\t\t\tcontinue;\n\t\t}\n\n\t\tofs_in_node = le16_to_cpu(entry->ofs_in_node);\n\n\t\tif (phase == 2) {\n\t\t\tinode = f2fs_iget(sb, dni.ino);\n\t\t\tif (IS_ERR(inode) || is_bad_inode(inode))\n\t\t\t\tcontinue;\n\n\t\t\tstart_bidx = start_bidx_of_node(nofs, F2FS_I(inode));\n\n\t\t\tdata_page = find_data_page(inode,\n\t\t\t\t\tstart_bidx + ofs_in_node, false);\n\t\t\tif (IS_ERR(data_page)) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf2fs_put_page(data_page, 0);\n\t\t\tadd_gc_inode(gc_list, inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* phase 3 */\n\t\tinode = find_gc_inode(gc_list, dni.ino);\n\t\tif (inode) {\n\t\t\tstart_bidx = start_bidx_of_node(nofs, F2FS_I(inode));\n\t\t\tdata_page = get_lock_data_page(inode,\n\t\t\t\t\t\tstart_bidx + ofs_in_node);\n\t\t\tif (IS_ERR(data_page))\n\t\t\t\tcontinue;\n\t\t\tmove_data_page(inode, data_page, gc_type);\n\t\t\tstat_inc_data_blk_count(sbi, 1);\n\t\t}\n\t}\n\n\tif (++phase < 4)\n\t\tgoto next_step;\n\n\tif (gc_type == FG_GC) {\n\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\n\t\t/*\n\t\t * In the case of FG_GC, it'd be better to reclaim this victim\n\t\t * completely.\n\t\t */\n\t\tif (get_valid_blocks(sbi, segno, 1) != 0) {\n\t\t\tphase = 2;\n\t\t\tgoto next_step;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "move_data_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "521-544",
    "snippet": "static void move_data_page(struct inode *inode, struct page *page, int gc_type)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC,\n\t};\n\n\tif (gc_type == BG_GC) {\n\t\tif (PageWriteback(page))\n\t\t\tgoto out;\n\t\tset_page_dirty(page);\n\t\tset_cold_data(page);\n\t} else {\n\t\tf2fs_wait_on_page_writeback(page, DATA);\n\n\t\tif (clear_page_dirty_for_io(page))\n\t\t\tinode_dec_dirty_pages(inode);\n\t\tset_cold_data(page);\n\t\tdo_write_data_page(page, &fio);\n\t\tclear_cold_data(page);\n\t}\nout:\n\tf2fs_put_page(page, 1);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_cold_data",
          "args": [
            "page"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "clear_cold_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "377-380",
          "snippet": "static inline void clear_cold_data(struct page *page)\n{\n\tClearPageChecked(page);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void clear_cold_data(struct page *page)\n{\n\tClearPageChecked(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_write_data_page",
          "args": [
            "page",
            "&fio"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "do_write_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "802-838",
          "snippet": "int do_write_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tfio->blk_addr = dn.data_blkaddr;\n\n\t/* This page is already truncated */\n\tif (fio->blk_addr == NULL_ADDR)\n\t\tgoto out_writepage;\n\n\tset_page_writeback(page);\n\n\t/*\n\t * If current allocation needs SSR,\n\t * it had better in-place writes for updated data.\n\t */\n\tif (unlikely(fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode))) {\n\t\trewrite_data_page(page, fio);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_WRITE);\n\t} else {\n\t\twrite_data_page(page, &dn, fio);\n\t\tupdate_extent_cache(&dn);\n\t\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\t}\nout_writepage:\n\tf2fs_put_dnode(&dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint do_write_data_page(struct page *page, struct f2fs_io_info *fio)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tfio->blk_addr = dn.data_blkaddr;\n\n\t/* This page is already truncated */\n\tif (fio->blk_addr == NULL_ADDR)\n\t\tgoto out_writepage;\n\n\tset_page_writeback(page);\n\n\t/*\n\t * If current allocation needs SSR,\n\t * it had better in-place writes for updated data.\n\t */\n\tif (unlikely(fio->blk_addr != NEW_ADDR &&\n\t\t\t!is_cold_data(page) &&\n\t\t\tneed_inplace_update(inode))) {\n\t\trewrite_data_page(page, fio);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_WRITE);\n\t} else {\n\t\twrite_data_page(page, &dn, fio);\n\t\tupdate_extent_cache(&dn);\n\t\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\t}\nout_writepage:\n\tf2fs_put_dnode(&dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cold_data",
          "args": [
            "page"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "set_cold_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "372-375",
          "snippet": "static inline void set_cold_data(struct page *page)\n{\n\tSetPageChecked(page);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_cold_data(struct page *page)\n{\n\tSetPageChecked(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dec_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "876-885",
          "snippet": "static inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "DATA"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void move_data_page(struct inode *inode, struct page *page, int gc_type)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC,\n\t};\n\n\tif (gc_type == BG_GC) {\n\t\tif (PageWriteback(page))\n\t\t\tgoto out;\n\t\tset_page_dirty(page);\n\t\tset_cold_data(page);\n\t} else {\n\t\tf2fs_wait_on_page_writeback(page, DATA);\n\n\t\tif (clear_page_dirty_for_io(page))\n\t\t\tinode_dec_dirty_pages(inode);\n\t\tset_cold_data(page);\n\t\tdo_write_data_page(page, &fio);\n\t\tclear_cold_data(page);\n\t}\nout:\n\tf2fs_put_page(page, 1);\n}"
  },
  {
    "function_name": "check_dnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "490-519",
    "snippet": "static int check_dnode(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct node_info *dni, block_t blkaddr, unsigned int *nofs)\n{\n\tstruct page *node_page;\n\tnid_t nid;\n\tunsigned int ofs_in_node;\n\tblock_t source_blkaddr;\n\n\tnid = le32_to_cpu(sum->nid);\n\tofs_in_node = le16_to_cpu(sum->ofs_in_node);\n\n\tnode_page = get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn 0;\n\n\tget_node_info(sbi, nid, dni);\n\n\tif (sum->version != dni->version) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn 0;\n\t}\n\n\t*nofs = ofs_of_node(node_page);\n\tsource_blkaddr = datablock_addr(node_page, ofs_in_node);\n\tf2fs_put_page(node_page, 1);\n\n\tif (source_blkaddr != blkaddr)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "node_page",
            "1"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "datablock_addr",
          "args": [
            "node_page",
            "ofs_in_node"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "datablock_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1098-1106",
          "snippet": "static inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofs_of_node",
          "args": [
            "node_page"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "ofs_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "259-264",
          "snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "nid",
            "dni"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node_page"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sum->ofs_in_node"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sum->nid"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int check_dnode(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct node_info *dni, block_t blkaddr, unsigned int *nofs)\n{\n\tstruct page *node_page;\n\tnid_t nid;\n\tunsigned int ofs_in_node;\n\tblock_t source_blkaddr;\n\n\tnid = le32_to_cpu(sum->nid);\n\tofs_in_node = le16_to_cpu(sum->ofs_in_node);\n\n\tnode_page = get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn 0;\n\n\tget_node_info(sbi, nid, dni);\n\n\tif (sum->version != dni->version) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn 0;\n\t}\n\n\t*nofs = ofs_of_node(node_page);\n\tsource_blkaddr = datablock_addr(node_page, ofs_in_node);\n\tf2fs_put_page(node_page, 1);\n\n\tif (source_blkaddr != blkaddr)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "start_bidx_of_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "470-488",
    "snippet": "block_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADDRS_PER_INODE",
          "args": [
            "fi"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nblock_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}"
  },
  {
    "function_name": "gc_node_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "394-461",
    "snippet": "static void gc_node_segment(struct f2fs_sb_info *sbi,\n\t\tstruct f2fs_summary *sum, unsigned int segno, int gc_type)\n{\n\tbool initial = true;\n\tstruct f2fs_summary *entry;\n\tint off;\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n\t\tnid_t nid = le32_to_cpu(entry->nid);\n\t\tstruct page *node_page;\n\n\t\t/* stop BG_GC if there is not enough free sections. */\n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0))\n\t\t\treturn;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (initial) {\n\t\t\tra_node_page(sbi, nid);\n\t\t\tcontinue;\n\t\t}\n\t\tnode_page = get_node_page(sbi, nid);\n\t\tif (IS_ERR(node_page))\n\t\t\tcontinue;\n\n\t\t/* block may become invalid during get_node_page */\n\t\tif (check_valid_map(sbi, segno, off) == 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set page dirty and write it */\n\t\tif (gc_type == FG_GC) {\n\t\t\tf2fs_wait_on_page_writeback(node_page, NODE);\n\t\t\tset_page_dirty(node_page);\n\t\t} else {\n\t\t\tif (!PageWriteback(node_page))\n\t\t\t\tset_page_dirty(node_page);\n\t\t}\n\t\tf2fs_put_page(node_page, 1);\n\t\tstat_inc_node_blk_count(sbi, 1);\n\t}\n\n\tif (initial) {\n\t\tinitial = false;\n\t\tgoto next_step;\n\t}\n\n\tif (gc_type == FG_GC) {\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_ALL,\n\t\t\t.nr_to_write = LONG_MAX,\n\t\t\t.for_reclaim = 0,\n\t\t};\n\t\tsync_node_pages(sbi, 0, &wbc);\n\n\t\t/*\n\t\t * In the case of FG_GC, it'd be better to reclaim this victim\n\t\t * completely.\n\t\t */\n\t\tif (get_valid_blocks(sbi, segno, 1) != 0)\n\t\t\tgoto next_step;\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "1"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_node_pages",
          "args": [
            "sbi",
            "0",
            "&wbc"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "sync_node_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1131-1237",
          "snippet": "int sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint sync_node_pages(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = ino ? 2 : 0;\n\tint nwritten = 0, wrote = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = LONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If an fsync mode,\n\t\t\t * we should not skip writing node pages.\n\t\t\t */\n\t\t\tif (ino && ino_of_node(page) == ino)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino && ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\t/* called by fsync() */\n\t\t\tif (ino && IS_DNODE(page)) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (!is_checkpointed_node(sbi, ino) &&\n\t\t\t\t\t\t!has_fsynced_inode(sbi, ino))\n\t\t\t\t\t\tset_dentry_mark(page, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t\t}\n\t\t\t\tnwritten++;\n\t\t\t} else {\n\t\t\t\tset_fsync_mark(page, 0);\n\t\t\t\tset_dentry_mark(page, 0);\n\t\t\t}\n\n\t\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(page, wbc))\n\t\t\t\tunlock_page(page);\n\t\t\telse\n\t\t\t\twrote++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\n\n\tif (wrote)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_node_blk_count",
          "args": [
            "sbi",
            "1"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "node_page",
            "1"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "node_page"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "node_page"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "node_page",
            "NODE"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_valid_map",
          "args": [
            "sbi",
            "segno",
            "off"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "check_valid_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "375-387",
          "snippet": "static int check_valid_map(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int offset)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct seg_entry *sentry;\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tsentry = get_seg_entry(sbi, segno);\n\tret = f2fs_test_bit(offset, sentry->cur_valid_map);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int check_valid_map(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int offset)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct seg_entry *sentry;\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tsentry = get_seg_entry(sbi, segno);\n\tret = f2fs_test_bit(offset, sentry->cur_valid_map);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node_page"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_node_page",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "ra_node_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1012-1033",
          "snippet": "void ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tapage = find_get_page(NODE_MAPPING(sbi), nid);\n\tif (apage && PageUptodate(apage)) {\n\t\tf2fs_put_page(apage, 0);\n\t\treturn;\n\t}\n\tf2fs_put_page(apage, 0);\n\n\tapage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, READA);\n\tif (err == 0)\n\t\tf2fs_put_page(apage, 0);\n\telse if (err == LOCKED_PAGE)\n\t\tf2fs_put_page(apage, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tapage = find_get_page(NODE_MAPPING(sbi), nid);\n\tif (apage && PageUptodate(apage)) {\n\t\tf2fs_put_page(apage, 0);\n\t\treturn;\n\t}\n\tf2fs_put_page(apage, 0);\n\n\tapage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, READA);\n\tif (err == 0)\n\t\tf2fs_put_page(apage, 0);\n\telse if (err == LOCKED_PAGE)\n\t\tf2fs_put_page(apage, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_not_enough_free_secs",
          "args": [
            "sbi",
            "0"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "has_not_enough_free_secs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "459-469",
          "snippet": "static inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi, int freed)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\treturn (free_sections(sbi) + freed) <= (node_secs + 2 * dent_secs +\n\t\t\t\t\t\treserved_sections(sbi));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->nid"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void gc_node_segment(struct f2fs_sb_info *sbi,\n\t\tstruct f2fs_summary *sum, unsigned int segno, int gc_type)\n{\n\tbool initial = true;\n\tstruct f2fs_summary *entry;\n\tint off;\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n\t\tnid_t nid = le32_to_cpu(entry->nid);\n\t\tstruct page *node_page;\n\n\t\t/* stop BG_GC if there is not enough free sections. */\n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0))\n\t\t\treturn;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (initial) {\n\t\t\tra_node_page(sbi, nid);\n\t\t\tcontinue;\n\t\t}\n\t\tnode_page = get_node_page(sbi, nid);\n\t\tif (IS_ERR(node_page))\n\t\t\tcontinue;\n\n\t\t/* block may become invalid during get_node_page */\n\t\tif (check_valid_map(sbi, segno, off) == 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set page dirty and write it */\n\t\tif (gc_type == FG_GC) {\n\t\t\tf2fs_wait_on_page_writeback(node_page, NODE);\n\t\t\tset_page_dirty(node_page);\n\t\t} else {\n\t\t\tif (!PageWriteback(node_page))\n\t\t\t\tset_page_dirty(node_page);\n\t\t}\n\t\tf2fs_put_page(node_page, 1);\n\t\tstat_inc_node_blk_count(sbi, 1);\n\t}\n\n\tif (initial) {\n\t\tinitial = false;\n\t\tgoto next_step;\n\t}\n\n\tif (gc_type == FG_GC) {\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_ALL,\n\t\t\t.nr_to_write = LONG_MAX,\n\t\t\t.for_reclaim = 0,\n\t\t};\n\t\tsync_node_pages(sbi, 0, &wbc);\n\n\t\t/*\n\t\t * In the case of FG_GC, it'd be better to reclaim this victim\n\t\t * completely.\n\t\t */\n\t\tif (get_valid_blocks(sbi, segno, 1) != 0)\n\t\t\tgoto next_step;\n\t}\n}"
  },
  {
    "function_name": "check_valid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "375-387",
    "snippet": "static int check_valid_map(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int offset)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct seg_entry *sentry;\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tsentry = get_seg_entry(sbi, segno);\n\tret = f2fs_test_bit(offset, sentry->cur_valid_map);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_test_bit",
          "args": [
            "offset",
            "sentry->cur_valid_map"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1108-1115",
          "snippet": "static inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sit_i->sentry_lock"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int check_valid_map(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int offset)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct seg_entry *sentry;\n\tint ret;\n\n\tmutex_lock(&sit_i->sentry_lock);\n\tsentry = get_seg_entry(sbi, segno);\n\tret = f2fs_test_bit(offset, sentry->cur_valid_map);\n\tmutex_unlock(&sit_i->sentry_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "put_gc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "364-373",
    "snippet": "static void put_gc_inode(struct gc_inode_list *gc_list)\n{\n\tstruct inode_entry *ie, *next_ie;\n\tlist_for_each_entry_safe(ie, next_ie, &gc_list->ilist, list) {\n\t\tradix_tree_delete(&gc_list->iroot, ie->inode->i_ino);\n\t\tiput(ie->inode);\n\t\tlist_del(&ie->list);\n\t\tkmem_cache_free(inode_entry_slab, ie);\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_entry_slab",
            "ie"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ie->list"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ie->inode"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&gc_list->iroot",
            "ie->inode->i_ino"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ie",
            "next_ie",
            "&gc_list->ilist",
            "list"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void put_gc_inode(struct gc_inode_list *gc_list)\n{\n\tstruct inode_entry *ie, *next_ie;\n\tlist_for_each_entry_safe(ie, next_ie, &gc_list->ilist, list) {\n\t\tradix_tree_delete(&gc_list->iroot, ie->inode->i_ino);\n\t\tiput(ie->inode);\n\t\tlist_del(&ie->list);\n\t\tkmem_cache_free(inode_entry_slab, ie);\n\t}\n}"
  },
  {
    "function_name": "add_gc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "349-362",
    "snippet": "static void add_gc_inode(struct gc_inode_list *gc_list, struct inode *inode)\n{\n\tstruct inode_entry *new_ie;\n\n\tif (inode == find_gc_inode(gc_list, inode->i_ino)) {\n\t\tiput(inode);\n\t\treturn;\n\t}\n\tnew_ie = f2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tnew_ie->inode = inode;\n\n\tf2fs_radix_tree_insert(&gc_list->iroot, inode->i_ino, new_ie);\n\tlist_add_tail(&new_ie->list, &gc_list->ilist);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new_ie->list",
            "&gc_list->ilist"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_radix_tree_insert",
          "args": [
            "&gc_list->iroot",
            "inode->i_ino",
            "new_ie"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_alloc",
          "args": [
            "inode_entry_slab",
            "GFP_NOFS"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_gc_inode",
          "args": [
            "gc_list",
            "inode->i_ino"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "find_gc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "339-347",
          "snippet": "static struct inode *find_gc_inode(struct gc_inode_list *gc_list, nid_t ino)\n{\n\tstruct inode_entry *ie;\n\n\tie = radix_tree_lookup(&gc_list->iroot, ino);\n\tif (ie)\n\t\treturn ie->inode;\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct inode *find_gc_inode(struct gc_inode_list *gc_list, nid_t ino)\n{\n\tstruct inode_entry *ie;\n\n\tie = radix_tree_lookup(&gc_list->iroot, ino);\n\tif (ie)\n\t\treturn ie->inode;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void add_gc_inode(struct gc_inode_list *gc_list, struct inode *inode)\n{\n\tstruct inode_entry *new_ie;\n\n\tif (inode == find_gc_inode(gc_list, inode->i_ino)) {\n\t\tiput(inode);\n\t\treturn;\n\t}\n\tnew_ie = f2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tnew_ie->inode = inode;\n\n\tf2fs_radix_tree_insert(&gc_list->iroot, inode->i_ino, new_ie);\n\tlist_add_tail(&new_ie->list, &gc_list->ilist);\n}"
  },
  {
    "function_name": "find_gc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "339-347",
    "snippet": "static struct inode *find_gc_inode(struct gc_inode_list *gc_list, nid_t ino)\n{\n\tstruct inode_entry *ie;\n\n\tie = radix_tree_lookup(&gc_list->iroot, ino);\n\tif (ie)\n\t\treturn ie->inode;\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&gc_list->iroot",
            "ino"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct inode *find_gc_inode(struct gc_inode_list *gc_list, nid_t ino)\n{\n\tstruct inode_entry *ie;\n\n\tie = radix_tree_lookup(&gc_list->iroot, ino);\n\tif (ie)\n\t\treturn ie->inode;\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_victim_by_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "254-333",
    "snippet": "static int get_victim_by_default(struct f2fs_sb_info *sbi,\n\t\tunsigned int *result, int gc_type, int type, char alloc_mode)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct victim_sel_policy p;\n\tunsigned int secno, max_cost;\n\tint nsearched = 0;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tp.alloc_mode = alloc_mode;\n\tselect_policy(sbi, gc_type, type, &p);\n\n\tp.min_segno = NULL_SEGNO;\n\tp.min_cost = max_cost = get_max_cost(sbi, &p);\n\n\tif (p.alloc_mode == LFS && gc_type == FG_GC) {\n\t\tp.min_segno = check_bg_victims(sbi);\n\t\tif (p.min_segno != NULL_SEGNO)\n\t\t\tgoto got_it;\n\t}\n\n\twhile (1) {\n\t\tunsigned long cost;\n\t\tunsigned int segno;\n\n\t\tsegno = find_next_bit(p.dirty_segmap, MAIN_SEGS(sbi), p.offset);\n\t\tif (segno >= MAIN_SEGS(sbi)) {\n\t\t\tif (sbi->last_victim[p.gc_mode]) {\n\t\t\t\tsbi->last_victim[p.gc_mode] = 0;\n\t\t\t\tp.offset = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tp.offset = segno + p.ofs_unit;\n\t\tif (p.ofs_unit > 1)\n\t\t\tp.offset -= segno % p.ofs_unit;\n\n\t\tsecno = GET_SECNO(sbi, segno);\n\n\t\tif (sec_usage_check(sbi, secno))\n\t\t\tcontinue;\n\t\tif (gc_type == BG_GC && test_bit(secno, dirty_i->victim_secmap))\n\t\t\tcontinue;\n\n\t\tcost = get_gc_cost(sbi, segno, &p);\n\n\t\tif (p.min_cost > cost) {\n\t\t\tp.min_segno = segno;\n\t\t\tp.min_cost = cost;\n\t\t} else if (unlikely(cost == max_cost)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nsearched++ >= p.max_search) {\n\t\t\tsbi->last_victim[p.gc_mode] = segno;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p.min_segno != NULL_SEGNO) {\ngot_it:\n\t\tif (p.alloc_mode == LFS) {\n\t\t\tsecno = GET_SECNO(sbi, p.min_segno);\n\t\t\tif (gc_type == FG_GC)\n\t\t\t\tsbi->cur_victim_sec = secno;\n\t\t\telse\n\t\t\t\tset_bit(secno, dirty_i->victim_secmap);\n\t\t}\n\t\t*result = (p.min_segno / p.ofs_unit) * p.ofs_unit;\n\n\t\ttrace_f2fs_get_victim(sbi->sb, type, gc_type, &p,\n\t\t\t\tsbi->cur_victim_sec,\n\t\t\t\tprefree_segments(sbi), free_segments(sbi));\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treturn (p.min_segno == NULL_SEGNO) ? 0 : 1;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_get_victim",
          "args": [
            "sbi->sb",
            "type",
            "gc_type",
            "&p",
            "sbi->cur_victim_sec",
            "prefree_segments(sbi)",
            "free_segments(sbi)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_segments",
          "args": [
            "sbi"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "no_free_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "31-36",
          "snippet": "static int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefree_segments",
          "args": [
            "sbi"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "clear_prefree_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "585-623",
          "snippet": "void clear_prefree_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tfor (i = start; i < end; i++)\n\t\t\tclear_bit(i, prefree_map);\n\n\t\tdirty_i->nr_dirty[PRE] -= end - start;\n\n\t\tif (!test_opt(sbi, DISCARD))\n\t\t\tcontinue;\n\n\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tf2fs_issue_discard(sbi, entry->blkaddr, entry->len);\n\t\tlist_del(&entry->list);\n\t\tSM_I(sbi)->nr_discards -= entry->len;\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *discard_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *discard_entry_slab;\n\nvoid clear_prefree_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->discard_list);\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tfor (i = start; i < end; i++)\n\t\t\tclear_bit(i, prefree_map);\n\n\t\tdirty_i->nr_dirty[PRE] -= end - start;\n\n\t\tif (!test_opt(sbi, DISCARD))\n\t\t\tcontinue;\n\n\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tf2fs_issue_discard(sbi, entry->blkaddr, entry->len);\n\t\tlist_del(&entry->list);\n\t\tSM_I(sbi)->nr_discards -= entry->len;\n\t\tkmem_cache_free(discard_entry_slab, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "secno",
            "dirty_i->victim_secmap"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SECNO",
          "args": [
            "sbi",
            "p.min_segno"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cost == max_cost"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gc_cost",
          "args": [
            "sbi",
            "segno",
            "&p"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "get_gc_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "233-244",
          "snippet": "static inline unsigned int get_gc_cost(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct victim_sel_policy *p)\n{\n\tif (p->alloc_mode == SSR)\n\t\treturn get_seg_entry(sbi, segno)->ckpt_valid_blocks;\n\n\t/* alloc_mode == LFS */\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\telse\n\t\treturn get_cb_cost(sbi, segno);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int get_gc_cost(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct victim_sel_policy *p)\n{\n\tif (p->alloc_mode == SSR)\n\t\treturn get_seg_entry(sbi, segno)->ckpt_valid_blocks;\n\n\t/* alloc_mode == LFS */\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\telse\n\t\treturn get_cb_cost(sbi, segno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "secno",
            "dirty_i->victim_secmap"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1108-1115",
          "snippet": "static inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sec_usage_check",
          "args": [
            "sbi",
            "secno"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "sec_usage_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "692-697",
          "snippet": "static inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)\n{\n\tif (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)\n{\n\tif (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SECNO",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "p.dirty_segmap",
            "MAIN_SEGS(sbi)",
            "p.offset"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAIN_SEGS",
          "args": [
            "sbi"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_bg_victims",
          "args": [
            "sbi"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "check_bg_victims",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "182-199",
          "snippet": "static unsigned int check_bg_victims(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int secno;\n\n\t/*\n\t * If the gc_type is FG_GC, we can select victim segments\n\t * selected by background GC before.\n\t * Those segments guarantee they have small valid blocks.\n\t */\n\tfor_each_set_bit(secno, dirty_i->victim_secmap, MAIN_SECS(sbi)) {\n\t\tif (sec_usage_check(sbi, secno))\n\t\t\tcontinue;\n\t\tclear_bit(secno, dirty_i->victim_secmap);\n\t\treturn secno * sbi->segs_per_sec;\n\t}\n\treturn NULL_SEGNO;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int check_bg_victims(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int secno;\n\n\t/*\n\t * If the gc_type is FG_GC, we can select victim segments\n\t * selected by background GC before.\n\t * Those segments guarantee they have small valid blocks.\n\t */\n\tfor_each_set_bit(secno, dirty_i->victim_secmap, MAIN_SECS(sbi)) {\n\t\tif (sec_usage_check(sbi, secno))\n\t\t\tcontinue;\n\t\tclear_bit(secno, dirty_i->victim_secmap);\n\t\treturn secno * sbi->segs_per_sec;\n\t}\n\treturn NULL_SEGNO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_max_cost",
          "args": [
            "sbi",
            "&p"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "168-180",
          "snippet": "static unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_policy",
          "args": [
            "sbi",
            "gc_type",
            "type",
            "&p"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "select_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "145-166",
          "snippet": "static void select_policy(struct f2fs_sb_info *sbi, int gc_type,\n\t\t\tint type, struct victim_sel_policy *p)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (p->alloc_mode == SSR) {\n\t\tp->gc_mode = GC_GREEDY;\n\t\tp->dirty_segmap = dirty_i->dirty_segmap[type];\n\t\tp->max_search = dirty_i->nr_dirty[type];\n\t\tp->ofs_unit = 1;\n\t} else {\n\t\tp->gc_mode = select_gc_type(sbi->gc_thread, gc_type);\n\t\tp->dirty_segmap = dirty_i->dirty_segmap[DIRTY];\n\t\tp->max_search = dirty_i->nr_dirty[DIRTY];\n\t\tp->ofs_unit = sbi->segs_per_sec;\n\t}\n\n\tif (p->max_search > sbi->max_victim_search)\n\t\tp->max_search = sbi->max_victim_search;\n\n\tp->offset = sbi->last_victim[p->gc_mode];\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void select_policy(struct f2fs_sb_info *sbi, int gc_type,\n\t\t\tint type, struct victim_sel_policy *p)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (p->alloc_mode == SSR) {\n\t\tp->gc_mode = GC_GREEDY;\n\t\tp->dirty_segmap = dirty_i->dirty_segmap[type];\n\t\tp->max_search = dirty_i->nr_dirty[type];\n\t\tp->ofs_unit = 1;\n\t} else {\n\t\tp->gc_mode = select_gc_type(sbi->gc_thread, gc_type);\n\t\tp->dirty_segmap = dirty_i->dirty_segmap[DIRTY];\n\t\tp->max_search = dirty_i->nr_dirty[DIRTY];\n\t\tp->ofs_unit = sbi->segs_per_sec;\n\t}\n\n\tif (p->max_search > sbi->max_victim_search)\n\t\tp->max_search = sbi->max_victim_search;\n\n\tp->offset = sbi->last_victim[p->gc_mode];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dirty_i->seglist_lock"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int get_victim_by_default(struct f2fs_sb_info *sbi,\n\t\tunsigned int *result, int gc_type, int type, char alloc_mode)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct victim_sel_policy p;\n\tunsigned int secno, max_cost;\n\tint nsearched = 0;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tp.alloc_mode = alloc_mode;\n\tselect_policy(sbi, gc_type, type, &p);\n\n\tp.min_segno = NULL_SEGNO;\n\tp.min_cost = max_cost = get_max_cost(sbi, &p);\n\n\tif (p.alloc_mode == LFS && gc_type == FG_GC) {\n\t\tp.min_segno = check_bg_victims(sbi);\n\t\tif (p.min_segno != NULL_SEGNO)\n\t\t\tgoto got_it;\n\t}\n\n\twhile (1) {\n\t\tunsigned long cost;\n\t\tunsigned int segno;\n\n\t\tsegno = find_next_bit(p.dirty_segmap, MAIN_SEGS(sbi), p.offset);\n\t\tif (segno >= MAIN_SEGS(sbi)) {\n\t\t\tif (sbi->last_victim[p.gc_mode]) {\n\t\t\t\tsbi->last_victim[p.gc_mode] = 0;\n\t\t\t\tp.offset = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tp.offset = segno + p.ofs_unit;\n\t\tif (p.ofs_unit > 1)\n\t\t\tp.offset -= segno % p.ofs_unit;\n\n\t\tsecno = GET_SECNO(sbi, segno);\n\n\t\tif (sec_usage_check(sbi, secno))\n\t\t\tcontinue;\n\t\tif (gc_type == BG_GC && test_bit(secno, dirty_i->victim_secmap))\n\t\t\tcontinue;\n\n\t\tcost = get_gc_cost(sbi, segno, &p);\n\n\t\tif (p.min_cost > cost) {\n\t\t\tp.min_segno = segno;\n\t\t\tp.min_cost = cost;\n\t\t} else if (unlikely(cost == max_cost)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nsearched++ >= p.max_search) {\n\t\t\tsbi->last_victim[p.gc_mode] = segno;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p.min_segno != NULL_SEGNO) {\ngot_it:\n\t\tif (p.alloc_mode == LFS) {\n\t\t\tsecno = GET_SECNO(sbi, p.min_segno);\n\t\t\tif (gc_type == FG_GC)\n\t\t\t\tsbi->cur_victim_sec = secno;\n\t\t\telse\n\t\t\t\tset_bit(secno, dirty_i->victim_secmap);\n\t\t}\n\t\t*result = (p.min_segno / p.ofs_unit) * p.ofs_unit;\n\n\t\ttrace_f2fs_get_victim(sbi->sb, type, gc_type, &p,\n\t\t\t\tsbi->cur_victim_sec,\n\t\t\t\tprefree_segments(sbi), free_segments(sbi));\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treturn (p.min_segno == NULL_SEGNO) ? 0 : 1;\n}"
  },
  {
    "function_name": "get_gc_cost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "233-244",
    "snippet": "static inline unsigned int get_gc_cost(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct victim_sel_policy *p)\n{\n\tif (p->alloc_mode == SSR)\n\t\treturn get_seg_entry(sbi, segno)->ckpt_valid_blocks;\n\n\t/* alloc_mode == LFS */\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\telse\n\t\treturn get_cb_cost(sbi, segno);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cb_cost",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "get_cb_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "201-231",
          "snippet": "static unsigned int get_cb_cost(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int secno = GET_SECNO(sbi, segno);\n\tunsigned int start = secno * sbi->segs_per_sec;\n\tunsigned long long mtime = 0;\n\tunsigned int vblocks;\n\tunsigned char age = 0;\n\tunsigned char u;\n\tunsigned int i;\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tmtime += get_seg_entry(sbi, start + i)->mtime;\n\tvblocks = get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\n\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\tvblocks = div_u64(vblocks, sbi->segs_per_sec);\n\n\tu = (vblocks * 100) >> sbi->log_blocks_per_seg;\n\n\t/* Handle if the system time has changed by the user */\n\tif (mtime < sit_i->min_mtime)\n\t\tsit_i->min_mtime = mtime;\n\tif (mtime > sit_i->max_mtime)\n\t\tsit_i->max_mtime = mtime;\n\tif (sit_i->max_mtime != sit_i->min_mtime)\n\t\tage = 100 - div64_u64(100 * (mtime - sit_i->min_mtime),\n\t\t\t\tsit_i->max_mtime - sit_i->min_mtime);\n\n\treturn UINT_MAX - ((100 * (100 - u) * age) / (100 + u));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int get_cb_cost(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int secno = GET_SECNO(sbi, segno);\n\tunsigned int start = secno * sbi->segs_per_sec;\n\tunsigned long long mtime = 0;\n\tunsigned int vblocks;\n\tunsigned char age = 0;\n\tunsigned char u;\n\tunsigned int i;\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tmtime += get_seg_entry(sbi, start + i)->mtime;\n\tvblocks = get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\n\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\tvblocks = div_u64(vblocks, sbi->segs_per_sec);\n\n\tu = (vblocks * 100) >> sbi->log_blocks_per_seg;\n\n\t/* Handle if the system time has changed by the user */\n\tif (mtime < sit_i->min_mtime)\n\t\tsit_i->min_mtime = mtime;\n\tif (mtime > sit_i->max_mtime)\n\t\tsit_i->max_mtime = mtime;\n\tif (sit_i->max_mtime != sit_i->min_mtime)\n\t\tage = 100 - div64_u64(100 * (mtime - sit_i->min_mtime),\n\t\t\t\tsit_i->max_mtime - sit_i->min_mtime);\n\n\treturn UINT_MAX - ((100 * (100 - u) * age) / (100 + u));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "sbi->segs_per_sec"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int get_gc_cost(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct victim_sel_policy *p)\n{\n\tif (p->alloc_mode == SSR)\n\t\treturn get_seg_entry(sbi, segno)->ckpt_valid_blocks;\n\n\t/* alloc_mode == LFS */\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\telse\n\t\treturn get_cb_cost(sbi, segno);\n}"
  },
  {
    "function_name": "get_cb_cost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "201-231",
    "snippet": "static unsigned int get_cb_cost(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int secno = GET_SECNO(sbi, segno);\n\tunsigned int start = secno * sbi->segs_per_sec;\n\tunsigned long long mtime = 0;\n\tunsigned int vblocks;\n\tunsigned char age = 0;\n\tunsigned char u;\n\tunsigned int i;\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tmtime += get_seg_entry(sbi, start + i)->mtime;\n\tvblocks = get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\n\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\tvblocks = div_u64(vblocks, sbi->segs_per_sec);\n\n\tu = (vblocks * 100) >> sbi->log_blocks_per_seg;\n\n\t/* Handle if the system time has changed by the user */\n\tif (mtime < sit_i->min_mtime)\n\t\tsit_i->min_mtime = mtime;\n\tif (mtime > sit_i->max_mtime)\n\t\tsit_i->max_mtime = mtime;\n\tif (sit_i->max_mtime != sit_i->min_mtime)\n\t\tage = 100 - div64_u64(100 * (mtime - sit_i->min_mtime),\n\t\t\t\tsit_i->max_mtime - sit_i->min_mtime);\n\n\treturn UINT_MAX - ((100 * (100 - u) * age) / (100 + u));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "100 * (mtime - sit_i->min_mtime)",
            "sit_i->max_mtime - sit_i->min_mtime"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "vblocks",
            "sbi->segs_per_sec"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "mtime",
            "sbi->segs_per_sec"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_valid_blocks",
          "args": [
            "sbi",
            "segno",
            "sbi->segs_per_sec"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "get_valid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "282-293",
          "snippet": "static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int section)\n{\n\t/*\n\t * In order to get # of valid blocks in a section instantly from many\n\t * segments, f2fs manages two counting structures separately.\n\t */\n\tif (section > 1)\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "start + i"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_SECNO",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIT_I",
          "args": [
            "sbi"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "SIT_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "690-693",
          "snippet": "static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int get_cb_cost(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int secno = GET_SECNO(sbi, segno);\n\tunsigned int start = secno * sbi->segs_per_sec;\n\tunsigned long long mtime = 0;\n\tunsigned int vblocks;\n\tunsigned char age = 0;\n\tunsigned char u;\n\tunsigned int i;\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tmtime += get_seg_entry(sbi, start + i)->mtime;\n\tvblocks = get_valid_blocks(sbi, segno, sbi->segs_per_sec);\n\n\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\tvblocks = div_u64(vblocks, sbi->segs_per_sec);\n\n\tu = (vblocks * 100) >> sbi->log_blocks_per_seg;\n\n\t/* Handle if the system time has changed by the user */\n\tif (mtime < sit_i->min_mtime)\n\t\tsit_i->min_mtime = mtime;\n\tif (mtime > sit_i->max_mtime)\n\t\tsit_i->max_mtime = mtime;\n\tif (sit_i->max_mtime != sit_i->min_mtime)\n\t\tage = 100 - div64_u64(100 * (mtime - sit_i->min_mtime),\n\t\t\t\tsit_i->max_mtime - sit_i->min_mtime);\n\n\treturn UINT_MAX - ((100 * (100 - u) * age) / (100 + u));\n}"
  },
  {
    "function_name": "check_bg_victims",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "182-199",
    "snippet": "static unsigned int check_bg_victims(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int secno;\n\n\t/*\n\t * If the gc_type is FG_GC, we can select victim segments\n\t * selected by background GC before.\n\t * Those segments guarantee they have small valid blocks.\n\t */\n\tfor_each_set_bit(secno, dirty_i->victim_secmap, MAIN_SECS(sbi)) {\n\t\tif (sec_usage_check(sbi, secno))\n\t\t\tcontinue;\n\t\tclear_bit(secno, dirty_i->victim_secmap);\n\t\treturn secno * sbi->segs_per_sec;\n\t}\n\treturn NULL_SEGNO;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "secno",
            "dirty_i->victim_secmap"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sec_usage_check",
          "args": [
            "sbi",
            "secno"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "sec_usage_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "692-697",
          "snippet": "static inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)\n{\n\tif (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)\n{\n\tif (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "secno",
            "dirty_i->victim_secmap",
            "MAIN_SECS(sbi)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_SECS",
          "args": [
            "sbi"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int check_bg_victims(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int secno;\n\n\t/*\n\t * If the gc_type is FG_GC, we can select victim segments\n\t * selected by background GC before.\n\t * Those segments guarantee they have small valid blocks.\n\t */\n\tfor_each_set_bit(secno, dirty_i->victim_secmap, MAIN_SECS(sbi)) {\n\t\tif (sec_usage_check(sbi, secno))\n\t\t\tcontinue;\n\t\tclear_bit(secno, dirty_i->victim_secmap);\n\t\treturn secno * sbi->segs_per_sec;\n\t}\n\treturn NULL_SEGNO;\n}"
  },
  {
    "function_name": "get_max_cost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "168-180",
    "snippet": "static unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}"
  },
  {
    "function_name": "select_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "145-166",
    "snippet": "static void select_policy(struct f2fs_sb_info *sbi, int gc_type,\n\t\t\tint type, struct victim_sel_policy *p)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (p->alloc_mode == SSR) {\n\t\tp->gc_mode = GC_GREEDY;\n\t\tp->dirty_segmap = dirty_i->dirty_segmap[type];\n\t\tp->max_search = dirty_i->nr_dirty[type];\n\t\tp->ofs_unit = 1;\n\t} else {\n\t\tp->gc_mode = select_gc_type(sbi->gc_thread, gc_type);\n\t\tp->dirty_segmap = dirty_i->dirty_segmap[DIRTY];\n\t\tp->max_search = dirty_i->nr_dirty[DIRTY];\n\t\tp->ofs_unit = sbi->segs_per_sec;\n\t}\n\n\tif (p->max_search > sbi->max_victim_search)\n\t\tp->max_search = sbi->max_victim_search;\n\n\tp->offset = sbi->last_victim[p->gc_mode];\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "select_gc_type",
          "args": [
            "sbi->gc_thread",
            "gc_type"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "select_gc_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "132-143",
          "snippet": "static int select_gc_type(struct f2fs_gc_kthread *gc_th, int gc_type)\n{\n\tint gc_mode = (gc_type == BG_GC) ? GC_CB : GC_GREEDY;\n\n\tif (gc_th && gc_th->gc_idle) {\n\t\tif (gc_th->gc_idle == 1)\n\t\t\tgc_mode = GC_CB;\n\t\telse if (gc_th->gc_idle == 2)\n\t\t\tgc_mode = GC_GREEDY;\n\t}\n\treturn gc_mode;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int select_gc_type(struct f2fs_gc_kthread *gc_th, int gc_type)\n{\n\tint gc_mode = (gc_type == BG_GC) ? GC_CB : GC_GREEDY;\n\n\tif (gc_th && gc_th->gc_idle) {\n\t\tif (gc_th->gc_idle == 1)\n\t\t\tgc_mode = GC_CB;\n\t\telse if (gc_th->gc_idle == 2)\n\t\t\tgc_mode = GC_GREEDY;\n\t}\n\treturn gc_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIRTY_I",
          "args": [
            "sbi"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "DIRTY_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "700-703",
          "snippet": "static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic void select_policy(struct f2fs_sb_info *sbi, int gc_type,\n\t\t\tint type, struct victim_sel_policy *p)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (p->alloc_mode == SSR) {\n\t\tp->gc_mode = GC_GREEDY;\n\t\tp->dirty_segmap = dirty_i->dirty_segmap[type];\n\t\tp->max_search = dirty_i->nr_dirty[type];\n\t\tp->ofs_unit = 1;\n\t} else {\n\t\tp->gc_mode = select_gc_type(sbi->gc_thread, gc_type);\n\t\tp->dirty_segmap = dirty_i->dirty_segmap[DIRTY];\n\t\tp->max_search = dirty_i->nr_dirty[DIRTY];\n\t\tp->ofs_unit = sbi->segs_per_sec;\n\t}\n\n\tif (p->max_search > sbi->max_victim_search)\n\t\tp->max_search = sbi->max_victim_search;\n\n\tp->offset = sbi->last_victim[p->gc_mode];\n}"
  },
  {
    "function_name": "select_gc_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "132-143",
    "snippet": "static int select_gc_type(struct f2fs_gc_kthread *gc_th, int gc_type)\n{\n\tint gc_mode = (gc_type == BG_GC) ? GC_CB : GC_GREEDY;\n\n\tif (gc_th && gc_th->gc_idle) {\n\t\tif (gc_th->gc_idle == 1)\n\t\t\tgc_mode = GC_CB;\n\t\telse if (gc_th->gc_idle == 2)\n\t\t\tgc_mode = GC_GREEDY;\n\t}\n\treturn gc_mode;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int select_gc_type(struct f2fs_gc_kthread *gc_th, int gc_type)\n{\n\tint gc_mode = (gc_type == BG_GC) ? GC_CB : GC_GREEDY;\n\n\tif (gc_th && gc_th->gc_idle) {\n\t\tif (gc_th->gc_idle == 1)\n\t\t\tgc_mode = GC_CB;\n\t\telse if (gc_th->gc_idle == 2)\n\t\t\tgc_mode = GC_GREEDY;\n\t}\n\treturn gc_mode;\n}"
  },
  {
    "function_name": "stop_gc_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "122-130",
    "snippet": "void stop_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\tif (!gc_th)\n\t\treturn;\n\tkthread_stop(gc_th->f2fs_gc_task);\n\tkfree(gc_th);\n\tsbi->gc_thread = NULL;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "gc_th"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "gc_th->f2fs_gc_task"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid stop_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\tif (!gc_th)\n\t\treturn;\n\tkthread_stop(gc_th->f2fs_gc_task);\n\tkfree(gc_th);\n\tsbi->gc_thread = NULL;\n}"
  },
  {
    "function_name": "start_gc_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "91-120",
    "snippet": "int start_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th;\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tint err = 0;\n\n\tgc_th = kmalloc(sizeof(struct f2fs_gc_kthread), GFP_KERNEL);\n\tif (!gc_th) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tgc_th->min_sleep_time = DEF_GC_THREAD_MIN_SLEEP_TIME;\n\tgc_th->max_sleep_time = DEF_GC_THREAD_MAX_SLEEP_TIME;\n\tgc_th->no_gc_sleep_time = DEF_GC_THREAD_NOGC_SLEEP_TIME;\n\n\tgc_th->gc_idle = 0;\n\n\tsbi->gc_thread = gc_th;\n\tinit_waitqueue_head(&sbi->gc_thread->gc_wait_queue_head);\n\tsbi->gc_thread->f2fs_gc_task = kthread_run(gc_thread_func, sbi,\n\t\t\t\"f2fs_gc-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(gc_th->f2fs_gc_task)) {\n\t\terr = PTR_ERR(gc_th->f2fs_gc_task);\n\t\tkfree(gc_th);\n\t\tsbi->gc_thread = NULL;\n\t}\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "gc_th"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gc_th->f2fs_gc_task"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "gc_th->f2fs_gc_task"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "gc_thread_func",
            "sbi",
            "\"f2fs_gc-%u:%u\"",
            "MAJOR(dev)",
            "MINOR(dev)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sbi->gc_thread->gc_wait_queue_head"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct f2fs_gc_kthread)",
            "GFP_KERNEL"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint start_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th;\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tint err = 0;\n\n\tgc_th = kmalloc(sizeof(struct f2fs_gc_kthread), GFP_KERNEL);\n\tif (!gc_th) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tgc_th->min_sleep_time = DEF_GC_THREAD_MIN_SLEEP_TIME;\n\tgc_th->max_sleep_time = DEF_GC_THREAD_MAX_SLEEP_TIME;\n\tgc_th->no_gc_sleep_time = DEF_GC_THREAD_NOGC_SLEEP_TIME;\n\n\tgc_th->gc_idle = 0;\n\n\tsbi->gc_thread = gc_th;\n\tinit_waitqueue_head(&sbi->gc_thread->gc_wait_queue_head);\n\tsbi->gc_thread->f2fs_gc_task = kthread_run(gc_thread_func, sbi,\n\t\t\t\"f2fs_gc-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(gc_th->f2fs_gc_task)) {\n\t\terr = PTR_ERR(gc_th->f2fs_gc_task);\n\t\tkfree(gc_th);\n\t\tsbi->gc_thread = NULL;\n\t}\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "gc_thread_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
    "lines": "27-89",
    "snippet": "static int gc_thread_func(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\twait_queue_head_t *wq = &sbi->gc_thread->gc_wait_queue_head;\n\tlong wait_ms;\n\n\twait_ms = gc_th->min_sleep_time;\n\n\tdo {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\telse\n\t\t\twait_event_interruptible_timeout(*wq,\n\t\t\t\t\t\tkthread_should_stop(),\n\t\t\t\t\t\tmsecs_to_jiffies(wait_ms));\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (sbi->sb->s_writers.frozen >= SB_FREEZE_WRITE) {\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * [GC triggering condition]\n\t\t * 0. GC is not conducted currently.\n\t\t * 1. There are enough dirty segments.\n\t\t * 2. IO subsystem is idle by checking the # of writeback pages.\n\t\t * 3. IO subsystem is idle by checking the # of requests in\n\t\t *    bdev's request list.\n\t\t *\n\t\t * Note) We have to avoid triggering GCs frequently.\n\t\t * Because it is possible that some segments can be\n\t\t * invalidated soon after by user update or deletion.\n\t\t * So, I'd like to wait some time to collect dirty segments.\n\t\t */\n\t\tif (!mutex_trylock(&sbi->gc_mutex))\n\t\t\tcontinue;\n\n\t\tif (!is_idle(sbi)) {\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\n\t\t\tmutex_unlock(&sbi->gc_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (has_enough_invalid_blocks(sbi))\n\t\t\tdecrease_sleep_time(gc_th, &wait_ms);\n\t\telse\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\n\n\t\tstat_inc_bggc_count(sbi);\n\n\t\t/* if return value is not zero, no victim was selected */\n\t\tif (f2fs_gc(sbi))\n\t\t\twait_ms = gc_th->no_gc_sleep_time;\n\n\t\t/* balancing f2fs's metadata periodically */\n\t\tf2fs_balance_fs_bg(sbi);\n\n\t} while (!kthread_should_stop());\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"gc.h\"",
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/init.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs_bg",
          "args": [
            "sbi"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_gc",
          "args": [
            "sbi"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "689-741",
          "snippet": "int f2fs_gc(struct f2fs_sb_info *sbi)\n{\n\tunsigned int segno, i;\n\tint gc_type = BG_GC;\n\tint nfree = 0;\n\tint ret = -1;\n\tstruct cp_control cpc;\n\tstruct gc_inode_list gc_list = {\n\t\t.ilist = LIST_HEAD_INIT(gc_list.ilist),\n\t\t.iroot = RADIX_TREE_INIT(GFP_NOFS),\n\t};\n\n\tcpc.reason = __get_cp_reason(sbi);\ngc_more:\n\tif (unlikely(!(sbi->sb->s_flags & MS_ACTIVE)))\n\t\tgoto stop;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto stop;\n\n\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, nfree)) {\n\t\tgc_type = FG_GC;\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\tif (!__get_victim(sbi, &segno, gc_type))\n\t\tgoto stop;\n\tret = 0;\n\n\t/* readahead multi ssa blocks those have contiguous address */\n\tif (sbi->segs_per_sec > 1)\n\t\tra_meta_pages(sbi, GET_SUM_BLOCK(sbi, segno), sbi->segs_per_sec,\n\t\t\t\t\t\t\t\tMETA_SSA);\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tdo_garbage_collect(sbi, segno + i, &gc_list, gc_type);\n\n\tif (gc_type == FG_GC) {\n\t\tsbi->cur_victim_sec = NULL_SEGNO;\n\t\tnfree++;\n\t\tWARN_ON(get_valid_blocks(sbi, segno, sbi->segs_per_sec));\n\t}\n\n\tif (has_not_enough_free_secs(sbi, nfree))\n\t\tgoto gc_more;\n\n\tif (gc_type == FG_GC)\n\t\twrite_checkpoint(sbi, &cpc);\nstop:\n\tmutex_unlock(&sbi->gc_mutex);\n\n\tput_gc_inode(&gc_list);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint f2fs_gc(struct f2fs_sb_info *sbi)\n{\n\tunsigned int segno, i;\n\tint gc_type = BG_GC;\n\tint nfree = 0;\n\tint ret = -1;\n\tstruct cp_control cpc;\n\tstruct gc_inode_list gc_list = {\n\t\t.ilist = LIST_HEAD_INIT(gc_list.ilist),\n\t\t.iroot = RADIX_TREE_INIT(GFP_NOFS),\n\t};\n\n\tcpc.reason = __get_cp_reason(sbi);\ngc_more:\n\tif (unlikely(!(sbi->sb->s_flags & MS_ACTIVE)))\n\t\tgoto stop;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto stop;\n\n\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, nfree)) {\n\t\tgc_type = FG_GC;\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\n\tif (!__get_victim(sbi, &segno, gc_type))\n\t\tgoto stop;\n\tret = 0;\n\n\t/* readahead multi ssa blocks those have contiguous address */\n\tif (sbi->segs_per_sec > 1)\n\t\tra_meta_pages(sbi, GET_SUM_BLOCK(sbi, segno), sbi->segs_per_sec,\n\t\t\t\t\t\t\t\tMETA_SSA);\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tdo_garbage_collect(sbi, segno + i, &gc_list, gc_type);\n\n\tif (gc_type == FG_GC) {\n\t\tsbi->cur_victim_sec = NULL_SEGNO;\n\t\tnfree++;\n\t\tWARN_ON(get_valid_blocks(sbi, segno, sbi->segs_per_sec));\n\t}\n\n\tif (has_not_enough_free_secs(sbi, nfree))\n\t\tgoto gc_more;\n\n\tif (gc_type == FG_GC)\n\t\twrite_checkpoint(sbi, &cpc);\nstop:\n\tmutex_unlock(&sbi->gc_mutex);\n\n\tput_gc_inode(&gc_list);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_bggc_count",
          "args": [
            "sbi"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "increase_sleep_time",
          "args": [
            "gc_th",
            "&wait_ms"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "increase_sleep_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.h",
          "lines": "67-76",
          "snippet": "static inline void increase_sleep_time(struct f2fs_gc_kthread *gc_th,\n\t\t\t\t\t\t\t\tlong *wait)\n{\n\tif (*wait == gc_th->no_gc_sleep_time)\n\t\treturn;\n\n\t*wait += gc_th->min_sleep_time;\n\tif (*wait > gc_th->max_sleep_time)\n\t\t*wait = gc_th->max_sleep_time;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void increase_sleep_time(struct f2fs_gc_kthread *gc_th,\n\t\t\t\t\t\t\t\tlong *wait)\n{\n\tif (*wait == gc_th->no_gc_sleep_time)\n\t\treturn;\n\n\t*wait += gc_th->min_sleep_time;\n\tif (*wait > gc_th->max_sleep_time)\n\t\t*wait = gc_th->max_sleep_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decrease_sleep_time",
          "args": [
            "gc_th",
            "&wait_ms"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "decrease_sleep_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.h",
          "lines": "78-87",
          "snippet": "static inline void decrease_sleep_time(struct f2fs_gc_kthread *gc_th,\n\t\t\t\t\t\t\t\tlong *wait)\n{\n\tif (*wait == gc_th->no_gc_sleep_time)\n\t\t*wait = gc_th->max_sleep_time;\n\n\t*wait -= gc_th->min_sleep_time;\n\tif (*wait <= gc_th->min_sleep_time)\n\t\t*wait = gc_th->min_sleep_time;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void decrease_sleep_time(struct f2fs_gc_kthread *gc_th,\n\t\t\t\t\t\t\t\tlong *wait)\n{\n\tif (*wait == gc_th->no_gc_sleep_time)\n\t\t*wait = gc_th->max_sleep_time;\n\n\t*wait -= gc_th->min_sleep_time;\n\tif (*wait <= gc_th->min_sleep_time)\n\t\t*wait = gc_th->min_sleep_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_enough_invalid_blocks",
          "args": [
            "sbi"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "has_enough_invalid_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.h",
          "lines": "89-102",
          "snippet": "static inline bool has_enough_invalid_blocks(struct f2fs_sb_info *sbi)\n{\n\tblock_t invalid_user_blocks = sbi->user_block_count -\n\t\t\t\t\twritten_block_count(sbi);\n\t/*\n\t * Background GC is triggered with the following conditions.\n\t * 1. There are a number of invalid blocks.\n\t * 2. There is not enough free space.\n\t */\n\tif (invalid_user_blocks > limit_invalid_user_blocks(sbi) &&\n\t\t\tfree_user_blocks(sbi) < limit_free_user_blocks(sbi))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool has_enough_invalid_blocks(struct f2fs_sb_info *sbi)\n{\n\tblock_t invalid_user_blocks = sbi->user_block_count -\n\t\t\t\t\twritten_block_count(sbi);\n\t/*\n\t * Background GC is triggered with the following conditions.\n\t * 1. There are a number of invalid blocks.\n\t * 2. There is not enough free space.\n\t */\n\tif (invalid_user_blocks > limit_invalid_user_blocks(sbi) &&\n\t\t\tfree_user_blocks(sbi) < limit_free_user_blocks(sbi))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle",
          "args": [
            "sbi"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "is_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.h",
          "lines": "104-110",
          "snippet": "static inline int is_idle(struct f2fs_sb_info *sbi)\n{\n\tstruct block_device *bdev = sbi->sb->s_bdev;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tstruct request_list *rl = &q->root_rl;\n\treturn !(rl->count[BLK_RW_SYNC]) && !(rl->count[BLK_RW_ASYNC]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int is_idle(struct f2fs_sb_info *sbi)\n{\n\tstruct block_device *bdev = sbi->sb->s_bdev;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tstruct request_list *rl = &q->root_rl;\n\treturn !(rl->count[BLK_RW_SYNC]) && !(rl->count[BLK_RW_ASYNC]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&sbi->gc_mutex"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "*wq",
            "kthread_should_stop()",
            "msecs_to_jiffies(wait_ms)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "wait_ms"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int gc_thread_func(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\twait_queue_head_t *wq = &sbi->gc_thread->gc_wait_queue_head;\n\tlong wait_ms;\n\n\twait_ms = gc_th->min_sleep_time;\n\n\tdo {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\telse\n\t\t\twait_event_interruptible_timeout(*wq,\n\t\t\t\t\t\tkthread_should_stop(),\n\t\t\t\t\t\tmsecs_to_jiffies(wait_ms));\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (sbi->sb->s_writers.frozen >= SB_FREEZE_WRITE) {\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * [GC triggering condition]\n\t\t * 0. GC is not conducted currently.\n\t\t * 1. There are enough dirty segments.\n\t\t * 2. IO subsystem is idle by checking the # of writeback pages.\n\t\t * 3. IO subsystem is idle by checking the # of requests in\n\t\t *    bdev's request list.\n\t\t *\n\t\t * Note) We have to avoid triggering GCs frequently.\n\t\t * Because it is possible that some segments can be\n\t\t * invalidated soon after by user update or deletion.\n\t\t * So, I'd like to wait some time to collect dirty segments.\n\t\t */\n\t\tif (!mutex_trylock(&sbi->gc_mutex))\n\t\t\tcontinue;\n\n\t\tif (!is_idle(sbi)) {\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\n\t\t\tmutex_unlock(&sbi->gc_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (has_enough_invalid_blocks(sbi))\n\t\t\tdecrease_sleep_time(gc_th, &wait_ms);\n\t\telse\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\n\n\t\tstat_inc_bggc_count(sbi);\n\n\t\t/* if return value is not zero, no victim was selected */\n\t\tif (f2fs_gc(sbi))\n\t\t\twait_ms = gc_th->no_gc_sleep_time;\n\n\t\t/* balancing f2fs's metadata periodically */\n\t\tf2fs_balance_fs_bg(sbi);\n\n\t} while (!kthread_should_stop());\n\treturn 0;\n}"
  }
]