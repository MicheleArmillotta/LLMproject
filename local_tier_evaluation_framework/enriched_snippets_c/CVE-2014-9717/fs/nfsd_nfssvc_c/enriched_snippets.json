[
  {
    "function_name": "nfsd_pool_stats_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "742-752",
    "snippet": "int nfsd_pool_stats_release(struct inode *inode, struct file *file)\n{\n\tint ret = seq_release(inode, file);\n\tstruct net *net = inode->i_sb->s_fs_info;\n\n\tmutex_lock(&nfsd_mutex);\n\t/* this function really, really should have been called svc_put() */\n\tnfsd_destroy(net);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "447-457",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_pool_stats_release(struct inode *inode, struct file *file)\n{\n\tint ret = seq_release(inode, file);\n\tstruct net *net = inode->i_sb->s_fs_info;\n\n\tmutex_lock(&nfsd_mutex);\n\t/* this function really, really should have been called svc_put() */\n\tnfsd_destroy(net);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_pool_stats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "725-740",
    "snippet": "int nfsd_pool_stats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(inode->i_sb->s_fs_info, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv == NULL) {\n\t\tmutex_unlock(&nfsd_mutex);\n\t\treturn -ENODEV;\n\t}\n\t/* bump up the psudo refcount while traversing */\n\tsvc_get(nn->nfsd_serv);\n\tret = svc_pool_stats_open(nn->nfsd_serv, file);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_pool_stats_open",
          "args": [
            "nn->nfsd_serv",
            "file"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_get",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "inode->i_sb->s_fs_info",
            "nfsd_net_id"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_pool_stats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(inode->i_sb->s_fs_info, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv == NULL) {\n\t\tmutex_unlock(&nfsd_mutex);\n\t\treturn -ENODEV;\n\t}\n\t/* bump up the psudo refcount while traversing */\n\tsvc_get(nn->nfsd_serv);\n\tret = svc_pool_stats_open(nn->nfsd_serv, file);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_dispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "650-723",
    "snippet": "int\nnfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n{\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n\t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n\tproc = rqstp->rq_procinfo;\n\n\t/*\n\t * Give the xdr decoder a chance to change this if it wants\n\t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_cache_update",
          "args": [
            "rqstp",
            "rqstp->rq_cachetype",
            "statp + 1"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "533-587",
          "snippet": "void\nnfsd_cache_update(struct svc_rqst *rqstp, int cachetype, __be32 *statp)\n{\n\tstruct svc_cacherep *rp = rqstp->rq_cacherep;\n\tstruct kvec\t*resv = &rqstp->rq_res.head[0], *cachv;\n\tu32\t\thash;\n\tstruct nfsd_drc_bucket *b;\n\tint\t\tlen;\n\tsize_t\t\tbufsize = 0;\n\n\tif (!rp)\n\t\treturn;\n\n\thash = nfsd_cache_hash(rp->c_xid);\n\tb = &drc_hashtbl[hash];\n\n\tlen = resv->iov_len - ((char*)statp - (char*)resv->iov_base);\n\tlen >>= 2;\n\n\t/* Don't cache excessive amounts of data and XDR failures */\n\tif (!statp || len > (256 >> 2)) {\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\n\tswitch (cachetype) {\n\tcase RC_REPLSTAT:\n\t\tif (len != 1)\n\t\t\tprintk(\"nfsd: RC_REPLSTAT/reply len %d!\\n\",len);\n\t\trp->c_replstat = *statp;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tcachv = &rp->c_replvec;\n\t\tbufsize = len << 2;\n\t\tcachv->iov_base = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!cachv->iov_base) {\n\t\t\tnfsd_reply_cache_free(b, rp);\n\t\t\treturn;\n\t\t}\n\t\tcachv->iov_len = bufsize;\n\t\tmemcpy(cachv->iov_base, statp, bufsize);\n\t\tbreak;\n\tcase RC_NOCACHE:\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\tspin_lock(&b->cache_lock);\n\tdrc_mem_usage += bufsize;\n\tlru_put_end(b, rp);\n\trp->c_secure = test_bit(RQ_SECURE, &rqstp->rq_flags);\n\trp->c_type = cachetype;\n\trp->c_state = RC_DONE;\n\tspin_unlock(&b->cache_lock);\n\treturn;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_mem_usage;\n\nvoid\nnfsd_cache_update(struct svc_rqst *rqstp, int cachetype, __be32 *statp)\n{\n\tstruct svc_cacherep *rp = rqstp->rq_cacherep;\n\tstruct kvec\t*resv = &rqstp->rq_res.head[0], *cachv;\n\tu32\t\thash;\n\tstruct nfsd_drc_bucket *b;\n\tint\t\tlen;\n\tsize_t\t\tbufsize = 0;\n\n\tif (!rp)\n\t\treturn;\n\n\thash = nfsd_cache_hash(rp->c_xid);\n\tb = &drc_hashtbl[hash];\n\n\tlen = resv->iov_len - ((char*)statp - (char*)resv->iov_base);\n\tlen >>= 2;\n\n\t/* Don't cache excessive amounts of data and XDR failures */\n\tif (!statp || len > (256 >> 2)) {\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\n\tswitch (cachetype) {\n\tcase RC_REPLSTAT:\n\t\tif (len != 1)\n\t\t\tprintk(\"nfsd: RC_REPLSTAT/reply len %d!\\n\",len);\n\t\trp->c_replstat = *statp;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tcachv = &rp->c_replvec;\n\t\tbufsize = len << 2;\n\t\tcachv->iov_base = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!cachv->iov_base) {\n\t\t\tnfsd_reply_cache_free(b, rp);\n\t\t\treturn;\n\t\t}\n\t\tcachv->iov_len = bufsize;\n\t\tmemcpy(cachv->iov_base, statp, bufsize);\n\t\tbreak;\n\tcase RC_NOCACHE:\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\tspin_lock(&b->cache_lock);\n\tdrc_mem_usage += bufsize;\n\tlru_put_end(b, rp);\n\trp->c_secure = test_bit(RQ_SECURE, &rqstp->rq_flags);\n\trp->c_type = cachetype;\n\trp->c_state = RC_DONE;\n\tspin_unlock(&b->cache_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: failed to encode result!\\n\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr",
          "args": [
            "rqstp",
            "nfserrp",
            "rqstp->rq_resp"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_dupstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "205-215",
          "snippet": "static char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: Dropping request; may be revisited later\\n\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_DROPME",
            "&rqstp->rq_flags"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_new_errors",
          "args": [
            "rqstp->rq_vers",
            "nfserr"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "map_new_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "641-648",
          "snippet": "static __be32 map_new_errors(u32 vers, __be32 nfserr)\n{\n\tif (nfserr == nfserr_jukebox && vers == 2)\n\t\treturn nfserr_dropit;\n\tif (nfserr == nfserr_wrongsec && vers < 4)\n\t\treturn nfserr_acces;\n\treturn nfserr;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic __be32 map_new_errors(u32 vers, __be32 nfserr)\n{\n\tif (nfserr == nfserr_jukebox && vers == 2)\n\t\treturn nfserr_dropit;\n\tif (nfserr == nfserr_wrongsec && vers < 4)\n\t\treturn nfserr_acces;\n\treturn nfserr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc->pc_func",
          "args": [
            "rqstp",
            "rqstp->rq_argp",
            "rqstp->rq_resp"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_lookup",
          "args": [
            "rqstp"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "404-515",
          "snippet": "int\nnfsd_cache_lookup(struct svc_rqst *rqstp)\n{\n\tstruct svc_cacherep\t*rp, *found;\n\t__be32\t\t\txid = rqstp->rq_xid;\n\tu32\t\t\tproto =  rqstp->rq_prot,\n\t\t\t\tvers = rqstp->rq_vers,\n\t\t\t\tproc = rqstp->rq_proc;\n\t__wsum\t\t\tcsum;\n\tu32 hash = nfsd_cache_hash(xid);\n\tstruct nfsd_drc_bucket *b = &drc_hashtbl[hash];\n\tunsigned long\t\tage;\n\tint type = rqstp->rq_cachetype;\n\tint rtn = RC_DOIT;\n\n\trqstp->rq_cacherep = NULL;\n\tif (type == RC_NOCACHE) {\n\t\tnfsdstats.rcnocache++;\n\t\treturn rtn;\n\t}\n\n\tcsum = nfsd_cache_csum(rqstp);\n\n\t/*\n\t * Since the common case is a cache miss followed by an insert,\n\t * preallocate an entry.\n\t */\n\trp = nfsd_reply_cache_alloc();\n\tspin_lock(&b->cache_lock);\n\tif (likely(rp)) {\n\t\tatomic_inc(&num_drc_entries);\n\t\tdrc_mem_usage += sizeof(*rp);\n\t}\n\n\t/* go ahead and prune the cache */\n\tprune_bucket(b);\n\n\tfound = nfsd_cache_search(b, rqstp, csum);\n\tif (found) {\n\t\tif (likely(rp))\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\trp = found;\n\t\tgoto found_entry;\n\t}\n\n\tif (!rp) {\n\t\tdprintk(\"nfsd: unable to allocate DRC entry!\\n\");\n\t\tgoto out;\n\t}\n\n\tnfsdstats.rcmisses++;\n\trqstp->rq_cacherep = rp;\n\trp->c_state = RC_INPROG;\n\trp->c_xid = xid;\n\trp->c_proc = proc;\n\trpc_copy_addr((struct sockaddr *)&rp->c_addr, svc_addr(rqstp));\n\trpc_set_port((struct sockaddr *)&rp->c_addr, rpc_get_port(svc_addr(rqstp)));\n\trp->c_prot = proto;\n\trp->c_vers = vers;\n\trp->c_len = rqstp->rq_arg.len;\n\trp->c_csum = csum;\n\n\tlru_put_end(b, rp);\n\n\t/* release any buffer */\n\tif (rp->c_type == RC_REPLBUFF) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t\trp->c_replvec.iov_base = NULL;\n\t}\n\trp->c_type = RC_NOCACHE;\n out:\n\tspin_unlock(&b->cache_lock);\n\treturn rtn;\n\nfound_entry:\n\tnfsdstats.rchits++;\n\t/* We found a matching entry which is either in progress or done. */\n\tage = jiffies - rp->c_timestamp;\n\tlru_put_end(b, rp);\n\n\trtn = RC_DROPIT;\n\t/* Request being processed or excessive rexmits */\n\tif (rp->c_state == RC_INPROG || age < RC_DELAY)\n\t\tgoto out;\n\n\t/* From the hall of fame of impractical attacks:\n\t * Is this a user who tries to snoop on the cache? */\n\trtn = RC_DOIT;\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && rp->c_secure)\n\t\tgoto out;\n\n\t/* Compose RPC reply header */\n\tswitch (rp->c_type) {\n\tcase RC_NOCACHE:\n\t\tbreak;\n\tcase RC_REPLSTAT:\n\t\tsvc_putu32(&rqstp->rq_res.head[0], rp->c_replstat);\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tif (!nfsd_cache_append(rqstp, &rp->c_replvec))\n\t\t\tgoto out;\t/* should not happen */\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad repcache type %d\\n\", rp->c_type);\n\t\tnfsd_reply_cache_free_locked(rp);\n\t}\n\n\tgoto out;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nint\nnfsd_cache_lookup(struct svc_rqst *rqstp)\n{\n\tstruct svc_cacherep\t*rp, *found;\n\t__be32\t\t\txid = rqstp->rq_xid;\n\tu32\t\t\tproto =  rqstp->rq_prot,\n\t\t\t\tvers = rqstp->rq_vers,\n\t\t\t\tproc = rqstp->rq_proc;\n\t__wsum\t\t\tcsum;\n\tu32 hash = nfsd_cache_hash(xid);\n\tstruct nfsd_drc_bucket *b = &drc_hashtbl[hash];\n\tunsigned long\t\tage;\n\tint type = rqstp->rq_cachetype;\n\tint rtn = RC_DOIT;\n\n\trqstp->rq_cacherep = NULL;\n\tif (type == RC_NOCACHE) {\n\t\tnfsdstats.rcnocache++;\n\t\treturn rtn;\n\t}\n\n\tcsum = nfsd_cache_csum(rqstp);\n\n\t/*\n\t * Since the common case is a cache miss followed by an insert,\n\t * preallocate an entry.\n\t */\n\trp = nfsd_reply_cache_alloc();\n\tspin_lock(&b->cache_lock);\n\tif (likely(rp)) {\n\t\tatomic_inc(&num_drc_entries);\n\t\tdrc_mem_usage += sizeof(*rp);\n\t}\n\n\t/* go ahead and prune the cache */\n\tprune_bucket(b);\n\n\tfound = nfsd_cache_search(b, rqstp, csum);\n\tif (found) {\n\t\tif (likely(rp))\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\trp = found;\n\t\tgoto found_entry;\n\t}\n\n\tif (!rp) {\n\t\tdprintk(\"nfsd: unable to allocate DRC entry!\\n\");\n\t\tgoto out;\n\t}\n\n\tnfsdstats.rcmisses++;\n\trqstp->rq_cacherep = rp;\n\trp->c_state = RC_INPROG;\n\trp->c_xid = xid;\n\trp->c_proc = proc;\n\trpc_copy_addr((struct sockaddr *)&rp->c_addr, svc_addr(rqstp));\n\trpc_set_port((struct sockaddr *)&rp->c_addr, rpc_get_port(svc_addr(rqstp)));\n\trp->c_prot = proto;\n\trp->c_vers = vers;\n\trp->c_len = rqstp->rq_arg.len;\n\trp->c_csum = csum;\n\n\tlru_put_end(b, rp);\n\n\t/* release any buffer */\n\tif (rp->c_type == RC_REPLBUFF) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t\trp->c_replvec.iov_base = NULL;\n\t}\n\trp->c_type = RC_NOCACHE;\n out:\n\tspin_unlock(&b->cache_lock);\n\treturn rtn;\n\nfound_entry:\n\tnfsdstats.rchits++;\n\t/* We found a matching entry which is either in progress or done. */\n\tage = jiffies - rp->c_timestamp;\n\tlru_put_end(b, rp);\n\n\trtn = RC_DROPIT;\n\t/* Request being processed or excessive rexmits */\n\tif (rp->c_state == RC_INPROG || age < RC_DELAY)\n\t\tgoto out;\n\n\t/* From the hall of fame of impractical attacks:\n\t * Is this a user who tries to snoop on the cache? */\n\trtn = RC_DOIT;\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && rp->c_secure)\n\t\tgoto out;\n\n\t/* Compose RPC reply header */\n\tswitch (rp->c_type) {\n\tcase RC_NOCACHE:\n\t\tbreak;\n\tcase RC_REPLSTAT:\n\t\tsvc_putu32(&rqstp->rq_res.head[0], rp->c_replstat);\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tif (!nfsd_cache_append(rqstp, &rp->c_replvec))\n\t\t\tgoto out;\t/* should not happen */\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad repcache type %d\\n\", rp->c_type);\n\t\tnfsd_reply_cache_free_locked(rp);\n\t}\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: failed to decode arguments!\\n\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd_dispatch: vers %d proc %d\\n\"",
            "rqstp->rq_vers",
            "rqstp->rq_proc"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint\nnfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n{\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n\t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n\tproc = rqstp->rq_procinfo;\n\n\t/*\n\t * Give the xdr decoder a chance to change this if it wants\n\t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}"
  },
  {
    "function_name": "map_new_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "641-648",
    "snippet": "static __be32 map_new_errors(u32 vers, __be32 nfserr)\n{\n\tif (nfserr == nfserr_jukebox && vers == 2)\n\t\treturn nfserr_dropit;\n\tif (nfserr == nfserr_wrongsec && vers < 4)\n\t\treturn nfserr_acces;\n\treturn nfserr;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic __be32 map_new_errors(u32 vers, __be32 nfserr)\n{\n\tif (nfserr == nfserr_jukebox && vers == 2)\n\t\treturn nfserr_dropit;\n\tif (nfserr == nfserr_wrongsec && vers < 4)\n\t\treturn nfserr_acces;\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "565-639",
    "snippet": "static int\nnfsd(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = (struct svc_rqst *) vrqstp;\n\tstruct svc_xprt *perm_sock = list_entry(rqstp->rq_server->sv_permsocks.next, typeof(struct svc_xprt), xpt_list);\n\tstruct net *net = perm_sock->xpt_net;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint err;\n\n\t/* Lock module and set up kernel thread */\n\tmutex_lock(&nfsd_mutex);\n\n\t/* At this point, the thread shares current->fs\n\t * with the init process. We need to create files with a\n\t * umask of 0 instead of init's umask. */\n\tif (unshare_fs_struct() < 0) {\n\t\tprintk(\"Unable to start nfsd thread: out of memory\\n\");\n\t\tgoto out;\n\t}\n\n\tcurrent->fs->umask = 0;\n\n\t/*\n\t * thread is spawned with all signals set to SIG_IGN, re-enable\n\t * the ones that will bring down the thread\n\t */\n\tallow_signal(SIGKILL);\n\tallow_signal(SIGHUP);\n\tallow_signal(SIGINT);\n\tallow_signal(SIGQUIT);\n\n\tnfsdstats.th_cnt++;\n\tmutex_unlock(&nfsd_mutex);\n\n\tset_freezable();\n\n\t/*\n\t * The main request loop\n\t */\n\tfor (;;) {\n\t\t/* Update sv_maxconn if it has changed */\n\t\trqstp->rq_server->sv_maxconn = nn->max_connections;\n\n\t\t/*\n\t\t * Find a socket with data available and call its\n\t\t * recvfrom routine.\n\t\t */\n\t\twhile ((err = svc_recv(rqstp, 60*60*HZ)) == -EAGAIN)\n\t\t\t;\n\t\tif (err == -EINTR)\n\t\t\tbreak;\n\t\tvalidate_process_creds();\n\t\tsvc_process(rqstp);\n\t\tvalidate_process_creds();\n\t}\n\n\t/* Clear signals before calling svc_exit_thread() */\n\tflush_signals(current);\n\n\tmutex_lock(&nfsd_mutex);\n\tnfsdstats.th_cnt --;\n\nout:\n\trqstp->rq_server = NULL;\n\n\t/* Release the thread */\n\tsvc_exit_thread(rqstp);\n\n\tnfsd_destroy(net);\n\n\t/* Release module */\n\tmutex_unlock(&nfsd_mutex);\n\tmodule_put_and_exit(0);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tnfsd(void *vrqstp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put_and_exit",
          "args": [
            "0"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "447-457",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_exit_thread",
          "args": [
            "rqstp"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_signals",
          "args": [
            "current"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_process_creds",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_process",
          "args": [
            "rqstp"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_process_creds",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_recv",
          "args": [
            "rqstp",
            "60*60*HZ"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGQUIT"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGINT"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGHUP"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGKILL"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Unable to start nfsd thread: out of memory\\n\""
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unshare_fs_struct",
          "args": [],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "unshare_fs_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "131-151",
          "snippet": "int unshare_fs_struct(void)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct fs_struct *new_fs = copy_fs_struct(fs);\n\tint kill;\n\n\tif (!new_fs)\n\t\treturn -ENOMEM;\n\n\ttask_lock(current);\n\tspin_lock(&fs->lock);\n\tkill = !--fs->users;\n\tcurrent->fs = new_fs;\n\tspin_unlock(&fs->lock);\n\ttask_unlock(current);\n\n\tif (kill)\n\t\tfree_fs_struct(fs);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint unshare_fs_struct(void)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct fs_struct *new_fs = copy_fs_struct(fs);\n\tint kill;\n\n\tif (!new_fs)\n\t\treturn -ENOMEM;\n\n\ttask_lock(current);\n\tspin_lock(&fs->lock);\n\tkill = !--fs->users;\n\tcurrent->fs = new_fs;\n\tspin_unlock(&fs->lock);\n\ttask_unlock(current);\n\n\tif (kill)\n\t\tfree_fs_struct(fs);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rqstp->rq_server->sv_permsocks.next",
            "typeof(struct svc_xprt)",
            "xpt_list"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "structsvc_xprt"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int\t\t\tnfsd(void *vrqstp);\n\nstatic int\nnfsd(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = (struct svc_rqst *) vrqstp;\n\tstruct svc_xprt *perm_sock = list_entry(rqstp->rq_server->sv_permsocks.next, typeof(struct svc_xprt), xpt_list);\n\tstruct net *net = perm_sock->xpt_net;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint err;\n\n\t/* Lock module and set up kernel thread */\n\tmutex_lock(&nfsd_mutex);\n\n\t/* At this point, the thread shares current->fs\n\t * with the init process. We need to create files with a\n\t * umask of 0 instead of init's umask. */\n\tif (unshare_fs_struct() < 0) {\n\t\tprintk(\"Unable to start nfsd thread: out of memory\\n\");\n\t\tgoto out;\n\t}\n\n\tcurrent->fs->umask = 0;\n\n\t/*\n\t * thread is spawned with all signals set to SIG_IGN, re-enable\n\t * the ones that will bring down the thread\n\t */\n\tallow_signal(SIGKILL);\n\tallow_signal(SIGHUP);\n\tallow_signal(SIGINT);\n\tallow_signal(SIGQUIT);\n\n\tnfsdstats.th_cnt++;\n\tmutex_unlock(&nfsd_mutex);\n\n\tset_freezable();\n\n\t/*\n\t * The main request loop\n\t */\n\tfor (;;) {\n\t\t/* Update sv_maxconn if it has changed */\n\t\trqstp->rq_server->sv_maxconn = nn->max_connections;\n\n\t\t/*\n\t\t * Find a socket with data available and call its\n\t\t * recvfrom routine.\n\t\t */\n\t\twhile ((err = svc_recv(rqstp, 60*60*HZ)) == -EAGAIN)\n\t\t\t;\n\t\tif (err == -EINTR)\n\t\t\tbreak;\n\t\tvalidate_process_creds();\n\t\tsvc_process(rqstp);\n\t\tvalidate_process_creds();\n\t}\n\n\t/* Clear signals before calling svc_exit_thread() */\n\tflush_signals(current);\n\n\tmutex_lock(&nfsd_mutex);\n\tnfsdstats.th_cnt --;\n\nout:\n\trqstp->rq_server = NULL;\n\n\t/* Release the thread */\n\tsvc_exit_thread(rqstp);\n\n\tnfsd_destroy(net);\n\n\t/* Release module */\n\tmutex_unlock(&nfsd_mutex);\n\tmodule_put_and_exit(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_svc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "517-559",
    "snippet": "int\nnfsd_svc(int nrservs, struct net *net)\n{\n\tint\terror;\n\tbool\tnfsd_up_before;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tdprintk(\"nfsd: creating service\\n\");\n\n\tnrservs = max(nrservs, 0);\n\tnrservs = min(nrservs, NFSD_MAXSERVS);\n\terror = 0;\n\n\tif (nrservs == 0 && nn->nfsd_serv == NULL)\n\t\tgoto out;\n\n\terror = nfsd_create_serv(net);\n\tif (error)\n\t\tgoto out;\n\n\tnfsd_up_before = nn->nfsd_net_up;\n\n\terror = nfsd_startup_net(nrservs, net);\n\tif (error)\n\t\tgoto out_destroy;\n\terror = svc_set_num_threads(nn->nfsd_serv, NULL, nrservs);\n\tif (error)\n\t\tgoto out_shutdown;\n\t/* We are holding a reference to nn->nfsd_serv which\n\t * we don't want to count in the return value,\n\t * so subtract 1\n\t */\n\terror = nn->nfsd_serv->sv_nrthreads - 1;\nout_shutdown:\n\tif (error < 0 && !nfsd_up_before)\n\t\tnfsd_shutdown_net(net);\nout_destroy:\n\tnfsd_destroy(net);\t\t/* Release server */\nout:\n\tmutex_unlock(&nfsd_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define\tNFSD_MAXSERVS\t\t8192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "447-457",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_shutdown_net",
          "args": [
            "net"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_shutdown_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "296-307",
          "snippet": "static void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_set_num_threads",
          "args": [
            "nn->nfsd_serv",
            "NULL",
            "nrservs"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_startup_net",
          "args": [
            "nrservs",
            "net"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_startup_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "257-294",
          "snippet": "static int nfsd_startup_net(int nrservs, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic(nrservs);\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd() && !nn->lockd_up) {\n\t\tret = lockd_up(net);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = 1;\n\t}\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_startup_net(int nrservs, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic(nrservs);\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd() && !nn->lockd_up) {\n\t\tret = lockd_up(net);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = 1;\n\t}\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_create_serv",
          "args": [
            "net"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create_serv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "394-422",
          "snippet": "int nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t      nfsd_last_thread, nfsd, THIS_MODULE);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct svc_program\tnfsd_program;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nextern struct svc_program\tnfsd_program;\n\nint nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t      nfsd_last_thread, nfsd, THIS_MODULE);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nrservs",
            "NFSD_MAXSERVS"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nrservs",
            "0"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_max_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "2299-2309",
          "snippet": "int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define op_encode_hdr_size\t\t(2)"
          ],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: creating service\\n\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define\tNFSD_MAXSERVS\t\t8192\n\nint\nnfsd_svc(int nrservs, struct net *net)\n{\n\tint\terror;\n\tbool\tnfsd_up_before;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tdprintk(\"nfsd: creating service\\n\");\n\n\tnrservs = max(nrservs, 0);\n\tnrservs = min(nrservs, NFSD_MAXSERVS);\n\terror = 0;\n\n\tif (nrservs == 0 && nn->nfsd_serv == NULL)\n\t\tgoto out;\n\n\terror = nfsd_create_serv(net);\n\tif (error)\n\t\tgoto out;\n\n\tnfsd_up_before = nn->nfsd_net_up;\n\n\terror = nfsd_startup_net(nrservs, net);\n\tif (error)\n\t\tgoto out_destroy;\n\terror = svc_set_num_threads(nn->nfsd_serv, NULL, nrservs);\n\tif (error)\n\t\tgoto out_shutdown;\n\t/* We are holding a reference to nn->nfsd_serv which\n\t * we don't want to count in the return value,\n\t * so subtract 1\n\t */\n\terror = nn->nfsd_serv->sv_nrthreads - 1;\nout_shutdown:\n\tif (error < 0 && !nfsd_up_before)\n\t\tnfsd_shutdown_net(net);\nout_destroy:\n\tnfsd_destroy(net);\t\t/* Release server */\nout:\n\tmutex_unlock(&nfsd_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "nfsd_set_nrthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "459-510",
    "snippet": "int nfsd_set_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tint tot = 0;\n\tint err = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\n\tif (nn->nfsd_serv == NULL || n <= 0)\n\t\treturn 0;\n\n\tif (n > nn->nfsd_serv->sv_nrpools)\n\t\tn = nn->nfsd_serv->sv_nrpools;\n\n\t/* enforce a global maximum number of threads */\n\ttot = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tnthreads[i] = min(nthreads[i], NFSD_MAXSERVS);\n\t\ttot += nthreads[i];\n\t}\n\tif (tot > NFSD_MAXSERVS) {\n\t\t/* total too large: scale down requested numbers */\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t    \tint new = nthreads[i] * NFSD_MAXSERVS / tot;\n\t\t\ttot -= (nthreads[i] - new);\n\t\t\tnthreads[i] = new;\n\t\t}\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t\tnthreads[i]--;\n\t\t\ttot--;\n\t\t}\n\t}\n\n\t/*\n\t * There must always be a thread in pool 0; the admin\n\t * can't shut down NFS completely using pool_threads.\n\t */\n\tif (nthreads[0] == 0)\n\t\tnthreads[0] = 1;\n\n\t/* apply the new numbers */\n\tsvc_get(nn->nfsd_serv);\n\tfor (i = 0; i < n; i++) {\n\t\terr = svc_set_num_threads(nn->nfsd_serv, &nn->nfsd_serv->sv_pools[i],\n\t\t\t\t    \t  nthreads[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tnfsd_destroy(net);\n\treturn err;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define\tNFSD_MAXSERVS\t\t8192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "447-457",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_set_num_threads",
          "args": [
            "nn->nfsd_serv",
            "&nn->nfsd_serv->sv_pools[i]",
            "nthreads[i]"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_get",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nthreads[i]",
            "NFSD_MAXSERVS"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&nfsd_mutex)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define\tNFSD_MAXSERVS\t\t8192\n\nint nfsd_set_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tint tot = 0;\n\tint err = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\n\tif (nn->nfsd_serv == NULL || n <= 0)\n\t\treturn 0;\n\n\tif (n > nn->nfsd_serv->sv_nrpools)\n\t\tn = nn->nfsd_serv->sv_nrpools;\n\n\t/* enforce a global maximum number of threads */\n\ttot = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tnthreads[i] = min(nthreads[i], NFSD_MAXSERVS);\n\t\ttot += nthreads[i];\n\t}\n\tif (tot > NFSD_MAXSERVS) {\n\t\t/* total too large: scale down requested numbers */\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t    \tint new = nthreads[i] * NFSD_MAXSERVS / tot;\n\t\t\ttot -= (nthreads[i] - new);\n\t\t\tnthreads[i] = new;\n\t\t}\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t\tnthreads[i]--;\n\t\t\ttot--;\n\t\t}\n\t}\n\n\t/*\n\t * There must always be a thread in pool 0; the admin\n\t * can't shut down NFS completely using pool_threads.\n\t */\n\tif (nthreads[0] == 0)\n\t\tnthreads[0] = 1;\n\n\t/* apply the new numbers */\n\tsvc_get(nn->nfsd_serv);\n\tfor (i = 0; i < n; i++) {\n\t\terr = svc_set_num_threads(nn->nfsd_serv, &nn->nfsd_serv->sv_pools[i],\n\t\t\t\t    \t  nthreads[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tnfsd_destroy(net);\n\treturn err;\n}"
  },
  {
    "function_name": "nfsd_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "447-457",
    "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_destroy",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_shutdown_net",
          "args": [
            "nn->nfsd_serv",
            "net"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
  },
  {
    "function_name": "nfsd_get_nrthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "434-445",
    "snippet": "int nfsd_get_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv != NULL) {\n\t\tfor (i = 0; i < nn->nfsd_serv->sv_nrpools && i < n; i++)\n\t\t\tnthreads[i] = nn->nfsd_serv->sv_pools[i].sp_nrthreads;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_get_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv != NULL) {\n\t\tfor (i = 0; i < nn->nfsd_serv->sv_nrpools && i < n; i++)\n\t\t\tnthreads[i] = nn->nfsd_serv->sv_pools[i].sp_nrthreads;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_nrpools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "424-432",
    "snippet": "int nfsd_nrpools(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\telse\n\t\treturn nn->nfsd_serv->sv_nrpools;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_nrpools(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\telse\n\t\treturn nn->nfsd_serv->sv_nrpools;\n}"
  },
  {
    "function_name": "nfsd_create_serv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "394-422",
    "snippet": "int nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t      nfsd_last_thread, nfsd, THIS_MODULE);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct svc_program\tnfsd_program;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_gettimeofday",
          "args": [
            "&nn->nfssvc_boot"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_max_drc",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "set_max_drc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "363-371",
          "snippet": "static void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define NFSD_DRC_SIZE_SHIFT\t10"
          ],
          "globals_used": [
            "spinlock_t\tnfsd_drc_lock;",
            "unsigned long\tnfsd_drc_max_mem;",
            "unsigned long\tnfsd_drc_mem_used;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_DRC_SIZE_SHIFT\t10\n\nspinlock_t\tnfsd_drc_lock;\nunsigned long\tnfsd_drc_max_mem;\nunsigned long\tnfsd_drc_mem_used;\n\nstatic void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_destroy",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_bind",
          "args": [
            "nn->nfsd_serv",
            "net"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_create_pooled",
          "args": [
            "&nfsd_program",
            "nfsd_max_blksize",
            "nfsd_last_thread",
            "nfsd",
            "THIS_MODULE"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reset_versions",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reset_versions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "330-349",
          "snippet": "void nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)",
            "#define NFSD_MINVERS    \t2",
            "#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)",
            "#define NFSD_ACL_MINVERS            2"
          ],
          "globals_used": [
            "extern struct svc_program\tnfsd_program;",
            "static struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n#define NFSD_MINVERS    \t2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n#define NFSD_ACL_MINVERS            2\n\nextern struct svc_program\tnfsd_program;\nstatic struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\n\nvoid nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_get_default_max_blksize",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_get_default_max_blksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "373-392",
          "snippet": "static int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t/*\n\t * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig\n\t * machines, but only uses 32K on 128M machines.  Bottom out at\n\t * 8K on 32M and smaller.  Of course, this is only a default.\n\t */\n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t/*\n\t * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig\n\t * machines, but only uses 32K on 128M machines.  Bottom out at\n\t * 8K on 32M and smaller.  Of course, this is only a default.\n\t */\n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_get",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&nfsd_mutex)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nextern struct svc_program\tnfsd_program;\n\nint nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t      nfsd_last_thread, nfsd, THIS_MODULE);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_get_default_max_blksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "373-392",
    "snippet": "static int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t/*\n\t * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig\n\t * machines, but only uses 32K on 128M machines.  Bottom out at\n\t * 8K on 32M and smaller.  Of course, this is only a default.\n\t */\n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "&i"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t/*\n\t * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig\n\t * machines, but only uses 32K on 128M machines.  Bottom out at\n\t * 8K on 32M and smaller.  Of course, this is only a default.\n\t */\n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}"
  },
  {
    "function_name": "set_max_drc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "363-371",
    "snippet": "static void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define NFSD_DRC_SIZE_SHIFT\t10"
    ],
    "globals_used": [
      "spinlock_t\tnfsd_drc_lock;",
      "unsigned long\tnfsd_drc_max_mem;",
      "unsigned long\tnfsd_drc_mem_used;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s nfsd_drc_max_mem %lu \\n\"",
            "__func__",
            "nfsd_drc_max_mem"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_buffer_pages",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_DRC_SIZE_SHIFT\t10\n\nspinlock_t\tnfsd_drc_lock;\nunsigned long\tnfsd_drc_max_mem;\nunsigned long\tnfsd_drc_mem_used;\n\nstatic void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}"
  },
  {
    "function_name": "nfsd_reset_versions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "330-349",
    "snippet": "void nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)",
      "#define NFSD_MINVERS    \t2",
      "#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)",
      "#define NFSD_ACL_MINVERS            2"
    ],
    "globals_used": [
      "extern struct svc_program\tnfsd_program;",
      "static struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n#define NFSD_MINVERS    \t2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n#define NFSD_ACL_MINVERS            2\n\nextern struct svc_program\tnfsd_program;\nstatic struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\n\nvoid nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}"
  },
  {
    "function_name": "nfsd_last_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "309-328",
    "snippet": "static void nfsd_last_thread(struct svc_serv *serv, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * write_ports can create the server without actually starting\n\t * any threads--if we get shut down before any threads are\n\t * started, then nfsd_last_thread will be run before any of this\n\t * other initialization has been done.\n\t */\n\tif (!nn->nfsd_net_up)\n\t\treturn;\n\tnfsd_shutdown_net(net);\n\n\tsvc_rpcb_cleanup(serv, net);\n\n\tprintk(KERN_WARNING \"nfsd: last server has exited, flushing export \"\n\t\t\t    \"cache\\n\");\n\tnfsd_export_flush(net);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_export_flush",
          "args": [
            "net"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_export_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1319-1326",
          "snippet": "void\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"nfsd: last server has exited, flushing export \"\n\t\t\t    \"cache\\n\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_rpcb_cleanup",
          "args": [
            "serv",
            "net"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_shutdown_net",
          "args": [
            "net"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_shutdown_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "296-307",
          "snippet": "static void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_last_thread(struct svc_serv *serv, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * write_ports can create the server without actually starting\n\t * any threads--if we get shut down before any threads are\n\t * started, then nfsd_last_thread will be run before any of this\n\t * other initialization has been done.\n\t */\n\tif (!nn->nfsd_net_up)\n\t\treturn;\n\tnfsd_shutdown_net(net);\n\n\tsvc_rpcb_cleanup(serv, net);\n\n\tprintk(KERN_WARNING \"nfsd: last server has exited, flushing export \"\n\t\t\t    \"cache\\n\");\n\tnfsd_export_flush(net);\n}"
  },
  {
    "function_name": "nfsd_shutdown_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "296-307",
    "snippet": "static void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_shutdown_generic",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_shutdown_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "239-246",
          "snippet": "static void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockd_down",
          "args": [
            "net"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "lockd_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc.c",
          "lines": "406-432",
          "snippet": "void\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}",
          "includes": [
            "#include \"procfs.h\"",
            "#include \"netns.h\"",
            "#include <linux/nfs.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <net/ip.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/types.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/smp.h>",
            "#include <linux/uio.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlmsvc_mutex);",
            "static unsigned int\t\tnlmsvc_users;",
            "static struct task_struct\t*nlmsvc_task;",
            "static struct svc_rqst\t\t*nlmsvc_rqst;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n#include <net/ip.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/types.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/smp.h>\n#include <linux/uio.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\nstatic struct task_struct\t*nlmsvc_task;\nstatic struct svc_rqst\t\t*nlmsvc_rqst;\n\nvoid\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_shutdown_net",
          "args": [
            "net"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_shutdown_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "133-133",
          "snippet": "static inline void nfs4_state_shutdown_net(struct net *net) { }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline void nfs4_state_shutdown_net(struct net *net) { }"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}"
  },
  {
    "function_name": "nfsd_startup_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "257-294",
    "snippet": "static int nfsd_startup_net(int nrservs, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic(nrservs);\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd() && !nn->lockd_up) {\n\t\tret = lockd_up(net);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = 1;\n\t}\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_shutdown_generic",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_shutdown_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "239-246",
          "snippet": "static void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockd_down",
          "args": [
            "net"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "lockd_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc.c",
          "lines": "406-432",
          "snippet": "void\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}",
          "includes": [
            "#include \"procfs.h\"",
            "#include \"netns.h\"",
            "#include <linux/nfs.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <net/ip.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/types.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/smp.h>",
            "#include <linux/uio.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlmsvc_mutex);",
            "static unsigned int\t\tnlmsvc_users;",
            "static struct task_struct\t*nlmsvc_task;",
            "static struct svc_rqst\t\t*nlmsvc_rqst;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n#include <net/ip.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/types.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/smp.h>\n#include <linux/uio.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\nstatic struct task_struct\t*nlmsvc_task;\nstatic struct svc_rqst\t\t*nlmsvc_rqst;\n\nvoid\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_rqst->rq_server, net);\n\tif (nlmsvc_users) {\n\t\tif (--nlmsvc_users)\n\t\t\tgoto out;\n\t} else {\n\t\tprintk(KERN_ERR \"lockd_down: no users! task=%p\\n\",\n\t\t\tnlmsvc_task);\n\t\tBUG();\n\t}\n\n\tif (!nlmsvc_task) {\n\t\tprintk(KERN_ERR \"lockd_down: no lockd running.\\n\");\n\t\tBUG();\n\t}\n\tkthread_stop(nlmsvc_task);\n\tdprintk(\"lockd_down: service stopped\\n\");\n\tsvc_exit_thread(nlmsvc_rqst);\n\tdprintk(\"lockd_down: service destroyed\\n\");\n\tnlmsvc_task = NULL;\n\tnlmsvc_rqst = NULL;\nout:\n\tmutex_unlock(&nlmsvc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_start_net",
          "args": [
            "net"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "131-131",
          "snippet": "static inline int nfs4_state_start_net(struct net *net) { return 0; }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline int nfs4_state_start_net(struct net *net) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "lockd_up",
          "args": [
            "net"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "lockd_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc.c",
          "lines": "365-400",
          "snippet": "int lockd_up(struct net *net)\n{\n\tstruct svc_serv *serv;\n\tint error;\n\n\tmutex_lock(&nlmsvc_mutex);\n\n\tserv = lockd_create_svc();\n\tif (IS_ERR(serv)) {\n\t\terror = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\terror = lockd_up_net(serv, net);\n\tif (error < 0)\n\t\tgoto err_net;\n\n\terror = lockd_start_svc(serv);\n\tif (error < 0)\n\t\tgoto err_start;\n\n\tnlmsvc_users++;\n\t/*\n\t * Note: svc_serv structures have an initial use count of 1,\n\t * so we exit through here on both success and failure.\n\t */\nerr_net:\n\tsvc_destroy(serv);\nerr_create:\n\tmutex_unlock(&nlmsvc_mutex);\n\treturn error;\n\nerr_start:\n\tlockd_down_net(serv, net);\n\tgoto err_net;\n}",
          "includes": [
            "#include \"procfs.h\"",
            "#include \"netns.h\"",
            "#include <linux/nfs.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <net/ip.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/types.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mutex.h>",
            "#include <linux/smp.h>",
            "#include <linux/uio.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlmsvc_mutex);",
            "static unsigned int\t\tnlmsvc_users;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n#include <net/ip.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/types.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/smp.h>\n#include <linux/uio.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\n\nint lockd_up(struct net *net)\n{\n\tstruct svc_serv *serv;\n\tint error;\n\n\tmutex_lock(&nlmsvc_mutex);\n\n\tserv = lockd_create_svc();\n\tif (IS_ERR(serv)) {\n\t\terror = PTR_ERR(serv);\n\t\tgoto err_create;\n\t}\n\n\terror = lockd_up_net(serv, net);\n\tif (error < 0)\n\t\tgoto err_net;\n\n\terror = lockd_start_svc(serv);\n\tif (error < 0)\n\t\tgoto err_start;\n\n\tnlmsvc_users++;\n\t/*\n\t * Note: svc_serv structures have an initial use count of 1,\n\t * so we exit through here on both success and failure.\n\t */\nerr_net:\n\tsvc_destroy(serv);\nerr_create:\n\tmutex_unlock(&nlmsvc_mutex);\n\treturn error;\n\nerr_start:\n\tlockd_down_net(serv, net);\n\tgoto err_net;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_needs_lockd",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_needs_lockd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "248-255",
          "snippet": "static bool nfsd_needs_lockd(void)\n{\n#if defined(CONFIG_NFSD_V3)\n\treturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\n#else\n\treturn (nfsd_versions[2] != NULL);\n#endif\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_version *nfsd_versions[NFSD_NRVERS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic struct svc_version *nfsd_versions[NFSD_NRVERS];\n\nstatic bool nfsd_needs_lockd(void)\n{\n#if defined(CONFIG_NFSD_V3)\n\treturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\n#else\n\treturn (nfsd_versions[2] != NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_init_socks",
          "args": [
            "net"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_init_socks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "188-207",
          "snippet": "static int nfsd_init_socks(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_init_socks(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_startup_generic",
          "args": [
            "nrservs"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_startup_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "211-237",
          "snippet": "static int nfsd_startup_generic(int nrservs)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\t/*\n\t * Readahead param cache - will no-op if it already exists.\n\t * (Note therefore results will be suboptimal if number of\n\t * threads is modified after nfsd start.)\n\t */\n\tret = nfsd_racache_init(2*nrservs);\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_racache;\n\treturn 0;\n\nout_racache:\n\tnfsd_racache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_startup_generic(int nrservs)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\t/*\n\t * Readahead param cache - will no-op if it already exists.\n\t * (Note therefore results will be suboptimal if number of\n\t * threads is modified after nfsd start.)\n\t */\n\tret = nfsd_racache_init(2*nrservs);\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_racache;\n\treturn 0;\n\nout_racache:\n\tnfsd_racache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_startup_net(int nrservs, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic(nrservs);\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd() && !nn->lockd_up) {\n\t\tret = lockd_up(net);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = 1;\n\t}\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_needs_lockd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "248-255",
    "snippet": "static bool nfsd_needs_lockd(void)\n{\n#if defined(CONFIG_NFSD_V3)\n\treturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\n#else\n\treturn (nfsd_versions[2] != NULL);\n#endif\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_version *nfsd_versions[NFSD_NRVERS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic struct svc_version *nfsd_versions[NFSD_NRVERS];\n\nstatic bool nfsd_needs_lockd(void)\n{\n#if defined(CONFIG_NFSD_V3)\n\treturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\n#else\n\treturn (nfsd_versions[2] != NULL);\n#endif\n}"
  },
  {
    "function_name": "nfsd_shutdown_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "239-246",
    "snippet": "static void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_racache_shutdown",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_racache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "2096-2113",
          "snippet": "void\nnfsd_racache_shutdown(void)\n{\n\tstruct raparms *raparm, *last_raparm;\n\tunsigned int i;\n\n\tdprintk(\"nfsd: freeing readahead buffers.\\n\");\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\traparm = raparm_hash[i].pb_head;\n\t\twhile(raparm) {\n\t\t\tlast_raparm = raparm;\n\t\t\traparm = raparm->p_next;\n\t\t\tkfree(last_raparm);\n\t\t}\n\t\traparm_hash[i].pb_head = NULL;\n\t}\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)"
          ],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nvoid\nnfsd_racache_shutdown(void)\n{\n\tstruct raparms *raparm, *last_raparm;\n\tunsigned int i;\n\n\tdprintk(\"nfsd: freeing readahead buffers.\\n\");\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\traparm = raparm_hash[i].pb_head;\n\t\twhile(raparm) {\n\t\t\tlast_raparm = raparm;\n\t\t\traparm = raparm->p_next;\n\t\t\tkfree(last_raparm);\n\t\t}\n\t\traparm_hash[i].pb_head = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_shutdown",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "132-132",
          "snippet": "static inline void nfs4_state_shutdown(void) { }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline void nfs4_state_shutdown(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}"
  },
  {
    "function_name": "nfsd_startup_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "211-237",
    "snippet": "static int nfsd_startup_generic(int nrservs)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\t/*\n\t * Readahead param cache - will no-op if it already exists.\n\t * (Note therefore results will be suboptimal if number of\n\t * threads is modified after nfsd start.)\n\t */\n\tret = nfsd_racache_init(2*nrservs);\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_racache;\n\treturn 0;\n\nout_racache:\n\tnfsd_racache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_racache_shutdown",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_racache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "2096-2113",
          "snippet": "void\nnfsd_racache_shutdown(void)\n{\n\tstruct raparms *raparm, *last_raparm;\n\tunsigned int i;\n\n\tdprintk(\"nfsd: freeing readahead buffers.\\n\");\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\traparm = raparm_hash[i].pb_head;\n\t\twhile(raparm) {\n\t\t\tlast_raparm = raparm;\n\t\t\traparm = raparm->p_next;\n\t\t\tkfree(last_raparm);\n\t\t}\n\t\traparm_hash[i].pb_head = NULL;\n\t}\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)"
          ],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nvoid\nnfsd_racache_shutdown(void)\n{\n\tstruct raparms *raparm, *last_raparm;\n\tunsigned int i;\n\n\tdprintk(\"nfsd: freeing readahead buffers.\\n\");\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\traparm = raparm_hash[i].pb_head;\n\t\twhile(raparm) {\n\t\t\tlast_raparm = raparm;\n\t\t\traparm = raparm->p_next;\n\t\t\tkfree(last_raparm);\n\t\t}\n\t\traparm_hash[i].pb_head = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_start",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "130-130",
          "snippet": "static inline int nfs4_state_start(void) { return 0; }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline int nfs4_state_start(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_racache_init",
          "args": [
            "2*nrservs"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_racache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "2117-2154",
          "snippet": "int\nnfsd_racache_init(int cache_size)\n{\n\tint\ti;\n\tint\tj = 0;\n\tint\tnperbucket;\n\tstruct raparms **raparm = NULL;\n\n\n\tif (raparm_hash[0].pb_head)\n\t\treturn 0;\n\tnperbucket = DIV_ROUND_UP(cache_size, RAPARM_HASH_SIZE);\n\tnperbucket = max(2, nperbucket);\n\tcache_size = nperbucket * RAPARM_HASH_SIZE;\n\n\tdprintk(\"nfsd: allocating %d readahead buffers.\\n\", cache_size);\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\tspin_lock_init(&raparm_hash[i].pb_lock);\n\n\t\traparm = &raparm_hash[i].pb_head;\n\t\tfor (j = 0; j < nperbucket; j++) {\n\t\t\t*raparm = kzalloc(sizeof(struct raparms), GFP_KERNEL);\n\t\t\tif (!*raparm)\n\t\t\t\tgoto out_nomem;\n\t\t\traparm = &(*raparm)->p_next;\n\t\t}\n\t\t*raparm = NULL;\n\t}\n\n\tnfsdstats.ra_size = cache_size;\n\treturn 0;\n\nout_nomem:\n\tdprintk(\"nfsd: kmalloc failed, freeing readahead buffers\\n\");\n\tnfsd_racache_shutdown();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)"
          ],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nint\nnfsd_racache_init(int cache_size)\n{\n\tint\ti;\n\tint\tj = 0;\n\tint\tnperbucket;\n\tstruct raparms **raparm = NULL;\n\n\n\tif (raparm_hash[0].pb_head)\n\t\treturn 0;\n\tnperbucket = DIV_ROUND_UP(cache_size, RAPARM_HASH_SIZE);\n\tnperbucket = max(2, nperbucket);\n\tcache_size = nperbucket * RAPARM_HASH_SIZE;\n\n\tdprintk(\"nfsd: allocating %d readahead buffers.\\n\", cache_size);\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\tspin_lock_init(&raparm_hash[i].pb_lock);\n\n\t\traparm = &raparm_hash[i].pb_head;\n\t\tfor (j = 0; j < nperbucket; j++) {\n\t\t\t*raparm = kzalloc(sizeof(struct raparms), GFP_KERNEL);\n\t\t\tif (!*raparm)\n\t\t\t\tgoto out_nomem;\n\t\t\traparm = &(*raparm)->p_next;\n\t\t}\n\t\t*raparm = NULL;\n\t}\n\n\tnfsdstats.ra_size = cache_size;\n\treturn 0;\n\nout_nomem:\n\tdprintk(\"nfsd: kmalloc failed, freeing readahead buffers\\n\");\n\tnfsd_racache_shutdown();\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_startup_generic(int nrservs)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\t/*\n\t * Readahead param cache - will no-op if it already exists.\n\t * (Note therefore results will be suboptimal if number of\n\t * threads is modified after nfsd start.)\n\t */\n\tret = nfsd_racache_init(2*nrservs);\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_racache;\n\treturn 0;\n\nout_racache:\n\tnfsd_racache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_init_socks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "188-207",
    "snippet": "static int nfsd_init_socks(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "nn->nfsd_serv",
            "\"tcp\"",
            "net",
            "PF_INET",
            "NFS_PORT",
            "SVC_SOCK_DEFAULTS"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "nn->nfsd_serv",
            "\"udp\"",
            "net",
            "PF_INET",
            "NFS_PORT",
            "SVC_SOCK_DEFAULTS"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->nfsd_serv->sv_permsocks"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_init_socks(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_nrthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "176-186",
    "snippet": "int nfsd_nrthreads(struct net *net)\n{\n\tint rv = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv)\n\t\trv = nn->nfsd_serv->sv_nrthreads;\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_nrthreads(struct net *net)\n{\n\tint rv = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv)\n\t\trv = nn->nfsd_serv->sv_nrthreads;\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
  },
  {
    "function_name": "nfsd_minorversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "152-169",
    "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_vers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
    "lines": "125-150",
    "snippet": "int nfsd_vers(int vers, enum vers_op change)\n{\n\tif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\n\t\treturn 0;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_versions[vers] = nfsd_version[vers];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = nfsd_acl_version[vers];\n#endif\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_versions[vers] = NULL;\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = NULL;\n#endif\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_versions[vers] != NULL;\n\tcase NFSD_AVAIL:\n\t\treturn nfsd_version[vers] != NULL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)",
      "#define NFSD_MINVERS    \t2",
      "#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)"
    ],
    "globals_used": [
      "static struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};",
      "static struct svc_version *nfsd_versions[NFSD_NRVERS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n#define NFSD_MINVERS    \t2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n\nstatic struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\nstatic struct svc_version *nfsd_versions[NFSD_NRVERS];\n\nint nfsd_vers(int vers, enum vers_op change)\n{\n\tif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\n\t\treturn 0;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_versions[vers] = nfsd_version[vers];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = nfsd_acl_version[vers];\n#endif\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_versions[vers] = NULL;\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = NULL;\n#endif\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_versions[vers] != NULL;\n\tcase NFSD_AVAIL:\n\t\treturn nfsd_version[vers] != NULL;\n\t}\n\treturn 0;\n}"
  }
]