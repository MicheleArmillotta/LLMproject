[
  {
    "function_name": "xfs_dir2_sf_toino8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "1073-1142",
    "snippet": "static void\nxfs_dir2_sf_toino8(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino8(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 0);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size (nb: entry count + 1 for parent)\n\t */\n\tnewsize =\n\t\toldsize +\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 1;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE | XFS_ILOG_DDATA"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "buf"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ftype",
          "args": [
            "sfep",
            "dp->d_ops->sf_get_ftype(oldsfep)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ftype",
          "args": [
            "oldsfep"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ino",
          "args": [
            "sfp",
            "sfep",
            "dp->d_ops->sf_get_ino(oldsfp, oldsfep)"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ino",
          "args": [
            "oldsfp",
            "oldsfep"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfep->name",
            "oldsfep->name",
            "sfep->namelen"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "oldsfp",
            "oldsfep"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "oldsfp"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_parent_ino",
          "args": [
            "sfp",
            "dp->d_ops->sf_get_parent_ino(oldsfp)"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_parent_ino",
          "args": [
            "oldsfp"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "newsize",
            "XFS_DATA_FORK"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "oldsfp",
            "oldsize"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldsfp->i8count == 0"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "oldsize",
            "KM_SLEEP"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_sf_toino8",
          "args": [
            "args"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_toino8(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino8(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 0);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size (nb: entry count + 1 for parent)\n\t */\n\tnewsize =\n\t\toldsize +\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 1;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}"
  },
  {
    "function_name": "xfs_dir2_sf_toino4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "997-1066",
    "snippet": "static void\nxfs_dir2_sf_toino4(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino4(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 1);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size.\n\t */\n\tnewsize =\n\t\toldsize -\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 0;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE | XFS_ILOG_DDATA"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "buf"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ftype",
          "args": [
            "sfep",
            "dp->d_ops->sf_get_ftype(oldsfep)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ftype",
          "args": [
            "oldsfep"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ino",
          "args": [
            "sfp",
            "sfep",
            "dp->d_ops->sf_get_ino(oldsfp, oldsfep)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ino",
          "args": [
            "oldsfp",
            "oldsfep"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfep->name",
            "oldsfep->name",
            "sfep->namelen"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "oldsfp",
            "oldsfep"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "oldsfp"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_parent_ino",
          "args": [
            "sfp",
            "dp->d_ops->sf_get_parent_ino(oldsfp)"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_parent_ino",
          "args": [
            "oldsfp"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "newsize",
            "XFS_DATA_FORK"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "oldsfp",
            "oldsize"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldsfp->i8count == 1"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "oldsize",
            "KM_SLEEP"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_sf_toino4",
          "args": [
            "args"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_toino4(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino4(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 1);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size.\n\t */\n\tnewsize =\n\t\toldsize -\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 0;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}"
  },
  {
    "function_name": "xfs_dir2_sf_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "868-991",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\txfs_ino_t\t\tino=0;\t\t/* entry old inode number */\n\tint\t\t\ti8elevated;\t/* sf_toino8 set i8count=1 */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\ttrace_xfs_dir2_sf_replace(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the shortform directory is way too small.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\n\t/*\n\t * New inode number is large, and need to convert to 8-byte inodes.\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\tint\terror;\t\t\t/* error return value */\n\t\tint\tnewsize;\t\t/* new inode size */\n\n\t\tnewsize =\n\t\t\tdp->i_df.if_bytes +\n\t\t\t(sfp->count + 1) *\n\t\t\t((uint)sizeof(xfs_dir2_ino8_t) -\n\t\t\t (uint)sizeof(xfs_dir2_ino4_t));\n\t\t/*\n\t\t * Won't fit as shortform, convert to block then do replace.\n\t\t */\n\t\tif (newsize > XFS_IFORK_DSIZE(dp)) {\n\t\t\terror = xfs_dir2_sf_to_block(args);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\treturn xfs_dir2_block_replace(args);\n\t\t}\n\t\t/*\n\t\t * Still fits, convert to 8-byte now.\n\t\t */\n\t\txfs_dir2_sf_toino8(args);\n\t\ti8elevated = 1;\n\t\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t} else\n\t\ti8elevated = 0;\n\n\tASSERT(args->namelen != 1 || args->name[0] != '.');\n\t/*\n\t * Replace ..'s entry.\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\t\tASSERT(args->inumber != ino);\n\t\tdp->d_ops->sf_put_parent_ino(sfp, args->inumber);\n\t}\n\t/*\n\t * Normal entry, look for the name.\n\t */\n\telse {\n\t\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t\tif (xfs_da_compname(args, sfep->name, sfep->namelen) ==\n\t\t\t\t\t\t\t\tXFS_CMP_EXACT) {\n\t\t\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\t\tASSERT(args->inumber != ino);\n\t\t\t\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\t\t\t\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Didn't find it.\n\t\t */\n\t\tif (i == sfp->count) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\tif (i8elevated)\n\t\t\t\txfs_dir2_sf_toino4(args);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * See if the old number was large, the new number is small.\n\t */\n\tif (ino > XFS_DIR2_MAX_SHORT_INUM &&\n\t    args->inumber <= XFS_DIR2_MAX_SHORT_INUM) {\n\t\t/*\n\t\t * And the old count was one, so need to convert to small.\n\t\t */\n\t\tif (sfp->i8count == 1)\n\t\t\txfs_dir2_sf_toino4(args);\n\t\telse\n\t\t\tsfp->i8count--;\n\t}\n\t/*\n\t * See if the old number was small, the new number is large.\n\t */\n\tif (ino <= XFS_DIR2_MAX_SHORT_INUM &&\n\t    args->inumber > XFS_DIR2_MAX_SHORT_INUM) {\n\t\t/*\n\t\t * add to the i8count unless we just converted to 8-byte\n\t\t * inodes (which does an implied i8count = 1)\n\t\t */\n\t\tASSERT(sfp->i8count != 0);\n\t\tif (!i8elevated)\n\t\t\tsfp->i8count++;\n\t}\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_DDATA);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_DDATA"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_check",
          "args": [
            "args"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "601-636",
          "snippet": "static void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sfp->i8count != 0"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_toino4",
          "args": [
            "args"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_toino4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "997-1066",
          "snippet": "static void\nxfs_dir2_sf_toino4(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino4(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 1);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size.\n\t */\n\tnewsize =\n\t\toldsize -\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 0;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_toino4(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino4(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 1);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size.\n\t */\n\tnewsize =\n\t\toldsize -\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 0;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->op_flags & XFS_DA_OP_OKNOENT"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ftype",
          "args": [
            "sfep",
            "args->filetype"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ino",
          "args": [
            "sfp",
            "sfep",
            "args->inumber"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->inumber != ino"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ino",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_compname",
          "args": [
            "args",
            "sfep->name",
            "sfep->namelen"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_compname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1972-1980",
          "snippet": "enum xfs_dacmp\nxfs_da_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\treturn (args->namelen == len && memcmp(args->name, name, len) == 0) ?\n\t\t\t\t\tXFS_CMP_EXACT : XFS_CMP_DIFFERENT;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nenum xfs_dacmp\nxfs_da_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\treturn (args->namelen == len && memcmp(args->name, name, len) == 0) ?\n\t\t\t\t\tXFS_CMP_EXACT : XFS_CMP_DIFFERENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "sfp"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_parent_ino",
          "args": [
            "sfp",
            "args->inumber"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->inumber != ino"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_parent_ino",
          "args": [
            "sfp"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->namelen != 1 || args->name[0] != '.'"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_toino8",
          "args": [
            "args"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_toino8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "1073-1142",
          "snippet": "static void\nxfs_dir2_sf_toino8(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino8(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 0);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size (nb: entry count + 1 for parent)\n\t */\n\tnewsize =\n\t\toldsize +\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 1;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_toino8(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino8(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 0);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size (nb: entry count + 1 for parent)\n\t */\n\tnewsize =\n\t\toldsize +\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 1;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_replace",
          "args": [
            "args"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "834-875",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_replace(args);\n\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_replace(args);\n\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_to_block",
          "args": [
            "args"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "1042-1254",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_to_block(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_dir2_db_t\t\tblkno;\t\t/* dir-relative block # (0) */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tdummy;\t\t/* trash */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tint\t\t\tendoffset;\t/* end of data objects */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to scan block freespc */\n\tint\t\t\tnewoffset;\t/* offset from current entry */\n\tint\t\t\toffset;\t\t/* target block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* sf entry pointer */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old shortform header  */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform header  */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_name\t\tname;\n\tstruct xfs_ifork\t*ifp;\n\n\ttrace_xfs_dir2_sf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tifp = XFS_IFORK_PTR(dp, XFS_DATA_FORK);\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t/*\n\t * Bomb out if the shortform directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn -EIO;\n\t}\n\n\toldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;\n\n\tASSERT(ifp->if_bytes == dp->i_d.di_size);\n\tASSERT(ifp->if_u1.if_data != NULL);\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count));\n\tASSERT(dp->i_d.di_nextents == 0);\n\n\t/*\n\t * Copy the directory into a temporary buffer.\n\t * Then pitch the incore inode data so we can make extents.\n\t */\n\tsfp = kmem_alloc(ifp->if_bytes, KM_SLEEP);\n\tmemcpy(sfp, oldsfp, ifp->if_bytes);\n\n\txfs_idata_realloc(dp, -ifp->if_bytes, XFS_DATA_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_DATA_FORK);\n\tdp->i_d.di_size = 0;\n\n\t/*\n\t * Add block 0 to the inode.\n\t */\n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, &blkno);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the data block, then convert it to block format.\n\t */\n\terror = xfs_dir3_data_init(args, blkno, &bp);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\txfs_dir3_block_init(mp, tp, bp, dp);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Compute size of block \"tail\" area.\n\t */\n\ti = (uint)sizeof(*btp) +\n\t    (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t);\n\t/*\n\t * The whole thing is initialized to free by the init routine.\n\t * Say we're using the leaf and tail area.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_use_free(args, bp, dup, args->geo->blksize - i,\n\t\t\t       i, &needlog, &needscan);\n\tASSERT(needscan == 0);\n\t/*\n\t * Fill in the tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(sfp->count + 2);\t/* ., .. */\n\tbtp->stale = 0;\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tendoffset = (uint)((char *)blp - (char *)hdr);\n\t/*\n\t * Remove the freespace, we'll manage it.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\tbe16_to_cpu(dup->length), &needlog, &needscan);\n\t/*\n\t * Create entry for .\n\t */\n\tdep = dp->d_ops->data_dot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->i_ino);\n\tdep->namelen = 1;\n\tdep->name[0] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);\n\tblp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\t/*\n\t * Create entry for ..\n\t */\n\tdep = dp->d_ops->data_dotdot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));\n\tdep->namelen = 2;\n\tdep->name[0] = dep->name[1] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);\n\tblp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\toffset = dp->d_ops->data_first_offset;\n\t/*\n\t * Loop over existing entries, stuff them in.\n\t */\n\ti = 0;\n\tif (!sfp->count)\n\t\tsfep = NULL;\n\telse\n\t\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Need to preserve the existing offset values in the sf directory.\n\t * Insert holes (unused entries) where necessary.\n\t */\n\twhile (offset < endoffset) {\n\t\t/*\n\t\t * sfep is null when we reach the end of the list.\n\t\t */\n\t\tif (sfep == NULL)\n\t\t\tnewoffset = endoffset;\n\t\telse\n\t\t\tnewoffset = xfs_dir2_sf_get_offset(sfep);\n\t\t/*\n\t\t * There should be a hole here, make one.\n\t\t */\n\t\tif (offset < newoffset) {\n\t\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\t\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\t\tdup->length = cpu_to_be16(newoffset - offset);\n\t\t\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16(\n\t\t\t\t((char *)dup - (char *)hdr));\n\t\t\txfs_dir2_data_log_unused(args, bp, dup);\n\t\t\txfs_dir2_data_freeinsert(hdr,\n\t\t\t\t\t\t dp->d_ops->data_bestfree_p(hdr),\n\t\t\t\t\t\t dup, &dummy);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Copy a real entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);\n\t\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));\n\t\tdep->namelen = sfep->namelen;\n\t\tdp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));\n\t\tmemcpy(dep->name, sfep->name, dep->namelen);\n\t\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t\txfs_dir2_data_log_entry(args, bp, dep);\n\t\tname.name = sfep->name;\n\t\tname.len = sfep->namelen;\n\t\tblp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name));\n\t\tblp[2 + i].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr));\n\t\toffset = (int)((char *)(tagp + 1) - (char *)hdr);\n\t\tif (++i == sfp->count)\n\t\t\tsfep = NULL;\n\t\telse\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/* Done with the temporary buffer */\n\tkmem_free(sfp);\n\t/*\n\t * Sort the leaf entries by hash value.\n\t */\n\txfs_sort(blp, be32_to_cpu(btp->count), sizeof(*blp), xfs_dir2_block_sort);\n\t/*\n\t * Log the leaf entry area and tail.\n\t * Already logged the header in data_init, ignore needlog.\n\t */\n\tASSERT(needscan == 0);\n\txfs_dir2_block_log_leaf(tp, bp, 0, be32_to_cpu(btp->count) - 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
            "static xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nstatic xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_to_block(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_dir2_db_t\t\tblkno;\t\t/* dir-relative block # (0) */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tdummy;\t\t/* trash */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tint\t\t\tendoffset;\t/* end of data objects */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to scan block freespc */\n\tint\t\t\tnewoffset;\t/* offset from current entry */\n\tint\t\t\toffset;\t\t/* target block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* sf entry pointer */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old shortform header  */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform header  */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_name\t\tname;\n\tstruct xfs_ifork\t*ifp;\n\n\ttrace_xfs_dir2_sf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tifp = XFS_IFORK_PTR(dp, XFS_DATA_FORK);\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t/*\n\t * Bomb out if the shortform directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn -EIO;\n\t}\n\n\toldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;\n\n\tASSERT(ifp->if_bytes == dp->i_d.di_size);\n\tASSERT(ifp->if_u1.if_data != NULL);\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count));\n\tASSERT(dp->i_d.di_nextents == 0);\n\n\t/*\n\t * Copy the directory into a temporary buffer.\n\t * Then pitch the incore inode data so we can make extents.\n\t */\n\tsfp = kmem_alloc(ifp->if_bytes, KM_SLEEP);\n\tmemcpy(sfp, oldsfp, ifp->if_bytes);\n\n\txfs_idata_realloc(dp, -ifp->if_bytes, XFS_DATA_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_DATA_FORK);\n\tdp->i_d.di_size = 0;\n\n\t/*\n\t * Add block 0 to the inode.\n\t */\n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, &blkno);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the data block, then convert it to block format.\n\t */\n\terror = xfs_dir3_data_init(args, blkno, &bp);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\txfs_dir3_block_init(mp, tp, bp, dp);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Compute size of block \"tail\" area.\n\t */\n\ti = (uint)sizeof(*btp) +\n\t    (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t);\n\t/*\n\t * The whole thing is initialized to free by the init routine.\n\t * Say we're using the leaf and tail area.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_use_free(args, bp, dup, args->geo->blksize - i,\n\t\t\t       i, &needlog, &needscan);\n\tASSERT(needscan == 0);\n\t/*\n\t * Fill in the tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(sfp->count + 2);\t/* ., .. */\n\tbtp->stale = 0;\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tendoffset = (uint)((char *)blp - (char *)hdr);\n\t/*\n\t * Remove the freespace, we'll manage it.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\tbe16_to_cpu(dup->length), &needlog, &needscan);\n\t/*\n\t * Create entry for .\n\t */\n\tdep = dp->d_ops->data_dot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->i_ino);\n\tdep->namelen = 1;\n\tdep->name[0] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);\n\tblp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\t/*\n\t * Create entry for ..\n\t */\n\tdep = dp->d_ops->data_dotdot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));\n\tdep->namelen = 2;\n\tdep->name[0] = dep->name[1] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);\n\tblp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\toffset = dp->d_ops->data_first_offset;\n\t/*\n\t * Loop over existing entries, stuff them in.\n\t */\n\ti = 0;\n\tif (!sfp->count)\n\t\tsfep = NULL;\n\telse\n\t\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Need to preserve the existing offset values in the sf directory.\n\t * Insert holes (unused entries) where necessary.\n\t */\n\twhile (offset < endoffset) {\n\t\t/*\n\t\t * sfep is null when we reach the end of the list.\n\t\t */\n\t\tif (sfep == NULL)\n\t\t\tnewoffset = endoffset;\n\t\telse\n\t\t\tnewoffset = xfs_dir2_sf_get_offset(sfep);\n\t\t/*\n\t\t * There should be a hole here, make one.\n\t\t */\n\t\tif (offset < newoffset) {\n\t\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\t\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\t\tdup->length = cpu_to_be16(newoffset - offset);\n\t\t\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16(\n\t\t\t\t((char *)dup - (char *)hdr));\n\t\t\txfs_dir2_data_log_unused(args, bp, dup);\n\t\t\txfs_dir2_data_freeinsert(hdr,\n\t\t\t\t\t\t dp->d_ops->data_bestfree_p(hdr),\n\t\t\t\t\t\t dup, &dummy);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Copy a real entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);\n\t\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));\n\t\tdep->namelen = sfep->namelen;\n\t\tdp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));\n\t\tmemcpy(dep->name, sfep->name, dep->namelen);\n\t\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t\txfs_dir2_data_log_entry(args, bp, dep);\n\t\tname.name = sfep->name;\n\t\tname.len = sfep->namelen;\n\t\tblp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name));\n\t\tblp[2 + i].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr));\n\t\toffset = (int)((char *)(tagp + 1) - (char *)hdr);\n\t\tif (++i == sfp->count)\n\t\t\tsfep = NULL;\n\t\telse\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/* Done with the temporary buffer */\n\tkmem_free(sfp);\n\t/*\n\t * Sort the leaf entries by hash value.\n\t */\n\txfs_sort(blp, be32_to_cpu(btp->count), sizeof(*blp), xfs_dir2_block_sort);\n\t/*\n\t * Log the leaf entry area and tail.\n\t * Already logged the header in data_init, ignore needlog.\n\t */\n\tASSERT(needscan == 0);\n\txfs_dir2_block_log_leaf(tp, bp, 0, be32_to_cpu(btp->count) - 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "dp"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count)"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "sfp->i8count"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_u1.if_data != NULL"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_bytes == dp->i_d.di_size"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(dp->i_mount)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_flags & XFS_IFINLINE"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_sf_replace",
          "args": [
            "args"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\txfs_ino_t\t\tino=0;\t\t/* entry old inode number */\n\tint\t\t\ti8elevated;\t/* sf_toino8 set i8count=1 */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\ttrace_xfs_dir2_sf_replace(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the shortform directory is way too small.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\n\t/*\n\t * New inode number is large, and need to convert to 8-byte inodes.\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\tint\terror;\t\t\t/* error return value */\n\t\tint\tnewsize;\t\t/* new inode size */\n\n\t\tnewsize =\n\t\t\tdp->i_df.if_bytes +\n\t\t\t(sfp->count + 1) *\n\t\t\t((uint)sizeof(xfs_dir2_ino8_t) -\n\t\t\t (uint)sizeof(xfs_dir2_ino4_t));\n\t\t/*\n\t\t * Won't fit as shortform, convert to block then do replace.\n\t\t */\n\t\tif (newsize > XFS_IFORK_DSIZE(dp)) {\n\t\t\terror = xfs_dir2_sf_to_block(args);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\treturn xfs_dir2_block_replace(args);\n\t\t}\n\t\t/*\n\t\t * Still fits, convert to 8-byte now.\n\t\t */\n\t\txfs_dir2_sf_toino8(args);\n\t\ti8elevated = 1;\n\t\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t} else\n\t\ti8elevated = 0;\n\n\tASSERT(args->namelen != 1 || args->name[0] != '.');\n\t/*\n\t * Replace ..'s entry.\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\t\tASSERT(args->inumber != ino);\n\t\tdp->d_ops->sf_put_parent_ino(sfp, args->inumber);\n\t}\n\t/*\n\t * Normal entry, look for the name.\n\t */\n\telse {\n\t\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t\tif (xfs_da_compname(args, sfep->name, sfep->namelen) ==\n\t\t\t\t\t\t\t\tXFS_CMP_EXACT) {\n\t\t\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\t\tASSERT(args->inumber != ino);\n\t\t\t\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\t\t\t\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Didn't find it.\n\t\t */\n\t\tif (i == sfp->count) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\tif (i8elevated)\n\t\t\t\txfs_dir2_sf_toino4(args);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * See if the old number was large, the new number is small.\n\t */\n\tif (ino > XFS_DIR2_MAX_SHORT_INUM &&\n\t    args->inumber <= XFS_DIR2_MAX_SHORT_INUM) {\n\t\t/*\n\t\t * And the old count was one, so need to convert to small.\n\t\t */\n\t\tif (sfp->i8count == 1)\n\t\t\txfs_dir2_sf_toino4(args);\n\t\telse\n\t\t\tsfp->i8count--;\n\t}\n\t/*\n\t * See if the old number was small, the new number is large.\n\t */\n\tif (ino <= XFS_DIR2_MAX_SHORT_INUM &&\n\t    args->inumber > XFS_DIR2_MAX_SHORT_INUM) {\n\t\t/*\n\t\t * add to the i8count unless we just converted to 8-byte\n\t\t * inodes (which does an implied i8count = 1)\n\t\t */\n\t\tASSERT(sfp->i8count != 0);\n\t\tif (!i8elevated)\n\t\t\tsfp->i8count++;\n\t}\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_DDATA);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_sf_removename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "781-863",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_removename(\n\txfs_da_args_t\t\t*args)\n{\n\tint\t\t\tbyteoff;\t/* offset of removed entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tentsize;\t/* this entry's size */\n\tint\t\t\ti;\t\t/* shortform entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\ttrace_xfs_dir2_sf_removename(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\toldsize = (int)dp->i_d.di_size;\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (oldsize < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == oldsize);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsize >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Loop over the old directory entries.\n\t * Find the one we're deleting.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tif (xfs_da_compname(args, sfep->name, sfep->namelen) ==\n\t\t\t\t\t\t\t\tXFS_CMP_EXACT) {\n\t\t\tASSERT(dp->d_ops->sf_get_ino(sfp, sfep) ==\n\t\t\t       args->inumber);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find it.\n\t */\n\tif (i == sfp->count)\n\t\treturn -ENOENT;\n\t/*\n\t * Calculate sizes.\n\t */\n\tbyteoff = (int)((char *)sfep - (char *)sfp);\n\tentsize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tnewsize = oldsize - entsize;\n\t/*\n\t * Copy the part if any after the removed entry, sliding it down.\n\t */\n\tif (byteoff + entsize < oldsize)\n\t\tmemmove((char *)sfp + byteoff, (char *)sfp + byteoff + entsize,\n\t\t\toldsize - (byteoff + entsize));\n\t/*\n\t * Fix up the header and file size.\n\t */\n\tsfp->count--;\n\tdp->i_d.di_size = newsize;\n\t/*\n\t * Reallocate, making it smaller.\n\t */\n\txfs_idata_realloc(dp, newsize - oldsize, XFS_DATA_FORK);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Are we changing inode number size?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM) {\n\t\tif (sfp->i8count == 1)\n\t\t\txfs_dir2_sf_toino4(args);\n\t\telse\n\t\t\tsfp->i8count--;\n\t}\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE | XFS_ILOG_DDATA"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_check",
          "args": [
            "args"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "601-636",
          "snippet": "static void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_toino4",
          "args": [
            "args"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_toino4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "997-1066",
          "snippet": "static void\nxfs_dir2_sf_toino4(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino4(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 1);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size.\n\t */\n\tnewsize =\n\t\toldsize -\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 0;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_toino4(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino4(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 1);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size.\n\t */\n\tnewsize =\n\t\toldsize -\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 0;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "newsize - oldsize",
            "XFS_DATA_FORK"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *)sfp + byteoff",
            "(char *)sfp + byteoff + entsize",
            "oldsize - (byteoff + entsize)"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_entsize",
          "args": [
            "sfp",
            "args->namelen"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->d_ops->sf_get_ino(sfp, sfep) ==\n\t\t\t       args->inumber"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ino",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da_compname",
          "args": [
            "args",
            "sfep->name",
            "sfep->namelen"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_compname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1972-1980",
          "snippet": "enum xfs_dacmp\nxfs_da_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\treturn (args->namelen == len && memcmp(args->name, name, len) == 0) ?\n\t\t\t\t\tXFS_CMP_EXACT : XFS_CMP_DIFFERENT;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nenum xfs_dacmp\nxfs_da_compname(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\treturn (args->namelen == len && memcmp(args->name, name, len) == 0) ?\n\t\t\t\t\tXFS_CMP_EXACT : XFS_CMP_DIFFERENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "sfp"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldsize >= xfs_dir2_sf_hdr_size(sfp->i8count)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "sfp->i8count"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_u1.if_data != NULL"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_bytes == oldsize"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(dp->i_mount)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_flags & XFS_IFINLINE"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_sf_removename",
          "args": [
            "args"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_removename(\n\txfs_da_args_t\t\t*args)\n{\n\tint\t\t\tbyteoff;\t/* offset of removed entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tentsize;\t/* this entry's size */\n\tint\t\t\ti;\t\t/* shortform entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\ttrace_xfs_dir2_sf_removename(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\toldsize = (int)dp->i_d.di_size;\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (oldsize < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == oldsize);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsize >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Loop over the old directory entries.\n\t * Find the one we're deleting.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tif (xfs_da_compname(args, sfep->name, sfep->namelen) ==\n\t\t\t\t\t\t\t\tXFS_CMP_EXACT) {\n\t\t\tASSERT(dp->d_ops->sf_get_ino(sfp, sfep) ==\n\t\t\t       args->inumber);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find it.\n\t */\n\tif (i == sfp->count)\n\t\treturn -ENOENT;\n\t/*\n\t * Calculate sizes.\n\t */\n\tbyteoff = (int)((char *)sfep - (char *)sfp);\n\tentsize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tnewsize = oldsize - entsize;\n\t/*\n\t * Copy the part if any after the removed entry, sliding it down.\n\t */\n\tif (byteoff + entsize < oldsize)\n\t\tmemmove((char *)sfp + byteoff, (char *)sfp + byteoff + entsize,\n\t\t\toldsize - (byteoff + entsize));\n\t/*\n\t * Fix up the header and file size.\n\t */\n\tsfp->count--;\n\tdp->i_d.di_size = newsize;\n\t/*\n\t * Reallocate, making it smaller.\n\t */\n\txfs_idata_realloc(dp, newsize - oldsize, XFS_DATA_FORK);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Are we changing inode number size?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM) {\n\t\tif (sfp->i8count == 1)\n\t\t\txfs_dir2_sf_toino4(args);\n\t\telse\n\t\t\tsfp->i8count--;\n\t}\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_sf_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "696-776",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\terror;\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\txfs_dir2_sf_entry_t\t*ci_sfep;\t/* case-insens. entry */\n\n\ttrace_xfs_dir2_sf_lookup(args);\n\n\txfs_dir2_sf_check(args);\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Special case for .\n\t */\n\tif (args->namelen == 1 && args->name[0] == '.') {\n\t\targs->inumber = dp->i_ino;\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Special case for ..\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\targs->inumber = dp->d_ops->sf_get_parent_ino(sfp);\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Loop over all the entries trying to match ours.\n\t */\n\tci_sfep = NULL;\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the inode\n\t\t * number. If it's the first case-insensitive match, store the\n\t\t * inode number and continue looking for an exact match.\n\t\t */\n\t\tcmp = dp->i_mount->m_dirnameops->compname(args, sfep->name,\n\t\t\t\t\t\t\t\tsfep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\targs->filetype = dp->d_ops->sf_get_ftype(sfep);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t\tci_sfep = sfep;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was not found, return -ENOENT.\n\t */\n\tif (!ci_sfep)\n\t\treturn -ENOENT;\n\t/* otherwise process the CI match as required by the caller */\n\terror = xfs_dir_cilookup_result(args, ci_sfep->name, ci_sfep->namelen);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir_cilookup_result",
          "args": [
            "args",
            "ci_sfep->name",
            "ci_sfep->namelen"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_cilookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "327-346",
          "snippet": "int\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->op_flags & XFS_DA_OP_OKNOENT"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ftype",
          "args": [
            "sfep"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ino",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->i_mount->m_dirnameops->compname",
          "args": [
            "args",
            "sfep->name",
            "sfep->namelen"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "sfp"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_parent_ino",
          "args": [
            "sfp"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "sfp->i8count"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_u1.if_data != NULL"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_bytes == dp->i_d.di_size"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(dp->i_mount)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_flags & XFS_IFINLINE"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_check",
          "args": [
            "args"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "601-636",
          "snippet": "static void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_sf_lookup",
          "args": [
            "args"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\terror;\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\txfs_dir2_sf_entry_t\t*ci_sfep;\t/* case-insens. entry */\n\n\ttrace_xfs_dir2_sf_lookup(args);\n\n\txfs_dir2_sf_check(args);\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Special case for .\n\t */\n\tif (args->namelen == 1 && args->name[0] == '.') {\n\t\targs->inumber = dp->i_ino;\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Special case for ..\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\targs->inumber = dp->d_ops->sf_get_parent_ino(sfp);\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Loop over all the entries trying to match ours.\n\t */\n\tci_sfep = NULL;\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the inode\n\t\t * number. If it's the first case-insensitive match, store the\n\t\t * inode number and continue looking for an exact match.\n\t\t */\n\t\tcmp = dp->i_mount->m_dirnameops->compname(args, sfep->name,\n\t\t\t\t\t\t\t\tsfep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\targs->filetype = dp->d_ops->sf_get_ftype(sfep);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t\tci_sfep = sfep;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was not found, return -ENOENT.\n\t */\n\tif (!ci_sfep)\n\t\treturn -ENOENT;\n\t/* otherwise process the CI match as required by the caller */\n\terror = xfs_dir_cilookup_result(args, ci_sfep->name, ci_sfep->namelen);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir2_sf_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "642-690",
    "snippet": "int\t\t\t\t\t/* error, always 0 */\nxfs_dir2_sf_create(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\txfs_ino_t\tpino)\t\t/* parent inode number */\n{\n\txfs_inode_t\t*dp;\t\t/* incore directory inode */\n\tint\t\ti8count;\t/* parent inode is an 8-byte number */\n\txfs_dir2_sf_hdr_t *sfp;\t\t/* shortform structure */\n\tint\t\tsize;\t\t/* directory size */\n\n\ttrace_xfs_dir2_sf_create(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_d.di_size == 0);\n\t/*\n\t * If it's currently a zero-length extent file,\n\t * convert it to local format.\n\t */\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_EXTENTS) {\n\t\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\tdp->i_df.if_flags |= XFS_IFINLINE;\n\t}\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\tASSERT(dp->i_df.if_bytes == 0);\n\ti8count = pino > XFS_DIR2_MAX_SHORT_INUM;\n\tsize = xfs_dir2_sf_hdr_size(i8count);\n\t/*\n\t * Make a buffer for the data.\n\t */\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\t/*\n\t * Fill in the header,\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsfp->i8count = i8count;\n\t/*\n\t * Now can put in the inode number, since i8count is set.\n\t */\n\tdp->d_ops->sf_put_parent_ino(sfp, pino);\n\tsfp->count = 0;\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE | XFS_ILOG_DDATA"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_check",
          "args": [
            "args"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "601-636",
          "snippet": "static void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_parent_ino",
          "args": [
            "sfp",
            "pino"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "size",
            "XFS_DATA_FORK"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "i8count"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_bytes == 0"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_flags & XFS_IFINLINE"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_size == 0"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp != NULL"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_sf_create",
          "args": [
            "args"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t/* error, always 0 */\nxfs_dir2_sf_create(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\txfs_ino_t\tpino)\t\t/* parent inode number */\n{\n\txfs_inode_t\t*dp;\t\t/* incore directory inode */\n\tint\t\ti8count;\t/* parent inode is an 8-byte number */\n\txfs_dir2_sf_hdr_t *sfp;\t\t/* shortform structure */\n\tint\t\tsize;\t\t/* directory size */\n\n\ttrace_xfs_dir2_sf_create(args);\n\n\tdp = args->dp;\n\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_d.di_size == 0);\n\t/*\n\t * If it's currently a zero-length extent file,\n\t * convert it to local format.\n\t */\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_EXTENTS) {\n\t\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\tdp->i_df.if_flags |= XFS_IFINLINE;\n\t}\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\tASSERT(dp->i_df.if_bytes == 0);\n\ti8count = pino > XFS_DIR2_MAX_SHORT_INUM;\n\tsize = xfs_dir2_sf_hdr_size(i8count);\n\t/*\n\t * Make a buffer for the data.\n\t */\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\t/*\n\t * Fill in the header,\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsfp->i8count = i8count;\n\t/*\n\t * Now can put in the inode number, since i8count is set.\n\t */\n\tdp->d_ops->sf_put_parent_ino(sfp, pino);\n\tsfp->count = 0;\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_sf_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "601-636",
    "snippet": "static void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(char *)sfep - (char *)sfp == dp->i_d.di_size"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i8count == sfp->i8count"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ftype",
          "args": [
            "sfep"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "sfep->namelen"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_get_offset",
          "args": [
            "sfep"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_get_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "272-276",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ino",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_dir2_sf_get_offset(sfep) >= offset"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "sfp"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_parent_ino",
          "args": [
            "sfp"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}"
  },
  {
    "function_name": "xfs_dir2_sf_addname_pick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "530-595",
    "snippet": "static int\t\t\t\t\t/* pick result */\nxfs_dir2_sf_addname_pick(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tobjchange,\t/* inode # size changes */\n\txfs_dir2_sf_entry_t\t**sfepp,\t/* out(1): new entry ptr */\n\txfs_dir2_data_aoff_t\t*offsetp)\t/* out(1): new offset */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tholefit;\t/* found hole it will fit in */\n\tint\t\t\ti;\t\t/* entry number */\n\txfs_dir2_data_aoff_t\toffset;\t\t/* data block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tint\t\t\tsize;\t\t/* entry's data size */\n\tint\t\t\tused;\t\t/* data bytes used */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsize = dp->d_ops->data_entsize(args->namelen);\n\toffset = dp->d_ops->data_first_offset;\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\tholefit = 0;\n\t/*\n\t * Loop over sf entries.\n\t * Keep track of data offset and whether we've seen a place\n\t * to insert the new entry.\n\t */\n\tfor (i = 0; i < sfp->count; i++) {\n\t\tif (!holefit)\n\t\t\tholefit = offset + size <= xfs_dir2_sf_get_offset(sfep);\n\t\toffset = xfs_dir2_sf_get_offset(sfep) +\n\t\t\t dp->d_ops->data_entsize(sfep->namelen);\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/*\n\t * Calculate data bytes used excluding the new entry, if this\n\t * was a data block (block form directory).\n\t */\n\tused = offset +\n\t       (sfp->count + 3) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t);\n\t/*\n\t * If it won't fit in a block form then we can't insert it,\n\t * we'll go back, convert to block, then try the insert and convert\n\t * to leaf.\n\t */\n\tif (used + (holefit ? 0 : size) > args->geo->blksize)\n\t\treturn 0;\n\t/*\n\t * If changing the inode number size, do it the hard way.\n\t */\n\tif (objchange)\n\t\treturn 2;\n\t/*\n\t * If it won't fit at the end then do it the hard way (use the hole).\n\t */\n\tif (used + size > args->geo->blksize)\n\t\treturn 2;\n\t/*\n\t * Do it the easy way.\n\t */\n\t*sfepp = sfep;\n\t*offsetp = offset;\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_sf_addname_pick(xfs_da_args_t *args, int objchange,\n\t\t\t\t    xfs_dir2_sf_entry_t **sfepp,\n\t\t\t\t    xfs_dir2_data_aoff_t *offsetp);",
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "sfep->namelen"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_get_offset",
          "args": [
            "sfep"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_get_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "272-276",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "sfp"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "args->namelen"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_sf_addname_pick(xfs_da_args_t *args, int objchange,\n\t\t\t\t    xfs_dir2_sf_entry_t **sfepp,\n\t\t\t\t    xfs_dir2_data_aoff_t *offsetp);\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic int\t\t\t\t\t/* pick result */\nxfs_dir2_sf_addname_pick(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tobjchange,\t/* inode # size changes */\n\txfs_dir2_sf_entry_t\t**sfepp,\t/* out(1): new entry ptr */\n\txfs_dir2_data_aoff_t\t*offsetp)\t/* out(1): new offset */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tholefit;\t/* found hole it will fit in */\n\tint\t\t\ti;\t\t/* entry number */\n\txfs_dir2_data_aoff_t\toffset;\t\t/* data block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tint\t\t\tsize;\t\t/* entry's data size */\n\tint\t\t\tused;\t\t/* data bytes used */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsize = dp->d_ops->data_entsize(args->namelen);\n\toffset = dp->d_ops->data_first_offset;\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\tholefit = 0;\n\t/*\n\t * Loop over sf entries.\n\t * Keep track of data offset and whether we've seen a place\n\t * to insert the new entry.\n\t */\n\tfor (i = 0; i < sfp->count; i++) {\n\t\tif (!holefit)\n\t\t\tholefit = offset + size <= xfs_dir2_sf_get_offset(sfep);\n\t\toffset = xfs_dir2_sf_get_offset(sfep) +\n\t\t\t dp->d_ops->data_entsize(sfep->namelen);\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/*\n\t * Calculate data bytes used excluding the new entry, if this\n\t * was a data block (block form directory).\n\t */\n\tused = offset +\n\t       (sfp->count + 3) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t);\n\t/*\n\t * If it won't fit in a block form then we can't insert it,\n\t * we'll go back, convert to block, then try the insert and convert\n\t * to leaf.\n\t */\n\tif (used + (holefit ? 0 : size) > args->geo->blksize)\n\t\treturn 0;\n\t/*\n\t * If changing the inode number size, do it the hard way.\n\t */\n\tif (objchange)\n\t\treturn 2;\n\t/*\n\t * If it won't fit at the end then do it the hard way (use the hole).\n\t */\n\tif (used + size > args->geo->blksize)\n\t\treturn 2;\n\t/*\n\t * Do it the easy way.\n\t */\n\t*sfepp = sfep;\n\t*offsetp = offset;\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_dir2_sf_addname_hard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "437-521",
    "snippet": "static void\nxfs_dir2_sf_addname_hard(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tobjchange,\t/* changing inode number size */\n\tint\t\t\tnew_isize)\t/* new directory size */\n{\n\tint\t\t\tadd_datasize;\t/* data size need for new ent */\n\tchar\t\t\t*buf;\t\t/* buffer for old */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\teof;\t\t/* reached end of old dir */\n\tint\t\t\tnbytes;\t\t/* temp for byte copies */\n\txfs_dir2_data_aoff_t\tnew_offset;\t/* next offset value */\n\txfs_dir2_data_aoff_t\toffset;\t\t/* current offset value */\n\tint\t\t\told_isize;\t/* previous di_size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* entry in original dir */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* original shortform dir */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* entry in new dir */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new shortform dir */\n\n\t/*\n\t * Copy the old directory to the stack buffer.\n\t */\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\told_isize = (int)dp->i_d.di_size;\n\tbuf = kmem_alloc(old_isize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tmemcpy(oldsfp, sfp, old_isize);\n\t/*\n\t * Loop over the old directory finding the place we're going\n\t * to insert the new entry.\n\t * If it's going to end up at the end then oldsfep will point there.\n\t */\n\tfor (offset = dp->d_ops->data_first_offset,\n\t      oldsfep = xfs_dir2_sf_firstentry(oldsfp),\n\t      add_datasize = dp->d_ops->data_entsize(args->namelen),\n\t      eof = (char *)oldsfep == &buf[old_isize];\n\t     !eof;\n\t     offset = new_offset + dp->d_ops->data_entsize(oldsfep->namelen),\n\t      oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep),\n\t      eof = (char *)oldsfep == &buf[old_isize]) {\n\t\tnew_offset = xfs_dir2_sf_get_offset(oldsfep);\n\t\tif (offset + add_datasize <= new_offset)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Get rid of the old directory, then allocate space for\n\t * the new one.  We do this so xfs_idata_realloc won't copy\n\t * the data.\n\t */\n\txfs_idata_realloc(dp, -old_isize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, new_isize, XFS_DATA_FORK);\n\t/*\n\t * Reset the pointer since the buffer was reallocated.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Copy the first part of the directory, including the header.\n\t */\n\tnbytes = (int)((char *)oldsfep - (char *)oldsfp);\n\tmemcpy(sfp, oldsfp, nbytes);\n\tsfep = (xfs_dir2_sf_entry_t *)((char *)sfp + nbytes);\n\t/*\n\t * Fill in the new entry, and update the header counts.\n\t */\n\tsfep->namelen = args->namelen;\n\txfs_dir2_sf_put_offset(sfep, offset);\n\tmemcpy(sfep->name, args->name, sfep->namelen);\n\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\tsfp->count++;\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && !objchange)\n\t\tsfp->i8count++;\n\t/*\n\t * If there's more left to copy, do that.\n\t */\n\tif (!eof) {\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\tmemcpy(sfep, oldsfep, old_isize - nbytes);\n\t}\n\tkmem_free(buf);\n\tdp->i_d.di_size = new_isize;\n\txfs_dir2_sf_check(args);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);",
      "static void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);",
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_sf_check",
          "args": [
            "args"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "601-636",
          "snippet": "static void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "buf"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfep",
            "oldsfep",
            "old_isize - nbytes"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ftype",
          "args": [
            "sfep",
            "args->filetype"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ino",
          "args": [
            "sfp",
            "sfep",
            "args->inumber"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfep->name",
            "args->name",
            "sfep->namelen"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_put_offset",
          "args": [
            "sfep",
            "offset"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_put_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "278-282",
          "snippet": "static inline void\nxfs_dir2_sf_put_offset(xfs_dir2_sf_entry_t *sfep, xfs_dir2_data_aoff_t off)\n{\n\tput_unaligned_be16(off, &sfep->offset.i);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_dir2_sf_put_offset(xfs_dir2_sf_entry_t *sfep, xfs_dir2_data_aoff_t off)\n{\n\tput_unaligned_be16(off, &sfep->offset.i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfp",
            "oldsfp",
            "nbytes"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "new_isize",
            "XFS_DATA_FORK"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_get_offset",
          "args": [
            "oldsfep"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_get_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "272-276",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "oldsfp",
            "oldsfep"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "oldsfep->namelen"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "args->namelen"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "oldsfp"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "oldsfp",
            "sfp",
            "old_isize"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "old_isize",
            "KM_SLEEP"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_addname_hard(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tobjchange,\t/* changing inode number size */\n\tint\t\t\tnew_isize)\t/* new directory size */\n{\n\tint\t\t\tadd_datasize;\t/* data size need for new ent */\n\tchar\t\t\t*buf;\t\t/* buffer for old */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\teof;\t\t/* reached end of old dir */\n\tint\t\t\tnbytes;\t\t/* temp for byte copies */\n\txfs_dir2_data_aoff_t\tnew_offset;\t/* next offset value */\n\txfs_dir2_data_aoff_t\toffset;\t\t/* current offset value */\n\tint\t\t\told_isize;\t/* previous di_size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* entry in original dir */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* original shortform dir */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* entry in new dir */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new shortform dir */\n\n\t/*\n\t * Copy the old directory to the stack buffer.\n\t */\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\told_isize = (int)dp->i_d.di_size;\n\tbuf = kmem_alloc(old_isize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tmemcpy(oldsfp, sfp, old_isize);\n\t/*\n\t * Loop over the old directory finding the place we're going\n\t * to insert the new entry.\n\t * If it's going to end up at the end then oldsfep will point there.\n\t */\n\tfor (offset = dp->d_ops->data_first_offset,\n\t      oldsfep = xfs_dir2_sf_firstentry(oldsfp),\n\t      add_datasize = dp->d_ops->data_entsize(args->namelen),\n\t      eof = (char *)oldsfep == &buf[old_isize];\n\t     !eof;\n\t     offset = new_offset + dp->d_ops->data_entsize(oldsfep->namelen),\n\t      oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep),\n\t      eof = (char *)oldsfep == &buf[old_isize]) {\n\t\tnew_offset = xfs_dir2_sf_get_offset(oldsfep);\n\t\tif (offset + add_datasize <= new_offset)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Get rid of the old directory, then allocate space for\n\t * the new one.  We do this so xfs_idata_realloc won't copy\n\t * the data.\n\t */\n\txfs_idata_realloc(dp, -old_isize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, new_isize, XFS_DATA_FORK);\n\t/*\n\t * Reset the pointer since the buffer was reallocated.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Copy the first part of the directory, including the header.\n\t */\n\tnbytes = (int)((char *)oldsfep - (char *)oldsfp);\n\tmemcpy(sfp, oldsfp, nbytes);\n\tsfep = (xfs_dir2_sf_entry_t *)((char *)sfp + nbytes);\n\t/*\n\t * Fill in the new entry, and update the header counts.\n\t */\n\tsfep->namelen = args->namelen;\n\txfs_dir2_sf_put_offset(sfep, offset);\n\tmemcpy(sfep->name, args->name, sfep->namelen);\n\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\tsfp->count++;\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && !objchange)\n\t\tsfp->i8count++;\n\t/*\n\t * If there's more left to copy, do that.\n\t */\n\tif (!eof) {\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\tmemcpy(sfep, oldsfep, old_isize - nbytes);\n\t}\n\tkmem_free(buf);\n\tdp->i_d.di_size = new_isize;\n\txfs_dir2_sf_check(args);\n}"
  },
  {
    "function_name": "xfs_dir2_sf_addname_easy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "384-426",
    "snippet": "static void\nxfs_dir2_sf_addname_easy(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_dir2_sf_entry_t\t*sfep,\t\t/* pointer to new entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* offset to use for new ent */\n\tint\t\t\tnew_isize)\t/* new directory size */\n{\n\tint\t\t\tbyteoff;\t/* byte offset in sf dir */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tbyteoff = (int)((char *)sfep - (char *)sfp);\n\t/*\n\t * Grow the in-inode space.\n\t */\n\txfs_idata_realloc(dp, dp->d_ops->sf_entsize(sfp, args->namelen),\n\t\t\t  XFS_DATA_FORK);\n\t/*\n\t * Need to set up again due to realloc of the inode data.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsfep = (xfs_dir2_sf_entry_t *)((char *)sfp + byteoff);\n\t/*\n\t * Fill in the new entry.\n\t */\n\tsfep->namelen = args->namelen;\n\txfs_dir2_sf_put_offset(sfep, offset);\n\tmemcpy(sfep->name, args->name, sfep->namelen);\n\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\n\t/*\n\t * Update the header and inode.\n\t */\n\tsfp->count++;\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM)\n\t\tsfp->i8count++;\n\tdp->i_d.di_size = new_isize;\n\txfs_dir2_sf_check(args);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);",
      "static void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);",
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_sf_check",
          "args": [
            "args"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "601-636",
          "snippet": "static void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ftype",
          "args": [
            "sfep",
            "args->filetype"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ino",
          "args": [
            "sfp",
            "sfep",
            "args->inumber"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfep->name",
            "args->name",
            "sfep->namelen"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_put_offset",
          "args": [
            "sfep",
            "offset"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_put_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "278-282",
          "snippet": "static inline void\nxfs_dir2_sf_put_offset(xfs_dir2_sf_entry_t *sfep, xfs_dir2_data_aoff_t off)\n{\n\tput_unaligned_be16(off, &sfep->offset.i);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_dir2_sf_put_offset(xfs_dir2_sf_entry_t *sfep, xfs_dir2_data_aoff_t off)\n{\n\tput_unaligned_be16(off, &sfep->offset.i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "dp->d_ops->sf_entsize(sfp, args->namelen)",
            "XFS_DATA_FORK"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_entsize",
          "args": [
            "sfp",
            "args->namelen"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_addname_easy(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_dir2_sf_entry_t\t*sfep,\t\t/* pointer to new entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* offset to use for new ent */\n\tint\t\t\tnew_isize)\t/* new directory size */\n{\n\tint\t\t\tbyteoff;\t/* byte offset in sf dir */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tbyteoff = (int)((char *)sfep - (char *)sfp);\n\t/*\n\t * Grow the in-inode space.\n\t */\n\txfs_idata_realloc(dp, dp->d_ops->sf_entsize(sfp, args->namelen),\n\t\t\t  XFS_DATA_FORK);\n\t/*\n\t * Need to set up again due to realloc of the inode data.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsfep = (xfs_dir2_sf_entry_t *)((char *)sfp + byteoff);\n\t/*\n\t * Fill in the new entry.\n\t */\n\tsfep->namelen = args->namelen;\n\txfs_dir2_sf_put_offset(sfep, offset);\n\tmemcpy(sfep->name, args->name, sfep->namelen);\n\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\n\t/*\n\t * Update the header and inode.\n\t */\n\tsfp->count++;\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM)\n\t\tsfp->i8count++;\n\tdp->i_d.di_size = new_isize;\n\txfs_dir2_sf_check(args);\n}"
  },
  {
    "function_name": "xfs_dir2_sf_addname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "282-375",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tincr_isize;\t/* total change in size */\n\tint\t\t\tnew_isize;\t/* di_size after adding name */\n\tint\t\t\tobjchange;\t/* changing to 8-byte inodes */\n\txfs_dir2_data_aoff_t\toffset = 0;\t/* offset for new entry */\n\tint\t\t\tpick;\t\t/* which algorithm to use */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_sf_entry_t\t*sfep = NULL;\t/* shortform entry */\n\n\ttrace_xfs_dir2_sf_addname(args);\n\n\tASSERT(xfs_dir2_sf_lookup(args) == -ENOENT);\n\tdp = args->dp;\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Make sure the shortform value has some of its header.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Compute entry (and change in) size.\n\t */\n\tincr_isize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tobjchange = 0;\n\n\t/*\n\t * Do we have to change to 8 byte inodes?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\t/*\n\t\t * Yes, adjust the inode size.  old count + (parent + new)\n\t\t */\n\t\tincr_isize +=\n\t\t\t(sfp->count + 2) *\n\t\t\t((uint)sizeof(xfs_dir2_ino8_t) -\n\t\t\t (uint)sizeof(xfs_dir2_ino4_t));\n\t\tobjchange = 1;\n\t}\n\n\tnew_isize = (int)dp->i_d.di_size + incr_isize;\n\t/*\n\t * Won't fit as shortform any more (due to size),\n\t * or the pick routine says it won't (due to offset values).\n\t */\n\tif (new_isize > XFS_IFORK_DSIZE(dp) ||\n\t    (pick =\n\t     xfs_dir2_sf_addname_pick(args, objchange, &sfep, &offset)) == 0) {\n\t\t/*\n\t\t * Just checking or no space reservation, it doesn't fit.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to block form then add the name.\n\t\t */\n\t\terror = xfs_dir2_sf_to_block(args);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_block_addname(args);\n\t}\n\t/*\n\t * Just checking, it fits.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\t/*\n\t * Do it the easy way - just add it at the end.\n\t */\n\tif (pick == 1)\n\t\txfs_dir2_sf_addname_easy(args, sfep, offset, new_isize);\n\t/*\n\t * Do it the hard way - look for a place to insert the new entry.\n\t * Convert to 8 byte inode numbers first if necessary.\n\t */\n\telse {\n\t\tASSERT(pick == 2);\n\t\tif (objchange)\n\t\t\txfs_dir2_sf_toino8(args);\n\t\txfs_dir2_sf_addname_hard(args, objchange, new_isize);\n\t}\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);",
      "static void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);",
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "XFS_ILOG_CORE | XFS_ILOG_DDATA"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_addname_hard",
          "args": [
            "args",
            "objchange",
            "new_isize"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_addname_hard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "437-521",
          "snippet": "static void\nxfs_dir2_sf_addname_hard(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tobjchange,\t/* changing inode number size */\n\tint\t\t\tnew_isize)\t/* new directory size */\n{\n\tint\t\t\tadd_datasize;\t/* data size need for new ent */\n\tchar\t\t\t*buf;\t\t/* buffer for old */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\teof;\t\t/* reached end of old dir */\n\tint\t\t\tnbytes;\t\t/* temp for byte copies */\n\txfs_dir2_data_aoff_t\tnew_offset;\t/* next offset value */\n\txfs_dir2_data_aoff_t\toffset;\t\t/* current offset value */\n\tint\t\t\told_isize;\t/* previous di_size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* entry in original dir */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* original shortform dir */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* entry in new dir */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new shortform dir */\n\n\t/*\n\t * Copy the old directory to the stack buffer.\n\t */\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\told_isize = (int)dp->i_d.di_size;\n\tbuf = kmem_alloc(old_isize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tmemcpy(oldsfp, sfp, old_isize);\n\t/*\n\t * Loop over the old directory finding the place we're going\n\t * to insert the new entry.\n\t * If it's going to end up at the end then oldsfep will point there.\n\t */\n\tfor (offset = dp->d_ops->data_first_offset,\n\t      oldsfep = xfs_dir2_sf_firstentry(oldsfp),\n\t      add_datasize = dp->d_ops->data_entsize(args->namelen),\n\t      eof = (char *)oldsfep == &buf[old_isize];\n\t     !eof;\n\t     offset = new_offset + dp->d_ops->data_entsize(oldsfep->namelen),\n\t      oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep),\n\t      eof = (char *)oldsfep == &buf[old_isize]) {\n\t\tnew_offset = xfs_dir2_sf_get_offset(oldsfep);\n\t\tif (offset + add_datasize <= new_offset)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Get rid of the old directory, then allocate space for\n\t * the new one.  We do this so xfs_idata_realloc won't copy\n\t * the data.\n\t */\n\txfs_idata_realloc(dp, -old_isize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, new_isize, XFS_DATA_FORK);\n\t/*\n\t * Reset the pointer since the buffer was reallocated.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Copy the first part of the directory, including the header.\n\t */\n\tnbytes = (int)((char *)oldsfep - (char *)oldsfp);\n\tmemcpy(sfp, oldsfp, nbytes);\n\tsfep = (xfs_dir2_sf_entry_t *)((char *)sfp + nbytes);\n\t/*\n\t * Fill in the new entry, and update the header counts.\n\t */\n\tsfep->namelen = args->namelen;\n\txfs_dir2_sf_put_offset(sfep, offset);\n\tmemcpy(sfep->name, args->name, sfep->namelen);\n\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\tsfp->count++;\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && !objchange)\n\t\tsfp->i8count++;\n\t/*\n\t * If there's more left to copy, do that.\n\t */\n\tif (!eof) {\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\tmemcpy(sfep, oldsfep, old_isize - nbytes);\n\t}\n\tkmem_free(buf);\n\tdp->i_d.di_size = new_isize;\n\txfs_dir2_sf_check(args);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);",
            "static void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);",
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_addname_hard(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tobjchange,\t/* changing inode number size */\n\tint\t\t\tnew_isize)\t/* new directory size */\n{\n\tint\t\t\tadd_datasize;\t/* data size need for new ent */\n\tchar\t\t\t*buf;\t\t/* buffer for old */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\teof;\t\t/* reached end of old dir */\n\tint\t\t\tnbytes;\t\t/* temp for byte copies */\n\txfs_dir2_data_aoff_t\tnew_offset;\t/* next offset value */\n\txfs_dir2_data_aoff_t\toffset;\t\t/* current offset value */\n\tint\t\t\told_isize;\t/* previous di_size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* entry in original dir */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* original shortform dir */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* entry in new dir */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new shortform dir */\n\n\t/*\n\t * Copy the old directory to the stack buffer.\n\t */\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\told_isize = (int)dp->i_d.di_size;\n\tbuf = kmem_alloc(old_isize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tmemcpy(oldsfp, sfp, old_isize);\n\t/*\n\t * Loop over the old directory finding the place we're going\n\t * to insert the new entry.\n\t * If it's going to end up at the end then oldsfep will point there.\n\t */\n\tfor (offset = dp->d_ops->data_first_offset,\n\t      oldsfep = xfs_dir2_sf_firstentry(oldsfp),\n\t      add_datasize = dp->d_ops->data_entsize(args->namelen),\n\t      eof = (char *)oldsfep == &buf[old_isize];\n\t     !eof;\n\t     offset = new_offset + dp->d_ops->data_entsize(oldsfep->namelen),\n\t      oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep),\n\t      eof = (char *)oldsfep == &buf[old_isize]) {\n\t\tnew_offset = xfs_dir2_sf_get_offset(oldsfep);\n\t\tif (offset + add_datasize <= new_offset)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Get rid of the old directory, then allocate space for\n\t * the new one.  We do this so xfs_idata_realloc won't copy\n\t * the data.\n\t */\n\txfs_idata_realloc(dp, -old_isize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, new_isize, XFS_DATA_FORK);\n\t/*\n\t * Reset the pointer since the buffer was reallocated.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Copy the first part of the directory, including the header.\n\t */\n\tnbytes = (int)((char *)oldsfep - (char *)oldsfp);\n\tmemcpy(sfp, oldsfp, nbytes);\n\tsfep = (xfs_dir2_sf_entry_t *)((char *)sfp + nbytes);\n\t/*\n\t * Fill in the new entry, and update the header counts.\n\t */\n\tsfep->namelen = args->namelen;\n\txfs_dir2_sf_put_offset(sfep, offset);\n\tmemcpy(sfep->name, args->name, sfep->namelen);\n\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\tsfp->count++;\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && !objchange)\n\t\tsfp->i8count++;\n\t/*\n\t * If there's more left to copy, do that.\n\t */\n\tif (!eof) {\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\tmemcpy(sfep, oldsfep, old_isize - nbytes);\n\t}\n\tkmem_free(buf);\n\tdp->i_d.di_size = new_isize;\n\txfs_dir2_sf_check(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_toino8",
          "args": [
            "args"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_toino8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "1073-1142",
          "snippet": "static void\nxfs_dir2_sf_toino8(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino8(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 0);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size (nb: entry count + 1 for parent)\n\t */\n\tnewsize =\n\t\toldsize +\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 1;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_toino8(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tchar\t\t\t*buf;\t\t/* old dir's buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\tnewsize;\t/* new inode size */\n\txfs_dir2_sf_entry_t\t*oldsfep;\t/* old sf entry */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old sf directory */\n\tint\t\t\toldsize;\t/* old inode size */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* new sf entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* new sf directory */\n\n\ttrace_xfs_dir2_sf_toino8(args);\n\n\tdp = args->dp;\n\n\t/*\n\t * Copy the old directory to the buffer.\n\t * Then nuke it from the inode, and add the new buffer to the inode.\n\t * Don't want xfs_idata_realloc copying the data here.\n\t */\n\toldsize = dp->i_df.if_bytes;\n\tbuf = kmem_alloc(oldsize, KM_SLEEP);\n\toldsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(oldsfp->i8count == 0);\n\tmemcpy(buf, oldsfp, oldsize);\n\t/*\n\t * Compute the new inode size (nb: entry count + 1 for parent)\n\t */\n\tnewsize =\n\t\toldsize +\n\t\t(oldsfp->count + 1) *\n\t\t((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));\n\txfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);\n\txfs_idata_realloc(dp, newsize, XFS_DATA_FORK);\n\t/*\n\t * Reset our pointers, the data has moved.\n\t */\n\toldsfp = (xfs_dir2_sf_hdr_t *)buf;\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\t/*\n\t * Fill in the new header.\n\t */\n\tsfp->count = oldsfp->count;\n\tsfp->i8count = 1;\n\tdp->d_ops->sf_put_parent_ino(sfp, dp->d_ops->sf_get_parent_ino(oldsfp));\n\t/*\n\t * Copy the entries field by field.\n\t */\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp),\n\t\t    oldsfep = xfs_dir2_sf_firstentry(oldsfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),\n\t\t  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {\n\t\tsfep->namelen = oldsfep->namelen;\n\t\tsfep->offset = oldsfep->offset;\n\t\tmemcpy(sfep->name, oldsfep->name, sfep->namelen);\n\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t      dp->d_ops->sf_get_ino(oldsfp, oldsfep));\n\t\tdp->d_ops->sf_put_ftype(sfep, dp->d_ops->sf_get_ftype(oldsfep));\n\t}\n\t/*\n\t * Clean up the inode.\n\t */\n\tkmem_free(buf);\n\tdp->i_d.di_size = newsize;\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pick == 2"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_addname_easy",
          "args": [
            "args",
            "sfep",
            "offset",
            "new_isize"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_addname_easy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "384-426",
          "snippet": "static void\nxfs_dir2_sf_addname_easy(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_dir2_sf_entry_t\t*sfep,\t\t/* pointer to new entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* offset to use for new ent */\n\tint\t\t\tnew_isize)\t/* new directory size */\n{\n\tint\t\t\tbyteoff;\t/* byte offset in sf dir */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tbyteoff = (int)((char *)sfep - (char *)sfp);\n\t/*\n\t * Grow the in-inode space.\n\t */\n\txfs_idata_realloc(dp, dp->d_ops->sf_entsize(sfp, args->namelen),\n\t\t\t  XFS_DATA_FORK);\n\t/*\n\t * Need to set up again due to realloc of the inode data.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsfep = (xfs_dir2_sf_entry_t *)((char *)sfp + byteoff);\n\t/*\n\t * Fill in the new entry.\n\t */\n\tsfep->namelen = args->namelen;\n\txfs_dir2_sf_put_offset(sfep, offset);\n\tmemcpy(sfep->name, args->name, sfep->namelen);\n\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\n\t/*\n\t * Update the header and inode.\n\t */\n\tsfp->count++;\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM)\n\t\tsfp->i8count++;\n\tdp->i_d.di_size = new_isize;\n\txfs_dir2_sf_check(args);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);",
            "static void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);",
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_addname_easy(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_dir2_sf_entry_t\t*sfep,\t\t/* pointer to new entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* offset to use for new ent */\n\tint\t\t\tnew_isize)\t/* new directory size */\n{\n\tint\t\t\tbyteoff;\t/* byte offset in sf dir */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tbyteoff = (int)((char *)sfep - (char *)sfp);\n\t/*\n\t * Grow the in-inode space.\n\t */\n\txfs_idata_realloc(dp, dp->d_ops->sf_entsize(sfp, args->namelen),\n\t\t\t  XFS_DATA_FORK);\n\t/*\n\t * Need to set up again due to realloc of the inode data.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsfep = (xfs_dir2_sf_entry_t *)((char *)sfp + byteoff);\n\t/*\n\t * Fill in the new entry.\n\t */\n\tsfep->namelen = args->namelen;\n\txfs_dir2_sf_put_offset(sfep, offset);\n\tmemcpy(sfep->name, args->name, sfep->namelen);\n\tdp->d_ops->sf_put_ino(sfp, sfep, args->inumber);\n\tdp->d_ops->sf_put_ftype(sfep, args->filetype);\n\n\t/*\n\t * Update the header and inode.\n\t */\n\tsfp->count++;\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM)\n\t\tsfp->i8count++;\n\tdp->i_d.di_size = new_isize;\n\txfs_dir2_sf_check(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_addname",
          "args": [
            "args"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "330-562",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_addname(\n\txfs_da_args_t\t\t*args)\t\t/* directory op arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\tint\t\t\tcompact;\t/* need to compact leaf ents */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_data_unused_t\t*enddup=NULL;\t/* unused at end of data */\n\txfs_dahash_t\t\thash;\t\t/* hash value of found entry */\n\tint\t\t\thigh;\t\t/* high index for binary srch */\n\tint\t\t\thighstale;\t/* high stale index */\n\tint\t\t\tlfloghigh=0;\t/* last final leaf to log */\n\tint\t\t\tlfloglow=0;\t/* first final leaf to log */\n\tint\t\t\tlen;\t\t/* length of the new entry */\n\tint\t\t\tlow;\t\t/* low index for binary srch */\n\tint\t\t\tlowstale;\t/* low stale index */\n\tint\t\t\tmid=0;\t\t/* midpoint for binary srch */\n\tint\t\t\tneedlog;\t/* need to log header */\n\tint\t\t\tneedscan;\t/* need to rescan freespace */\n\t__be16\t\t\t*tagp;\t\t/* pointer to tag value */\n\txfs_trans_t\t\t*tp;\t\t/* transaction structure */\n\n\ttrace_xfs_dir2_block_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\t/* Read the (one and only) directory block into bp. */\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\tlen = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * Set up pointers to parts of the block.\n\t */\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Find out if we can reuse stale entries or whether we need extra\n\t * space for entry and new leaf.\n\t */\n\txfs_dir2_block_need_space(dp, hdr, btp, blp, &tagp, &dup,\n\t\t\t\t  &enddup, &compact, len);\n\n\t/*\n\t * Done everything we need for a space check now.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, bp);\n\t\tif (!dup)\n\t\t\treturn -ENOSPC;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we don't have space for the new entry & leaf ...\n\t */\n\tif (!dup) {\n\t\t/* Don't have a space reservation: return no-space.  */\n\t\tif (args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to the next larger format.\n\t\t * Then add the new entry in that format.\n\t\t */\n\t\terror = xfs_dir2_block_to_leaf(args, bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_leaf_addname(args);\n\t}\n\n\tneedlog = needscan = 0;\n\n\t/*\n\t * If need to compact the leaf entries, do it now.\n\t */\n\tif (compact) {\n\t\txfs_dir2_block_compact(args, bp, hdr, btp, blp, &needlog,\n\t\t\t\t      &lfloghigh, &lfloglow);\n\t\t/* recalculate blp post-compaction */\n\t\tblp = xfs_dir2_block_leaf_p(btp);\n\t} else if (btp->stale) {\n\t\t/*\n\t\t * Set leaf logging boundaries to impossible state.\n\t\t * For the no-stale case they're set explicitly.\n\t\t */\n\t\tlfloglow = be32_to_cpu(btp->count);\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Find the slot that's first lower than our hash value, -1 if none.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\twhile (mid >= 0 && be32_to_cpu(blp[mid].hashval) >= args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * No stale entries, will use enddup space to hold new leaf.\n\t */\n\tif (!btp->stale) {\n\t\t/*\n\t\t * Mark the space needed for the new leaf entry, now in use.\n\t\t */\n\t\txfs_dir2_data_use_free(args, bp, enddup,\n\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t((char *)enddup - (char *)hdr + be16_to_cpu(enddup->length) -\n\t\t\t sizeof(*blp)),\n\t\t\t(xfs_dir2_data_aoff_t)sizeof(*blp),\n\t\t\t&needlog, &needscan);\n\t\t/*\n\t\t * Update the tail (entry count).\n\t\t */\n\t\tbe32_add_cpu(&btp->count, 1);\n\t\t/*\n\t\t * If we now need to rebuild the bestfree map, do so.\n\t\t * This needs to happen before the next call to use_free.\n\t\t */\n\t\tif (needscan) {\n\t\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t\t\tneedscan = 0;\n\t\t}\n\t\t/*\n\t\t * Adjust pointer to the first leaf entry, we're about to move\n\t\t * the table up one to open up space for the new leaf entry.\n\t\t * Then adjust our index to match.\n\t\t */\n\t\tblp--;\n\t\tmid++;\n\t\tif (mid)\n\t\t\tmemmove(blp, &blp[1], mid * sizeof(*blp));\n\t\tlfloglow = 0;\n\t\tlfloghigh = mid;\n\t}\n\t/*\n\t * Use a stale leaf for our new entry.\n\t */\n\telse {\n\t\tfor (lowstale = mid;\n\t\t     lowstale >= 0 &&\n\t\t\tblp[lowstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\t\t     lowstale--)\n\t\t\tcontinue;\n\t\tfor (highstale = mid + 1;\n\t\t     highstale < be32_to_cpu(btp->count) &&\n\t\t\tblp[highstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR) &&\n\t\t\t(lowstale < 0 || mid - lowstale > highstale - mid);\n\t\t     highstale++)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Move entries toward the low-numbered stale entry.\n\t\t */\n\t\tif (lowstale >= 0 &&\n\t\t    (highstale == be32_to_cpu(btp->count) ||\n\t\t     mid - lowstale <= highstale - mid)) {\n\t\t\tif (mid - lowstale)\n\t\t\t\tmemmove(&blp[lowstale], &blp[lowstale + 1],\n\t\t\t\t\t(mid - lowstale) * sizeof(*blp));\n\t\t\tlfloglow = MIN(lowstale, lfloglow);\n\t\t\tlfloghigh = MAX(mid, lfloghigh);\n\t\t}\n\t\t/*\n\t\t * Move entries toward the high-numbered stale entry.\n\t\t */\n\t\telse {\n\t\t\tASSERT(highstale < be32_to_cpu(btp->count));\n\t\t\tmid++;\n\t\t\tif (highstale - mid)\n\t\t\t\tmemmove(&blp[mid + 1], &blp[mid],\n\t\t\t\t\t(highstale - mid) * sizeof(*blp));\n\t\t\tlfloglow = MIN(mid, lfloglow);\n\t\t\tlfloghigh = MAX(highstale, lfloghigh);\n\t\t}\n\t\tbe32_add_cpu(&btp->stale, -1);\n\t}\n\t/*\n\t * Point to the new data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\t/*\n\t * Fill in the leaf entry.\n\t */\n\tblp[mid].hashval = cpu_to_be32(args->hashval);\n\tblp[mid].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\txfs_dir2_block_log_leaf(tp, bp, lfloglow, lfloghigh);\n\t/*\n\t * Mark space for the data entry used.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)len, &needlog, &needscan);\n\t/*\n\t * Create the new data entry.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, args->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Clean up the bestfree array and log the header, tail, and entry.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);",
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_addname(\n\txfs_da_args_t\t\t*args)\t\t/* directory op arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\tint\t\t\tcompact;\t/* need to compact leaf ents */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_data_unused_t\t*enddup=NULL;\t/* unused at end of data */\n\txfs_dahash_t\t\thash;\t\t/* hash value of found entry */\n\tint\t\t\thigh;\t\t/* high index for binary srch */\n\tint\t\t\thighstale;\t/* high stale index */\n\tint\t\t\tlfloghigh=0;\t/* last final leaf to log */\n\tint\t\t\tlfloglow=0;\t/* first final leaf to log */\n\tint\t\t\tlen;\t\t/* length of the new entry */\n\tint\t\t\tlow;\t\t/* low index for binary srch */\n\tint\t\t\tlowstale;\t/* low stale index */\n\tint\t\t\tmid=0;\t\t/* midpoint for binary srch */\n\tint\t\t\tneedlog;\t/* need to log header */\n\tint\t\t\tneedscan;\t/* need to rescan freespace */\n\t__be16\t\t\t*tagp;\t\t/* pointer to tag value */\n\txfs_trans_t\t\t*tp;\t\t/* transaction structure */\n\n\ttrace_xfs_dir2_block_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\t/* Read the (one and only) directory block into bp. */\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\tlen = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * Set up pointers to parts of the block.\n\t */\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Find out if we can reuse stale entries or whether we need extra\n\t * space for entry and new leaf.\n\t */\n\txfs_dir2_block_need_space(dp, hdr, btp, blp, &tagp, &dup,\n\t\t\t\t  &enddup, &compact, len);\n\n\t/*\n\t * Done everything we need for a space check now.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, bp);\n\t\tif (!dup)\n\t\t\treturn -ENOSPC;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we don't have space for the new entry & leaf ...\n\t */\n\tif (!dup) {\n\t\t/* Don't have a space reservation: return no-space.  */\n\t\tif (args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to the next larger format.\n\t\t * Then add the new entry in that format.\n\t\t */\n\t\terror = xfs_dir2_block_to_leaf(args, bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_leaf_addname(args);\n\t}\n\n\tneedlog = needscan = 0;\n\n\t/*\n\t * If need to compact the leaf entries, do it now.\n\t */\n\tif (compact) {\n\t\txfs_dir2_block_compact(args, bp, hdr, btp, blp, &needlog,\n\t\t\t\t      &lfloghigh, &lfloglow);\n\t\t/* recalculate blp post-compaction */\n\t\tblp = xfs_dir2_block_leaf_p(btp);\n\t} else if (btp->stale) {\n\t\t/*\n\t\t * Set leaf logging boundaries to impossible state.\n\t\t * For the no-stale case they're set explicitly.\n\t\t */\n\t\tlfloglow = be32_to_cpu(btp->count);\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Find the slot that's first lower than our hash value, -1 if none.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\twhile (mid >= 0 && be32_to_cpu(blp[mid].hashval) >= args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * No stale entries, will use enddup space to hold new leaf.\n\t */\n\tif (!btp->stale) {\n\t\t/*\n\t\t * Mark the space needed for the new leaf entry, now in use.\n\t\t */\n\t\txfs_dir2_data_use_free(args, bp, enddup,\n\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t((char *)enddup - (char *)hdr + be16_to_cpu(enddup->length) -\n\t\t\t sizeof(*blp)),\n\t\t\t(xfs_dir2_data_aoff_t)sizeof(*blp),\n\t\t\t&needlog, &needscan);\n\t\t/*\n\t\t * Update the tail (entry count).\n\t\t */\n\t\tbe32_add_cpu(&btp->count, 1);\n\t\t/*\n\t\t * If we now need to rebuild the bestfree map, do so.\n\t\t * This needs to happen before the next call to use_free.\n\t\t */\n\t\tif (needscan) {\n\t\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t\t\tneedscan = 0;\n\t\t}\n\t\t/*\n\t\t * Adjust pointer to the first leaf entry, we're about to move\n\t\t * the table up one to open up space for the new leaf entry.\n\t\t * Then adjust our index to match.\n\t\t */\n\t\tblp--;\n\t\tmid++;\n\t\tif (mid)\n\t\t\tmemmove(blp, &blp[1], mid * sizeof(*blp));\n\t\tlfloglow = 0;\n\t\tlfloghigh = mid;\n\t}\n\t/*\n\t * Use a stale leaf for our new entry.\n\t */\n\telse {\n\t\tfor (lowstale = mid;\n\t\t     lowstale >= 0 &&\n\t\t\tblp[lowstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\t\t     lowstale--)\n\t\t\tcontinue;\n\t\tfor (highstale = mid + 1;\n\t\t     highstale < be32_to_cpu(btp->count) &&\n\t\t\tblp[highstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR) &&\n\t\t\t(lowstale < 0 || mid - lowstale > highstale - mid);\n\t\t     highstale++)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Move entries toward the low-numbered stale entry.\n\t\t */\n\t\tif (lowstale >= 0 &&\n\t\t    (highstale == be32_to_cpu(btp->count) ||\n\t\t     mid - lowstale <= highstale - mid)) {\n\t\t\tif (mid - lowstale)\n\t\t\t\tmemmove(&blp[lowstale], &blp[lowstale + 1],\n\t\t\t\t\t(mid - lowstale) * sizeof(*blp));\n\t\t\tlfloglow = MIN(lowstale, lfloglow);\n\t\t\tlfloghigh = MAX(mid, lfloghigh);\n\t\t}\n\t\t/*\n\t\t * Move entries toward the high-numbered stale entry.\n\t\t */\n\t\telse {\n\t\t\tASSERT(highstale < be32_to_cpu(btp->count));\n\t\t\tmid++;\n\t\t\tif (highstale - mid)\n\t\t\t\tmemmove(&blp[mid + 1], &blp[mid],\n\t\t\t\t\t(highstale - mid) * sizeof(*blp));\n\t\t\tlfloglow = MIN(mid, lfloglow);\n\t\t\tlfloghigh = MAX(highstale, lfloghigh);\n\t\t}\n\t\tbe32_add_cpu(&btp->stale, -1);\n\t}\n\t/*\n\t * Point to the new data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\t/*\n\t * Fill in the leaf entry.\n\t */\n\tblp[mid].hashval = cpu_to_be32(args->hashval);\n\tblp[mid].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\txfs_dir2_block_log_leaf(tp, bp, lfloglow, lfloghigh);\n\t/*\n\t * Mark space for the data entry used.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)len, &needlog, &needscan);\n\t/*\n\t * Create the new data entry.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, args->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Clean up the bestfree array and log the header, tail, and entry.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_to_block",
          "args": [
            "args"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "1042-1254",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_to_block(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_dir2_db_t\t\tblkno;\t\t/* dir-relative block # (0) */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tdummy;\t\t/* trash */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tint\t\t\tendoffset;\t/* end of data objects */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to scan block freespc */\n\tint\t\t\tnewoffset;\t/* offset from current entry */\n\tint\t\t\toffset;\t\t/* target block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* sf entry pointer */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old shortform header  */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform header  */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_name\t\tname;\n\tstruct xfs_ifork\t*ifp;\n\n\ttrace_xfs_dir2_sf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tifp = XFS_IFORK_PTR(dp, XFS_DATA_FORK);\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t/*\n\t * Bomb out if the shortform directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn -EIO;\n\t}\n\n\toldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;\n\n\tASSERT(ifp->if_bytes == dp->i_d.di_size);\n\tASSERT(ifp->if_u1.if_data != NULL);\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count));\n\tASSERT(dp->i_d.di_nextents == 0);\n\n\t/*\n\t * Copy the directory into a temporary buffer.\n\t * Then pitch the incore inode data so we can make extents.\n\t */\n\tsfp = kmem_alloc(ifp->if_bytes, KM_SLEEP);\n\tmemcpy(sfp, oldsfp, ifp->if_bytes);\n\n\txfs_idata_realloc(dp, -ifp->if_bytes, XFS_DATA_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_DATA_FORK);\n\tdp->i_d.di_size = 0;\n\n\t/*\n\t * Add block 0 to the inode.\n\t */\n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, &blkno);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the data block, then convert it to block format.\n\t */\n\terror = xfs_dir3_data_init(args, blkno, &bp);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\txfs_dir3_block_init(mp, tp, bp, dp);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Compute size of block \"tail\" area.\n\t */\n\ti = (uint)sizeof(*btp) +\n\t    (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t);\n\t/*\n\t * The whole thing is initialized to free by the init routine.\n\t * Say we're using the leaf and tail area.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_use_free(args, bp, dup, args->geo->blksize - i,\n\t\t\t       i, &needlog, &needscan);\n\tASSERT(needscan == 0);\n\t/*\n\t * Fill in the tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(sfp->count + 2);\t/* ., .. */\n\tbtp->stale = 0;\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tendoffset = (uint)((char *)blp - (char *)hdr);\n\t/*\n\t * Remove the freespace, we'll manage it.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\tbe16_to_cpu(dup->length), &needlog, &needscan);\n\t/*\n\t * Create entry for .\n\t */\n\tdep = dp->d_ops->data_dot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->i_ino);\n\tdep->namelen = 1;\n\tdep->name[0] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);\n\tblp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\t/*\n\t * Create entry for ..\n\t */\n\tdep = dp->d_ops->data_dotdot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));\n\tdep->namelen = 2;\n\tdep->name[0] = dep->name[1] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);\n\tblp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\toffset = dp->d_ops->data_first_offset;\n\t/*\n\t * Loop over existing entries, stuff them in.\n\t */\n\ti = 0;\n\tif (!sfp->count)\n\t\tsfep = NULL;\n\telse\n\t\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Need to preserve the existing offset values in the sf directory.\n\t * Insert holes (unused entries) where necessary.\n\t */\n\twhile (offset < endoffset) {\n\t\t/*\n\t\t * sfep is null when we reach the end of the list.\n\t\t */\n\t\tif (sfep == NULL)\n\t\t\tnewoffset = endoffset;\n\t\telse\n\t\t\tnewoffset = xfs_dir2_sf_get_offset(sfep);\n\t\t/*\n\t\t * There should be a hole here, make one.\n\t\t */\n\t\tif (offset < newoffset) {\n\t\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\t\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\t\tdup->length = cpu_to_be16(newoffset - offset);\n\t\t\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16(\n\t\t\t\t((char *)dup - (char *)hdr));\n\t\t\txfs_dir2_data_log_unused(args, bp, dup);\n\t\t\txfs_dir2_data_freeinsert(hdr,\n\t\t\t\t\t\t dp->d_ops->data_bestfree_p(hdr),\n\t\t\t\t\t\t dup, &dummy);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Copy a real entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);\n\t\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));\n\t\tdep->namelen = sfep->namelen;\n\t\tdp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));\n\t\tmemcpy(dep->name, sfep->name, dep->namelen);\n\t\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t\txfs_dir2_data_log_entry(args, bp, dep);\n\t\tname.name = sfep->name;\n\t\tname.len = sfep->namelen;\n\t\tblp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name));\n\t\tblp[2 + i].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr));\n\t\toffset = (int)((char *)(tagp + 1) - (char *)hdr);\n\t\tif (++i == sfp->count)\n\t\t\tsfep = NULL;\n\t\telse\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/* Done with the temporary buffer */\n\tkmem_free(sfp);\n\t/*\n\t * Sort the leaf entries by hash value.\n\t */\n\txfs_sort(blp, be32_to_cpu(btp->count), sizeof(*blp), xfs_dir2_block_sort);\n\t/*\n\t * Log the leaf entry area and tail.\n\t * Already logged the header in data_init, ignore needlog.\n\t */\n\tASSERT(needscan == 0);\n\txfs_dir2_block_log_leaf(tp, bp, 0, be32_to_cpu(btp->count) - 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
            "static xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nstatic xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_to_block(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_dir2_db_t\t\tblkno;\t\t/* dir-relative block # (0) */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tdummy;\t\t/* trash */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tint\t\t\tendoffset;\t/* end of data objects */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to scan block freespc */\n\tint\t\t\tnewoffset;\t/* offset from current entry */\n\tint\t\t\toffset;\t\t/* target block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* sf entry pointer */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old shortform header  */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform header  */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_name\t\tname;\n\tstruct xfs_ifork\t*ifp;\n\n\ttrace_xfs_dir2_sf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tifp = XFS_IFORK_PTR(dp, XFS_DATA_FORK);\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t/*\n\t * Bomb out if the shortform directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn -EIO;\n\t}\n\n\toldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;\n\n\tASSERT(ifp->if_bytes == dp->i_d.di_size);\n\tASSERT(ifp->if_u1.if_data != NULL);\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count));\n\tASSERT(dp->i_d.di_nextents == 0);\n\n\t/*\n\t * Copy the directory into a temporary buffer.\n\t * Then pitch the incore inode data so we can make extents.\n\t */\n\tsfp = kmem_alloc(ifp->if_bytes, KM_SLEEP);\n\tmemcpy(sfp, oldsfp, ifp->if_bytes);\n\n\txfs_idata_realloc(dp, -ifp->if_bytes, XFS_DATA_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_DATA_FORK);\n\tdp->i_d.di_size = 0;\n\n\t/*\n\t * Add block 0 to the inode.\n\t */\n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, &blkno);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the data block, then convert it to block format.\n\t */\n\terror = xfs_dir3_data_init(args, blkno, &bp);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\txfs_dir3_block_init(mp, tp, bp, dp);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Compute size of block \"tail\" area.\n\t */\n\ti = (uint)sizeof(*btp) +\n\t    (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t);\n\t/*\n\t * The whole thing is initialized to free by the init routine.\n\t * Say we're using the leaf and tail area.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_use_free(args, bp, dup, args->geo->blksize - i,\n\t\t\t       i, &needlog, &needscan);\n\tASSERT(needscan == 0);\n\t/*\n\t * Fill in the tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(sfp->count + 2);\t/* ., .. */\n\tbtp->stale = 0;\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tendoffset = (uint)((char *)blp - (char *)hdr);\n\t/*\n\t * Remove the freespace, we'll manage it.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\tbe16_to_cpu(dup->length), &needlog, &needscan);\n\t/*\n\t * Create entry for .\n\t */\n\tdep = dp->d_ops->data_dot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->i_ino);\n\tdep->namelen = 1;\n\tdep->name[0] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);\n\tblp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\t/*\n\t * Create entry for ..\n\t */\n\tdep = dp->d_ops->data_dotdot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));\n\tdep->namelen = 2;\n\tdep->name[0] = dep->name[1] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);\n\tblp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\toffset = dp->d_ops->data_first_offset;\n\t/*\n\t * Loop over existing entries, stuff them in.\n\t */\n\ti = 0;\n\tif (!sfp->count)\n\t\tsfep = NULL;\n\telse\n\t\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Need to preserve the existing offset values in the sf directory.\n\t * Insert holes (unused entries) where necessary.\n\t */\n\twhile (offset < endoffset) {\n\t\t/*\n\t\t * sfep is null when we reach the end of the list.\n\t\t */\n\t\tif (sfep == NULL)\n\t\t\tnewoffset = endoffset;\n\t\telse\n\t\t\tnewoffset = xfs_dir2_sf_get_offset(sfep);\n\t\t/*\n\t\t * There should be a hole here, make one.\n\t\t */\n\t\tif (offset < newoffset) {\n\t\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\t\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\t\tdup->length = cpu_to_be16(newoffset - offset);\n\t\t\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16(\n\t\t\t\t((char *)dup - (char *)hdr));\n\t\t\txfs_dir2_data_log_unused(args, bp, dup);\n\t\t\txfs_dir2_data_freeinsert(hdr,\n\t\t\t\t\t\t dp->d_ops->data_bestfree_p(hdr),\n\t\t\t\t\t\t dup, &dummy);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Copy a real entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);\n\t\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));\n\t\tdep->namelen = sfep->namelen;\n\t\tdp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));\n\t\tmemcpy(dep->name, sfep->name, dep->namelen);\n\t\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t\txfs_dir2_data_log_entry(args, bp, dep);\n\t\tname.name = sfep->name;\n\t\tname.len = sfep->namelen;\n\t\tblp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name));\n\t\tblp[2 + i].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr));\n\t\toffset = (int)((char *)(tagp + 1) - (char *)hdr);\n\t\tif (++i == sfp->count)\n\t\t\tsfep = NULL;\n\t\telse\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/* Done with the temporary buffer */\n\tkmem_free(sfp);\n\t/*\n\t * Sort the leaf entries by hash value.\n\t */\n\txfs_sort(blp, be32_to_cpu(btp->count), sizeof(*blp), xfs_dir2_block_sort);\n\t/*\n\t * Log the leaf entry area and tail.\n\t * Already logged the header in data_init, ignore needlog.\n\t */\n\tASSERT(needscan == 0);\n\txfs_dir2_block_log_leaf(tp, bp, 0, be32_to_cpu(btp->count) - 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_addname_pick",
          "args": [
            "args",
            "objchange",
            "&sfep",
            "&offset"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_addname_pick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "530-595",
          "snippet": "static int\t\t\t\t\t/* pick result */\nxfs_dir2_sf_addname_pick(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tobjchange,\t/* inode # size changes */\n\txfs_dir2_sf_entry_t\t**sfepp,\t/* out(1): new entry ptr */\n\txfs_dir2_data_aoff_t\t*offsetp)\t/* out(1): new offset */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tholefit;\t/* found hole it will fit in */\n\tint\t\t\ti;\t\t/* entry number */\n\txfs_dir2_data_aoff_t\toffset;\t\t/* data block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tint\t\t\tsize;\t\t/* entry's data size */\n\tint\t\t\tused;\t\t/* data bytes used */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsize = dp->d_ops->data_entsize(args->namelen);\n\toffset = dp->d_ops->data_first_offset;\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\tholefit = 0;\n\t/*\n\t * Loop over sf entries.\n\t * Keep track of data offset and whether we've seen a place\n\t * to insert the new entry.\n\t */\n\tfor (i = 0; i < sfp->count; i++) {\n\t\tif (!holefit)\n\t\t\tholefit = offset + size <= xfs_dir2_sf_get_offset(sfep);\n\t\toffset = xfs_dir2_sf_get_offset(sfep) +\n\t\t\t dp->d_ops->data_entsize(sfep->namelen);\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/*\n\t * Calculate data bytes used excluding the new entry, if this\n\t * was a data block (block form directory).\n\t */\n\tused = offset +\n\t       (sfp->count + 3) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t);\n\t/*\n\t * If it won't fit in a block form then we can't insert it,\n\t * we'll go back, convert to block, then try the insert and convert\n\t * to leaf.\n\t */\n\tif (used + (holefit ? 0 : size) > args->geo->blksize)\n\t\treturn 0;\n\t/*\n\t * If changing the inode number size, do it the hard way.\n\t */\n\tif (objchange)\n\t\treturn 2;\n\t/*\n\t * If it won't fit at the end then do it the hard way (use the hole).\n\t */\n\tif (used + size > args->geo->blksize)\n\t\treturn 2;\n\t/*\n\t * Do it the easy way.\n\t */\n\t*sfepp = sfep;\n\t*offsetp = offset;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_sf_addname_pick(xfs_da_args_t *args, int objchange,\n\t\t\t\t    xfs_dir2_sf_entry_t **sfepp,\n\t\t\t\t    xfs_dir2_data_aoff_t *offsetp);",
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_sf_addname_pick(xfs_da_args_t *args, int objchange,\n\t\t\t\t    xfs_dir2_sf_entry_t **sfepp,\n\t\t\t\t    xfs_dir2_data_aoff_t *offsetp);\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic int\t\t\t\t\t/* pick result */\nxfs_dir2_sf_addname_pick(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tobjchange,\t/* inode # size changes */\n\txfs_dir2_sf_entry_t\t**sfepp,\t/* out(1): new entry ptr */\n\txfs_dir2_data_aoff_t\t*offsetp)\t/* out(1): new offset */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tholefit;\t/* found hole it will fit in */\n\tint\t\t\ti;\t\t/* entry number */\n\txfs_dir2_data_aoff_t\toffset;\t\t/* data block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tint\t\t\tsize;\t\t/* entry's data size */\n\tint\t\t\tused;\t\t/* data bytes used */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tsize = dp->d_ops->data_entsize(args->namelen);\n\toffset = dp->d_ops->data_first_offset;\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\tholefit = 0;\n\t/*\n\t * Loop over sf entries.\n\t * Keep track of data offset and whether we've seen a place\n\t * to insert the new entry.\n\t */\n\tfor (i = 0; i < sfp->count; i++) {\n\t\tif (!holefit)\n\t\t\tholefit = offset + size <= xfs_dir2_sf_get_offset(sfep);\n\t\toffset = xfs_dir2_sf_get_offset(sfep) +\n\t\t\t dp->d_ops->data_entsize(sfep->namelen);\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/*\n\t * Calculate data bytes used excluding the new entry, if this\n\t * was a data block (block form directory).\n\t */\n\tused = offset +\n\t       (sfp->count + 3) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t);\n\t/*\n\t * If it won't fit in a block form then we can't insert it,\n\t * we'll go back, convert to block, then try the insert and convert\n\t * to leaf.\n\t */\n\tif (used + (holefit ? 0 : size) > args->geo->blksize)\n\t\treturn 0;\n\t/*\n\t * If changing the inode number size, do it the hard way.\n\t */\n\tif (objchange)\n\t\treturn 2;\n\t/*\n\t * If it won't fit at the end then do it the hard way (use the hole).\n\t */\n\tif (used + size > args->geo->blksize)\n\t\treturn 2;\n\t/*\n\t * Do it the easy way.\n\t */\n\t*sfepp = sfep;\n\t*offsetp = offset;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "dp"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_entsize",
          "args": [
            "sfp",
            "args->namelen"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "sfp->i8count"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_u1.if_data != NULL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_bytes == dp->i_d.di_size"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(dp->i_mount)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_flags & XFS_IFINLINE"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_dir2_sf_lookup(args) == -ENOENT"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_lookup",
          "args": [
            "args"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "696-776",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\terror;\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\txfs_dir2_sf_entry_t\t*ci_sfep;\t/* case-insens. entry */\n\n\ttrace_xfs_dir2_sf_lookup(args);\n\n\txfs_dir2_sf_check(args);\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Special case for .\n\t */\n\tif (args->namelen == 1 && args->name[0] == '.') {\n\t\targs->inumber = dp->i_ino;\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Special case for ..\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\targs->inumber = dp->d_ops->sf_get_parent_ino(sfp);\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Loop over all the entries trying to match ours.\n\t */\n\tci_sfep = NULL;\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the inode\n\t\t * number. If it's the first case-insensitive match, store the\n\t\t * inode number and continue looking for an exact match.\n\t\t */\n\t\tcmp = dp->i_mount->m_dirnameops->compname(args, sfep->name,\n\t\t\t\t\t\t\t\tsfep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\targs->filetype = dp->d_ops->sf_get_ftype(sfep);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t\tci_sfep = sfep;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was not found, return -ENOENT.\n\t */\n\tif (!ci_sfep)\n\t\treturn -ENOENT;\n\t/* otherwise process the CI match as required by the caller */\n\terror = xfs_dir_cilookup_result(args, ci_sfep->name, ci_sfep->namelen);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry index */\n\tint\t\t\terror;\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\txfs_dir2_sf_entry_t\t*ci_sfep;\t/* case-insens. entry */\n\n\ttrace_xfs_dir2_sf_lookup(args);\n\n\txfs_dir2_sf_check(args);\n\tdp = args->dp;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Bail out if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Special case for .\n\t */\n\tif (args->namelen == 1 && args->name[0] == '.') {\n\t\targs->inumber = dp->i_ino;\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Special case for ..\n\t */\n\tif (args->namelen == 2 &&\n\t    args->name[0] == '.' && args->name[1] == '.') {\n\t\targs->inumber = dp->d_ops->sf_get_parent_ino(sfp);\n\t\targs->cmpresult = XFS_CMP_EXACT;\n\t\targs->filetype = XFS_DIR3_FT_DIR;\n\t\treturn -EEXIST;\n\t}\n\t/*\n\t * Loop over all the entries trying to match ours.\n\t */\n\tci_sfep = NULL;\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp); i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the inode\n\t\t * number. If it's the first case-insensitive match, store the\n\t\t * inode number and continue looking for an exact match.\n\t\t */\n\t\tcmp = dp->i_mount->m_dirnameops->compname(args, sfep->name,\n\t\t\t\t\t\t\t\tsfep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\t\targs->filetype = dp->d_ops->sf_get_ftype(sfep);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t\tci_sfep = sfep;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was not found, return -ENOENT.\n\t */\n\tif (!ci_sfep)\n\t\treturn -ENOENT;\n\t/* otherwise process the CI match as required by the caller */\n\terror = xfs_dir_cilookup_result(args, ci_sfep->name, ci_sfep->namelen);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_sf_addname",
          "args": [
            "args"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_addname_easy(xfs_da_args_t *args,\n\t\t\t\t     xfs_dir2_sf_entry_t *sfep,\n\t\t\t\t     xfs_dir2_data_aoff_t offset,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_addname_hard(xfs_da_args_t *args, int objchange,\n\t\t\t\t     int new_isize);\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tincr_isize;\t/* total change in size */\n\tint\t\t\tnew_isize;\t/* di_size after adding name */\n\tint\t\t\tobjchange;\t/* changing to 8-byte inodes */\n\txfs_dir2_data_aoff_t\toffset = 0;\t/* offset for new entry */\n\tint\t\t\tpick;\t\t/* which algorithm to use */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_sf_entry_t\t*sfep = NULL;\t/* shortform entry */\n\n\ttrace_xfs_dir2_sf_addname(args);\n\n\tASSERT(xfs_dir2_sf_lookup(args) == -ENOENT);\n\tdp = args->dp;\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Make sure the shortform value has some of its header.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\t/*\n\t * Compute entry (and change in) size.\n\t */\n\tincr_isize = dp->d_ops->sf_entsize(sfp, args->namelen);\n\tobjchange = 0;\n\n\t/*\n\t * Do we have to change to 8 byte inodes?\n\t */\n\tif (args->inumber > XFS_DIR2_MAX_SHORT_INUM && sfp->i8count == 0) {\n\t\t/*\n\t\t * Yes, adjust the inode size.  old count + (parent + new)\n\t\t */\n\t\tincr_isize +=\n\t\t\t(sfp->count + 2) *\n\t\t\t((uint)sizeof(xfs_dir2_ino8_t) -\n\t\t\t (uint)sizeof(xfs_dir2_ino4_t));\n\t\tobjchange = 1;\n\t}\n\n\tnew_isize = (int)dp->i_d.di_size + incr_isize;\n\t/*\n\t * Won't fit as shortform any more (due to size),\n\t * or the pick routine says it won't (due to offset values).\n\t */\n\tif (new_isize > XFS_IFORK_DSIZE(dp) ||\n\t    (pick =\n\t     xfs_dir2_sf_addname_pick(args, objchange, &sfep, &offset)) == 0) {\n\t\t/*\n\t\t * Just checking or no space reservation, it doesn't fit.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to block form then add the name.\n\t\t */\n\t\terror = xfs_dir2_sf_to_block(args);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_block_addname(args);\n\t}\n\t/*\n\t * Just checking, it fits.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\t/*\n\t * Do it the easy way - just add it at the end.\n\t */\n\tif (pick == 1)\n\t\txfs_dir2_sf_addname_easy(args, sfep, offset, new_isize);\n\t/*\n\t * Do it the hard way - look for a place to insert the new entry.\n\t * Convert to 8 byte inode numbers first if necessary.\n\t */\n\telse {\n\t\tASSERT(pick == 2);\n\t\tif (objchange)\n\t\t\txfs_dir2_sf_toino8(args);\n\t\txfs_dir2_sf_addname_hard(args, objchange, new_isize);\n\t}\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_DDATA);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_block_to_sf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "152-274",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_sf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tsize,\t\t/* shortform directory size */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* shortform directory hdr */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data pointer */\n\tchar\t\t\t*endptr;\t/* end of data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlogflags;\t/* inode logging flags */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*ptr;\t\t/* current data pointer */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform directory header */\n\txfs_dir2_sf_hdr_t\t*dst;\t\t/* temporary data buffer */\n\n\ttrace_xfs_dir2_block_to_sf(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\n\t/*\n\t * allocate a temporary destination buffer the size of the inode\n\t * to format the data into. Once we have formatted the data, we\n\t * can free the block and copy the formatted data into the inode literal\n\t * area.\n\t */\n\tdst = kmem_alloc(mp->m_sb.sb_inodesize, KM_SLEEP);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Copy the header into the newly allocate local space.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dst;\n\tmemcpy(sfp, sfhp, xfs_dir2_sf_hdr_size(sfhp->i8count));\n\n\t/*\n\t * Set up to loop over the block's entries.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Loop over the active and unused entries.\n\t * Stop when we reach the leaf/tail portion of the block.\n\t */\n\twhile (ptr < endptr) {\n\t\t/*\n\t\t * If it's unused, just skip over it.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t/*\n\t\t * Skip .\n\t\t */\n\t\tif (dep->namelen == 1 && dep->name[0] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) == dp->i_ino);\n\t\t/*\n\t\t * Skip .., but make sure the inode number is right.\n\t\t */\n\t\telse if (dep->namelen == 2 &&\n\t\t\t dep->name[0] == '.' && dep->name[1] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) ==\n\t\t\t       dp->d_ops->sf_get_parent_ino(sfp));\n\t\t/*\n\t\t * Normal entry, copy it into shortform.\n\t\t */\n\t\telse {\n\t\t\tsfep->namelen = dep->namelen;\n\t\t\txfs_dir2_sf_put_offset(sfep,\n\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tmemcpy(sfep->name, dep->name, dep->namelen);\n\t\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t\t      be64_to_cpu(dep->inumber));\n\t\t\tdp->d_ops->sf_put_ftype(sfep,\n\t\t\t\t\tdp->d_ops->data_get_ftype(dep));\n\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t}\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t}\n\tASSERT((char *)sfep - (char *)sfp == size);\n\n\t/* now we are done with the block, we can shrink the inode */\n\tlogflags = XFS_ILOG_CORE;\n\terror = xfs_dir2_shrink_inode(args, args->geo->datablk, bp);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The buffer is now unconditionally gone, whether\n\t * xfs_dir2_shrink_inode worked or not.\n\t *\n\t * Convert the inode to local format and copy the data in.\n\t */\n\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\n\tdp->i_df.if_flags |= XFS_IFINLINE;\n\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\tASSERT(dp->i_df.if_bytes == 0);\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\n\tlogflags |= XFS_ILOG_DDATA;\n\tmemcpy(dp->i_df.if_u1.if_data, dst, size);\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\nout:\n\txfs_trans_log_inode(args->trans, dp, logflags);\n\tkmem_free(dst);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
      "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "dst"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args->trans",
            "dp",
            "logflags"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_check",
          "args": [
            "args"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "601-636",
          "snippet": "static void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nstatic void\nxfs_dir2_sf_check(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\ti;\t\t/* entry number */\n\tint\t\t\ti8count;\t/* number of big inode#s */\n\txfs_ino_t\t\tino;\t\t/* entry inode number */\n\tint\t\t\toffset;\t\t/* data offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform dir entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\n\tdp = args->dp;\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\toffset = dp->d_ops->data_first_offset;\n\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\ti8count = ino > XFS_DIR2_MAX_SHORT_INUM;\n\n\tfor (i = 0, sfep = xfs_dir2_sf_firstentry(sfp);\n\t     i < sfp->count;\n\t     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep)) {\n\t\tASSERT(xfs_dir2_sf_get_offset(sfep) >= offset);\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\ti8count += ino > XFS_DIR2_MAX_SHORT_INUM;\n\t\toffset =\n\t\t\txfs_dir2_sf_get_offset(sfep) +\n\t\t\tdp->d_ops->data_entsize(sfep->namelen);\n\t\tASSERT(dp->d_ops->sf_get_ftype(sfep) < XFS_DIR3_FT_MAX);\n\t}\n\tASSERT(i8count == sfp->i8count);\n\tASSERT((char *)sfep - (char *)sfp == dp->i_d.di_size);\n\tASSERT(offset +\n\t       (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t) +\n\t       (uint)sizeof(xfs_dir2_block_tail_t) <= args->geo->blksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dp->i_df.if_u1.if_data",
            "dst",
            "size"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "size",
            "XFS_DATA_FORK"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_bytes == 0"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOSPC"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_shrink_inode",
          "args": [
            "args",
            "args->geo->datablk",
            "bp"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "657-731",
          "snippet": "int\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(char *)sfep - (char *)sfp == size"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ftype",
          "args": [
            "sfep",
            "dp->d_ops->data_get_ftype(dep)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_get_ftype",
          "args": [
            "dep"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_ino",
          "args": [
            "sfp",
            "sfep",
            "be64_to_cpu(dep->inumber)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfep->name",
            "dep->name",
            "dep->namelen"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_put_offset",
          "args": [
            "sfep",
            "(xfs_dir2_data_aoff_t)\n\t\t\t\t((char *)dep - (char *)hdr)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_put_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "278-282",
          "snippet": "static inline void\nxfs_dir2_sf_put_offset(xfs_dir2_sf_entry_t *sfep, xfs_dir2_data_aoff_t off)\n{\n\tput_unaligned_be16(off, &sfep->offset.i);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_dir2_sf_put_offset(xfs_dir2_sf_entry_t *sfep, xfs_dir2_data_aoff_t off)\n{\n\tput_unaligned_be16(off, &sfep->offset.i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(dep->inumber) ==\n\t\t\t       dp->d_ops->sf_get_parent_ino(sfp)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_parent_ino",
          "args": [
            "sfp"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(dep->inumber) == dp->i_ino"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "sfp"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_p",
          "args": [
            "hdr"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfp",
            "sfhp",
            "xfs_dir2_sf_hdr_size(sfhp->i8count)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "sfhp->i8count"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "mp->m_sb.sb_inodesize",
            "KM_SLEEP"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_block_to_sf",
          "args": [
            "args"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_sf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tsize,\t\t/* shortform directory size */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* shortform directory hdr */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data pointer */\n\tchar\t\t\t*endptr;\t/* end of data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlogflags;\t/* inode logging flags */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*ptr;\t\t/* current data pointer */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform directory header */\n\txfs_dir2_sf_hdr_t\t*dst;\t\t/* temporary data buffer */\n\n\ttrace_xfs_dir2_block_to_sf(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\n\t/*\n\t * allocate a temporary destination buffer the size of the inode\n\t * to format the data into. Once we have formatted the data, we\n\t * can free the block and copy the formatted data into the inode literal\n\t * area.\n\t */\n\tdst = kmem_alloc(mp->m_sb.sb_inodesize, KM_SLEEP);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Copy the header into the newly allocate local space.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dst;\n\tmemcpy(sfp, sfhp, xfs_dir2_sf_hdr_size(sfhp->i8count));\n\n\t/*\n\t * Set up to loop over the block's entries.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Loop over the active and unused entries.\n\t * Stop when we reach the leaf/tail portion of the block.\n\t */\n\twhile (ptr < endptr) {\n\t\t/*\n\t\t * If it's unused, just skip over it.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t/*\n\t\t * Skip .\n\t\t */\n\t\tif (dep->namelen == 1 && dep->name[0] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) == dp->i_ino);\n\t\t/*\n\t\t * Skip .., but make sure the inode number is right.\n\t\t */\n\t\telse if (dep->namelen == 2 &&\n\t\t\t dep->name[0] == '.' && dep->name[1] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) ==\n\t\t\t       dp->d_ops->sf_get_parent_ino(sfp));\n\t\t/*\n\t\t * Normal entry, copy it into shortform.\n\t\t */\n\t\telse {\n\t\t\tsfep->namelen = dep->namelen;\n\t\t\txfs_dir2_sf_put_offset(sfep,\n\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tmemcpy(sfep->name, dep->name, dep->namelen);\n\t\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t\t      be64_to_cpu(dep->inumber));\n\t\t\tdp->d_ops->sf_put_ftype(sfep,\n\t\t\t\t\tdp->d_ops->data_get_ftype(dep));\n\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t}\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t}\n\tASSERT((char *)sfep - (char *)sfp == size);\n\n\t/* now we are done with the block, we can shrink the inode */\n\tlogflags = XFS_ILOG_CORE;\n\terror = xfs_dir2_shrink_inode(args, args->geo->datablk, bp);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The buffer is now unconditionally gone, whether\n\t * xfs_dir2_shrink_inode worked or not.\n\t *\n\t * Convert the inode to local format and copy the data in.\n\t */\n\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\n\tdp->i_df.if_flags |= XFS_IFINLINE;\n\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\tASSERT(dp->i_df.if_bytes == 0);\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\n\tlogflags |= XFS_ILOG_DDATA;\n\tmemcpy(dp->i_df.if_u1.if_data, dst, size);\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\nout:\n\txfs_trans_log_inode(args->trans, dp, logflags);\n\tkmem_free(dst);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir2_block_sfsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
    "lines": "61-146",
    "snippet": "int\t\t\t\t\t\t/* size for sf form */\nxfs_dir2_block_sfsize(\n\txfs_inode_t\t\t*dp,\t\t/* incore inode pointer */\n\txfs_dir2_data_hdr_t\t*hdr,\t\t/* block directory data */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* output: header for sf form */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* leaf area of the block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* tail area of the block */\n\tint\t\t\tcount;\t\t/* shortform entry count */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry in the block */\n\tint\t\t\ti;\t\t/* block entry index */\n\tint\t\t\ti8count;\t/* count of big-inode entries */\n\tint\t\t\tisdot;\t\t/* entry is \".\" */\n\tint\t\t\tisdotdot;\t/* entry is \"..\" */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure pointer */\n\tint\t\t\tnamelen;\t/* total name bytes */\n\txfs_ino_t\t\tparent = 0;\t/* parent inode number */\n\tint\t\t\tsize=0;\t\t/* total computed size */\n\tint\t\t\thas_ftype;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = dp->i_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * if there is a filetype field, add the extra byte to the namelen\n\t * for each entry that we see.\n\t */\n\thas_ftype = xfs_sb_version_hasftype(&mp->m_sb) ? 1 : 0;\n\n\tcount = i8count = namelen = 0;\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Iterate over the block's data entries by using the leaf pointers.\n\t */\n\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\tif ((addr = be32_to_cpu(blp[i].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Calculate the pointer to the entry at hand.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\t\txfs_dir2_dataptr_to_off(geo, addr));\n\t\t/*\n\t\t * Detect . and .., so we can special-case them.\n\t\t * . is not included in sf directories.\n\t\t * .. is included by just the parent inode number.\n\t\t */\n\t\tisdot = dep->namelen == 1 && dep->name[0] == '.';\n\t\tisdotdot =\n\t\t\tdep->namelen == 2 &&\n\t\t\tdep->name[0] == '.' && dep->name[1] == '.';\n\n\t\tif (!isdot)\n\t\t\ti8count += be64_to_cpu(dep->inumber) > XFS_DIR2_MAX_SHORT_INUM;\n\n\t\t/* take into account the file type field */\n\t\tif (!isdot && !isdotdot) {\n\t\t\tcount++;\n\t\t\tnamelen += dep->namelen + has_ftype;\n\t\t} else if (isdotdot)\n\t\t\tparent = be64_to_cpu(dep->inumber);\n\t\t/*\n\t\t * Calculate the new size, see if we should give up yet.\n\t\t */\n\t\tsize = xfs_dir2_sf_hdr_size(i8count) +\t\t/* header */\n\t\t       count +\t\t\t\t\t/* namelen */\n\t\t       count * (uint)sizeof(xfs_dir2_sf_off_t) + /* offset */\n\t\t       namelen +\t\t\t\t/* name */\n\t\t       (i8count ?\t\t\t\t/* inumber */\n\t\t\t\t(uint)sizeof(xfs_dir2_ino8_t) * count :\n\t\t\t\t(uint)sizeof(xfs_dir2_ino4_t) * count);\n\t\tif (size > XFS_IFORK_DSIZE(dp))\n\t\t\treturn size;\t\t/* size value is a failure */\n\t}\n\t/*\n\t * Create the output header, if it worked.\n\t */\n\tsfhp->count = count;\n\tsfhp->i8count = i8count;\n\tdp->d_ops->sf_put_parent_ino(sfhp, parent);\n\treturn size;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp->d_ops->sf_put_parent_ino",
          "args": [
            "sfhp",
            "parent"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "dp"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "i8count"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "geo",
            "addr"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[i].address"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "geo",
            "hdr"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasftype",
          "args": [
            "&mp->m_sb"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasftype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "557-563",
          "snippet": "static inline int xfs_sb_version_hasftype(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_FTYPE)) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_INCOMPAT_FTYPE\t(1 << 0)\t/* filetype in dirent */",
            "#define XFS_SB_VERSION2_FTYPE\t\t0x00000200\t/* inode type in dir */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_INCOMPAT_FTYPE\t(1 << 0)\t/* filetype in dirent */\n#define XFS_SB_VERSION2_FTYPE\t\t0x00000200\t/* inode type in dir */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasftype(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_FTYPE)) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* size for sf form */\nxfs_dir2_block_sfsize(\n\txfs_inode_t\t\t*dp,\t\t/* incore inode pointer */\n\txfs_dir2_data_hdr_t\t*hdr,\t\t/* block directory data */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* output: header for sf form */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* leaf area of the block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* tail area of the block */\n\tint\t\t\tcount;\t\t/* shortform entry count */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry in the block */\n\tint\t\t\ti;\t\t/* block entry index */\n\tint\t\t\ti8count;\t/* count of big-inode entries */\n\tint\t\t\tisdot;\t\t/* entry is \".\" */\n\tint\t\t\tisdotdot;\t/* entry is \"..\" */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure pointer */\n\tint\t\t\tnamelen;\t/* total name bytes */\n\txfs_ino_t\t\tparent = 0;\t/* parent inode number */\n\tint\t\t\tsize=0;\t\t/* total computed size */\n\tint\t\t\thas_ftype;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = dp->i_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * if there is a filetype field, add the extra byte to the namelen\n\t * for each entry that we see.\n\t */\n\thas_ftype = xfs_sb_version_hasftype(&mp->m_sb) ? 1 : 0;\n\n\tcount = i8count = namelen = 0;\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Iterate over the block's data entries by using the leaf pointers.\n\t */\n\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\tif ((addr = be32_to_cpu(blp[i].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Calculate the pointer to the entry at hand.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\t\txfs_dir2_dataptr_to_off(geo, addr));\n\t\t/*\n\t\t * Detect . and .., so we can special-case them.\n\t\t * . is not included in sf directories.\n\t\t * .. is included by just the parent inode number.\n\t\t */\n\t\tisdot = dep->namelen == 1 && dep->name[0] == '.';\n\t\tisdotdot =\n\t\t\tdep->namelen == 2 &&\n\t\t\tdep->name[0] == '.' && dep->name[1] == '.';\n\n\t\tif (!isdot)\n\t\t\ti8count += be64_to_cpu(dep->inumber) > XFS_DIR2_MAX_SHORT_INUM;\n\n\t\t/* take into account the file type field */\n\t\tif (!isdot && !isdotdot) {\n\t\t\tcount++;\n\t\t\tnamelen += dep->namelen + has_ftype;\n\t\t} else if (isdotdot)\n\t\t\tparent = be64_to_cpu(dep->inumber);\n\t\t/*\n\t\t * Calculate the new size, see if we should give up yet.\n\t\t */\n\t\tsize = xfs_dir2_sf_hdr_size(i8count) +\t\t/* header */\n\t\t       count +\t\t\t\t\t/* namelen */\n\t\t       count * (uint)sizeof(xfs_dir2_sf_off_t) + /* offset */\n\t\t       namelen +\t\t\t\t/* name */\n\t\t       (i8count ?\t\t\t\t/* inumber */\n\t\t\t\t(uint)sizeof(xfs_dir2_ino8_t) * count :\n\t\t\t\t(uint)sizeof(xfs_dir2_ino4_t) * count);\n\t\tif (size > XFS_IFORK_DSIZE(dp))\n\t\t\treturn size;\t\t/* size value is a failure */\n\t}\n\t/*\n\t * Create the output header, if it worked.\n\t */\n\tsfhp->count = count;\n\tsfhp->i8count = i8count;\n\tdp->d_ops->sf_put_parent_ino(sfhp, parent);\n\treturn size;\n}"
  }
]