[
  {
    "function_name": "kmem_zone_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
    "lines": "110-127",
    "snippet": "void *\nkmem_zone_alloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmem_cache_alloc(zone, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
    "includes": [
      "#include \"xfs_message.h\"",
      "#include \"kmem.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/50"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_err",
          "args": [
            "NULL",
            "\"possible memory allocation deadlock in %s (mode:0x%x)\"",
            "__func__",
            "lflags"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "zone",
            "lflags"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_flags_convert",
          "args": [
            "flags"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_flags_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "42-61",
          "snippet": "static inline gfp_t\nkmem_flags_convert(xfs_km_flags_t flags)\n{\n\tgfp_t\tlflags;\n\n\tBUG_ON(flags & ~(KM_SLEEP|KM_NOSLEEP|KM_NOFS|KM_MAYFAIL|KM_ZERO));\n\n\tif (flags & KM_NOSLEEP) {\n\t\tlflags = GFP_ATOMIC | __GFP_NOWARN;\n\t} else {\n\t\tlflags = GFP_KERNEL | __GFP_NOWARN;\n\t\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\t\tlflags &= ~__GFP_FS;\n\t}\n\n\tif (flags & KM_ZERO)\n\t\tlflags |= __GFP_ZERO;\n\n\treturn lflags;\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)",
            "#define KM_MAYFAIL\t((__force xfs_km_flags_t)0x0008u)",
            "#define KM_NOFS\t\t((__force xfs_km_flags_t)0x0004u)",
            "#define KM_NOSLEEP\t((__force xfs_km_flags_t)0x0002u)",
            "#define KM_SLEEP\t((__force xfs_km_flags_t)0x0001u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n#define KM_MAYFAIL\t((__force xfs_km_flags_t)0x0008u)\n#define KM_NOFS\t\t((__force xfs_km_flags_t)0x0004u)\n#define KM_NOSLEEP\t((__force xfs_km_flags_t)0x0002u)\n#define KM_SLEEP\t((__force xfs_km_flags_t)0x0001u)\n\nstatic inline gfp_t\nkmem_flags_convert(xfs_km_flags_t flags)\n{\n\tgfp_t\tlflags;\n\n\tBUG_ON(flags & ~(KM_SLEEP|KM_NOSLEEP|KM_NOFS|KM_MAYFAIL|KM_ZERO));\n\n\tif (flags & KM_NOSLEEP) {\n\t\tlflags = GFP_ATOMIC | __GFP_NOWARN;\n\t} else {\n\t\tlflags = GFP_KERNEL | __GFP_NOWARN;\n\t\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\t\tlflags &= ~__GFP_FS;\n\t}\n\n\tif (flags & KM_ZERO)\n\t\tlflags |= __GFP_ZERO;\n\n\treturn lflags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zone_alloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmem_cache_alloc(zone, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
  },
  {
    "function_name": "kmem_realloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
    "lines": "94-108",
    "snippet": "void *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}",
    "includes": [
      "#include \"xfs_message.h\"",
      "#include \"kmem.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ptr"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new",
            "ptr",
            "((oldsize < newsize) ? oldsize : newsize)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "newsize",
            "flags"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}"
  },
  {
    "function_name": "kmem_zalloc_large",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
    "lines": "64-92",
    "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
    "includes": [
      "#include \"xfs_message.h\"",
      "#include \"kmem.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memalloc_noio_restore",
          "args": [
            "noio_flag"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "lflags | __GFP_HIGHMEM | __GFP_ZERO",
            "PAGE_KERNEL"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_flags_convert",
          "args": [
            "flags"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_flags_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "42-61",
          "snippet": "static inline gfp_t\nkmem_flags_convert(xfs_km_flags_t flags)\n{\n\tgfp_t\tlflags;\n\n\tBUG_ON(flags & ~(KM_SLEEP|KM_NOSLEEP|KM_NOFS|KM_MAYFAIL|KM_ZERO));\n\n\tif (flags & KM_NOSLEEP) {\n\t\tlflags = GFP_ATOMIC | __GFP_NOWARN;\n\t} else {\n\t\tlflags = GFP_KERNEL | __GFP_NOWARN;\n\t\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\t\tlflags &= ~__GFP_FS;\n\t}\n\n\tif (flags & KM_ZERO)\n\t\tlflags |= __GFP_ZERO;\n\n\treturn lflags;\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)",
            "#define KM_MAYFAIL\t((__force xfs_km_flags_t)0x0008u)",
            "#define KM_NOFS\t\t((__force xfs_km_flags_t)0x0004u)",
            "#define KM_NOSLEEP\t((__force xfs_km_flags_t)0x0002u)",
            "#define KM_SLEEP\t((__force xfs_km_flags_t)0x0001u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n#define KM_MAYFAIL\t((__force xfs_km_flags_t)0x0008u)\n#define KM_NOFS\t\t((__force xfs_km_flags_t)0x0004u)\n#define KM_NOSLEEP\t((__force xfs_km_flags_t)0x0002u)\n#define KM_SLEEP\t((__force xfs_km_flags_t)0x0001u)\n\nstatic inline gfp_t\nkmem_flags_convert(xfs_km_flags_t flags)\n{\n\tgfp_t\tlflags;\n\n\tBUG_ON(flags & ~(KM_SLEEP|KM_NOSLEEP|KM_NOFS|KM_MAYFAIL|KM_ZERO));\n\n\tif (flags & KM_NOSLEEP) {\n\t\tlflags = GFP_ATOMIC | __GFP_NOWARN;\n\t} else {\n\t\tlflags = GFP_KERNEL | __GFP_NOWARN;\n\t\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\t\tlflags &= ~__GFP_FS;\n\t}\n\n\tif (flags & KM_ZERO)\n\t\tlflags |= __GFP_ZERO;\n\n\treturn lflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noio_save",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "size",
            "flags | KM_MAYFAIL"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "kmem_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
    "lines": "45-62",
    "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
    "includes": [
      "#include \"xfs_message.h\"",
      "#include \"kmem.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/50"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_err",
          "args": [
            "NULL",
            "\"possible memory allocation deadlock in %s (mode:0x%x)\"",
            "__func__",
            "lflags"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "lflags"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_flags_convert",
          "args": [
            "flags"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_flags_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "42-61",
          "snippet": "static inline gfp_t\nkmem_flags_convert(xfs_km_flags_t flags)\n{\n\tgfp_t\tlflags;\n\n\tBUG_ON(flags & ~(KM_SLEEP|KM_NOSLEEP|KM_NOFS|KM_MAYFAIL|KM_ZERO));\n\n\tif (flags & KM_NOSLEEP) {\n\t\tlflags = GFP_ATOMIC | __GFP_NOWARN;\n\t} else {\n\t\tlflags = GFP_KERNEL | __GFP_NOWARN;\n\t\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\t\tlflags &= ~__GFP_FS;\n\t}\n\n\tif (flags & KM_ZERO)\n\t\tlflags |= __GFP_ZERO;\n\n\treturn lflags;\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)",
            "#define KM_MAYFAIL\t((__force xfs_km_flags_t)0x0008u)",
            "#define KM_NOFS\t\t((__force xfs_km_flags_t)0x0004u)",
            "#define KM_NOSLEEP\t((__force xfs_km_flags_t)0x0002u)",
            "#define KM_SLEEP\t((__force xfs_km_flags_t)0x0001u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n#define KM_MAYFAIL\t((__force xfs_km_flags_t)0x0008u)\n#define KM_NOFS\t\t((__force xfs_km_flags_t)0x0004u)\n#define KM_NOSLEEP\t((__force xfs_km_flags_t)0x0002u)\n#define KM_SLEEP\t((__force xfs_km_flags_t)0x0001u)\n\nstatic inline gfp_t\nkmem_flags_convert(xfs_km_flags_t flags)\n{\n\tgfp_t\tlflags;\n\n\tBUG_ON(flags & ~(KM_SLEEP|KM_NOSLEEP|KM_NOFS|KM_MAYFAIL|KM_ZERO));\n\n\tif (flags & KM_NOSLEEP) {\n\t\tlflags = GFP_ATOMIC | __GFP_NOWARN;\n\t} else {\n\t\tlflags = GFP_KERNEL | __GFP_NOWARN;\n\t\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\t\tlflags &= ~__GFP_FS;\n\t}\n\n\tif (flags & KM_ZERO)\n\t\tlflags |= __GFP_ZERO;\n\n\treturn lflags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
  },
  {
    "function_name": "kmem_zalloc_greedy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
    "lines": "30-43",
    "snippet": "void *\nkmem_zalloc_greedy(size_t *size, size_t minsize, size_t maxsize)\n{\n\tvoid\t\t*ptr;\n\tsize_t\t\tkmsize = maxsize;\n\n\twhile (!(ptr = vzalloc(kmsize))) {\n\t\tif ((kmsize >>= 1) <= minsize)\n\t\t\tkmsize = minsize;\n\t}\n\tif (ptr)\n\t\t*size = kmsize;\n\treturn ptr;\n}",
    "includes": [
      "#include \"xfs_message.h\"",
      "#include \"kmem.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "kmsize"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_greedy(size_t *size, size_t minsize, size_t maxsize)\n{\n\tvoid\t\t*ptr;\n\tsize_t\t\tkmsize = maxsize;\n\n\twhile (!(ptr = vzalloc(kmsize))) {\n\t\tif ((kmsize >>= 1) <= minsize)\n\t\t\tkmsize = minsize;\n\t}\n\tif (ptr)\n\t\t*size = kmsize;\n\treturn ptr;\n}"
  }
]