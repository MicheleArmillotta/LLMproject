[
  {
    "function_name": "omfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "404-442",
    "snippet": "static int omfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct buffer_head *bh;\n\t__be64 *p;\n\tunsigned int hchain, hindex;\n\tint nbuckets;\n\n\tif (ctx->pos >> 32)\n\t\treturn -EINVAL;\n\n\tif (ctx->pos < 1 << 20) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1 << 20;\n\t}\n\n\tnbuckets = (dir->i_size - OMFS_DIR_START) / 8;\n\n\t/* high 12 bits store bucket + 1 and low 20 bits store hash index */\n\thchain = (ctx->pos >> 20) - 1;\n\thindex = ctx->pos & 0xfffff;\n\n\tbh = omfs_bread(dir->i_sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EINVAL;\n\n\tp = (__be64 *)(bh->b_data + OMFS_DIR_START) + hchain;\n\n\tfor (; hchain < nbuckets; hchain++) {\n\t\t__u64 fsblock = be64_to_cpu(*p++);\n\t\tif (!omfs_fill_chain(dir, ctx, fsblock, hindex))\n\t\t\tbreak;\n\t\thindex = 0;\n\t\tctx->pos = (hchain+2) << 20;\n\t}\n\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_fill_chain",
          "args": [
            "dir",
            "ctx",
            "fsblock",
            "hindex"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_fill_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "330-371",
          "snippet": "static bool omfs_fill_chain(struct inode *dir, struct dir_context *ctx,\n\t\tu64 fsblock, int hindex)\n{\n\t/* follow chain in this bucket */\n\twhile (fsblock != ~0) {\n\t\tstruct buffer_head *bh = omfs_bread(dir->i_sb, fsblock);\n\t\tstruct omfs_inode *oi;\n\t\tu64 self;\n\t\tunsigned char d_type;\n\n\t\tif (!bh)\n\t\t\treturn true;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, fsblock)) {\n\t\t\tbrelse(bh);\n\t\t\treturn true;\n\t\t}\n\n\t\tself = fsblock;\n\t\tfsblock = be64_to_cpu(oi->i_sibling);\n\n\t\t/* skip visited nodes */\n\t\tif (hindex) {\n\t\t\thindex--;\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\td_type = (oi->i_type == OMFS_DIR) ? DT_DIR : DT_REG;\n\n\t\tif (!dir_emit(ctx, oi->i_name,\n\t\t\t      strnlen(oi->i_name, OMFS_NAMELEN),\n\t\t\t      self, d_type)) {\n\t\t\tbrelse(bh);\n\t\t\treturn false;\n\t\t}\n\t\tbrelse(bh);\n\t\tctx->pos++;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic bool omfs_fill_chain(struct inode *dir, struct dir_context *ctx,\n\t\tu64 fsblock, int hindex)\n{\n\t/* follow chain in this bucket */\n\twhile (fsblock != ~0) {\n\t\tstruct buffer_head *bh = omfs_bread(dir->i_sb, fsblock);\n\t\tstruct omfs_inode *oi;\n\t\tu64 self;\n\t\tunsigned char d_type;\n\n\t\tif (!bh)\n\t\t\treturn true;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, fsblock)) {\n\t\t\tbrelse(bh);\n\t\t\treturn true;\n\t\t}\n\n\t\tself = fsblock;\n\t\tfsblock = be64_to_cpu(oi->i_sibling);\n\n\t\t/* skip visited nodes */\n\t\tif (hindex) {\n\t\t\thindex--;\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\td_type = (oi->i_type == OMFS_DIR) ? DT_DIR : DT_REG;\n\n\t\tif (!dir_emit(ctx, oi->i_name,\n\t\t\t      strnlen(oi->i_name, OMFS_NAMELEN),\n\t\t\t      self, d_type)) {\n\t\t\tbrelse(bh);\n\t\t\treturn false;\n\t\t}\n\t\tbrelse(bh);\n\t\tctx->pos++;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*p++"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "dir->i_sb",
            "dir->i_ino"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct buffer_head *bh;\n\t__be64 *p;\n\tunsigned int hchain, hindex;\n\tint nbuckets;\n\n\tif (ctx->pos >> 32)\n\t\treturn -EINVAL;\n\n\tif (ctx->pos < 1 << 20) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1 << 20;\n\t}\n\n\tnbuckets = (dir->i_size - OMFS_DIR_START) / 8;\n\n\t/* high 12 bits store bucket + 1 and low 20 bits store hash index */\n\thchain = (ctx->pos >> 20) - 1;\n\thindex = ctx->pos & 0xfffff;\n\n\tbh = omfs_bread(dir->i_sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EINVAL;\n\n\tp = (__be64 *)(bh->b_data + OMFS_DIR_START) + hchain;\n\n\tfor (; hchain < nbuckets; hchain++) {\n\t\t__u64 fsblock = be64_to_cpu(*p++);\n\t\tif (!omfs_fill_chain(dir, ctx, fsblock, hindex))\n\t\t\tbreak;\n\t\thindex = 0;\n\t\tctx->pos = (hchain+2) << 20;\n\t}\n\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "omfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "373-402",
    "snippet": "static int omfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tint err;\n\n\tif (new_inode) {\n\t\t/* overwriting existing file/dir */\n\t\terr = omfs_remove(new_dir, new_dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* since omfs locates files by name, we need to unlink _before_\n\t * adding the new link or we won't find the old one */\n\terr = omfs_delete_entry(old_dentry);\n\tif (err)\n\t\tgoto out;\n\n\tmark_inode_dirty(old_dir);\n\terr = omfs_add_link(new_dentry, old_inode);\n\tif (err)\n\t\tgoto out;\n\n\told_inode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(old_inode);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_inode"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_add_link",
          "args": [
            "new_dentry",
            "old_inode"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "111-154",
          "snippet": "static int omfs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 block;\n\t__be64 *entry;\n\tint ofs;\n\n\t/* just prepend to head of queue in proper bucket */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\t*entry = cpu_to_be64(inode->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\t/* now set the sibling and parent pointers on the new inode */\n\tbh = omfs_bread(dir->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\tmemcpy(oi->i_name, name, namelen);\n\tmemset(oi->i_name + namelen, 0, OMFS_NAMELEN - namelen);\n\toi->i_sibling = cpu_to_be64(block);\n\toi->i_parent = cpu_to_be64(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tdir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* mark affected inodes dirty to rebuild checksums */\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 block;\n\t__be64 *entry;\n\tint ofs;\n\n\t/* just prepend to head of queue in proper bucket */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\t*entry = cpu_to_be64(inode->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\t/* now set the sibling and parent pointers on the new inode */\n\tbh = omfs_bread(dir->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\tmemcpy(oi->i_name, name, namelen);\n\tmemset(oi->i_name + namelen, 0, OMFS_NAMELEN - namelen);\n\toi->i_sibling = cpu_to_be64(block);\n\toi->i_parent = cpu_to_be64(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tdir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* mark affected inodes dirty to rebuild checksums */\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_delete_entry",
          "args": [
            "old_dentry"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "156-214",
          "snippet": "static int omfs_delete_entry(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *dirty;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh, *bh2;\n\t__be64 *entry, next;\n\tu64 block, prev;\n\tint ofs;\n\tint err = -ENOMEM;\n\n\t/* delete the proper node in the bucket's linked list */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\n\tbh2 = omfs_scan_list(dir, block, name, namelen, &prev);\n\tif (IS_ERR(bh2)) {\n\t\terr = PTR_ERR(bh2);\n\t\tgoto out_free_bh;\n\t}\n\n\toi = (struct omfs_inode *) bh2->b_data;\n\tnext = oi->i_sibling;\n\tbrelse(bh2);\n\n\tif (prev != ~0) {\n\t\t/* found in middle of list, get list ptr */\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(dir->i_sb, prev);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tentry = &oi->i_sibling;\n\t}\n\n\t*entry = next;\n\tmark_buffer_dirty(bh);\n\n\tif (prev != ~0) {\n\t\tdirty = omfs_iget(dir->i_sb, prev);\n\t\tif (!IS_ERR(dirty)) {\n\t\t\tmark_inode_dirty(dirty);\n\t\t\tiput(dirty);\n\t\t}\n\t}\n\n\terr = 0;\nout_free_bh:\n\tbrelse(bh);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_delete_entry(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *dirty;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh, *bh2;\n\t__be64 *entry, next;\n\tu64 block, prev;\n\tint ofs;\n\tint err = -ENOMEM;\n\n\t/* delete the proper node in the bucket's linked list */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\n\tbh2 = omfs_scan_list(dir, block, name, namelen, &prev);\n\tif (IS_ERR(bh2)) {\n\t\terr = PTR_ERR(bh2);\n\t\tgoto out_free_bh;\n\t}\n\n\toi = (struct omfs_inode *) bh2->b_data;\n\tnext = oi->i_sibling;\n\tbrelse(bh2);\n\n\tif (prev != ~0) {\n\t\t/* found in middle of list, get list ptr */\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(dir->i_sb, prev);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tentry = &oi->i_sibling;\n\t}\n\n\t*entry = next;\n\tmark_buffer_dirty(bh);\n\n\tif (prev != ~0) {\n\t\tdirty = omfs_iget(dir->i_sb, prev);\n\t\tif (!IS_ERR(dirty)) {\n\t\t\tmark_inode_dirty(dirty);\n\t\t\tiput(dirty);\n\t\t}\n\t}\n\n\terr = 0;\nout_free_bh:\n\tbrelse(bh);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_remove",
          "args": [
            "new_dir",
            "new_dentry"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "238-256",
          "snippet": "static int omfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint ret;\n\n\n\tif (S_ISDIR(inode->i_mode) &&\n\t    !omfs_dir_is_empty(inode))\n\t\treturn -ENOTEMPTY;\n\n\tret = omfs_delete_entry(dentry);\n\tif (ret)\n\t\treturn ret;\n\t\n\tclear_nlink(inode);\n\tmark_inode_dirty(inode);\n\tmark_inode_dirty(dir);\n\treturn 0;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint ret;\n\n\n\tif (S_ISDIR(inode->i_mode) &&\n\t    !omfs_dir_is_empty(inode))\n\t\treturn -ENOTEMPTY;\n\n\tret = omfs_delete_entry(dentry);\n\tif (ret)\n\t\treturn ret;\n\t\n\tclear_nlink(inode);\n\tmark_inode_dirty(inode);\n\tmark_inode_dirty(dir);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tint err;\n\n\tif (new_inode) {\n\t\t/* overwriting existing file/dir */\n\t\terr = omfs_remove(new_dir, new_dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* since omfs locates files by name, we need to unlink _before_\n\t * adding the new link or we won't find the old one */\n\terr = omfs_delete_entry(old_dentry);\n\tif (err)\n\t\tgoto out;\n\n\tmark_inode_dirty(old_dir);\n\terr = omfs_add_link(new_dentry, old_inode);\n\tif (err)\n\t\tgoto out;\n\n\told_inode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(old_inode);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "omfs_fill_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "330-371",
    "snippet": "static bool omfs_fill_chain(struct inode *dir, struct dir_context *ctx,\n\t\tu64 fsblock, int hindex)\n{\n\t/* follow chain in this bucket */\n\twhile (fsblock != ~0) {\n\t\tstruct buffer_head *bh = omfs_bread(dir->i_sb, fsblock);\n\t\tstruct omfs_inode *oi;\n\t\tu64 self;\n\t\tunsigned char d_type;\n\n\t\tif (!bh)\n\t\t\treturn true;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, fsblock)) {\n\t\t\tbrelse(bh);\n\t\t\treturn true;\n\t\t}\n\n\t\tself = fsblock;\n\t\tfsblock = be64_to_cpu(oi->i_sibling);\n\n\t\t/* skip visited nodes */\n\t\tif (hindex) {\n\t\t\thindex--;\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\td_type = (oi->i_type == OMFS_DIR) ? DT_DIR : DT_REG;\n\n\t\tif (!dir_emit(ctx, oi->i_name,\n\t\t\t      strnlen(oi->i_name, OMFS_NAMELEN),\n\t\t\t      self, d_type)) {\n\t\t\tbrelse(bh);\n\t\t\treturn false;\n\t\t}\n\t\tbrelse(bh);\n\t\tctx->pos++;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "oi->i_name",
            "strnlen(oi->i_name, OMFS_NAMELEN)",
            "self",
            "d_type"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "oi->i_name",
            "OMFS_NAMELEN"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oi->i_sibling"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_is_bad",
          "args": [
            "OMFS_SB(dir->i_sb)",
            "&oi->i_head",
            "fsblock"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_is_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "316-328",
          "snippet": "int omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nint omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "dir->i_sb",
            "fsblock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic bool omfs_fill_chain(struct inode *dir, struct dir_context *ctx,\n\t\tu64 fsblock, int hindex)\n{\n\t/* follow chain in this bucket */\n\twhile (fsblock != ~0) {\n\t\tstruct buffer_head *bh = omfs_bread(dir->i_sb, fsblock);\n\t\tstruct omfs_inode *oi;\n\t\tu64 self;\n\t\tunsigned char d_type;\n\n\t\tif (!bh)\n\t\t\treturn true;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, fsblock)) {\n\t\t\tbrelse(bh);\n\t\t\treturn true;\n\t\t}\n\n\t\tself = fsblock;\n\t\tfsblock = be64_to_cpu(oi->i_sibling);\n\n\t\t/* skip visited nodes */\n\t\tif (hindex) {\n\t\t\thindex--;\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\td_type = (oi->i_type == OMFS_DIR) ? DT_DIR : DT_REG;\n\n\t\tif (!dir_emit(ctx, oi->i_name,\n\t\t\t      strnlen(oi->i_name, OMFS_NAMELEN),\n\t\t\t      self, d_type)) {\n\t\t\tbrelse(bh);\n\t\t\treturn false;\n\t\t}\n\t\tbrelse(bh);\n\t\tctx->pos++;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "omfs_is_bad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "316-328",
    "snippet": "int omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"omfs: bad hash chain detected\\n\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "header->h_self"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nint omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}"
  },
  {
    "function_name": "omfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "293-313",
    "snippet": "static struct dentry *omfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NULL;\n\n\tif (dentry->d_name.len > OMFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = omfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len);\n\tif (!IS_ERR(bh)) {\n\t\tstruct omfs_inode *oi = (struct omfs_inode *)bh->b_data;\n\t\tino_t ino = be64_to_cpu(oi->i_head.h_self);\n\t\tbrelse(bh);\n\t\tinode = omfs_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\td_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "200-262",
          "snippet": "struct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t/* check self */\n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode->i_ctime.tv_sec = ctime;\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\tinode->i_ctime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t/* check self */\n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode->i_ctime.tv_sec = ctime;\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\tinode->i_ctime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oi->i_head.h_self"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_find_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "67-82",
          "snippet": "static struct buffer_head *omfs_find_entry(struct inode *dir,\n\t\t\t\t\t   const char *name, int namelen)\n{\n\tstruct buffer_head *bh;\n\tint ofs;\n\tu64 block, dummy;\n\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tblock = be64_to_cpu(*((__be64 *) &bh->b_data[ofs]));\n\tbrelse(bh);\n\n\treturn omfs_scan_list(dir, block, name, namelen, &dummy);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_find_entry(struct inode *dir,\n\t\t\t\t\t   const char *name, int namelen)\n{\n\tstruct buffer_head *bh;\n\tint ofs;\n\tu64 block, dummy;\n\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tblock = be64_to_cpu(*((__be64 *) &bh->b_data[ofs]));\n\tbrelse(bh);\n\n\treturn omfs_scan_list(dir, block, name, namelen, &dummy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct dentry *omfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NULL;\n\n\tif (dentry->d_name.len > OMFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = omfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len);\n\tif (!IS_ERR(bh)) {\n\t\tstruct omfs_inode *oi = (struct omfs_inode *)bh->b_data;\n\t\tino_t ino = be64_to_cpu(oi->i_head.h_self);\n\t\tbrelse(bh);\n\t\tinode = omfs_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\td_add(dentry, inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "omfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "287-291",
    "snippet": "static int omfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\treturn omfs_add_node(dir, dentry, mode | S_IFREG);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omfs_add_node",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFREG"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_add_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "258-280",
          "snippet": "static int omfs_add_node(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tstruct inode *inode = omfs_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\terr = omfs_make_empty(inode, dir->i_sb);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\terr = omfs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_free_inode:\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_add_node(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tstruct inode *inode = omfs_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\terr = omfs_make_empty(inode, dir->i_sb);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\terr = omfs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_free_inode:\n\tiput(inode);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\treturn omfs_add_node(dir, dentry, mode | S_IFREG);\n}"
  },
  {
    "function_name": "omfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "282-285",
    "snippet": "static int omfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn omfs_add_node(dir, dentry, mode | S_IFDIR);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omfs_add_node",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFDIR"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_add_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "258-280",
          "snippet": "static int omfs_add_node(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tstruct inode *inode = omfs_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\terr = omfs_make_empty(inode, dir->i_sb);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\terr = omfs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_free_inode:\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_add_node(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tstruct inode *inode = omfs_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\terr = omfs_make_empty(inode, dir->i_sb);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\terr = omfs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_free_inode:\n\tiput(inode);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn omfs_add_node(dir, dentry, mode | S_IFDIR);\n}"
  },
  {
    "function_name": "omfs_add_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "258-280",
    "snippet": "static int omfs_add_node(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tstruct inode *inode = omfs_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\terr = omfs_make_empty(inode, dir->i_sb);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\terr = omfs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_free_inode:\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "111-154",
          "snippet": "static int omfs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 block;\n\t__be64 *entry;\n\tint ofs;\n\n\t/* just prepend to head of queue in proper bucket */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\t*entry = cpu_to_be64(inode->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\t/* now set the sibling and parent pointers on the new inode */\n\tbh = omfs_bread(dir->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\tmemcpy(oi->i_name, name, namelen);\n\tmemset(oi->i_name + namelen, 0, OMFS_NAMELEN - namelen);\n\toi->i_sibling = cpu_to_be64(block);\n\toi->i_parent = cpu_to_be64(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tdir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* mark affected inodes dirty to rebuild checksums */\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 block;\n\t__be64 *entry;\n\tint ofs;\n\n\t/* just prepend to head of queue in proper bucket */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\t*entry = cpu_to_be64(inode->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\t/* now set the sibling and parent pointers on the new inode */\n\tbh = omfs_bread(dir->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\tmemcpy(oi->i_name, name, namelen);\n\tmemset(oi->i_name + namelen, 0, OMFS_NAMELEN - namelen);\n\toi->i_sibling = cpu_to_be64(block);\n\toi->i_parent = cpu_to_be64(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tdir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* mark affected inodes dirty to rebuild checksums */\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_make_empty",
          "args": [
            "inode",
            "dir->i_sb"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_make_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "84-109",
          "snippet": "int omfs_make_empty(struct inode *inode, struct super_block *sb)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\n\tbh = omfs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tmemset(bh->b_data, 0, sizeof(struct omfs_inode));\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tmemset(&bh->b_data[OMFS_DIR_START], 0xff,\n\t\t\tsbi->s_sys_blocksize - OMFS_DIR_START);\n\t} else\n\t\tomfs_make_empty_table(bh, OMFS_EXTENT_START);\n\n\toi = (struct omfs_inode *) bh->b_data;\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\toi->i_sibling = ~cpu_to_be64(0ULL);\n\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nint omfs_make_empty(struct inode *inode, struct super_block *sb)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\n\tbh = omfs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tmemset(bh->b_data, 0, sizeof(struct omfs_inode));\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tmemset(&bh->b_data[OMFS_DIR_START], 0xff,\n\t\t\tsbi->s_sys_blocksize - OMFS_DIR_START);\n\t} else\n\t\tomfs_make_empty_table(bh, OMFS_EXTENT_START);\n\n\toi = (struct omfs_inode *) bh->b_data;\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\toi->i_sibling = ~cpu_to_be64(0ULL);\n\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "31-74",
          "snippet": "struct inode *omfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\tu64 new_block;\n\tint err;\n\tint len;\n\tstruct omfs_sb_info *sbi = OMFS_SB(dir->i_sb);\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = omfs_allocate_range(dir->i_sb, sbi->s_mirrors, sbi->s_mirrors,\n\t\t\t&new_block, &len);\n\tif (err)\n\t\tgoto fail;\n\n\tinode->i_ino = new_block;\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &omfs_file_inops;\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = 0;\n\t\tbreak;\n\t}\n\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\treturn inode;\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct inode *omfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\tu64 new_block;\n\tint err;\n\tint len;\n\tstruct omfs_sb_info *sbi = OMFS_SB(dir->i_sb);\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = omfs_allocate_range(dir->i_sb, sbi->s_mirrors, sbi->s_mirrors,\n\t\t\t&new_block, &len);\n\tif (err)\n\t\tgoto fail;\n\n\tinode->i_ino = new_block;\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &omfs_file_inops;\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = 0;\n\t\tbreak;\n\t}\n\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\treturn inode;\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_add_node(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tstruct inode *inode = omfs_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\terr = omfs_make_empty(inode, dir->i_sb);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\terr = omfs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_free_inode:\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "omfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "238-256",
    "snippet": "static int omfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint ret;\n\n\n\tif (S_ISDIR(inode->i_mode) &&\n\t    !omfs_dir_is_empty(inode))\n\t\treturn -ENOTEMPTY;\n\n\tret = omfs_delete_entry(dentry);\n\tif (ret)\n\t\treturn ret;\n\t\n\tclear_nlink(inode);\n\tmark_inode_dirty(inode);\n\tmark_inode_dirty(dir);\n\treturn 0;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_delete_entry",
          "args": [
            "dentry"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "156-214",
          "snippet": "static int omfs_delete_entry(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *dirty;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh, *bh2;\n\t__be64 *entry, next;\n\tu64 block, prev;\n\tint ofs;\n\tint err = -ENOMEM;\n\n\t/* delete the proper node in the bucket's linked list */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\n\tbh2 = omfs_scan_list(dir, block, name, namelen, &prev);\n\tif (IS_ERR(bh2)) {\n\t\terr = PTR_ERR(bh2);\n\t\tgoto out_free_bh;\n\t}\n\n\toi = (struct omfs_inode *) bh2->b_data;\n\tnext = oi->i_sibling;\n\tbrelse(bh2);\n\n\tif (prev != ~0) {\n\t\t/* found in middle of list, get list ptr */\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(dir->i_sb, prev);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tentry = &oi->i_sibling;\n\t}\n\n\t*entry = next;\n\tmark_buffer_dirty(bh);\n\n\tif (prev != ~0) {\n\t\tdirty = omfs_iget(dir->i_sb, prev);\n\t\tif (!IS_ERR(dirty)) {\n\t\t\tmark_inode_dirty(dirty);\n\t\t\tiput(dirty);\n\t\t}\n\t}\n\n\terr = 0;\nout_free_bh:\n\tbrelse(bh);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_delete_entry(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *dirty;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh, *bh2;\n\t__be64 *entry, next;\n\tu64 block, prev;\n\tint ofs;\n\tint err = -ENOMEM;\n\n\t/* delete the proper node in the bucket's linked list */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\n\tbh2 = omfs_scan_list(dir, block, name, namelen, &prev);\n\tif (IS_ERR(bh2)) {\n\t\terr = PTR_ERR(bh2);\n\t\tgoto out_free_bh;\n\t}\n\n\toi = (struct omfs_inode *) bh2->b_data;\n\tnext = oi->i_sibling;\n\tbrelse(bh2);\n\n\tif (prev != ~0) {\n\t\t/* found in middle of list, get list ptr */\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(dir->i_sb, prev);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tentry = &oi->i_sibling;\n\t}\n\n\t*entry = next;\n\tmark_buffer_dirty(bh);\n\n\tif (prev != ~0) {\n\t\tdirty = omfs_iget(dir->i_sb, prev);\n\t\tif (!IS_ERR(dirty)) {\n\t\t\tmark_inode_dirty(dirty);\n\t\t\tiput(dirty);\n\t\t}\n\t}\n\n\terr = 0;\nout_free_bh:\n\tbrelse(bh);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_dir_is_empty",
          "args": [
            "inode"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_dir_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "216-236",
          "snippet": "static int omfs_dir_is_empty(struct inode *inode)\n{\n\tint nbuckets = (inode->i_size - OMFS_DIR_START) / 8;\n\tstruct buffer_head *bh;\n\tu64 *ptr;\n\tint i;\n\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\n\tif (!bh)\n\t\treturn 0;\n\n\tptr = (u64 *) &bh->b_data[OMFS_DIR_START];\n\n\tfor (i = 0; i < nbuckets; i++, ptr++)\n\t\tif (*ptr != ~0)\n\t\t\tbreak;\n\n\tbrelse(bh);\n\treturn *ptr != ~0;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_dir_is_empty(struct inode *inode)\n{\n\tint nbuckets = (inode->i_size - OMFS_DIR_START) / 8;\n\tstruct buffer_head *bh;\n\tu64 *ptr;\n\tint i;\n\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\n\tif (!bh)\n\t\treturn 0;\n\n\tptr = (u64 *) &bh->b_data[OMFS_DIR_START];\n\n\tfor (i = 0; i < nbuckets; i++, ptr++)\n\t\tif (*ptr != ~0)\n\t\t\tbreak;\n\n\tbrelse(bh);\n\treturn *ptr != ~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint ret;\n\n\n\tif (S_ISDIR(inode->i_mode) &&\n\t    !omfs_dir_is_empty(inode))\n\t\treturn -ENOTEMPTY;\n\n\tret = omfs_delete_entry(dentry);\n\tif (ret)\n\t\treturn ret;\n\t\n\tclear_nlink(inode);\n\tmark_inode_dirty(inode);\n\tmark_inode_dirty(dir);\n\treturn 0;\n}"
  },
  {
    "function_name": "omfs_dir_is_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "216-236",
    "snippet": "static int omfs_dir_is_empty(struct inode *inode)\n{\n\tint nbuckets = (inode->i_size - OMFS_DIR_START) / 8;\n\tstruct buffer_head *bh;\n\tu64 *ptr;\n\tint i;\n\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\n\tif (!bh)\n\t\treturn 0;\n\n\tptr = (u64 *) &bh->b_data[OMFS_DIR_START];\n\n\tfor (i = 0; i < nbuckets; i++, ptr++)\n\t\tif (*ptr != ~0)\n\t\t\tbreak;\n\n\tbrelse(bh);\n\treturn *ptr != ~0;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "inode->i_sb",
            "inode->i_ino"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_dir_is_empty(struct inode *inode)\n{\n\tint nbuckets = (inode->i_size - OMFS_DIR_START) / 8;\n\tstruct buffer_head *bh;\n\tu64 *ptr;\n\tint i;\n\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\n\tif (!bh)\n\t\treturn 0;\n\n\tptr = (u64 *) &bh->b_data[OMFS_DIR_START];\n\n\tfor (i = 0; i < nbuckets; i++, ptr++)\n\t\tif (*ptr != ~0)\n\t\t\tbreak;\n\n\tbrelse(bh);\n\treturn *ptr != ~0;\n}"
  },
  {
    "function_name": "omfs_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "156-214",
    "snippet": "static int omfs_delete_entry(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *dirty;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh, *bh2;\n\t__be64 *entry, next;\n\tu64 block, prev;\n\tint ofs;\n\tint err = -ENOMEM;\n\n\t/* delete the proper node in the bucket's linked list */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\n\tbh2 = omfs_scan_list(dir, block, name, namelen, &prev);\n\tif (IS_ERR(bh2)) {\n\t\terr = PTR_ERR(bh2);\n\t\tgoto out_free_bh;\n\t}\n\n\toi = (struct omfs_inode *) bh2->b_data;\n\tnext = oi->i_sibling;\n\tbrelse(bh2);\n\n\tif (prev != ~0) {\n\t\t/* found in middle of list, get list ptr */\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(dir->i_sb, prev);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tentry = &oi->i_sibling;\n\t}\n\n\t*entry = next;\n\tmark_buffer_dirty(bh);\n\n\tif (prev != ~0) {\n\t\tdirty = omfs_iget(dir->i_sb, prev);\n\t\tif (!IS_ERR(dirty)) {\n\t\t\tmark_inode_dirty(dirty);\n\t\t\tiput(dirty);\n\t\t}\n\t}\n\n\terr = 0;\nout_free_bh:\n\tbrelse(bh);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dirty"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dirty"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dirty"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_iget",
          "args": [
            "dir->i_sb",
            "prev"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "200-262",
          "snippet": "struct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t/* check self */\n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode->i_ctime.tv_sec = ctime;\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\tinode->i_ctime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t/* check self */\n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode->i_ctime.tv_sec = ctime;\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\tinode->i_ctime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "dir->i_sb",
            "prev"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh2"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh2"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_scan_list",
          "args": [
            "dir",
            "block",
            "name",
            "namelen",
            "&prev"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_scan_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "34-65",
          "snippet": "static struct buffer_head *omfs_scan_list(struct inode *dir, u64 block,\n\t\t\t\tconst char *name, int namelen,\n\t\t\t\tu64 *prev_block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\tint err = -ENOENT;\n\t*prev_block = ~0;\n\n\twhile (block != ~0) {\n\t\tbh = omfs_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, block)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (strncmp(oi->i_name, name, namelen) == 0)\n\t\t\treturn bh;\n\n\t\t*prev_block = block;\n\t\tblock = be64_to_cpu(oi->i_sibling);\n\t\tbrelse(bh);\n\t}\nerr:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_scan_list(struct inode *dir, u64 block,\n\t\t\t\tconst char *name, int namelen,\n\t\t\t\tu64 *prev_block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\tint err = -ENOENT;\n\t*prev_block = ~0;\n\n\twhile (block != ~0) {\n\t\tbh = omfs_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, block)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (strncmp(oi->i_name, name, namelen) == 0)\n\t\t\treturn bh;\n\n\t\t*prev_block = block;\n\t\tblock = be64_to_cpu(oi->i_sibling);\n\t\tbrelse(bh);\n\t}\nerr:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*entry"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_get_bucket",
          "args": [
            "dir",
            "name",
            "namelen",
            "&ofs"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_get_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "24-32",
          "snippet": "static struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_delete_entry(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *dirty;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh, *bh2;\n\t__be64 *entry, next;\n\tu64 block, prev;\n\tint ofs;\n\tint err = -ENOMEM;\n\n\t/* delete the proper node in the bucket's linked list */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\n\tbh2 = omfs_scan_list(dir, block, name, namelen, &prev);\n\tif (IS_ERR(bh2)) {\n\t\terr = PTR_ERR(bh2);\n\t\tgoto out_free_bh;\n\t}\n\n\toi = (struct omfs_inode *) bh2->b_data;\n\tnext = oi->i_sibling;\n\tbrelse(bh2);\n\n\tif (prev != ~0) {\n\t\t/* found in middle of list, get list ptr */\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(dir->i_sb, prev);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tentry = &oi->i_sibling;\n\t}\n\n\t*entry = next;\n\tmark_buffer_dirty(bh);\n\n\tif (prev != ~0) {\n\t\tdirty = omfs_iget(dir->i_sb, prev);\n\t\tif (!IS_ERR(dirty)) {\n\t\t\tmark_inode_dirty(dirty);\n\t\t\tiput(dirty);\n\t\t}\n\t}\n\n\terr = 0;\nout_free_bh:\n\tbrelse(bh);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "omfs_add_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "111-154",
    "snippet": "static int omfs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 block;\n\t__be64 *entry;\n\tint ofs;\n\n\t/* just prepend to head of queue in proper bucket */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\t*entry = cpu_to_be64(inode->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\t/* now set the sibling and parent pointers on the new inode */\n\tbh = omfs_bread(dir->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\tmemcpy(oi->i_name, name, namelen);\n\tmemset(oi->i_name + namelen, 0, OMFS_NAMELEN - namelen);\n\toi->i_sibling = cpu_to_be64(block);\n\toi->i_parent = cpu_to_be64(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tdir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* mark affected inodes dirty to rebuild checksums */\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dir->i_ino"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "block"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "oi->i_name + namelen",
            "0",
            "OMFS_NAMELEN - namelen"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "oi->i_name",
            "name",
            "namelen"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "dir->i_sb",
            "inode->i_ino"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_ino"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*entry"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_get_bucket",
          "args": [
            "dir",
            "name",
            "namelen",
            "&ofs"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_get_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "24-32",
          "snippet": "static struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 block;\n\t__be64 *entry;\n\tint ofs;\n\n\t/* just prepend to head of queue in proper bucket */\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\t*entry = cpu_to_be64(inode->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\t/* now set the sibling and parent pointers on the new inode */\n\tbh = omfs_bread(dir->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\tmemcpy(oi->i_name, name, namelen);\n\tmemset(oi->i_name + namelen, 0, OMFS_NAMELEN - namelen);\n\toi->i_sibling = cpu_to_be64(block);\n\toi->i_parent = cpu_to_be64(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tdir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* mark affected inodes dirty to rebuild checksums */\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "omfs_make_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "84-109",
    "snippet": "int omfs_make_empty(struct inode *inode, struct super_block *sb)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\n\tbh = omfs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tmemset(bh->b_data, 0, sizeof(struct omfs_inode));\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tmemset(&bh->b_data[OMFS_DIR_START], 0xff,\n\t\t\tsbi->s_sys_blocksize - OMFS_DIR_START);\n\t} else\n\t\tomfs_make_empty_table(bh, OMFS_EXTENT_START);\n\n\toi = (struct omfs_inode *) bh->b_data;\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\toi->i_sibling = ~cpu_to_be64(0ULL);\n\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "0ULL"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_ino"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_make_empty_table",
          "args": [
            "bh",
            "OMFS_EXTENT_START"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_make_empty_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "20-29",
          "snippet": "void omfs_make_empty_table(struct buffer_head *bh, int offset)\n{\n\tstruct omfs_extent *oe = (struct omfs_extent *) &bh->b_data[offset];\n\n\toe->e_next = ~cpu_to_be64(0ULL);\n\toe->e_extent_count = cpu_to_be32(1),\n\toe->e_fill = cpu_to_be32(0x22),\n\toe->e_entry.e_cluster = ~cpu_to_be64(0ULL);\n\toe->e_entry.e_blocks = ~cpu_to_be64(0ULL);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid omfs_make_empty_table(struct buffer_head *bh, int offset)\n{\n\tstruct omfs_extent *oe = (struct omfs_extent *) &bh->b_data[offset];\n\n\toe->e_next = ~cpu_to_be64(0ULL);\n\toe->e_extent_count = cpu_to_be32(1),\n\toe->e_fill = cpu_to_be32(0x22),\n\toe->e_entry.e_cluster = ~cpu_to_be64(0ULL);\n\toe->e_entry.e_blocks = ~cpu_to_be64(0ULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&bh->b_data[OMFS_DIR_START]",
            "0xff",
            "sbi->s_sys_blocksize - OMFS_DIR_START"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sizeof(struct omfs_inode)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "sb"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nint omfs_make_empty(struct inode *inode, struct super_block *sb)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\n\tbh = omfs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tmemset(bh->b_data, 0, sizeof(struct omfs_inode));\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tmemset(&bh->b_data[OMFS_DIR_START], 0xff,\n\t\t\tsbi->s_sys_blocksize - OMFS_DIR_START);\n\t} else\n\t\tomfs_make_empty_table(bh, OMFS_EXTENT_START);\n\n\toi = (struct omfs_inode *) bh->b_data;\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\toi->i_sibling = ~cpu_to_be64(0ULL);\n\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "omfs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "67-82",
    "snippet": "static struct buffer_head *omfs_find_entry(struct inode *dir,\n\t\t\t\t\t   const char *name, int namelen)\n{\n\tstruct buffer_head *bh;\n\tint ofs;\n\tu64 block, dummy;\n\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tblock = be64_to_cpu(*((__be64 *) &bh->b_data[ofs]));\n\tbrelse(bh);\n\n\treturn omfs_scan_list(dir, block, name, namelen, &dummy);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omfs_scan_list",
          "args": [
            "dir",
            "block",
            "name",
            "namelen",
            "&dummy"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_scan_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "34-65",
          "snippet": "static struct buffer_head *omfs_scan_list(struct inode *dir, u64 block,\n\t\t\t\tconst char *name, int namelen,\n\t\t\t\tu64 *prev_block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\tint err = -ENOENT;\n\t*prev_block = ~0;\n\n\twhile (block != ~0) {\n\t\tbh = omfs_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, block)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (strncmp(oi->i_name, name, namelen) == 0)\n\t\t\treturn bh;\n\n\t\t*prev_block = block;\n\t\tblock = be64_to_cpu(oi->i_sibling);\n\t\tbrelse(bh);\n\t}\nerr:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_scan_list(struct inode *dir, u64 block,\n\t\t\t\tconst char *name, int namelen,\n\t\t\t\tu64 *prev_block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\tint err = -ENOENT;\n\t*prev_block = ~0;\n\n\twhile (block != ~0) {\n\t\tbh = omfs_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, block)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (strncmp(oi->i_name, name, namelen) == 0)\n\t\t\treturn bh;\n\n\t\t*prev_block = block;\n\t\tblock = be64_to_cpu(oi->i_sibling);\n\t\tbrelse(bh);\n\t}\nerr:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*((__be64 *) &bh->b_data[ofs])"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_get_bucket",
          "args": [
            "dir",
            "name",
            "namelen",
            "&ofs"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_get_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "24-32",
          "snippet": "static struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_find_entry(struct inode *dir,\n\t\t\t\t\t   const char *name, int namelen)\n{\n\tstruct buffer_head *bh;\n\tint ofs;\n\tu64 block, dummy;\n\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tblock = be64_to_cpu(*((__be64 *) &bh->b_data[ofs]));\n\tbrelse(bh);\n\n\treturn omfs_scan_list(dir, block, name, namelen, &dummy);\n}"
  },
  {
    "function_name": "omfs_scan_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "34-65",
    "snippet": "static struct buffer_head *omfs_scan_list(struct inode *dir, u64 block,\n\t\t\t\tconst char *name, int namelen,\n\t\t\t\tu64 *prev_block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\tint err = -ENOENT;\n\t*prev_block = ~0;\n\n\twhile (block != ~0) {\n\t\tbh = omfs_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, block)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (strncmp(oi->i_name, name, namelen) == 0)\n\t\t\treturn bh;\n\n\t\t*prev_block = block;\n\t\tblock = be64_to_cpu(oi->i_sibling);\n\t\tbrelse(bh);\n\t}\nerr:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oi->i_sibling"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "oi->i_name",
            "name",
            "namelen"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_is_bad",
          "args": [
            "OMFS_SB(dir->i_sb)",
            "&oi->i_head",
            "block"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_is_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "316-328",
          "snippet": "int omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nint omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "dir->i_sb",
            "block"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_scan_list(struct inode *dir, u64 block,\n\t\t\t\tconst char *name, int namelen,\n\t\t\t\tu64 *prev_block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\tint err = -ENOENT;\n\t*prev_block = ~0;\n\n\twhile (block != ~0) {\n\t\tbh = omfs_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, block)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (strncmp(oi->i_name, name, namelen) == 0)\n\t\t\treturn bh;\n\n\t\t*prev_block = block;\n\t\tblock = be64_to_cpu(oi->i_sibling);\n\t\tbrelse(bh);\n\t}\nerr:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "omfs_get_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "24-32",
    "snippet": "static struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "dir->i_sb",
            "dir->i_ino"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_hash",
          "args": [
            "name",
            "namelen",
            "nbuckets"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
          "lines": "12-18",
          "snippet": "static int omfs_hash(const char *name, int namelen, int mod)\n{\n\tint i, hash = 0;\n\tfor (i = 0; i < namelen; i++)\n\t\thash ^= tolower(name[i]) << (i % 24);\n\treturn hash % mod;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_hash(const char *name, int namelen, int mod)\n{\n\tint i, hash = 0;\n\tfor (i = 0; i < namelen; i++)\n\t\thash ^= tolower(name[i]) << (i % 24);\n\treturn hash % mod;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}"
  },
  {
    "function_name": "omfs_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/dir.c",
    "lines": "12-18",
    "snippet": "static int omfs_hash(const char *name, int namelen, int mod)\n{\n\tint i, hash = 0;\n\tfor (i = 0; i < namelen; i++)\n\t\thash ^= tolower(name[i]) << (i % 24);\n\treturn hash % mod;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/ctype.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "name[i]"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "fat_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "38-41",
          "snippet": "static inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n\nstatic int omfs_hash(const char *name, int namelen, int mod)\n{\n\tint i, hash = 0;\n\tfor (i = 0; i < namelen; i++)\n\t\thash ^= tolower(name[i]) << (i % 24);\n\treturn hash % mod;\n}"
  }
]