[
  {
    "function_name": "reiserfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "3309-3448",
    "snippet": "int reiserfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\t/* must be turned off for recursive notify_change calls */\n\tia_valid = attr->ia_valid &= ~(ATTR_KILL_SUID|ATTR_KILL_SGID);\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\treiserfs_write_lock(inode->i_sb);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/*\n\t\t * version 2 items will be caught by the s_maxbytes check\n\t\t * done for us in vmtruncate\n\t\t */\n\t\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&\n\t\t    attr->ia_size > MAX_NON_LFS) {\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\terror = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode_dio_wait(inode);\n\n\t\t/* fill in hole pointers in the expanding truncate case. */\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = generic_cont_expand_simple(inode, attr->ia_size);\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\t\t\tint err;\n\t\t\t\tstruct reiserfs_transaction_handle th;\n\t\t\t\t/* we're changing at most 2 bitmaps, inode + super */\n\t\t\t\terr = journal_begin(&th, inode->i_sb, 4);\n\t\t\t\tif (!err) {\n\t\t\t\t\treiserfs_discard_prealloc(&th, inode);\n\t\t\t\t\terr = journal_end(&th);\n\t\t\t\t}\n\t\t\t\tif (err)\n\t\t\t\t\terror = err;\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * file size is changed, ctime and mtime are\n\t\t\t * to be updated\n\t\t\t */\n\t\t\tattr->ia_valid |= (ATTR_MTIME | ATTR_CTIME);\n\t\t}\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\tif ((((attr->ia_valid & ATTR_UID) && (from_kuid(&init_user_ns, attr->ia_uid) & ~0xffff)) ||\n\t     ((attr->ia_valid & ATTR_GID) && (from_kgid(&init_user_ns, attr->ia_gid) & ~0xffff))) &&\n\t    (get_inode_sd_version(inode) == STAT_DATA_V1)) {\n\t\t/* stat data of format v3.5 has 16 bit uid and gid */\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\tstruct reiserfs_transaction_handle th;\n\t\tint jbegin_count =\n\t\t    2 *\n\t\t    (REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb) +\n\t\t     REISERFS_QUOTA_DEL_BLOCKS(inode->i_sb)) +\n\t\t    2;\n\n\t\terror = reiserfs_chown_xattrs(inode, attr);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * (user+group)*(old+new) structure - we count quota\n\t\t * info and , inode write (sb, inode)\n\t\t */\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = dquot_transfer(inode, attr);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (error) {\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Update corresponding info in inode so that everything\n\t\t * is in one transaction\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tmark_inode_dirty(inode);\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Could race against reiserfs_file_release\n\t\t\t * if called from NFS, so take tailpack mutex.\n\t\t\t */\n\t\t\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\treiserfs_truncate_file(inode, 1);\n\t\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t\t}\n\t}\n\n\tif (!error) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (!error && reiserfs_posixacl(inode->i_sb)) {\n\t\tif (attr->ia_valid & ATTR_MODE)\n\t\t\terror = reiserfs_acl_chmod(inode);\n\t}\n\nout:\n\treturn error;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_acl_chmod",
          "args": [
            "inode"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "398-407",
          "snippet": "int reiserfs_acl_chmod(struct inode *inode)\n{\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\n\t    !reiserfs_posixacl(inode->i_sb))\n\t\treturn 0;\n\n\treturn posix_acl_chmod(inode, inode->i_mode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint reiserfs_acl_chmod(struct inode *inode)\n{\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\n\t    !reiserfs_posixacl(inode->i_sb))\n\t\treturn 0;\n\n\treturn posix_acl_chmod(inode, inode->i_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_posixacl",
          "args": [
            "inode->i_sb"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&REISERFS_I(inode)->tailpack"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 3432
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_truncate_file",
          "args": [
            "inode",
            "1"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_truncate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2263-2362",
          "snippet": "int reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t/* we want the offset for the first byte after the end of the file */\n\tunsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * -ENOENT means we truncated past the end of the\n\t\t\t * file, and get_block_create_0 could not find a\n\t\t\t * block to read in, which is ok.\n\t\t\t */\n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * so, if page != NULL, we have a buffer head for the offset at\n\t * the end of the file. if the bh is mapped, and bh->b_blocknr != 0,\n\t * then we have an unformatted node.  Otherwise, we have a direct item,\n\t * and no zeroing is required on disk.  We zero after the truncate,\n\t * because the truncate might pack the item anyway\n\t * (it will unmap bh if it packs).\n\t *\n\t * it is enough to reserve space in transaction for 2 balancings:\n\t * one for \"save\" link adding and another for the first\n\t * cut_from_item. 1 is for update_sd\n\t */\n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t/*\n\t\t * we are doing real truncate: if the system crashes\n\t\t * before the last transaction of truncating gets committed\n\t\t * - on reboot the file either appears truncated properly\n\t\t * or not truncated at all\n\t\t */\n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t/* check reiserfs_do_truncate after ending the transaction */\n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1 /* truncate */);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t/* if we are not on a block boundary */\n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t/* we want the offset for the first byte after the end of the file */\n\tunsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * -ENOENT means we truncated past the end of the\n\t\t\t * file, and get_block_create_0 could not find a\n\t\t\t * block to read in, which is ok.\n\t\t\t */\n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * so, if page != NULL, we have a buffer head for the offset at\n\t * the end of the file. if the bh is mapped, and bh->b_blocknr != 0,\n\t * then we have an unformatted node.  Otherwise, we have a direct item,\n\t * and no zeroing is required on disk.  We zero after the truncate,\n\t * because the truncate might pack the item anyway\n\t * (it will unmap bh if it packs).\n\t *\n\t * it is enough to reserve space in transaction for 2 balancings:\n\t * one for \"save\" link adding and another for the first\n\t * cut_from_item. 1 is for update_sd\n\t */\n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t/*\n\t\t * we are doing real truncate: if the system crashes\n\t\t * before the last transaction of truncating gets committed\n\t\t * - on reboot the file either appears truncated properly\n\t\t * or not truncated at all\n\t\t */\n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t/* check reiserfs_do_truncate after ending the transaction */\n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1 /* truncate */);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t/* if we are not on a block boundary */\n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&REISERFS_I(inode)->tailpack"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 3423
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "823-843",
          "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_transfer",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1933-1950",
          "snippet": "int dquot_transfer(struct inode *inode, struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\n\tif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\n\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\n\tif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\n\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\n\n\tret = __dquot_transfer(inode, transfer_to);\n\tdqput_all(transfer_to);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_transfer(struct inode *inode, struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\n\tif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\n\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\n\tif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\n\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\n\n\tret = __dquot_transfer(inode, transfer_to);\n\tdqput_all(transfer_to);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "jbegin_count"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_chown_xattrs",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_chown_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "361-369",
          "snippet": "int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)\n{\n\tint err = reiserfs_for_each_xattr(inode, chown_one_xattr, attrs);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20007\",\n\t\t\t\t \"Couldn't chown all xattrs (%d)\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)\n{\n\tint err = reiserfs_for_each_xattr(inode, chown_one_xattr, attrs);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20007\",\n\t\t\t\t \"Couldn't chown all xattrs (%d)\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_DEL_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_INIT_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "inode->i_gid"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "inode->i_uid"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "inode"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "attr->ia_gid"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "attr->ia_uid"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_discard_prealloc",
          "args": [
            "&th",
            "inode"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_discard_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "528-536",
          "snippet": "void reiserfs_discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tstruct reiserfs_inode_info *ei = REISERFS_I(inode);\n\n\tBUG_ON(!th->t_trans_id);\n\tif (ei->i_prealloc_count)\n\t\t__discard_prealloc(th, ei);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tstruct reiserfs_inode_info *ei = REISERFS_I(inode);\n\n\tBUG_ON(!th->t_trans_id);\n\tif (ei->i_prealloc_count)\n\t\t__discard_prealloc(th, ei);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_cont_expand_simple",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "generic_cont_expand_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2249-2271",
          "snippet": "int generic_cont_expand_simple(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\n\terr = inode_newsize_ok(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE|AOP_FLAG_CONT_EXPAND,\n\t\t\t\t&page, &fsdata);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);\n\tBUG_ON(err > 0);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_cont_expand_simple(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\n\terr = inode_newsize_ok(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE|AOP_FLAG_CONT_EXPAND,\n\t\t\t\t&page, &fsdata);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);\n\tBUG_ON(err > 0);\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 3337
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_item_key_version",
          "args": [
            "inode"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_quota_modification",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\t/* must be turned off for recursive notify_change calls */\n\tia_valid = attr->ia_valid &= ~(ATTR_KILL_SUID|ATTR_KILL_SGID);\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\treiserfs_write_lock(inode->i_sb);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/*\n\t\t * version 2 items will be caught by the s_maxbytes check\n\t\t * done for us in vmtruncate\n\t\t */\n\t\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&\n\t\t    attr->ia_size > MAX_NON_LFS) {\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\terror = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode_dio_wait(inode);\n\n\t\t/* fill in hole pointers in the expanding truncate case. */\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = generic_cont_expand_simple(inode, attr->ia_size);\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\t\t\tint err;\n\t\t\t\tstruct reiserfs_transaction_handle th;\n\t\t\t\t/* we're changing at most 2 bitmaps, inode + super */\n\t\t\t\terr = journal_begin(&th, inode->i_sb, 4);\n\t\t\t\tif (!err) {\n\t\t\t\t\treiserfs_discard_prealloc(&th, inode);\n\t\t\t\t\terr = journal_end(&th);\n\t\t\t\t}\n\t\t\t\tif (err)\n\t\t\t\t\terror = err;\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * file size is changed, ctime and mtime are\n\t\t\t * to be updated\n\t\t\t */\n\t\t\tattr->ia_valid |= (ATTR_MTIME | ATTR_CTIME);\n\t\t}\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\tif ((((attr->ia_valid & ATTR_UID) && (from_kuid(&init_user_ns, attr->ia_uid) & ~0xffff)) ||\n\t     ((attr->ia_valid & ATTR_GID) && (from_kgid(&init_user_ns, attr->ia_gid) & ~0xffff))) &&\n\t    (get_inode_sd_version(inode) == STAT_DATA_V1)) {\n\t\t/* stat data of format v3.5 has 16 bit uid and gid */\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\tstruct reiserfs_transaction_handle th;\n\t\tint jbegin_count =\n\t\t    2 *\n\t\t    (REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb) +\n\t\t     REISERFS_QUOTA_DEL_BLOCKS(inode->i_sb)) +\n\t\t    2;\n\n\t\terror = reiserfs_chown_xattrs(inode, attr);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * (user+group)*(old+new) structure - we count quota\n\t\t * info and , inode write (sb, inode)\n\t\t */\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = dquot_transfer(inode, attr);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (error) {\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Update corresponding info in inode so that everything\n\t\t * is in one transaction\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tmark_inode_dirty(inode);\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Could race against reiserfs_file_release\n\t\t\t * if called from NFS, so take tailpack mutex.\n\t\t\t */\n\t\t\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\treiserfs_truncate_file(inode, 1);\n\t\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t\t}\n\t}\n\n\tif (!error) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (!error && reiserfs_posixacl(inode->i_sb)) {\n\t\tif (attr->ia_valid & ATTR_MODE)\n\t\t\terror = reiserfs_acl_chmod(inode);\n\t}\n\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "reiserfs_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "3281-3307",
    "snippet": "static ssize_t reiserfs_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t\t  struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset,\n\t\t\t\t reiserfs_get_blocks_direct_io);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif ((end > isize) && inode_newsize_ok(inode, isize) == 0) {\n\t\t\ttruncate_setsize(inode, isize);\n\t\t\treiserfs_vfs_truncate_file(inode);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_vfs_truncate_file",
          "args": [
            "inode"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_vfs_truncate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/file.c",
          "lines": "136-141",
          "snippet": "void reiserfs_vfs_truncate_file(struct inode *inode)\n{\n\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\treiserfs_truncate_file(inode, 1);\n\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode)\n{\n\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\treiserfs_truncate_file(inode, 1);\n\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "isize"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "isize"
          ],
          "line": 3300
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "823-843",
          "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(rw & WRITE) && ret < 0"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "reiserfs_get_blocks_direct_io"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic ssize_t reiserfs_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t\t  struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset,\n\t\t\t\t reiserfs_get_blocks_direct_io);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif ((end > isize) && inode_newsize_ok(inode, isize) == 0) {\n\t\t\ttruncate_setsize(inode, isize);\n\t\t\treiserfs_vfs_truncate_file(inode);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "3248-3275",
    "snippet": "static int reiserfs_releasepage(struct page *page, gfp_t unused_gfp_flags)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 1;\n\n\tWARN_ON(PageChecked(page));\n\tspin_lock(&j->j_dirty_buffers_lock);\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (bh->b_private) {\n\t\t\tif (!buffer_dirty(bh) && !buffer_locked(bh)) {\n\t\t\t\treiserfs_free_jh(bh);\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tif (ret)\n\t\tret = try_to_free_buffers(page);\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&j->j_dirty_buffers_lock"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_free_jh",
          "args": [
            "bh"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_jh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "731-746",
          "snippet": "void reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);\n\nvoid reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3262
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&j->j_dirty_buffers_lock"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageChecked(page)"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "inode->i_sb"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_releasepage(struct page *page, gfp_t unused_gfp_flags)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 1;\n\n\tWARN_ON(PageChecked(page));\n\tspin_lock(&j->j_dirty_buffers_lock);\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (bh->b_private) {\n\t\t\tif (!buffer_dirty(bh) && !buffer_locked(bh)) {\n\t\t\t\treiserfs_free_jh(bh);\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tif (ret)\n\t\tret = try_to_free_buffers(page);\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "3229-3237",
    "snippet": "static int reiserfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tSetPageChecked(page);\n\t\treturn __set_page_dirty_nobuffers(page);\n\t}\n\treturn __set_page_dirty_buffers(page);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty_buffers",
          "args": [
            "page"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "668-692",
          "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_file_data_log",
          "args": [
            "inode"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_file_data_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2888-2894",
          "snippet": "static inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tSetPageChecked(page);\n\t\treturn __set_page_dirty_nobuffers(page);\n\t}\n\treturn __set_page_dirty_buffers(page);\n}"
  },
  {
    "function_name": "reiserfs_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "3176-3227",
    "snippet": "static void reiserfs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t    unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = offset + length;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tint ret = 1;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!partial_page)\n\t\tClearPageChecked(page);\n\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off) {\n\t\t\tif (invalidatepage_can_drop(inode, bh))\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (!partial_page && ret) {\n\t\tret = try_to_release_page(page, 0);\n\t\t/* maybe should BUG_ON(!ret); - neilb */\n\t}\nout:\n\treturn;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "0"
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_unmap_buffer",
          "args": [
            "bh"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_unmap_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
          "lines": "166-191",
          "snippet": "void reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nvoid reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidatepage_can_drop",
          "args": [
            "inode",
            "bh"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "invalidatepage_can_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "3122-3173",
          "snippet": "static int invalidatepage_can_drop(struct inode *inode, struct buffer_head *bh)\n{\n\tint ret = 1;\n\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\n\tlock_buffer(bh);\n\tspin_lock(&j->j_dirty_buffers_lock);\n\tif (!buffer_mapped(bh)) {\n\t\tgoto free_jh;\n\t}\n\t/*\n\t * the page is locked, and the only places that log a data buffer\n\t * also lock the page.\n\t */\n\tif (reiserfs_file_data_log(inode)) {\n\t\t/*\n\t\t * very conservative, leave the buffer pinned if\n\t\t * anyone might need it.\n\t\t */\n\t\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\t\tret = 0;\n\t\t}\n\t} else  if (buffer_dirty(bh)) {\n\t\tstruct reiserfs_journal_list *jl;\n\t\tstruct reiserfs_jh *jh = bh->b_private;\n\n\t\t/*\n\t\t * why is this safe?\n\t\t * reiserfs_setattr updates i_size in the on disk\n\t\t * stat data before allowing vmtruncate to be called.\n\t\t *\n\t\t * If buffer was put onto the ordered list for this\n\t\t * transaction, we know for sure either this transaction\n\t\t * or an older one already has updated i_size on disk,\n\t\t * and this ordered data won't be referenced in the file\n\t\t * if we crash.\n\t\t *\n\t\t * if the buffer was put onto the ordered list for an older\n\t\t * transaction, we need to leave it around\n\t\t */\n\t\tif (jh && (jl = jh->jl)\n\t\t    && jl != SB_JOURNAL(inode->i_sb)->j_current_jl)\n\t\t\tret = 0;\n\t}\nfree_jh:\n\tif (ret && bh->b_private) {\n\t\treiserfs_free_jh(bh);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\tunlock_buffer(bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int invalidatepage_can_drop(struct inode *inode, struct buffer_head *bh)\n{\n\tint ret = 1;\n\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\n\tlock_buffer(bh);\n\tspin_lock(&j->j_dirty_buffers_lock);\n\tif (!buffer_mapped(bh)) {\n\t\tgoto free_jh;\n\t}\n\t/*\n\t * the page is locked, and the only places that log a data buffer\n\t * also lock the page.\n\t */\n\tif (reiserfs_file_data_log(inode)) {\n\t\t/*\n\t\t * very conservative, leave the buffer pinned if\n\t\t * anyone might need it.\n\t\t */\n\t\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\t\tret = 0;\n\t\t}\n\t} else  if (buffer_dirty(bh)) {\n\t\tstruct reiserfs_journal_list *jl;\n\t\tstruct reiserfs_jh *jh = bh->b_private;\n\n\t\t/*\n\t\t * why is this safe?\n\t\t * reiserfs_setattr updates i_size in the on disk\n\t\t * stat data before allowing vmtruncate to be called.\n\t\t *\n\t\t * If buffer was put onto the ordered list for this\n\t\t * transaction, we know for sure either this transaction\n\t\t * or an older one already has updated i_size on disk,\n\t\t * and this ordered data won't be referenced in the file\n\t\t * if we crash.\n\t\t *\n\t\t * if the buffer was put onto the ordered list for an older\n\t\t * transaction, we need to leave it around\n\t\t */\n\t\tif (jh && (jl = jh->jl)\n\t\t    && jl != SB_JOURNAL(inode->i_sb)->j_current_jl)\n\t\t\tret = 0;\n\t}\nfree_jh:\n\tif (ret && bh->b_private) {\n\t\treiserfs_free_jh(bh);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\tunlock_buffer(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t    unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = offset + length;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tint ret = 1;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!partial_page)\n\t\tClearPageChecked(page);\n\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off) {\n\t\t\tif (invalidatepage_can_drop(inode, bh))\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (!partial_page && ret) {\n\t\tret = try_to_release_page(page, 0);\n\t\t/* maybe should BUG_ON(!ret); - neilb */\n\t}\nout:\n\treturn;\n}"
  },
  {
    "function_name": "invalidatepage_can_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "3122-3173",
    "snippet": "static int invalidatepage_can_drop(struct inode *inode, struct buffer_head *bh)\n{\n\tint ret = 1;\n\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\n\tlock_buffer(bh);\n\tspin_lock(&j->j_dirty_buffers_lock);\n\tif (!buffer_mapped(bh)) {\n\t\tgoto free_jh;\n\t}\n\t/*\n\t * the page is locked, and the only places that log a data buffer\n\t * also lock the page.\n\t */\n\tif (reiserfs_file_data_log(inode)) {\n\t\t/*\n\t\t * very conservative, leave the buffer pinned if\n\t\t * anyone might need it.\n\t\t */\n\t\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\t\tret = 0;\n\t\t}\n\t} else  if (buffer_dirty(bh)) {\n\t\tstruct reiserfs_journal_list *jl;\n\t\tstruct reiserfs_jh *jh = bh->b_private;\n\n\t\t/*\n\t\t * why is this safe?\n\t\t * reiserfs_setattr updates i_size in the on disk\n\t\t * stat data before allowing vmtruncate to be called.\n\t\t *\n\t\t * If buffer was put onto the ordered list for this\n\t\t * transaction, we know for sure either this transaction\n\t\t * or an older one already has updated i_size on disk,\n\t\t * and this ordered data won't be referenced in the file\n\t\t * if we crash.\n\t\t *\n\t\t * if the buffer was put onto the ordered list for an older\n\t\t * transaction, we need to leave it around\n\t\t */\n\t\tif (jh && (jl = jh->jl)\n\t\t    && jl != SB_JOURNAL(inode->i_sb)->j_current_jl)\n\t\t\tret = 0;\n\t}\nfree_jh:\n\tif (ret && bh->b_private) {\n\t\treiserfs_free_jh(bh);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\tunlock_buffer(bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&j->j_dirty_buffers_lock"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_free_jh",
          "args": [
            "bh"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_jh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "731-746",
          "snippet": "void reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);\n\nvoid reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "inode->i_sb"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "bh"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_file_data_log",
          "args": [
            "inode"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_file_data_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2888-2894",
          "snippet": "static inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline int reiserfs_file_data_log(struct inode *inode)\n{\n\tif (reiserfs_data_log(inode->i_sb) ||\n\t    (REISERFS_I(inode)->i_flags & i_data_log))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&j->j_dirty_buffers_lock"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "inode->i_sb"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int invalidatepage_can_drop(struct inode *inode, struct buffer_head *bh)\n{\n\tint ret = 1;\n\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\n\tlock_buffer(bh);\n\tspin_lock(&j->j_dirty_buffers_lock);\n\tif (!buffer_mapped(bh)) {\n\t\tgoto free_jh;\n\t}\n\t/*\n\t * the page is locked, and the only places that log a data buffer\n\t * also lock the page.\n\t */\n\tif (reiserfs_file_data_log(inode)) {\n\t\t/*\n\t\t * very conservative, leave the buffer pinned if\n\t\t * anyone might need it.\n\t\t */\n\t\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\t\tret = 0;\n\t\t}\n\t} else  if (buffer_dirty(bh)) {\n\t\tstruct reiserfs_journal_list *jl;\n\t\tstruct reiserfs_jh *jh = bh->b_private;\n\n\t\t/*\n\t\t * why is this safe?\n\t\t * reiserfs_setattr updates i_size in the on disk\n\t\t * stat data before allowing vmtruncate to be called.\n\t\t *\n\t\t * If buffer was put onto the ordered list for this\n\t\t * transaction, we know for sure either this transaction\n\t\t * or an older one already has updated i_size on disk,\n\t\t * and this ordered data won't be referenced in the file\n\t\t * if we crash.\n\t\t *\n\t\t * if the buffer was put onto the ordered list for an older\n\t\t * transaction, we need to leave it around\n\t\t */\n\t\tif (jh && (jl = jh->jl)\n\t\t    && jl != SB_JOURNAL(inode->i_sb)->j_current_jl)\n\t\t\tret = 0;\n\t}\nfree_jh:\n\tif (ret && bh->b_private) {\n\t\treiserfs_free_jh(bh);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\tunlock_buffer(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "i_attrs_to_sd_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "3096-3116",
    "snippet": "void i_attrs_to_sd_attrs(struct inode *inode, __u16 * sd_attrs)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (inode->i_flags & S_IMMUTABLE)\n\t\t\t*sd_attrs |= REISERFS_IMMUTABLE_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_IMMUTABLE_FL;\n\t\tif (inode->i_flags & S_SYNC)\n\t\t\t*sd_attrs |= REISERFS_SYNC_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_SYNC_FL;\n\t\tif (inode->i_flags & S_NOATIME)\n\t\t\t*sd_attrs |= REISERFS_NOATIME_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOATIME_FL;\n\t\tif (REISERFS_I(inode)->i_flags & i_nopack_mask)\n\t\t\t*sd_attrs |= REISERFS_NOTAIL_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOTAIL_FL;\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_attrs",
          "args": [
            "inode->i_sb"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid i_attrs_to_sd_attrs(struct inode *inode, __u16 * sd_attrs)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (inode->i_flags & S_IMMUTABLE)\n\t\t\t*sd_attrs |= REISERFS_IMMUTABLE_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_IMMUTABLE_FL;\n\t\tif (inode->i_flags & S_SYNC)\n\t\t\t*sd_attrs |= REISERFS_SYNC_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_SYNC_FL;\n\t\tif (inode->i_flags & S_NOATIME)\n\t\t\t*sd_attrs |= REISERFS_NOATIME_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOATIME_FL;\n\t\tif (REISERFS_I(inode)->i_flags & i_nopack_mask)\n\t\t\t*sd_attrs |= REISERFS_NOTAIL_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOTAIL_FL;\n\t}\n}"
  },
  {
    "function_name": "sd_attrs_to_i_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "3070-3094",
    "snippet": "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_attrs",
          "args": [
            "inode->i_sb"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}"
  },
  {
    "function_name": "reiserfs_commit_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2994-3068",
    "snippet": "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around\n\t\t * on the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_end_persistent_transaction",
          "args": [
            "th"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_end_persistent_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3174-3187",
          "snippet": "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "inode"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&myth"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&myth",
            "inode->i_sb",
            "1"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_block_size",
          "args": [
            "inode"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_small_tails",
          "args": [
            "inode->i_sb"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_block_size",
          "args": [
            "inode"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_large_tails",
          "args": [
            "inode->i_sb"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_commit_page",
          "args": [
            "inode",
            "page",
            "from",
            "to"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_commit_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/file.c",
          "lines": "176-243",
          "snippet": "int reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\tunsigned long i_size_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint new;\n\tint logit = reiserfs_file_data_log(inode);\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;\n\tstruct reiserfs_transaction_handle th;\n\tint ret = 0;\n\n\tth.t_trans_id = 0;\n\tblocksize = 1 << inode->i_blkbits;\n\n\tif (logit) {\n\t\treiserfs_write_lock(s);\n\t\tret = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (ret)\n\t\t\tgoto drop_write_lock;\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\n\t\tnew = buffer_new(bh);\n\t\tclear_buffer_new(bh);\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (logit) {\n\t\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\t} else if (!buffer_dirty(bh)) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t/*\n\t\t\t\t * do data=ordered on any page past the end\n\t\t\t\t * of file and any buffer marked BH_New.\n\t\t\t\t */\n\t\t\t\tif (reiserfs_data_ordered(inode->i_sb) &&\n\t\t\t\t    (new || page->index >= i_size_index)) {\n\t\t\t\t\treiserfs_add_ordered_list(inode, bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (logit) {\n\t\tret = journal_end(&th);\ndrop_write_lock:\n\t\treiserfs_write_unlock(s);\n\t}\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\tunsigned long i_size_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint new;\n\tint logit = reiserfs_file_data_log(inode);\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;\n\tstruct reiserfs_transaction_handle th;\n\tint ret = 0;\n\n\tth.t_trans_id = 0;\n\tblocksize = 1 << inode->i_blkbits;\n\n\tif (logit) {\n\t\treiserfs_write_lock(s);\n\t\tret = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (ret)\n\t\t\tgoto drop_write_lock;\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\n\t\tnew = buffer_new(bh);\n\t\tclear_buffer_new(bh);\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (logit) {\n\t\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\t} else if (!buffer_dirty(bh)) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t/*\n\t\t\t\t * do data=ordered on any page past the end\n\t\t\t\t * of file and any buffer marked BH_New.\n\t\t\t\t */\n\t\t\t\tif (reiserfs_data_ordered(inode->i_sb) &&\n\t\t\t\t    (new || page->index >= i_size_index)) {\n\t\t\t\t\treiserfs_add_ordered_list(inode, bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (logit) {\n\t\tret = journal_end(&th);\ndrop_write_lock:\n\t\treiserfs_write_unlock(s);\n\t}\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_transaction_running",
          "args": [
            "inode->i_sb"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_transaction_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2896-2904",
          "snippet": "static inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "inode->i_sb",
            "depth"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_wait_on_write_block",
          "args": [
            "inode->i_sb"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_wait_on_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2952-2957",
          "snippet": "void reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "inode->i_sb"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around\n\t\t * on the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2891-2992",
    "snippet": "static int reiserfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t      loff_t pos, unsigned len, unsigned copied,\n\t\t\t      struct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th;\n\tunsigned start;\n\tbool locked = false;\n\n\tif ((unsigned long)fsdata & AOP_FLAG_CONT_EXPAND)\n\t\tpos ++;\n\n\treiserfs_wait_on_write_block(inode->i_sb);\n\tif (reiserfs_transaction_running(inode->i_sb))\n\t\tth = current->journal_info;\n\telse\n\t\tth = NULL;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start + copied, start + len);\n\t}\n\tflush_dcache_page(page);\n\n\treiserfs_commit_page(inode, page, start, start + copied);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tlocked = true;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos + copied;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around on\n\t\t * the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!locked) {\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tlocked = true;\n\t\t}\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (locked)\n\t\treiserfs_write_unlock(inode->i_sb);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (pos + len > inode->i_size)\n\t\treiserfs_truncate_failed_write(inode);\n\n\treturn ret == 0 ? copied : ret;\n\njournal_error:\n\treiserfs_write_unlock(inode->i_sb);\n\tlocked = false;\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_end_persistent_transaction",
          "args": [
            "th"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_end_persistent_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3174-3187",
          "snippet": "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "inode"
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2751-2755",
          "snippet": "static void reiserfs_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\treiserfs_truncate_file(inode, 0);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\treiserfs_truncate_file(inode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&myth"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&myth",
            "inode->i_sb",
            "1"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_block_size",
          "args": [
            "inode"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_small_tails",
          "args": [
            "inode->i_sb"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_block_size",
          "args": [
            "inode"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_large_tails",
          "args": [
            "inode->i_sb"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_commit_page",
          "args": [
            "inode",
            "page",
            "start",
            "start + copied"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_commit_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/file.c",
          "lines": "176-243",
          "snippet": "int reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\tunsigned long i_size_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint new;\n\tint logit = reiserfs_file_data_log(inode);\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;\n\tstruct reiserfs_transaction_handle th;\n\tint ret = 0;\n\n\tth.t_trans_id = 0;\n\tblocksize = 1 << inode->i_blkbits;\n\n\tif (logit) {\n\t\treiserfs_write_lock(s);\n\t\tret = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (ret)\n\t\t\tgoto drop_write_lock;\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\n\t\tnew = buffer_new(bh);\n\t\tclear_buffer_new(bh);\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (logit) {\n\t\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\t} else if (!buffer_dirty(bh)) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t/*\n\t\t\t\t * do data=ordered on any page past the end\n\t\t\t\t * of file and any buffer marked BH_New.\n\t\t\t\t */\n\t\t\t\tif (reiserfs_data_ordered(inode->i_sb) &&\n\t\t\t\t    (new || page->index >= i_size_index)) {\n\t\t\t\t\treiserfs_add_ordered_list(inode, bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (logit) {\n\t\tret = journal_end(&th);\ndrop_write_lock:\n\t\treiserfs_write_unlock(s);\n\t}\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\tunsigned long i_size_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint new;\n\tint logit = reiserfs_file_data_log(inode);\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;\n\tstruct reiserfs_transaction_handle th;\n\tint ret = 0;\n\n\tth.t_trans_id = 0;\n\tblocksize = 1 << inode->i_blkbits;\n\n\tif (logit) {\n\t\treiserfs_write_lock(s);\n\t\tret = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (ret)\n\t\t\tgoto drop_write_lock;\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\tfor (bh = head = page_buffers(page), block_start = 0;\n\t     bh != head || !block_start;\n\t     block_start = block_end, bh = bh->b_this_page) {\n\n\t\tnew = buffer_new(bh);\n\t\tclear_buffer_new(bh);\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (logit) {\n\t\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\t} else if (!buffer_dirty(bh)) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t/*\n\t\t\t\t * do data=ordered on any page past the end\n\t\t\t\t * of file and any buffer marked BH_New.\n\t\t\t\t */\n\t\t\t\tif (reiserfs_data_ordered(inode->i_sb) &&\n\t\t\t\t    (new || page->index >= i_size_index)) {\n\t\t\t\t\treiserfs_add_ordered_list(inode, bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (logit) {\n\t\tret = journal_end(&th);\ndrop_write_lock:\n\t\treiserfs_write_unlock(s);\n\t}\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "start + copied",
            "start + len"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1845-1879",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < len"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_transaction_running",
          "args": [
            "inode->i_sb"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_transaction_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2896-2904",
          "snippet": "static inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_wait_on_write_block",
          "args": [
            "inode->i_sb"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_wait_on_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2952-2957",
          "snippet": "void reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int reiserfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t      loff_t pos, unsigned len, unsigned copied,\n\t\t\t      struct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th;\n\tunsigned start;\n\tbool locked = false;\n\n\tif ((unsigned long)fsdata & AOP_FLAG_CONT_EXPAND)\n\t\tpos ++;\n\n\treiserfs_wait_on_write_block(inode->i_sb);\n\tif (reiserfs_transaction_running(inode->i_sb))\n\t\tth = current->journal_info;\n\telse\n\t\tth = NULL;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start + copied, start + len);\n\t}\n\tflush_dcache_page(page);\n\n\treiserfs_commit_page(inode, page, start, start + copied);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tlocked = true;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos + copied;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around on\n\t\t * the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!locked) {\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tlocked = true;\n\t\t}\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (locked)\n\t\treiserfs_write_unlock(inode->i_sb);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (pos + len > inode->i_size)\n\t\treiserfs_truncate_failed_write(inode);\n\n\treturn ret == 0 ? copied : ret;\n\njournal_error:\n\treiserfs_write_unlock(inode->i_sb);\n\tlocked = false;\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "reiserfs_aop_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2886-2889",
    "snippet": "static sector_t reiserfs_aop_bmap(struct address_space *as, sector_t block)\n{\n\treturn generic_block_bmap(as, block, reiserfs_bmap);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "as",
            "block",
            "reiserfs_bmap"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic sector_t reiserfs_aop_bmap(struct address_space *as, sector_t block)\n{\n\treturn generic_block_bmap(as, block, reiserfs_bmap);\n}"
  },
  {
    "function_name": "__reiserfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2831-2884",
    "snippet": "int __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_end_persistent_transaction",
          "args": [
            "th"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_end_persistent_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3174-3187",
          "snippet": "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_transaction_running",
          "args": [
            "inode->i_sb"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_transaction_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2896-2904",
          "snippet": "static inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "from",
            "len",
            "reiserfs_get_block"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_refcount"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fix_tail_page_for_writing",
          "args": [
            "page"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "fix_tail_page_for_writing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "192-207",
          "snippet": "static inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "inode->i_sb",
            "depth"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_wait_on_write_block",
          "args": [
            "inode->i_sb"
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_wait_on_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2952-2957",
          "snippet": "void reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}"
  },
  {
    "function_name": "reiserfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2757-2829",
    "snippet": "static int reiserfs_write_begin(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\tint old_ref = 0;\n\n \tinode = mapping->host;\n\t*fsdata = NULL;\n \tif (flags & AOP_FLAG_CONT_EXPAND &&\n \t    (pos & (inode->i_sb->s_blocksize - 1)) == 0) {\n \t\tpos ++;\n\t\t*fsdata = (void *)(unsigned long)flags;\n\t}\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\treiserfs_wait_on_write_block(inode->i_sb);\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\tret = __block_write_begin(page, pos, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\t/* Truncate allocated blocks */\n\t\treiserfs_truncate_failed_write(inode);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2751-2755",
          "snippet": "static void reiserfs_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\treiserfs_truncate_file(inode, 0);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\treiserfs_truncate_file(inode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_end_persistent_transaction",
          "args": [
            "th"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_end_persistent_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3174-3187",
          "snippet": "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_transaction_running",
          "args": [
            "inode->i_sb"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_transaction_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2896-2904",
          "snippet": "static inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "reiserfs_get_block"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_refcount"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fix_tail_page_for_writing",
          "args": [
            "page"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "fix_tail_page_for_writing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "192-207",
          "snippet": "static inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_wait_on_write_block",
          "args": [
            "inode->i_sb"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_wait_on_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2952-2957",
          "snippet": "void reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int reiserfs_write_begin(struct file *file,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\tint old_ref = 0;\n\n \tinode = mapping->host;\n\t*fsdata = NULL;\n \tif (flags & AOP_FLAG_CONT_EXPAND &&\n \t    (pos & (inode->i_sb->s_blocksize - 1)) == 0) {\n \t\tpos ++;\n\t\t*fsdata = (void *)(unsigned long)flags;\n\t}\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\treiserfs_wait_on_write_block(inode->i_sb);\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\tret = __block_write_begin(page, pos, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\t/* Truncate allocated blocks */\n\t\treiserfs_truncate_failed_write(inode);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_truncate_failed_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2751-2755",
    "snippet": "static void reiserfs_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\treiserfs_truncate_file(inode, 0);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_truncate_file",
          "args": [
            "inode",
            "0"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_truncate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2263-2362",
          "snippet": "int reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t/* we want the offset for the first byte after the end of the file */\n\tunsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * -ENOENT means we truncated past the end of the\n\t\t\t * file, and get_block_create_0 could not find a\n\t\t\t * block to read in, which is ok.\n\t\t\t */\n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * so, if page != NULL, we have a buffer head for the offset at\n\t * the end of the file. if the bh is mapped, and bh->b_blocknr != 0,\n\t * then we have an unformatted node.  Otherwise, we have a direct item,\n\t * and no zeroing is required on disk.  We zero after the truncate,\n\t * because the truncate might pack the item anyway\n\t * (it will unmap bh if it packs).\n\t *\n\t * it is enough to reserve space in transaction for 2 balancings:\n\t * one for \"save\" link adding and another for the first\n\t * cut_from_item. 1 is for update_sd\n\t */\n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t/*\n\t\t * we are doing real truncate: if the system crashes\n\t\t * before the last transaction of truncating gets committed\n\t\t * - on reboot the file either appears truncated properly\n\t\t * or not truncated at all\n\t\t */\n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t/* check reiserfs_do_truncate after ending the transaction */\n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1 /* truncate */);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t/* if we are not on a block boundary */\n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t/* we want the offset for the first byte after the end of the file */\n\tunsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * -ENOENT means we truncated past the end of the\n\t\t\t * file, and get_block_create_0 could not find a\n\t\t\t * block to read in, which is ok.\n\t\t\t */\n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * so, if page != NULL, we have a buffer head for the offset at\n\t * the end of the file. if the bh is mapped, and bh->b_blocknr != 0,\n\t * then we have an unformatted node.  Otherwise, we have a direct item,\n\t * and no zeroing is required on disk.  We zero after the truncate,\n\t * because the truncate might pack the item anyway\n\t * (it will unmap bh if it packs).\n\t *\n\t * it is enough to reserve space in transaction for 2 balancings:\n\t * one for \"save\" link adding and another for the first\n\t * cut_from_item. 1 is for update_sd\n\t */\n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t/*\n\t\t * we are doing real truncate: if the system crashes\n\t\t * before the last transaction of truncating gets committed\n\t\t * - on reboot the file either appears truncated properly\n\t\t * or not truncated at all\n\t\t */\n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t/* check reiserfs_do_truncate after ending the transaction */\n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1 /* truncate */);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t/* if we are not on a block boundary */\n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "inode->i_mapping",
            "inode->i_size"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\treiserfs_truncate_file(inode, 0);\n}"
  },
  {
    "function_name": "reiserfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2744-2749",
    "snippet": "static int reiserfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treturn reiserfs_write_full_page(page, wbc);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_full_page",
          "args": [
            "page",
            "wbc"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2523-2737",
          "snippet": "static int reiserfs_write_full_page(struct page *page,\n\t\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint error = 0;\n\tunsigned long block;\n\tsector_t last_block;\n\tstruct buffer_head *head, *bh;\n\tint partial = 0;\n\tint nr = 0;\n\tint checked = PageChecked(page);\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;\n\tth.t_trans_id = 0;\n\n\t/* no logging allowed when nonblocking or from PF_MEMALLOC */\n\tif (checked && (current->flags & PF_MEMALLOC)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The page dirty bit is cleared before writepage is called, which\n\t * means we have to tell create_empty_buffers to make dirty buffers\n\t * The page really should be up to date at this point, so tossing\n\t * in the BH_Uptodate is just a sanity check.\n\t */\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, s->s_blocksize,\n\t\t\t\t     (1 << BH_Dirty) | (1 << BH_Uptodate));\n\t}\n\thead = page_buffers(page);\n\n\t/*\n\t * last page in the file, zero out any contents past the\n\t * last byte in the file\n\t */\n\tif (page->index >= end_index) {\n\t\tunsigned last_offset;\n\n\t\tlast_offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\t\t/* no file contents in this page */\n\t\tif (page->index >= end_index + 1 || !last_offset) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tzero_user_segment(page, last_offset, PAGE_CACHE_SIZE);\n\t}\n\tbh = head;\n\tblock = page->index << (PAGE_CACHE_SHIFT - s->s_blocksize_bits);\n\tlast_block = (i_size_read(inode) - 1) >> inode->i_blkbits;\n\t/* first map all the buffers, logging any direct items we find */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * This can happen when the block size is less than\n\t\t\t * the page size.  The corresponding bytes in the page\n\t\t\t * were zero filled above\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((checked || buffer_dirty(bh)) &&\n\t\t           (!buffer_mapped(bh) || (buffer_mapped(bh)\n\t\t\t\t\t\t       && bh->b_blocknr ==\n\t\t\t\t\t\t       0))) {\n\t\t\t/*\n\t\t\t * not mapped yet, or it points to a direct item, search\n\t\t\t * the btree for the mapping info, and log any direct\n\t\t\t * items found\n\t\t\t */\n\t\t\tif ((error = map_block_for_writepage(inode, bh, block))) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\t/*\n\t * we start the transaction after map_block_for_writepage,\n\t * because it can create holes in the file (an unbounded operation).\n\t * starting it here, we can make a reliable estimate for how many\n\t * blocks we're going to log\n\t */\n\tif (checked) {\n\t\tClearPageChecked(page);\n\t\treiserfs_write_lock(s);\n\t\terror = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (error) {\n\t\t\treiserfs_write_unlock(s);\n\t\t\tgoto fail;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\t/* now go through and lock any dirty buffers on the page */\n\tdo {\n\t\tget_bh(bh);\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0)\n\t\t\tcontinue;\n\n\t\tif (checked) {\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * from this point on, we know the buffer is mapped to a\n\t\t * real block and not a direct item\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (checked) {\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(s);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\n\t/*\n\t * since any buffer might be the only dirty buffer on the page,\n\t * the first submit_bh can bring the page out of writeback.\n\t * be careful with the buffers.\n\t */\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\n\terror = 0;\ndone:\n\tif (nr == 0) {\n\t\t/*\n\t\t * if this page only had a direct item, it is very possible for\n\t\t * no io to be required without there being an error.  Or,\n\t\t * someone else could have locked them and sent them down the\n\t\t * pipe without locking the page\n\t\t */\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tpartial = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t\tend_page_writeback(page);\n\t}\n\treturn error;\n\nfail:\n\t/*\n\t * catches various errors, we need to make sure any valid dirty blocks\n\t * get to the media.  The page is currently locked and not marked for\n\t * writeback\n\t */\n\tClearPageUptodate(page);\n\tbh = head;\n\tdo {\n\t\tget_bh(bh);\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) && bh->b_blocknr) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * clear any dirty bits that might have come from\n\t\t\t * getting attached to a dirty page\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\tgoto done;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int reiserfs_write_full_page(struct page *page,\n\t\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint error = 0;\n\tunsigned long block;\n\tsector_t last_block;\n\tstruct buffer_head *head, *bh;\n\tint partial = 0;\n\tint nr = 0;\n\tint checked = PageChecked(page);\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;\n\tth.t_trans_id = 0;\n\n\t/* no logging allowed when nonblocking or from PF_MEMALLOC */\n\tif (checked && (current->flags & PF_MEMALLOC)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The page dirty bit is cleared before writepage is called, which\n\t * means we have to tell create_empty_buffers to make dirty buffers\n\t * The page really should be up to date at this point, so tossing\n\t * in the BH_Uptodate is just a sanity check.\n\t */\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, s->s_blocksize,\n\t\t\t\t     (1 << BH_Dirty) | (1 << BH_Uptodate));\n\t}\n\thead = page_buffers(page);\n\n\t/*\n\t * last page in the file, zero out any contents past the\n\t * last byte in the file\n\t */\n\tif (page->index >= end_index) {\n\t\tunsigned last_offset;\n\n\t\tlast_offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\t\t/* no file contents in this page */\n\t\tif (page->index >= end_index + 1 || !last_offset) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tzero_user_segment(page, last_offset, PAGE_CACHE_SIZE);\n\t}\n\tbh = head;\n\tblock = page->index << (PAGE_CACHE_SHIFT - s->s_blocksize_bits);\n\tlast_block = (i_size_read(inode) - 1) >> inode->i_blkbits;\n\t/* first map all the buffers, logging any direct items we find */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * This can happen when the block size is less than\n\t\t\t * the page size.  The corresponding bytes in the page\n\t\t\t * were zero filled above\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((checked || buffer_dirty(bh)) &&\n\t\t           (!buffer_mapped(bh) || (buffer_mapped(bh)\n\t\t\t\t\t\t       && bh->b_blocknr ==\n\t\t\t\t\t\t       0))) {\n\t\t\t/*\n\t\t\t * not mapped yet, or it points to a direct item, search\n\t\t\t * the btree for the mapping info, and log any direct\n\t\t\t * items found\n\t\t\t */\n\t\t\tif ((error = map_block_for_writepage(inode, bh, block))) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\t/*\n\t * we start the transaction after map_block_for_writepage,\n\t * because it can create holes in the file (an unbounded operation).\n\t * starting it here, we can make a reliable estimate for how many\n\t * blocks we're going to log\n\t */\n\tif (checked) {\n\t\tClearPageChecked(page);\n\t\treiserfs_write_lock(s);\n\t\terror = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (error) {\n\t\t\treiserfs_write_unlock(s);\n\t\t\tgoto fail;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\t/* now go through and lock any dirty buffers on the page */\n\tdo {\n\t\tget_bh(bh);\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0)\n\t\t\tcontinue;\n\n\t\tif (checked) {\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * from this point on, we know the buffer is mapped to a\n\t\t * real block and not a direct item\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (checked) {\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(s);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\n\t/*\n\t * since any buffer might be the only dirty buffer on the page,\n\t * the first submit_bh can bring the page out of writeback.\n\t * be careful with the buffers.\n\t */\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\n\terror = 0;\ndone:\n\tif (nr == 0) {\n\t\t/*\n\t\t * if this page only had a direct item, it is very possible for\n\t\t * no io to be required without there being an error.  Or,\n\t\t * someone else could have locked them and sent them down the\n\t\t * pipe without locking the page\n\t\t */\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tpartial = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t\tend_page_writeback(page);\n\t}\n\treturn error;\n\nfail:\n\t/*\n\t * catches various errors, we need to make sure any valid dirty blocks\n\t * get to the media.  The page is currently locked and not marked for\n\t * writeback\n\t */\n\tClearPageUptodate(page);\n\tbh = head;\n\tdo {\n\t\tget_bh(bh);\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) && bh->b_blocknr) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * clear any dirty bits that might have come from\n\t\t\t * getting attached to a dirty page\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_wait_on_write_block",
          "args": [
            "inode->i_sb"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_wait_on_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2952-2957",
          "snippet": "void reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treturn reiserfs_write_full_page(page, wbc);\n}"
  },
  {
    "function_name": "reiserfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2739-2742",
    "snippet": "static int reiserfs_readpage(struct file *f, struct page *page)\n{\n\treturn block_read_full_page(page, reiserfs_get_block);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "reiserfs_get_block"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_readpage(struct file *f, struct page *page)\n{\n\treturn block_read_full_page(page, reiserfs_get_block);\n}"
  },
  {
    "function_name": "reiserfs_write_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2523-2737",
    "snippet": "static int reiserfs_write_full_page(struct page *page,\n\t\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint error = 0;\n\tunsigned long block;\n\tsector_t last_block;\n\tstruct buffer_head *head, *bh;\n\tint partial = 0;\n\tint nr = 0;\n\tint checked = PageChecked(page);\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;\n\tth.t_trans_id = 0;\n\n\t/* no logging allowed when nonblocking or from PF_MEMALLOC */\n\tif (checked && (current->flags & PF_MEMALLOC)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The page dirty bit is cleared before writepage is called, which\n\t * means we have to tell create_empty_buffers to make dirty buffers\n\t * The page really should be up to date at this point, so tossing\n\t * in the BH_Uptodate is just a sanity check.\n\t */\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, s->s_blocksize,\n\t\t\t\t     (1 << BH_Dirty) | (1 << BH_Uptodate));\n\t}\n\thead = page_buffers(page);\n\n\t/*\n\t * last page in the file, zero out any contents past the\n\t * last byte in the file\n\t */\n\tif (page->index >= end_index) {\n\t\tunsigned last_offset;\n\n\t\tlast_offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\t\t/* no file contents in this page */\n\t\tif (page->index >= end_index + 1 || !last_offset) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tzero_user_segment(page, last_offset, PAGE_CACHE_SIZE);\n\t}\n\tbh = head;\n\tblock = page->index << (PAGE_CACHE_SHIFT - s->s_blocksize_bits);\n\tlast_block = (i_size_read(inode) - 1) >> inode->i_blkbits;\n\t/* first map all the buffers, logging any direct items we find */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * This can happen when the block size is less than\n\t\t\t * the page size.  The corresponding bytes in the page\n\t\t\t * were zero filled above\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((checked || buffer_dirty(bh)) &&\n\t\t           (!buffer_mapped(bh) || (buffer_mapped(bh)\n\t\t\t\t\t\t       && bh->b_blocknr ==\n\t\t\t\t\t\t       0))) {\n\t\t\t/*\n\t\t\t * not mapped yet, or it points to a direct item, search\n\t\t\t * the btree for the mapping info, and log any direct\n\t\t\t * items found\n\t\t\t */\n\t\t\tif ((error = map_block_for_writepage(inode, bh, block))) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\t/*\n\t * we start the transaction after map_block_for_writepage,\n\t * because it can create holes in the file (an unbounded operation).\n\t * starting it here, we can make a reliable estimate for how many\n\t * blocks we're going to log\n\t */\n\tif (checked) {\n\t\tClearPageChecked(page);\n\t\treiserfs_write_lock(s);\n\t\terror = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (error) {\n\t\t\treiserfs_write_unlock(s);\n\t\t\tgoto fail;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\t/* now go through and lock any dirty buffers on the page */\n\tdo {\n\t\tget_bh(bh);\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0)\n\t\t\tcontinue;\n\n\t\tif (checked) {\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * from this point on, we know the buffer is mapped to a\n\t\t * real block and not a direct item\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (checked) {\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(s);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\n\t/*\n\t * since any buffer might be the only dirty buffer on the page,\n\t * the first submit_bh can bring the page out of writeback.\n\t * be careful with the buffers.\n\t */\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\n\terror = 0;\ndone:\n\tif (nr == 0) {\n\t\t/*\n\t\t * if this page only had a direct item, it is very possible for\n\t\t * no io to be required without there being an error.  Or,\n\t\t * someone else could have locked them and sent them down the\n\t\t * pipe without locking the page\n\t\t */\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tpartial = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t\tend_page_writeback(page);\n\t}\n\treturn error;\n\nfail:\n\t/*\n\t * catches various errors, we need to make sure any valid dirty blocks\n\t * get to the media.  The page is currently locked and not marked for\n\t * writeback\n\t */\n\tClearPageUptodate(page);\n\tbh = head;\n\tdo {\n\t\tget_bh(bh);\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) && bh->b_blocknr) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * clear any dirty bits that might have come from\n\t\t\t * getting attached to a dirty page\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\tgoto done;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE",
            "bh"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "420-423",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "s"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "bh"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "bh",
            "1"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "s",
            "bh_per_page + 1"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "s"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_block_for_writepage",
          "args": [
            "inode",
            "bh",
            "block"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "map_block_for_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2364-2516",
          "snippet": "static int map_block_for_writepage(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh_result,\n\t\t\t\t   unsigned long block)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint fs_gen;\n\tstruct item_head tmp_ih;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\t__le32 *item;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tint jbegin_count = JOURNAL_PER_BALANCE_CNT;\n\tloff_t byte_offset = ((loff_t)block << inode->i_sb->s_blocksize_bits)+1;\n\tint retval;\n\tint use_get_block = 0;\n\tint bytes_copied = 0;\n\tint copy_size;\n\tint trans_running = 0;\n\n\t/*\n\t * catch places below that try to log something without\n\t * starting a trans\n\t */\n\tth.t_trans_id = 0;\n\n\tif (!buffer_uptodate(bh_result)) {\n\t\treturn -EIO;\n\t}\n\n\tkmap(bh_result->b_page);\nstart_over:\n\treiserfs_write_lock(inode->i_sb);\n\tmake_cpu_key(&key, inode, byte_offset, TYPE_ANY, 3);\n\nresearch:\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval != POSITION_FOUND) {\n\t\tuse_get_block = 1;\n\t\tgoto out;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\t/* we've found an unformatted node */\n\tif (indirect_item_found(retval, ih)) {\n\t\tif (bytes_copied > 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"clm-6002\",\n\t\t\t\t\t \"bytes_copied %d\", bytes_copied);\n\t\t}\n\t\tif (!get_block_num(item, pos_in_item)) {\n\t\t\t/* crap, we are writing to a hole */\n\t\t\tuse_get_block = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t     get_block_num(item, pos_in_item), inode);\n\t} else if (is_direct_le_ih(ih)) {\n\t\tchar *p;\n\t\tp = page_address(bh_result->b_page);\n\t\tp += (byte_offset - 1) & (PAGE_CACHE_SIZE - 1);\n\t\tcopy_size = ih_item_len(ih) - pos_in_item;\n\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tcopy_item_head(&tmp_ih, ih);\n\n\t\tif (!trans_running) {\n\t\t\t/* vs-3050 is gone, no need to drop the path */\n\t\t\tretval = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\t\tif (retval)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t\ttrans_running = 1;\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t}\n\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tgoto research;\n\t\t}\n\n\t\tmemcpy(ih_item_body(bh, ih) + pos_in_item, p + bytes_copied,\n\t\t       copy_size);\n\n\t\tjournal_mark_dirty(&th, bh);\n\t\tbytes_copied += copy_size;\n\t\tset_block_dev_mapped(bh_result, 0, inode);\n\n\t\t/* are there still bytes left? */\n\t\tif (bytes_copied < bh_result->b_size &&\n\t\t    (byte_offset + bytes_copied) < inode->i_size) {\n\t\t\tset_cpu_key_k_offset(&key,\n\t\t\t\t\t     cpu_key_k_offset(&key) +\n\t\t\t\t\t     copy_size);\n\t\t\tgoto research;\n\t\t}\n\t} else {\n\t\treiserfs_warning(inode->i_sb, \"clm-6003\",\n\t\t\t\t \"bad item inode %lu\", inode->i_ino);\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\tretval = 0;\n\nout:\n\tpathrelse(&path);\n\tif (trans_running) {\n\t\tint err = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\ttrans_running = 0;\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\t/* this is where we fill in holes in the file. */\n\tif (use_get_block) {\n\t\tretval = reiserfs_get_block(inode, block, bh_result,\n\t\t\t\t\t    GET_BLOCK_CREATE | GET_BLOCK_NO_IMUX\n\t\t\t\t\t    | GET_BLOCK_NO_DANGLE);\n\t\tif (!retval) {\n\t\t\tif (!buffer_mapped(bh_result)\n\t\t\t    || bh_result->b_blocknr == 0) {\n\t\t\t\t/* get_block failed to find a mapped unformatted node. */\n\t\t\t\tuse_get_block = 0;\n\t\t\t\tgoto start_over;\n\t\t\t}\n\t\t}\n\t}\n\tkunmap(bh_result->b_page);\n\n\tif (!retval && buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {\n\t\t/*\n\t\t * we've copied data from the page into the direct item, so the\n\t\t * buffer in the page is now clean, mark it to reflect that.\n\t\t */\n\t\tlock_buffer(bh_result);\n\t\tclear_buffer_dirty(bh_result);\n\t\tunlock_buffer(bh_result);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int map_block_for_writepage(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh_result,\n\t\t\t\t   unsigned long block)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint fs_gen;\n\tstruct item_head tmp_ih;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\t__le32 *item;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tint jbegin_count = JOURNAL_PER_BALANCE_CNT;\n\tloff_t byte_offset = ((loff_t)block << inode->i_sb->s_blocksize_bits)+1;\n\tint retval;\n\tint use_get_block = 0;\n\tint bytes_copied = 0;\n\tint copy_size;\n\tint trans_running = 0;\n\n\t/*\n\t * catch places below that try to log something without\n\t * starting a trans\n\t */\n\tth.t_trans_id = 0;\n\n\tif (!buffer_uptodate(bh_result)) {\n\t\treturn -EIO;\n\t}\n\n\tkmap(bh_result->b_page);\nstart_over:\n\treiserfs_write_lock(inode->i_sb);\n\tmake_cpu_key(&key, inode, byte_offset, TYPE_ANY, 3);\n\nresearch:\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval != POSITION_FOUND) {\n\t\tuse_get_block = 1;\n\t\tgoto out;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\t/* we've found an unformatted node */\n\tif (indirect_item_found(retval, ih)) {\n\t\tif (bytes_copied > 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"clm-6002\",\n\t\t\t\t\t \"bytes_copied %d\", bytes_copied);\n\t\t}\n\t\tif (!get_block_num(item, pos_in_item)) {\n\t\t\t/* crap, we are writing to a hole */\n\t\t\tuse_get_block = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t     get_block_num(item, pos_in_item), inode);\n\t} else if (is_direct_le_ih(ih)) {\n\t\tchar *p;\n\t\tp = page_address(bh_result->b_page);\n\t\tp += (byte_offset - 1) & (PAGE_CACHE_SIZE - 1);\n\t\tcopy_size = ih_item_len(ih) - pos_in_item;\n\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tcopy_item_head(&tmp_ih, ih);\n\n\t\tif (!trans_running) {\n\t\t\t/* vs-3050 is gone, no need to drop the path */\n\t\t\tretval = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\t\tif (retval)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t\ttrans_running = 1;\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t}\n\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tgoto research;\n\t\t}\n\n\t\tmemcpy(ih_item_body(bh, ih) + pos_in_item, p + bytes_copied,\n\t\t       copy_size);\n\n\t\tjournal_mark_dirty(&th, bh);\n\t\tbytes_copied += copy_size;\n\t\tset_block_dev_mapped(bh_result, 0, inode);\n\n\t\t/* are there still bytes left? */\n\t\tif (bytes_copied < bh_result->b_size &&\n\t\t    (byte_offset + bytes_copied) < inode->i_size) {\n\t\t\tset_cpu_key_k_offset(&key,\n\t\t\t\t\t     cpu_key_k_offset(&key) +\n\t\t\t\t\t     copy_size);\n\t\t\tgoto research;\n\t\t}\n\t} else {\n\t\treiserfs_warning(inode->i_sb, \"clm-6003\",\n\t\t\t\t \"bad item inode %lu\", inode->i_ino);\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\tretval = 0;\n\nout:\n\tpathrelse(&path);\n\tif (trans_running) {\n\t\tint err = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\ttrans_running = 0;\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\t/* this is where we fill in holes in the file. */\n\tif (use_get_block) {\n\t\tretval = reiserfs_get_block(inode, block, bh_result,\n\t\t\t\t\t    GET_BLOCK_CREATE | GET_BLOCK_NO_IMUX\n\t\t\t\t\t    | GET_BLOCK_NO_DANGLE);\n\t\tif (!retval) {\n\t\t\tif (!buffer_mapped(bh_result)\n\t\t\t    || bh_result->b_blocknr == 0) {\n\t\t\t\t/* get_block failed to find a mapped unformatted node. */\n\t\t\t\tuse_get_block = 0;\n\t\t\t\tgoto start_over;\n\t\t\t}\n\t\t}\n\t}\n\tkunmap(bh_result->b_page);\n\n\tif (!retval && buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {\n\t\t/*\n\t\t * we've copied data from the page into the direct item, so the\n\t\t * buffer in the page is now clean, mark it to reflect that.\n\t\t */\n\t\tlock_buffer(bh_result);\n\t\tclear_buffer_dirty(bh_result);\n\t\tunlock_buffer(bh_result);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "last_offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "s->s_blocksize",
            "(1 << BH_Dirty) | (1 << BH_Uptodate)"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int reiserfs_write_full_page(struct page *page,\n\t\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;\n\tint error = 0;\n\tunsigned long block;\n\tsector_t last_block;\n\tstruct buffer_head *head, *bh;\n\tint partial = 0;\n\tint nr = 0;\n\tint checked = PageChecked(page);\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *s = inode->i_sb;\n\tint bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;\n\tth.t_trans_id = 0;\n\n\t/* no logging allowed when nonblocking or from PF_MEMALLOC */\n\tif (checked && (current->flags & PF_MEMALLOC)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The page dirty bit is cleared before writepage is called, which\n\t * means we have to tell create_empty_buffers to make dirty buffers\n\t * The page really should be up to date at this point, so tossing\n\t * in the BH_Uptodate is just a sanity check.\n\t */\n\tif (!page_has_buffers(page)) {\n\t\tcreate_empty_buffers(page, s->s_blocksize,\n\t\t\t\t     (1 << BH_Dirty) | (1 << BH_Uptodate));\n\t}\n\thead = page_buffers(page);\n\n\t/*\n\t * last page in the file, zero out any contents past the\n\t * last byte in the file\n\t */\n\tif (page->index >= end_index) {\n\t\tunsigned last_offset;\n\n\t\tlast_offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\t\t/* no file contents in this page */\n\t\tif (page->index >= end_index + 1 || !last_offset) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tzero_user_segment(page, last_offset, PAGE_CACHE_SIZE);\n\t}\n\tbh = head;\n\tblock = page->index << (PAGE_CACHE_SHIFT - s->s_blocksize_bits);\n\tlast_block = (i_size_read(inode) - 1) >> inode->i_blkbits;\n\t/* first map all the buffers, logging any direct items we find */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * This can happen when the block size is less than\n\t\t\t * the page size.  The corresponding bytes in the page\n\t\t\t * were zero filled above\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((checked || buffer_dirty(bh)) &&\n\t\t           (!buffer_mapped(bh) || (buffer_mapped(bh)\n\t\t\t\t\t\t       && bh->b_blocknr ==\n\t\t\t\t\t\t       0))) {\n\t\t\t/*\n\t\t\t * not mapped yet, or it points to a direct item, search\n\t\t\t * the btree for the mapping info, and log any direct\n\t\t\t * items found\n\t\t\t */\n\t\t\tif ((error = map_block_for_writepage(inode, bh, block))) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\t/*\n\t * we start the transaction after map_block_for_writepage,\n\t * because it can create holes in the file (an unbounded operation).\n\t * starting it here, we can make a reliable estimate for how many\n\t * blocks we're going to log\n\t */\n\tif (checked) {\n\t\tClearPageChecked(page);\n\t\treiserfs_write_lock(s);\n\t\terror = journal_begin(&th, s, bh_per_page + 1);\n\t\tif (error) {\n\t\t\treiserfs_write_unlock(s);\n\t\t\tgoto fail;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\n\t/* now go through and lock any dirty buffers on the page */\n\tdo {\n\t\tget_bh(bh);\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0)\n\t\t\tcontinue;\n\n\t\tif (checked) {\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\tjournal_mark_dirty(&th, bh);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * from this point on, we know the buffer is mapped to a\n\t\t * real block and not a direct item\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else {\n\t\t\tif (!trylock_buffer(bh)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (checked) {\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(s);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\n\t/*\n\t * since any buffer might be the only dirty buffer on the page,\n\t * the first submit_bh can bring the page out of writeback.\n\t * be careful with the buffers.\n\t */\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\n\terror = 0;\ndone:\n\tif (nr == 0) {\n\t\t/*\n\t\t * if this page only had a direct item, it is very possible for\n\t\t * no io to be required without there being an error.  Or,\n\t\t * someone else could have locked them and sent them down the\n\t\t * pipe without locking the page\n\t\t */\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tpartial = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t\tend_page_writeback(page);\n\t}\n\treturn error;\n\nfail:\n\t/*\n\t * catches various errors, we need to make sure any valid dirty blocks\n\t * get to the media.  The page is currently locked and not marked for\n\t * writeback\n\t */\n\tClearPageUptodate(page);\n\tbh = head;\n\tdo {\n\t\tget_bh(bh);\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) && bh->b_blocknr) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * clear any dirty bits that might have come from\n\t\t\t * getting attached to a dirty page\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tnr++;\n\t\t}\n\t\tput_bh(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\tgoto done;\n}"
  },
  {
    "function_name": "map_block_for_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2364-2516",
    "snippet": "static int map_block_for_writepage(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh_result,\n\t\t\t\t   unsigned long block)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint fs_gen;\n\tstruct item_head tmp_ih;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\t__le32 *item;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tint jbegin_count = JOURNAL_PER_BALANCE_CNT;\n\tloff_t byte_offset = ((loff_t)block << inode->i_sb->s_blocksize_bits)+1;\n\tint retval;\n\tint use_get_block = 0;\n\tint bytes_copied = 0;\n\tint copy_size;\n\tint trans_running = 0;\n\n\t/*\n\t * catch places below that try to log something without\n\t * starting a trans\n\t */\n\tth.t_trans_id = 0;\n\n\tif (!buffer_uptodate(bh_result)) {\n\t\treturn -EIO;\n\t}\n\n\tkmap(bh_result->b_page);\nstart_over:\n\treiserfs_write_lock(inode->i_sb);\n\tmake_cpu_key(&key, inode, byte_offset, TYPE_ANY, 3);\n\nresearch:\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval != POSITION_FOUND) {\n\t\tuse_get_block = 1;\n\t\tgoto out;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\t/* we've found an unformatted node */\n\tif (indirect_item_found(retval, ih)) {\n\t\tif (bytes_copied > 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"clm-6002\",\n\t\t\t\t\t \"bytes_copied %d\", bytes_copied);\n\t\t}\n\t\tif (!get_block_num(item, pos_in_item)) {\n\t\t\t/* crap, we are writing to a hole */\n\t\t\tuse_get_block = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t     get_block_num(item, pos_in_item), inode);\n\t} else if (is_direct_le_ih(ih)) {\n\t\tchar *p;\n\t\tp = page_address(bh_result->b_page);\n\t\tp += (byte_offset - 1) & (PAGE_CACHE_SIZE - 1);\n\t\tcopy_size = ih_item_len(ih) - pos_in_item;\n\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tcopy_item_head(&tmp_ih, ih);\n\n\t\tif (!trans_running) {\n\t\t\t/* vs-3050 is gone, no need to drop the path */\n\t\t\tretval = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\t\tif (retval)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t\ttrans_running = 1;\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t}\n\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tgoto research;\n\t\t}\n\n\t\tmemcpy(ih_item_body(bh, ih) + pos_in_item, p + bytes_copied,\n\t\t       copy_size);\n\n\t\tjournal_mark_dirty(&th, bh);\n\t\tbytes_copied += copy_size;\n\t\tset_block_dev_mapped(bh_result, 0, inode);\n\n\t\t/* are there still bytes left? */\n\t\tif (bytes_copied < bh_result->b_size &&\n\t\t    (byte_offset + bytes_copied) < inode->i_size) {\n\t\t\tset_cpu_key_k_offset(&key,\n\t\t\t\t\t     cpu_key_k_offset(&key) +\n\t\t\t\t\t     copy_size);\n\t\t\tgoto research;\n\t\t}\n\t} else {\n\t\treiserfs_warning(inode->i_sb, \"clm-6003\",\n\t\t\t\t \"bad item inode %lu\", inode->i_ino);\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\tretval = 0;\n\nout:\n\tpathrelse(&path);\n\tif (trans_running) {\n\t\tint err = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\ttrans_running = 0;\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\t/* this is where we fill in holes in the file. */\n\tif (use_get_block) {\n\t\tretval = reiserfs_get_block(inode, block, bh_result,\n\t\t\t\t\t    GET_BLOCK_CREATE | GET_BLOCK_NO_IMUX\n\t\t\t\t\t    | GET_BLOCK_NO_DANGLE);\n\t\tif (!retval) {\n\t\t\tif (!buffer_mapped(bh_result)\n\t\t\t    || bh_result->b_blocknr == 0) {\n\t\t\t\t/* get_block failed to find a mapped unformatted node. */\n\t\t\t\tuse_get_block = 0;\n\t\t\t\tgoto start_over;\n\t\t\t}\n\t\t}\n\t}\n\tkunmap(bh_result->b_page);\n\n\tif (!retval && buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {\n\t\t/*\n\t\t * we've copied data from the page into the direct item, so the\n\t\t * buffer in the page is now clean, mark it to reflect that.\n\t\t */\n\t\tlock_buffer(bh_result);\n\t\tclear_buffer_dirty(bh_result);\n\t\tunlock_buffer(bh_result);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh_result"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh_result"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh_result"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bh_result->b_page"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh_result"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_get_block",
          "args": [
            "inode",
            "block",
            "bh_result",
            "GET_BLOCK_CREATE | GET_BLOCK_NO_IMUX\n\t\t\t\t\t    | GET_BLOCK_NO_DANGLE"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "656-1159",
          "snippet": "int reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"clm-6003\"",
            "\"bad item inode %lu\"",
            "inode->i_ino"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&key",
            "cpu_key_k_offset(&key) +\n\t\t\t\t\t     copy_size"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "&key"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_block_dev_mapped",
          "args": [
            "bh_result",
            "0",
            "inode"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "set_block_dev_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "230-234",
          "snippet": "static inline void set_block_dev_mapped(struct buffer_head *bh,\n\t\t\t\t\tb_blocknr_t block, struct inode *inode)\n{\n\tmap_bh(bh, inode->i_sb, block);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void set_block_dev_mapped(struct buffer_head *bh,\n\t\t\t\t\tb_blocknr_t block, struct inode *inode)\n{\n\tmap_bh(bh, inode->i_sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "bh"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ih_item_body(bh, ih) + pos_in_item",
            "p + bytes_copied",
            "copy_size"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "bh",
            "ih"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "inode->i_sb",
            "bh"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&tmp_ih",
            "&path"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_changed",
          "args": [
            "fs_gen",
            "inode->i_sb"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "inode->i_sb",
            "bh",
            "1"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&tmp_ih",
            "&path"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_changed",
          "args": [
            "fs_gen",
            "inode->i_sb"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "jbegin_count"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&tmp_ih",
            "ih"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_generation",
          "args": [
            "inode->i_sb"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "bh_result->b_page"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "ih"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_block_num",
          "args": [
            "item",
            "pos_in_item"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block_num",
          "args": [
            "item",
            "pos_in_item"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indirect_item_found",
          "args": [
            "retval",
            "ih"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "indirect_item_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "225-228",
          "snippet": "static inline int indirect_item_found(int retval, struct item_head *ih)\n{\n\treturn (retval == POSITION_FOUND) && is_indirect_le_ih(ih);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int indirect_item_found(int retval, struct item_head *ih)\n{\n\treturn (retval == POSITION_FOUND) && is_indirect_le_ih(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_body",
          "args": [
            "&path"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2230-2233",
          "snippet": "static inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "&path"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "&path"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_for_position_by_key",
          "args": [
            "inode->i_sb",
            "&key",
            "&path"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "search_for_position_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "830-903",
          "snippet": "int search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&key",
            "inode",
            "byte_offset",
            "TYPE_ANY",
            "3"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "bh_result->b_page"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh_result"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int map_block_for_writepage(struct inode *inode,\n\t\t\t\t   struct buffer_head *bh_result,\n\t\t\t\t   unsigned long block)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint fs_gen;\n\tstruct item_head tmp_ih;\n\tstruct item_head *ih;\n\tstruct buffer_head *bh;\n\t__le32 *item;\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tint jbegin_count = JOURNAL_PER_BALANCE_CNT;\n\tloff_t byte_offset = ((loff_t)block << inode->i_sb->s_blocksize_bits)+1;\n\tint retval;\n\tint use_get_block = 0;\n\tint bytes_copied = 0;\n\tint copy_size;\n\tint trans_running = 0;\n\n\t/*\n\t * catch places below that try to log something without\n\t * starting a trans\n\t */\n\tth.t_trans_id = 0;\n\n\tif (!buffer_uptodate(bh_result)) {\n\t\treturn -EIO;\n\t}\n\n\tkmap(bh_result->b_page);\nstart_over:\n\treiserfs_write_lock(inode->i_sb);\n\tmake_cpu_key(&key, inode, byte_offset, TYPE_ANY, 3);\n\nresearch:\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval != POSITION_FOUND) {\n\t\tuse_get_block = 1;\n\t\tgoto out;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\t/* we've found an unformatted node */\n\tif (indirect_item_found(retval, ih)) {\n\t\tif (bytes_copied > 0) {\n\t\t\treiserfs_warning(inode->i_sb, \"clm-6002\",\n\t\t\t\t\t \"bytes_copied %d\", bytes_copied);\n\t\t}\n\t\tif (!get_block_num(item, pos_in_item)) {\n\t\t\t/* crap, we are writing to a hole */\n\t\t\tuse_get_block = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t     get_block_num(item, pos_in_item), inode);\n\t} else if (is_direct_le_ih(ih)) {\n\t\tchar *p;\n\t\tp = page_address(bh_result->b_page);\n\t\tp += (byte_offset - 1) & (PAGE_CACHE_SIZE - 1);\n\t\tcopy_size = ih_item_len(ih) - pos_in_item;\n\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\tcopy_item_head(&tmp_ih, ih);\n\n\t\tif (!trans_running) {\n\t\t\t/* vs-3050 is gone, no need to drop the path */\n\t\t\tretval = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\t\tif (retval)\n\t\t\t\tgoto out;\n\t\t\treiserfs_update_inode_transaction(inode);\n\t\t\ttrans_running = 1;\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t}\n\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tgoto research;\n\t\t}\n\n\t\tmemcpy(ih_item_body(bh, ih) + pos_in_item, p + bytes_copied,\n\t\t       copy_size);\n\n\t\tjournal_mark_dirty(&th, bh);\n\t\tbytes_copied += copy_size;\n\t\tset_block_dev_mapped(bh_result, 0, inode);\n\n\t\t/* are there still bytes left? */\n\t\tif (bytes_copied < bh_result->b_size &&\n\t\t    (byte_offset + bytes_copied) < inode->i_size) {\n\t\t\tset_cpu_key_k_offset(&key,\n\t\t\t\t\t     cpu_key_k_offset(&key) +\n\t\t\t\t\t     copy_size);\n\t\t\tgoto research;\n\t\t}\n\t} else {\n\t\treiserfs_warning(inode->i_sb, \"clm-6003\",\n\t\t\t\t \"bad item inode %lu\", inode->i_ino);\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\tretval = 0;\n\nout:\n\tpathrelse(&path);\n\tif (trans_running) {\n\t\tint err = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\ttrans_running = 0;\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\t/* this is where we fill in holes in the file. */\n\tif (use_get_block) {\n\t\tretval = reiserfs_get_block(inode, block, bh_result,\n\t\t\t\t\t    GET_BLOCK_CREATE | GET_BLOCK_NO_IMUX\n\t\t\t\t\t    | GET_BLOCK_NO_DANGLE);\n\t\tif (!retval) {\n\t\t\tif (!buffer_mapped(bh_result)\n\t\t\t    || bh_result->b_blocknr == 0) {\n\t\t\t\t/* get_block failed to find a mapped unformatted node. */\n\t\t\t\tuse_get_block = 0;\n\t\t\t\tgoto start_over;\n\t\t\t}\n\t\t}\n\t}\n\tkunmap(bh_result->b_page);\n\n\tif (!retval && buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {\n\t\t/*\n\t\t * we've copied data from the page into the direct item, so the\n\t\t * buffer in the page is now clean, mark it to reflect that.\n\t\t */\n\t\tlock_buffer(bh_result);\n\t\tclear_buffer_dirty(bh_result);\n\t\tunlock_buffer(bh_result);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_truncate_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2263-2362",
    "snippet": "int reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t/* we want the offset for the first byte after the end of the file */\n\tunsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * -ENOENT means we truncated past the end of the\n\t\t\t * file, and get_block_create_0 could not find a\n\t\t\t * block to read in, which is ok.\n\t\t\t */\n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * so, if page != NULL, we have a buffer head for the offset at\n\t * the end of the file. if the bh is mapped, and bh->b_blocknr != 0,\n\t * then we have an unformatted node.  Otherwise, we have a direct item,\n\t * and no zeroing is required on disk.  We zero after the truncate,\n\t * because the truncate might pack the item anyway\n\t * (it will unmap bh if it packs).\n\t *\n\t * it is enough to reserve space in transaction for 2 balancings:\n\t * one for \"save\" link adding and another for the first\n\t * cut_from_item. 1 is for update_sd\n\t */\n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t/*\n\t\t * we are doing real truncate: if the system crashes\n\t\t * before the last transaction of truncating gets committed\n\t\t * - on reboot the file either appears truncated properly\n\t\t * or not truncated at all\n\t\t */\n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t/* check reiserfs_do_truncate after ending the transaction */\n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1 /* truncate */);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t/* if we are not on a block boundary */\n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_save_link",
          "args": [
            "inode",
            "1/* truncate */"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "remove_save_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "476-514",
          "snippet": "int remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t/* we are going to do one balancing only */\n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t/* setup key of \"save\" link */\n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t/* truncate */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t/* don't take quota bytes from anywhere */\n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t/* we are going to do one balancing only */\n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t/* setup key of \"save\" link */\n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t/* truncate */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t/* don't take quota bytes from anywhere */\n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_do_truncate",
          "args": [
            "&th",
            "inode",
            "page",
            "update_timestamps"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_save_link",
          "args": [
            "&th",
            "inode",
            "1"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "add_save_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "395-473",
          "snippet": "void add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "JOURNAL_PER_BALANCE_CNT * 2 + 1"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"clm-6001\"",
            "\"grab_tail_page failed %d\"",
            "error"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_tail_page",
          "args": [
            "inode",
            "&page",
            "&bh"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "grab_tail_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2182-2255",
          "snippet": "static int grab_tail_page(struct inode *inode,\n\t\t\t  struct page **page_result,\n\t\t\t  struct buffer_head **bh_result)\n{\n\n\t/*\n\t * we want the page with the last byte in the file,\n\t * not the page that will hold the next byte for appending\n\t */\n\tunsigned long index = (inode->i_size - 1) >> PAGE_CACHE_SHIFT;\n\tunsigned long pos = 0;\n\tunsigned long start = 0;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned long offset = (inode->i_size) & (PAGE_CACHE_SIZE - 1);\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint error;\n\n\t/*\n\t * we know that we are only called with inode->i_size > 0.\n\t * we also know that a file tail can never be as big as a block\n\t * If i_size % blocksize == 0, our file is currently block aligned\n\t * and it won't need converting or zeroing after a truncate.\n\t */\n\tif ((offset & (blocksize - 1)) == 0) {\n\t\treturn -ENOENT;\n\t}\n\tpage = grab_cache_page(inode->i_mapping, index);\n\terror = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\t/* start within the page of the last block in the file */\n\tstart = (offset / blocksize) * blocksize;\n\n\terror = __block_write_begin(page, start, offset - start,\n\t\t\t\t    reiserfs_get_block_create_0);\n\tif (error)\n\t\tgoto unlock;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (pos >= start) {\n\t\t\tbreak;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tpos += blocksize;\n\t} while (bh != head);\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/*\n\t\t * note, this should never happen, prepare_write should be\n\t\t * taking care of this for us.  If the buffer isn't up to\n\t\t * date, I've screwed up the code to find the buffer, or the\n\t\t * code to call prepare_write\n\t\t */\n\t\treiserfs_error(inode->i_sb, \"clm-6000\",\n\t\t\t       \"error reading block %lu\", bh->b_blocknr);\n\t\terror = -EIO;\n\t\tgoto unlock;\n\t}\n\t*bh_result = bh;\n\t*page_result = page;\n\nout:\n\treturn error;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn error;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int grab_tail_page(struct inode *inode,\n\t\t\t  struct page **page_result,\n\t\t\t  struct buffer_head **bh_result)\n{\n\n\t/*\n\t * we want the page with the last byte in the file,\n\t * not the page that will hold the next byte for appending\n\t */\n\tunsigned long index = (inode->i_size - 1) >> PAGE_CACHE_SHIFT;\n\tunsigned long pos = 0;\n\tunsigned long start = 0;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned long offset = (inode->i_size) & (PAGE_CACHE_SIZE - 1);\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint error;\n\n\t/*\n\t * we know that we are only called with inode->i_size > 0.\n\t * we also know that a file tail can never be as big as a block\n\t * If i_size % blocksize == 0, our file is currently block aligned\n\t * and it won't need converting or zeroing after a truncate.\n\t */\n\tif ((offset & (blocksize - 1)) == 0) {\n\t\treturn -ENOENT;\n\t}\n\tpage = grab_cache_page(inode->i_mapping, index);\n\terror = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\t/* start within the page of the last block in the file */\n\tstart = (offset / blocksize) * blocksize;\n\n\terror = __block_write_begin(page, start, offset - start,\n\t\t\t\t    reiserfs_get_block_create_0);\n\tif (error)\n\t\tgoto unlock;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (pos >= start) {\n\t\t\tbreak;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tpos += blocksize;\n\t} while (bh != head);\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/*\n\t\t * note, this should never happen, prepare_write should be\n\t\t * taking care of this for us.  If the buffer isn't up to\n\t\t * date, I've screwed up the code to find the buffer, or the\n\t\t * code to call prepare_write\n\t\t */\n\t\treiserfs_error(inode->i_sb, \"clm-6000\",\n\t\t\t       \"error reading block %lu\", bh->b_blocknr);\n\t\terror = -EIO;\n\t\tgoto unlock;\n\t}\n\t*bh_result = bh;\n\t*page_result = page;\n\nout:\n\treturn error;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_truncate_file(struct inode *inode, int update_timestamps)\n{\n\tstruct reiserfs_transaction_handle th;\n\t/* we want the offset for the first byte after the end of the file */\n\tunsigned long offset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned length;\n\tstruct page *page = NULL;\n\tint error;\n\tstruct buffer_head *bh = NULL;\n\tint err2;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tif (inode->i_size > 0) {\n\t\terror = grab_tail_page(inode, &page, &bh);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * -ENOENT means we truncated past the end of the\n\t\t\t * file, and get_block_create_0 could not find a\n\t\t\t * block to read in, which is ok.\n\t\t\t */\n\t\t\tif (error != -ENOENT)\n\t\t\t\treiserfs_error(inode->i_sb, \"clm-6001\",\n\t\t\t\t\t       \"grab_tail_page failed %d\",\n\t\t\t\t\t       error);\n\t\t\tpage = NULL;\n\t\t\tbh = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * so, if page != NULL, we have a buffer head for the offset at\n\t * the end of the file. if the bh is mapped, and bh->b_blocknr != 0,\n\t * then we have an unformatted node.  Otherwise, we have a direct item,\n\t * and no zeroing is required on disk.  We zero after the truncate,\n\t * because the truncate might pack the item anyway\n\t * (it will unmap bh if it packs).\n\t *\n\t * it is enough to reserve space in transaction for 2 balancings:\n\t * one for \"save\" link adding and another for the first\n\t * cut_from_item. 1 is for update_sd\n\t */\n\terror = journal_begin(&th, inode->i_sb,\n\t\t\t      JOURNAL_PER_BALANCE_CNT * 2 + 1);\n\tif (error)\n\t\tgoto out;\n\treiserfs_update_inode_transaction(inode);\n\tif (update_timestamps)\n\t\t/*\n\t\t * we are doing real truncate: if the system crashes\n\t\t * before the last transaction of truncating gets committed\n\t\t * - on reboot the file either appears truncated properly\n\t\t * or not truncated at all\n\t\t */\n\t\tadd_save_link(&th, inode, 1);\n\terr2 = reiserfs_do_truncate(&th, inode, page, update_timestamps);\n\terror = journal_end(&th);\n\tif (error)\n\t\tgoto out;\n\n\t/* check reiserfs_do_truncate after ending the transaction */\n\tif (err2) {\n\t\terror = err2;\n  \t\tgoto out;\n\t}\n\t\n\tif (update_timestamps) {\n\t\terror = remove_save_link(inode, 1 /* truncate */);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (page) {\n\t\tlength = offset & (blocksize - 1);\n\t\t/* if we are not on a block boundary */\n\t\tif (length) {\n\t\t\tlength = blocksize - length;\n\t\t\tzero_user(page, offset, length);\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr != 0) {\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn 0;\nout:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn error;\n}"
  },
  {
    "function_name": "grab_tail_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "2182-2255",
    "snippet": "static int grab_tail_page(struct inode *inode,\n\t\t\t  struct page **page_result,\n\t\t\t  struct buffer_head **bh_result)\n{\n\n\t/*\n\t * we want the page with the last byte in the file,\n\t * not the page that will hold the next byte for appending\n\t */\n\tunsigned long index = (inode->i_size - 1) >> PAGE_CACHE_SHIFT;\n\tunsigned long pos = 0;\n\tunsigned long start = 0;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned long offset = (inode->i_size) & (PAGE_CACHE_SIZE - 1);\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint error;\n\n\t/*\n\t * we know that we are only called with inode->i_size > 0.\n\t * we also know that a file tail can never be as big as a block\n\t * If i_size % blocksize == 0, our file is currently block aligned\n\t * and it won't need converting or zeroing after a truncate.\n\t */\n\tif ((offset & (blocksize - 1)) == 0) {\n\t\treturn -ENOENT;\n\t}\n\tpage = grab_cache_page(inode->i_mapping, index);\n\terror = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\t/* start within the page of the last block in the file */\n\tstart = (offset / blocksize) * blocksize;\n\n\terror = __block_write_begin(page, start, offset - start,\n\t\t\t\t    reiserfs_get_block_create_0);\n\tif (error)\n\t\tgoto unlock;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (pos >= start) {\n\t\t\tbreak;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tpos += blocksize;\n\t} while (bh != head);\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/*\n\t\t * note, this should never happen, prepare_write should be\n\t\t * taking care of this for us.  If the buffer isn't up to\n\t\t * date, I've screwed up the code to find the buffer, or the\n\t\t * code to call prepare_write\n\t\t */\n\t\treiserfs_error(inode->i_sb, \"clm-6000\",\n\t\t\t       \"error reading block %lu\", bh->b_blocknr);\n\t\terror = -EIO;\n\t\tgoto unlock;\n\t}\n\t*bh_result = bh;\n\t*page_result = page;\n\nout:\n\treturn error;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn error;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"clm-6000\"",
            "\"error reading block %lu\"",
            "bh->b_blocknr"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "start",
            "offset - start",
            "reiserfs_get_block_create_0"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int grab_tail_page(struct inode *inode,\n\t\t\t  struct page **page_result,\n\t\t\t  struct buffer_head **bh_result)\n{\n\n\t/*\n\t * we want the page with the last byte in the file,\n\t * not the page that will hold the next byte for appending\n\t */\n\tunsigned long index = (inode->i_size - 1) >> PAGE_CACHE_SHIFT;\n\tunsigned long pos = 0;\n\tunsigned long start = 0;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned long offset = (inode->i_size) & (PAGE_CACHE_SIZE - 1);\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint error;\n\n\t/*\n\t * we know that we are only called with inode->i_size > 0.\n\t * we also know that a file tail can never be as big as a block\n\t * If i_size % blocksize == 0, our file is currently block aligned\n\t * and it won't need converting or zeroing after a truncate.\n\t */\n\tif ((offset & (blocksize - 1)) == 0) {\n\t\treturn -ENOENT;\n\t}\n\tpage = grab_cache_page(inode->i_mapping, index);\n\terror = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\t/* start within the page of the last block in the file */\n\tstart = (offset / blocksize) * blocksize;\n\n\terror = __block_write_begin(page, start, offset - start,\n\t\t\t\t    reiserfs_get_block_create_0);\n\tif (error)\n\t\tgoto unlock;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (pos >= start) {\n\t\t\tbreak;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tpos += blocksize;\n\t} while (bh != head);\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/*\n\t\t * note, this should never happen, prepare_write should be\n\t\t * taking care of this for us.  If the buffer isn't up to\n\t\t * date, I've screwed up the code to find the buffer, or the\n\t\t * code to call prepare_write\n\t\t */\n\t\treiserfs_error(inode->i_sb, \"clm-6000\",\n\t\t\t       \"error reading block %lu\", bh->b_blocknr);\n\t\terror = -EIO;\n\t\tgoto unlock;\n\t}\n\t*bh_result = bh;\n\t*page_result = page;\n\nout:\n\treturn error;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn error;\n}"
  },
  {
    "function_name": "reiserfs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1926-2167",
    "snippet": "int reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "inode->i_sb",
            "depth"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "inode->i_sb"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "th"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&path_to_key"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "inode"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_security_write",
          "args": [
            "th",
            "inode",
            "security"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_security_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
          "lines": "91-105",
          "snippet": "int reiserfs_security_write(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode,\n\t\t\t    struct reiserfs_security_handle *sec)\n{\n\tint error;\n\tif (strlen(sec->name) < sizeof(XATTR_SECURITY_PREFIX))\n\t\treturn -EINVAL;\n\n\terror = reiserfs_xattr_set_handle(th, inode, sec->name, sec->value,\n\t\t\t\t\t  sec->length, XATTR_CREATE);\n\tif (error == -ENODATA || error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include \"xattr.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nint reiserfs_security_write(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode,\n\t\t\t    struct reiserfs_security_handle *sec)\n{\n\tint error;\n\tif (strlen(sec->name) < sizeof(XATTR_SECURITY_PREFIX))\n\t\treturn -EINVAL;\n\n\terror = reiserfs_xattr_set_handle(th, inode, sec->name, sec->value,\n\t\t\t\t\t  sec->length, XATTR_CREATE);\n\tif (error == -ENODATA || error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "dir"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"jdm-13090\"",
            "\"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\""
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_inherit_default_acl",
          "args": [
            "th",
            "dir",
            "dentry",
            "inode"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_inherit_default_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "301-352",
          "snippet": "int\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *dir, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint err = 0;\n\n\t/* ACLs only get applied to files and directories */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\t/*\n\t * ACLs can only be used on \"new\" objects, so if it's an old object\n\t * there is nothing to inherit from\n\t */\n\tif (get_inode_sd_version(dir) == STAT_DATA_V1)\n\t\tgoto apply_umask;\n\n\t/*\n\t * Don't apply ACLs to objects in the .reiserfs_priv tree.. This\n\t * would be useless since permissions are ignored, and a pain because\n\t * it introduces locking cycles\n\t */\n\tif (IS_PRIVATE(dir)) {\n\t\tinode->i_flags |= S_PRIVATE;\n\t\tgoto apply_umask;\n\t}\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t\t default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t\t acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn err;\n\napply_umask:\n\t/* no ACL, apply umask */\n\tinode->i_mode &= ~current_umask();\n\treturn err;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nint\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *dir, struct dentry *dentry,\n\t\t\t     struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint err = 0;\n\n\t/* ACLs only get applied to files and directories */\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\t/*\n\t * ACLs can only be used on \"new\" objects, so if it's an old object\n\t * there is nothing to inherit from\n\t */\n\tif (get_inode_sd_version(dir) == STAT_DATA_V1)\n\t\tgoto apply_umask;\n\n\t/*\n\t * Don't apply ACLs to objects in the .reiserfs_priv tree.. This\n\t * would be useless since permissions are ignored, and a pain because\n\t * it introduces locking cycles\n\t */\n\tif (IS_PRIVATE(dir)) {\n\t\tinode->i_flags |= S_PRIVATE;\n\t\tgoto apply_umask;\n\t}\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t\t default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = __reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t\t acl);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn err;\n\napply_umask:\n\t/* no ACL, apply umask */\n\tinode->i_mode &= ~current_umask();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_posixacl",
          "args": [
            "inode->i_sb"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_new_symlink",
          "args": [
            "th",
            "inode",
            "&ih",
            "&path_to_key",
            "symname",
            "i_size"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_new_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1867-1904",
          "snippet": "static int reiserfs_new_symlink(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct item_head *ih,\n\t\t\t\tstruct treepath *path, const char *symname,\n\t\t\t\tint item_len)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5,\n\t\t      le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid),\n\t\t      1, TYPE_DIRECT, 3 /*key length */ );\n\n\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, 1, TYPE_DIRECT, item_len,\n\t\t\t  0 /*free_space */ );\n\n\t/* look for place in the tree for new item */\n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new symlink\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13080\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t/* insert item, that is body of symlink */\n\treturn reiserfs_insert_item(th, path, &key, ih, inode, symname);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_new_symlink(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct item_head *ih,\n\t\t\t\tstruct treepath *path, const char *symname,\n\t\t\t\tint item_len)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5,\n\t\t      le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid),\n\t\t      1, TYPE_DIRECT, 3 /*key length */ );\n\n\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, 1, TYPE_DIRECT, item_len,\n\t\t\t  0 /*free_space */ );\n\n\t/* look for place in the tree for new item */\n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new symlink\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13080\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t/* insert item, that is body of symlink */\n\treturn reiserfs_insert_item(th, path, &key, ih, inode, symname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "i_size"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "sb"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_new_directory",
          "args": [
            "th",
            "inode",
            "&ih",
            "&path_to_key",
            "dir"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_new_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1804-1861",
          "snippet": "static int reiserfs_new_directory(struct reiserfs_transaction_handle *th,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct item_head *ih, struct treepath *path,\n\t\t\t\t  struct inode *dir)\n{\n\tstruct super_block *sb = th->t_super;\n\tchar empty_dir[EMPTY_DIR_SIZE];\n\tchar *body = empty_dir;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5, le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid), DOT_OFFSET,\n\t\t      TYPE_DIRENTRY, 3 /*key length */ );\n\n\t/*\n\t * compose item head for new item. Directories consist of items of\n\t * old type (ITEM_VERSION_1). Do not set key (second arg is 0), it\n\t * is done by reiserfs_new_inode\n\t */\n\tif (old_format_only(sb)) {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE_V1, 2);\n\n\t\tmake_empty_dir_item_v1(body, ih->ih_key.k_dir_id,\n\t\t\t\t       ih->ih_key.k_objectid,\n\t\t\t\t       INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t       INODE_PKEY(dir)->k_objectid);\n\t} else {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE, 2);\n\n\t\tmake_empty_dir_item(body, ih->ih_key.k_dir_id,\n\t\t\t\t    ih->ih_key.k_objectid,\n\t\t\t\t    INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t    INODE_PKEY(dir)->k_objectid);\n\t}\n\n\t/* look for place in the tree for new item */\n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new directory\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13070\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t/* insert item, that is empty directory item */\n\treturn reiserfs_insert_item(th, path, &key, ih, inode, body);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_new_directory(struct reiserfs_transaction_handle *th,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct item_head *ih, struct treepath *path,\n\t\t\t\t  struct inode *dir)\n{\n\tstruct super_block *sb = th->t_super;\n\tchar empty_dir[EMPTY_DIR_SIZE];\n\tchar *body = empty_dir;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5, le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid), DOT_OFFSET,\n\t\t      TYPE_DIRENTRY, 3 /*key length */ );\n\n\t/*\n\t * compose item head for new item. Directories consist of items of\n\t * old type (ITEM_VERSION_1). Do not set key (second arg is 0), it\n\t * is done by reiserfs_new_inode\n\t */\n\tif (old_format_only(sb)) {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE_V1, 2);\n\n\t\tmake_empty_dir_item_v1(body, ih->ih_key.k_dir_id,\n\t\t\t\t       ih->ih_key.k_objectid,\n\t\t\t\t       INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t       INODE_PKEY(dir)->k_objectid);\n\t} else {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE, 2);\n\n\t\tmake_empty_dir_item(body, ih->ih_key.k_dir_id,\n\t\t\t\t    ih->ih_key.k_objectid,\n\t\t\t\t    INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t    INODE_PKEY(dir)->k_objectid);\n\t}\n\n\t/* look for place in the tree for new item */\n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new directory\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13070\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t/* insert item, that is empty directory item */\n\treturn reiserfs_insert_item(th, path, &key, ih, inode, body);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "dir"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_insert_item",
          "args": [
            "th",
            "&path_to_key",
            "&key",
            "&ih",
            "inode",
            "(char *)(&sd)"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_sd_version",
          "args": [
            "inode",
            "STAT_DATA_V2"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_sd_version",
          "args": [
            "inode",
            "STAT_DATA_V1"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "sb"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_item_key_version",
          "args": [
            "inode",
            "KEY_FORMAT_3_6"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_item_key_version",
          "args": [
            "inode",
            "KEY_FORMAT_3_5"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "sb"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode2sd",
          "args": [
            "&sd",
            "inode",
            "inode->i_size"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "inode2sd_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1397-1418",
          "snippet": "static void inode2sd_v1(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data_v1 *sd_v1 = (struct stat_data_v1 *)sd;\n\n\tset_sd_v1_mode(sd_v1, inode->i_mode);\n\tset_sd_v1_uid(sd_v1, i_uid_read(inode));\n\tset_sd_v1_gid(sd_v1, i_gid_read(inode));\n\tset_sd_v1_nlink(sd_v1, inode->i_nlink);\n\tset_sd_v1_size(sd_v1, size);\n\tset_sd_v1_atime(sd_v1, inode->i_atime.tv_sec);\n\tset_sd_v1_ctime(sd_v1, inode->i_ctime.tv_sec);\n\tset_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v1_blocks(sd_v1, to_fake_used_blocks(inode, SD_V1_SIZE));\n\n\t/* Sigh. i_first_direct_byte is back */\n\tset_sd_v1_first_direct_byte(sd_v1,\n\t\t\t\t    REISERFS_I(inode)->i_first_direct_byte);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void inode2sd_v1(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data_v1 *sd_v1 = (struct stat_data_v1 *)sd;\n\n\tset_sd_v1_mode(sd_v1, inode->i_mode);\n\tset_sd_v1_uid(sd_v1, i_uid_read(inode));\n\tset_sd_v1_gid(sd_v1, i_gid_read(inode));\n\tset_sd_v1_nlink(sd_v1, inode->i_nlink);\n\tset_sd_v1_size(sd_v1, size);\n\tset_sd_v1_atime(sd_v1, inode->i_atime.tv_sec);\n\tset_sd_v1_ctime(sd_v1, inode->i_ctime.tv_sec);\n\tset_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v1_blocks(sd_v1, to_fake_used_blocks(inode, SD_V1_SIZE));\n\n\t/* Sigh. i_first_direct_byte is back */\n\tset_sd_v1_first_direct_byte(sd_v1,\n\t\t\t\t    REISERFS_I(inode)->i_first_direct_byte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path_to_key"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "sb"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "sb",
            "&key",
            "&path_to_key"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_make_cpu_key",
          "args": [
            "&key",
            "KEY_FORMAT_3_6",
            "le32_to_cpu(ih.ih_key.k_dir_id)",
            "le32_to_cpu(ih.ih_key.k_objectid)",
            "SD_OFFSET",
            "TYPE_STAT_DATA",
            "3/*key length */"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "_make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "110-120",
          "snippet": "static void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ih.ih_key.k_objectid"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_init_xattr_rwsem",
          "args": [
            "inode"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_init_xattr_rwsem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "100-102",
          "snippet": "static inline void reiserfs_init_xattr_rwsem(struct inode *inode)\n{\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline void reiserfs_init_xattr_rwsem(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_attrs_to_i_attrs",
          "args": [
            "REISERFS_I(inode)->i_attrs",
            "inode"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "sd_attrs_to_i_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "3070-3094",
          "snippet": "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&REISERFS_I(inode)->i_prealloc_list"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "(S_ISDIR(mode) ? 2 : 1)"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "sb"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_inode_locked4",
          "args": [
            "inode",
            "args.objectid",
            "reiserfs_find_actor",
            "&args"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1365-1405",
          "snippet": "int insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "INODE_PKEY(inode)",
            "&ih.ih_key",
            "KEY_SIZE"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_le_item_head",
          "args": [
            "&ih",
            "NULL",
            "KEY_FORMAT_3_6",
            "SD_OFFSET",
            "TYPE_STAT_DATA",
            "SD_SIZE",
            "MAX_US_INT"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "make_le_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "136-156",
          "snippet": "inline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\ninline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "sb"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "reiserfs_get_unused_objectid(th)"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_get_unused_objectid",
          "args": [
            "th"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_unused_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
          "lines": "49-94",
          "snippet": "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\t__u32 unused_objectid;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t/* comment needed -Hans */\n\tunused_objectid = le32_to_cpu(map[1]);\n\tif (unused_objectid == U32_MAX) {\n\t\treiserfs_warning(s, \"reiserfs-15100\", \"no more object ids\");\n\t\treiserfs_restore_prepared_buffer(s, SB_BUFFER_WITH_SB(s));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This incrementation allocates the first unused objectid. That\n\t * is to say, the first entry on the objectid map is the first\n\t * unused objectid, and by incrementing it we use it.  See below\n\t * where we check to see if we eliminated a sequence of unused\n\t * objectids....\n\t */\n\tmap[1] = cpu_to_le32(unused_objectid + 1);\n\n\t/*\n\t * Now we check to see if we eliminated the last remaining member of\n\t * the first even sequence (and can eliminate the sequence by\n\t * eliminating its last objectid from oids), and can collapse the\n\t * first two odd sequences into one sequence.  If so, then the net\n\t * result is to eliminate a pair of objectids from oids.  We do this\n\t * by shifting the entire map to the left.\n\t */\n\tif (sb_oid_cursize(rs) > 2 && map[1] == map[2]) {\n\t\tmemmove(map + 1, map + 3,\n\t\t\t(sb_oid_cursize(rs) - 3) * sizeof(__u32));\n\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\t}\n\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\treturn unused_objectid;\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\t__u32 unused_objectid;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t/* comment needed -Hans */\n\tunused_objectid = le32_to_cpu(map[1]);\n\tif (unused_objectid == U32_MAX) {\n\t\treiserfs_warning(s, \"reiserfs-15100\", \"no more object ids\");\n\t\treiserfs_restore_prepared_buffer(s, SB_BUFFER_WITH_SB(s));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This incrementation allocates the first unused objectid. That\n\t * is to say, the first entry on the objectid map is the first\n\t * unused objectid, and by incrementing it we use it.  See below\n\t * where we check to see if we eliminated a sequence of unused\n\t * objectids....\n\t */\n\tmap[1] = cpu_to_le32(unused_objectid + 1);\n\n\t/*\n\t * Now we check to see if we eliminated the last remaining member of\n\t * the first even sequence (and can eliminate the sequence by\n\t * eliminating its last objectid from oids), and can collapse the\n\t * first two odd sequences into one sequence.  If so, then the net\n\t * result is to eliminate a pair of objectids from oids.  We do this\n\t * by shifting the entire map to the left.\n\t */\n\tif (sb_oid_cursize(rs) > 2 && map[1] == map[2]) {\n\t\tmemmove(map + 1, map + 3,\n\t\t\t(sb_oid_cursize(rs) - 3) * sizeof(__u32));\n\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\t}\n\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\treturn unused_objectid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_choose_packing",
          "args": [
            "dir"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_choose_packing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "325-341",
          "snippet": "__le32 reiserfs_choose_packing(struct inode * dir)\n{\n\t__le32 packing;\n\tif (TEST_OPTION(packing_groups, dir->i_sb)) {\n\t\tu32 parent_dir = le32_to_cpu(INODE_PKEY(dir)->k_dir_id);\n\t\t/*\n\t\t * some versions of reiserfsck expect packing locality 1 to be\n\t\t * special\n\t\t */\n\t\tif (parent_dir == 1 || block_group_used(dir->i_sb, parent_dir))\n\t\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\t\telse\n\t\t\tpacking = INODE_PKEY(dir)->k_dir_id;\n\t} else\n\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\treturn packing;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\n__le32 reiserfs_choose_packing(struct inode * dir)\n{\n\t__le32 packing;\n\tif (TEST_OPTION(packing_groups, dir->i_sb)) {\n\t\tu32 parent_dir = le32_to_cpu(INODE_PKEY(dir)->k_dir_id);\n\t\t/*\n\t\t * some versions of reiserfsck expect packing locality 1 to be\n\t\t * special\n\t\t */\n\t\tif (parent_dir == 1 || block_group_used(dir->i_sb, parent_dir))\n\t\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\t\telse\n\t\t\tpacking = INODE_PKEY(dir)->k_dir_id;\n\t} else\n\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\treturn packing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_inode",
          "args": [
            "inode"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1651-1685",
          "snippet": "int dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path_to_key"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "reiserfs_new_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1867-1904",
    "snippet": "static int reiserfs_new_symlink(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct item_head *ih,\n\t\t\t\tstruct treepath *path, const char *symname,\n\t\t\t\tint item_len)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5,\n\t\t      le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid),\n\t\t      1, TYPE_DIRECT, 3 /*key length */ );\n\n\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, 1, TYPE_DIRECT, item_len,\n\t\t\t  0 /*free_space */ );\n\n\t/* look for place in the tree for new item */\n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new symlink\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13080\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t/* insert item, that is body of symlink */\n\treturn reiserfs_insert_item(th, path, &key, ih, inode, symname);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_insert_item",
          "args": [
            "th",
            "path",
            "&key",
            "ih",
            "inode",
            "symname"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"vs-13080\"",
            "\"object with this key exists (%k)\"",
            "&(ih->ih_key)"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "path"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "sb",
            "\"vs-13080\"",
            "\"i/o failure occurred creating new symlink\""
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "sb",
            "&key",
            "path"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_le_item_head",
          "args": [
            "ih",
            "NULL",
            "KEY_FORMAT_3_5",
            "1",
            "TYPE_DIRECT",
            "item_len",
            "0/*free_space */"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "make_le_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "136-156",
          "snippet": "inline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\ninline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_make_cpu_key",
          "args": [
            "&key",
            "KEY_FORMAT_3_5",
            "le32_to_cpu(ih->ih_key.k_dir_id)",
            "le32_to_cpu(ih->ih_key.k_objectid)",
            "1",
            "TYPE_DIRECT",
            "3/*key length */"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "_make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "110-120",
          "snippet": "static void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ih->ih_key.k_objectid"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_new_symlink(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct item_head *ih,\n\t\t\t\tstruct treepath *path, const char *symname,\n\t\t\t\tint item_len)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5,\n\t\t      le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid),\n\t\t      1, TYPE_DIRECT, 3 /*key length */ );\n\n\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, 1, TYPE_DIRECT, item_len,\n\t\t\t  0 /*free_space */ );\n\n\t/* look for place in the tree for new item */\n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new symlink\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13080\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t/* insert item, that is body of symlink */\n\treturn reiserfs_insert_item(th, path, &key, ih, inode, symname);\n}"
  },
  {
    "function_name": "reiserfs_new_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1804-1861",
    "snippet": "static int reiserfs_new_directory(struct reiserfs_transaction_handle *th,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct item_head *ih, struct treepath *path,\n\t\t\t\t  struct inode *dir)\n{\n\tstruct super_block *sb = th->t_super;\n\tchar empty_dir[EMPTY_DIR_SIZE];\n\tchar *body = empty_dir;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5, le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid), DOT_OFFSET,\n\t\t      TYPE_DIRENTRY, 3 /*key length */ );\n\n\t/*\n\t * compose item head for new item. Directories consist of items of\n\t * old type (ITEM_VERSION_1). Do not set key (second arg is 0), it\n\t * is done by reiserfs_new_inode\n\t */\n\tif (old_format_only(sb)) {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE_V1, 2);\n\n\t\tmake_empty_dir_item_v1(body, ih->ih_key.k_dir_id,\n\t\t\t\t       ih->ih_key.k_objectid,\n\t\t\t\t       INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t       INODE_PKEY(dir)->k_objectid);\n\t} else {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE, 2);\n\n\t\tmake_empty_dir_item(body, ih->ih_key.k_dir_id,\n\t\t\t\t    ih->ih_key.k_objectid,\n\t\t\t\t    INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t    INODE_PKEY(dir)->k_objectid);\n\t}\n\n\t/* look for place in the tree for new item */\n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new directory\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13070\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t/* insert item, that is empty directory item */\n\treturn reiserfs_insert_item(th, path, &key, ih, inode, body);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_insert_item",
          "args": [
            "th",
            "path",
            "&key",
            "ih",
            "inode",
            "body"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"vs-13070\"",
            "\"object with this key exists (%k)\"",
            "&(ih->ih_key)"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "path"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "sb",
            "\"vs-13080\"",
            "\"i/o failure occurred creating new directory\""
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "sb",
            "&key",
            "path"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_empty_dir_item",
          "args": [
            "body",
            "ih->ih_key.k_dir_id",
            "ih->ih_key.k_objectid",
            "INODE_PKEY(dir)->k_dir_id",
            "INODE_PKEY(dir)->k_objectid"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
          "lines": "315-346",
          "snippet": "void make_empty_dir_item(char *body, __le32 dirid, __le32 objid,\n\t\t\t __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t/* direntry header of \".\" */\n\tput_deh_offset(dot, DOT_OFFSET);\n\t/* these two are from make_le_item_head, and are are LE */\n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dot, EMPTY_DIR_SIZE - ROUND_UP(strlen(\".\")));\n\tmark_de_visible(dot);\n\n\t/* direntry header of \"..\" */\n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t/* key of \"..\" for the root directory */\n\t/* these two are from the inode, and are are LE */\n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dotdot, deh_location(dot) - ROUND_UP(strlen(\"..\")));\n\tmark_de_visible(dotdot);\n\n\t/* copy \"..\" and \".\" */\n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nvoid make_empty_dir_item(char *body, __le32 dirid, __le32 objid,\n\t\t\t __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t/* direntry header of \".\" */\n\tput_deh_offset(dot, DOT_OFFSET);\n\t/* these two are from make_le_item_head, and are are LE */\n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dot, EMPTY_DIR_SIZE - ROUND_UP(strlen(\".\")));\n\tmark_de_visible(dot);\n\n\t/* direntry header of \"..\" */\n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t/* key of \"..\" for the root directory */\n\t/* these two are from the inode, and are are LE */\n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dotdot, deh_location(dot) - ROUND_UP(strlen(\"..\")));\n\tmark_de_visible(dotdot);\n\n\t/* copy \"..\" and \".\" */\n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_le_item_head",
          "args": [
            "ih",
            "NULL",
            "KEY_FORMAT_3_5",
            "DOT_OFFSET",
            "TYPE_DIRENTRY",
            "EMPTY_DIR_SIZE",
            "2"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "make_le_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "136-156",
          "snippet": "inline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\ninline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_empty_dir_item_v1",
          "args": [
            "body",
            "ih->ih_key.k_dir_id",
            "ih->ih_key.k_objectid",
            "INODE_PKEY(dir)->k_dir_id",
            "INODE_PKEY(dir)->k_objectid"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_dir_item_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
          "lines": "281-312",
          "snippet": "void make_empty_dir_item_v1(char *body, __le32 dirid, __le32 objid,\n\t\t\t    __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE_V1);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t/* direntry header of \".\" */\n\tput_deh_offset(dot, DOT_OFFSET);\n\t/* these two are from make_le_item_head, and are are LE */\n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dot, EMPTY_DIR_SIZE_V1 - strlen(\".\"));\n\tmark_de_visible(dot);\n\n\t/* direntry header of \"..\" */\n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t/* key of \"..\" for the root directory */\n\t/* these two are from the inode, and are are LE */\n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dotdot, deh_location(dot) - strlen(\"..\"));\n\tmark_de_visible(dotdot);\n\n\t/* copy \"..\" and \".\" */\n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nvoid make_empty_dir_item_v1(char *body, __le32 dirid, __le32 objid,\n\t\t\t    __le32 par_dirid, __le32 par_objid)\n{\n\tstruct reiserfs_de_head *dot, *dotdot;\n\n\tmemset(body, 0, EMPTY_DIR_SIZE_V1);\n\tdot = (struct reiserfs_de_head *)body;\n\tdotdot = dot + 1;\n\n\t/* direntry header of \".\" */\n\tput_deh_offset(dot, DOT_OFFSET);\n\t/* these two are from make_le_item_head, and are are LE */\n\tdot->deh_dir_id = dirid;\n\tdot->deh_objectid = objid;\n\tdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dot, EMPTY_DIR_SIZE_V1 - strlen(\".\"));\n\tmark_de_visible(dot);\n\n\t/* direntry header of \"..\" */\n\tput_deh_offset(dotdot, DOT_DOT_OFFSET);\n\t/* key of \"..\" for the root directory */\n\t/* these two are from the inode, and are are LE */\n\tdotdot->deh_dir_id = par_dirid;\n\tdotdot->deh_objectid = par_objid;\n\tdotdot->deh_state = 0;\t/* Endian safe if 0 */\n\tput_deh_location(dotdot, deh_location(dot) - strlen(\"..\"));\n\tmark_de_visible(dotdot);\n\n\t/* copy \"..\" and \".\" */\n\tmemcpy(body + deh_location(dot), \".\", 1);\n\tmemcpy(body + deh_location(dotdot), \"..\", 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "sb"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_make_cpu_key",
          "args": [
            "&key",
            "KEY_FORMAT_3_5",
            "le32_to_cpu(ih->ih_key.k_dir_id)",
            "le32_to_cpu(ih->ih_key.k_objectid)",
            "DOT_OFFSET",
            "TYPE_DIRENTRY",
            "3/*key length */"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "_make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "110-120",
          "snippet": "static void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ih->ih_key.k_objectid"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_new_directory(struct reiserfs_transaction_handle *th,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct item_head *ih, struct treepath *path,\n\t\t\t\t  struct inode *dir)\n{\n\tstruct super_block *sb = th->t_super;\n\tchar empty_dir[EMPTY_DIR_SIZE];\n\tchar *body = empty_dir;\n\tstruct cpu_key key;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t_make_cpu_key(&key, KEY_FORMAT_3_5, le32_to_cpu(ih->ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih->ih_key.k_objectid), DOT_OFFSET,\n\t\t      TYPE_DIRENTRY, 3 /*key length */ );\n\n\t/*\n\t * compose item head for new item. Directories consist of items of\n\t * old type (ITEM_VERSION_1). Do not set key (second arg is 0), it\n\t * is done by reiserfs_new_inode\n\t */\n\tif (old_format_only(sb)) {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE_V1, 2);\n\n\t\tmake_empty_dir_item_v1(body, ih->ih_key.k_dir_id,\n\t\t\t\t       ih->ih_key.k_objectid,\n\t\t\t\t       INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t       INODE_PKEY(dir)->k_objectid);\n\t} else {\n\t\tmake_le_item_head(ih, NULL, KEY_FORMAT_3_5, DOT_OFFSET,\n\t\t\t\t  TYPE_DIRENTRY, EMPTY_DIR_SIZE, 2);\n\n\t\tmake_empty_dir_item(body, ih->ih_key.k_dir_id,\n\t\t\t\t    ih->ih_key.k_objectid,\n\t\t\t\t    INODE_PKEY(dir)->k_dir_id,\n\t\t\t\t    INODE_PKEY(dir)->k_objectid);\n\t}\n\n\t/* look for place in the tree for new item */\n\tretval = search_item(sb, &key, path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(sb, \"vs-13080\",\n\t\t\t       \"i/o failure occurred creating new directory\");\n\t\treturn -EIO;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(path);\n\t\treiserfs_warning(sb, \"vs-13070\",\n\t\t\t\t \"object with this key exists (%k)\",\n\t\t\t\t &(ih->ih_key));\n\t\treturn -EEXIST;\n\t}\n\n\t/* insert item, that is empty directory item */\n\treturn reiserfs_insert_item(th, path, &key, ih, inode, body);\n}"
  },
  {
    "function_name": "reiserfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1775-1798",
    "snippet": "int reiserfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count = 1;\n\n\tif (inode->i_sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\t/*\n\t * memory pressure can sometimes initiate write_inode calls with\n\t * sync == 1,\n\t * these cases are just when the system needs ram, not when the\n\t * inode needs to reach disk for safety, and they can safely be\n\t * ignored because the altered inode has already been logged.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !(current->flags & PF_MEMALLOC)) {\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (!journal_begin(&th, inode->i_sb, jbegin_count)) {\n\t\t\treiserfs_update_sd(&th, inode);\n\t\t\tjournal_end_sync(&th);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end_sync",
          "args": [
            "&th"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "inode"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "jbegin_count"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count = 1;\n\n\tif (inode->i_sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\t/*\n\t * memory pressure can sometimes initiate write_inode calls with\n\t * sync == 1,\n\t * these cases are just when the system needs ram, not when the\n\t * inode needs to reach disk for safety, and they can safely be\n\t * ignored because the altered inode has already been logged.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !(current->flags & PF_MEMALLOC)) {\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (!journal_begin(&th, inode->i_sb, jbegin_count)) {\n\t\t\treiserfs_update_sd(&th, inode);\n\t\t\tjournal_end_sync(&th);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1736-1763",
    "snippet": "int reiserfs_encode_fh(struct inode *inode, __u32 * data, int *lenp,\n\t\t       struct inode *parent)\n{\n\tint maxlen = *lenp;\n\n\tif (parent && (maxlen < 5)) {\n\t\t*lenp = 5;\n\t\treturn FILEID_INVALID;\n\t} else if (maxlen < 3) {\n\t\t*lenp = 3;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tdata[0] = inode->i_ino;\n\tdata[1] = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\tdata[2] = inode->i_generation;\n\t*lenp = 3;\n\tif (parent) {\n\t\tdata[3] = parent->i_ino;\n\t\tdata[4] = le32_to_cpu(INODE_PKEY(parent)->k_dir_id);\n\t\t*lenp = 5;\n\t\tif (maxlen >= 6) {\n\t\t\tdata[5] = parent->i_generation;\n\t\t\t*lenp = 6;\n\t\t}\n\t}\n\treturn *lenp;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(parent)->k_dir_id"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "parent"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_encode_fh(struct inode *inode, __u32 * data, int *lenp,\n\t\t       struct inode *parent)\n{\n\tint maxlen = *lenp;\n\n\tif (parent && (maxlen < 5)) {\n\t\t*lenp = 5;\n\t\treturn FILEID_INVALID;\n\t} else if (maxlen < 3) {\n\t\t*lenp = 3;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tdata[0] = inode->i_ino;\n\tdata[1] = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\tdata[2] = inode->i_generation;\n\t*lenp = 3;\n\tif (parent) {\n\t\tdata[3] = parent->i_ino;\n\t\tdata[4] = le32_to_cpu(INODE_PKEY(parent)->k_dir_id);\n\t\t*lenp = 5;\n\t\tif (maxlen >= 6) {\n\t\t\tdata[5] = parent->i_generation;\n\t\t\t*lenp = 6;\n\t\t}\n\t}\n\treturn *lenp;\n}"
  },
  {
    "function_name": "reiserfs_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1722-1734",
    "snippet": "struct dentry *reiserfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\tif (fh_type > fh_len)\n\t\tfh_type = fh_len;\n\tif (fh_type < 4)\n\t\treturn NULL;\n\n\treturn reiserfs_get_dentry(sb,\n\t\t(fh_type >= 5) ? fid->raw[3] : fid->raw[2],\n\t\t(fh_type >= 5) ? fid->raw[4] : fid->raw[3],\n\t\t(fh_type == 6) ? fid->raw[5] : 0);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_get_dentry",
          "args": [
            "sb",
            "(fh_type >= 5) ? fid->raw[3] : fid->raw[2]",
            "(fh_type >= 5) ? fid->raw[4] : fid->raw[3]",
            "(fh_type == 6) ? fid->raw[5] : 0"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1671-1690",
          "snippet": "static struct dentry *reiserfs_get_dentry(struct super_block *sb,\n\tu32 objectid, u32 dir_id, u32 generation)\n\n{\n\tstruct cpu_key key;\n\tstruct inode *inode;\n\n\tkey.on_disk_key.k_objectid = objectid;\n\tkey.on_disk_key.k_dir_id = dir_id;\n\treiserfs_write_lock(sb);\n\tinode = reiserfs_iget(sb, &key);\n\tif (inode && !IS_ERR(inode) && generation != 0 &&\n\t    generation != inode->i_generation) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treiserfs_write_unlock(sb);\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct dentry *reiserfs_get_dentry(struct super_block *sb,\n\tu32 objectid, u32 dir_id, u32 generation)\n\n{\n\tstruct cpu_key key;\n\tstruct inode *inode;\n\n\tkey.on_disk_key.k_objectid = objectid;\n\tkey.on_disk_key.k_dir_id = dir_id;\n\treiserfs_write_lock(sb);\n\tinode = reiserfs_iget(sb, &key);\n\tif (inode && !IS_ERR(inode) && generation != 0 &&\n\t    generation != inode->i_generation) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treiserfs_write_unlock(sb);\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstruct dentry *reiserfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\tif (fh_type > fh_len)\n\t\tfh_type = fh_len;\n\tif (fh_type < 4)\n\t\treturn NULL;\n\n\treturn reiserfs_get_dentry(sb,\n\t\t(fh_type >= 5) ? fid->raw[3] : fid->raw[2],\n\t\t(fh_type >= 5) ? fid->raw[4] : fid->raw[3],\n\t\t(fh_type == 6) ? fid->raw[5] : 0);\n}"
  },
  {
    "function_name": "reiserfs_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1692-1720",
    "snippet": "struct dentry *reiserfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\t/*\n\t * fhtype happens to reflect the number of u32s encoded.\n\t * due to a bug in earlier code, fhtype might indicate there\n\t * are more u32s then actually fitted.\n\t * so if fhtype seems to be more than len, reduce fhtype.\n\t * Valid types are:\n\t *   2 - objectid + dir_id - legacy support\n\t *   3 - objectid + dir_id + generation\n\t *   4 - objectid + dir_id + objectid and dirid of parent - legacy\n\t *   5 - objectid + dir_id + generation + objectid and dirid of parent\n\t *   6 - as above plus generation of directory\n\t * 6 does not fit in NFSv2 handles\n\t */\n\tif (fh_type > fh_len) {\n\t\tif (fh_type != 6 || fh_len != 5)\n\t\t\treiserfs_warning(sb, \"reiserfs-13077\",\n\t\t\t\t\"nfsd/reiserfs, fhtype=%d, len=%d - odd\",\n\t\t\t\tfh_type, fh_len);\n\t\tfh_type = fh_len;\n\t}\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\treturn reiserfs_get_dentry(sb, fid->raw[0], fid->raw[1],\n\t\t(fh_type == 3 || fh_type >= 5) ? fid->raw[2] : 0);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_get_dentry",
          "args": [
            "sb",
            "fid->raw[0]",
            "fid->raw[1]",
            "(fh_type == 3 || fh_type >= 5) ? fid->raw[2] : 0"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1671-1690",
          "snippet": "static struct dentry *reiserfs_get_dentry(struct super_block *sb,\n\tu32 objectid, u32 dir_id, u32 generation)\n\n{\n\tstruct cpu_key key;\n\tstruct inode *inode;\n\n\tkey.on_disk_key.k_objectid = objectid;\n\tkey.on_disk_key.k_dir_id = dir_id;\n\treiserfs_write_lock(sb);\n\tinode = reiserfs_iget(sb, &key);\n\tif (inode && !IS_ERR(inode) && generation != 0 &&\n\t    generation != inode->i_generation) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treiserfs_write_unlock(sb);\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct dentry *reiserfs_get_dentry(struct super_block *sb,\n\tu32 objectid, u32 dir_id, u32 generation)\n\n{\n\tstruct cpu_key key;\n\tstruct inode *inode;\n\n\tkey.on_disk_key.k_objectid = objectid;\n\tkey.on_disk_key.k_dir_id = dir_id;\n\treiserfs_write_lock(sb);\n\tinode = reiserfs_iget(sb, &key);\n\tif (inode && !IS_ERR(inode) && generation != 0 &&\n\t    generation != inode->i_generation) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treiserfs_write_unlock(sb);\n\n\treturn d_obtain_alias(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"reiserfs-13077\"",
            "\"nfsd/reiserfs, fhtype=%d, len=%d - odd\"",
            "fh_type",
            "fh_len"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstruct dentry *reiserfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\t/*\n\t * fhtype happens to reflect the number of u32s encoded.\n\t * due to a bug in earlier code, fhtype might indicate there\n\t * are more u32s then actually fitted.\n\t * so if fhtype seems to be more than len, reduce fhtype.\n\t * Valid types are:\n\t *   2 - objectid + dir_id - legacy support\n\t *   3 - objectid + dir_id + generation\n\t *   4 - objectid + dir_id + objectid and dirid of parent - legacy\n\t *   5 - objectid + dir_id + generation + objectid and dirid of parent\n\t *   6 - as above plus generation of directory\n\t * 6 does not fit in NFSv2 handles\n\t */\n\tif (fh_type > fh_len) {\n\t\tif (fh_type != 6 || fh_len != 5)\n\t\t\treiserfs_warning(sb, \"reiserfs-13077\",\n\t\t\t\t\"nfsd/reiserfs, fhtype=%d, len=%d - odd\",\n\t\t\t\tfh_type, fh_len);\n\t\tfh_type = fh_len;\n\t}\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\treturn reiserfs_get_dentry(sb, fid->raw[0], fid->raw[1],\n\t\t(fh_type == 3 || fh_type >= 5) ? fid->raw[2] : 0);\n}"
  },
  {
    "function_name": "reiserfs_get_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1671-1690",
    "snippet": "static struct dentry *reiserfs_get_dentry(struct super_block *sb,\n\tu32 objectid, u32 dir_id, u32 generation)\n\n{\n\tstruct cpu_key key;\n\tstruct inode *inode;\n\n\tkey.on_disk_key.k_objectid = objectid;\n\tkey.on_disk_key.k_dir_id = dir_id;\n\treiserfs_write_lock(sb);\n\tinode = reiserfs_iget(sb, &key);\n\tif (inode && !IS_ERR(inode) && generation != 0 &&\n\t    generation != inode->i_generation) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treiserfs_write_unlock(sb);\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_iget",
          "args": [
            "sb",
            "&key"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1642-1669",
          "snippet": "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct dentry *reiserfs_get_dentry(struct super_block *sb,\n\tu32 objectid, u32 dir_id, u32 generation)\n\n{\n\tstruct cpu_key key;\n\tstruct inode *inode;\n\n\tkey.on_disk_key.k_objectid = objectid;\n\tkey.on_disk_key.k_dir_id = dir_id;\n\treiserfs_write_lock(sb);\n\tinode = reiserfs_iget(sb, &key);\n\tif (inode && !IS_ERR(inode) && generation != 0 &&\n\t    generation != inode->i_generation) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treiserfs_write_unlock(sb);\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "reiserfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1642-1669",
    "snippet": "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_short_keys",
          "args": [
            "INODE_PKEY(inode)",
            "key"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "comp_short_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "43-58",
          "snippet": "inline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key)\n{\n\t__u32 n;\n\tn = le32_to_cpu(le_key->k_dir_id);\n\tif (n < cpu_key->on_disk_key.k_dir_id)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_dir_id)\n\t\treturn 1;\n\tn = le32_to_cpu(le_key->k_objectid);\n\tif (n < cpu_key->on_disk_key.k_objectid)\n\t\treturn -1;\n\tif (n > cpu_key->on_disk_key.k_objectid)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_read_locked_inode",
          "args": [
            "inode",
            "&args"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1542-1618",
          "snippet": "void reiserfs_read_locked_inode(struct inode *inode,\n\t\t\t\tstruct reiserfs_iget_args *args)\n{\n\tINITIALIZE_PATH(path_to_sd);\n\tstruct cpu_key key;\n\tunsigned long dirino;\n\tint retval;\n\n\tdirino = args->dirid;\n\n\t/*\n\t * set version 1, version 2 could be used too, because stat data\n\t * key is the same in both versions\n\t */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = dirino;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tkey.on_disk_key.k_offset = 0;\n\tkey.on_disk_key.k_type = 0;\n\n\t/* look for the object's stat data */\n\tretval = search_item(inode->i_sb, &key, &path_to_sd);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-13070\",\n\t\t\t       \"i/o failure occurred trying to find \"\n\t\t\t       \"stat data of %K\", &key);\n\t\treiserfs_make_bad_inode(inode);\n\t\treturn;\n\t}\n\n\t/* a stale NFS handle can trigger this without it being an error */\n\tif (retval != ITEM_FOUND) {\n\t\tpathrelse(&path_to_sd);\n\t\treiserfs_make_bad_inode(inode);\n\t\tclear_nlink(inode);\n\t\treturn;\n\t}\n\n\tinit_inode(inode, &path_to_sd);\n\n\t/*\n\t * It is possible that knfsd is trying to access inode of a file\n\t * that is being removed from the disk by some other thread. As we\n\t * update sd on unlink all that is required is to check for nlink\n\t * here. This bug was first found by Sizif when debugging\n\t * SquidNG/Butterfly, forgotten, and found again after Philippe\n\t * Gramoulle <philippe.gramoulle@mmania.com> reproduced it.\n\n\t * More logical fix would require changes in fs/inode.c:iput() to\n\t * remove inode from hash-table _after_ fs cleaned disk stuff up and\n\t * in iget() to return NULL if I_FREEING inode is found in\n\t * hash-table.\n\t */\n\n\t/*\n\t * Currently there is one place where it's ok to meet inode with\n\t * nlink==0: processing of open-unlinked and half-truncated files\n\t * during mount (fs/reiserfs/super.c:finish_unfinished()).\n\t */\n\tif ((inode->i_nlink == 0) &&\n\t    !REISERFS_SB(inode->i_sb)->s_is_unlinked_ok) {\n\t\treiserfs_warning(inode->i_sb, \"vs-13075\",\n\t\t\t\t \"dead inode read from disk %K. \"\n\t\t\t\t \"This is likely to be race with knfsd. Ignore\",\n\t\t\t\t &key);\n\t\treiserfs_make_bad_inode(inode);\n\t}\n\n\t/* init inode should be relsing */\n\treiserfs_check_path(&path_to_sd);\n\n\t/*\n\t * Stat data v1 doesn't support ACLs.\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\tcache_no_acl(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nvoid reiserfs_read_locked_inode(struct inode *inode,\n\t\t\t\tstruct reiserfs_iget_args *args)\n{\n\tINITIALIZE_PATH(path_to_sd);\n\tstruct cpu_key key;\n\tunsigned long dirino;\n\tint retval;\n\n\tdirino = args->dirid;\n\n\t/*\n\t * set version 1, version 2 could be used too, because stat data\n\t * key is the same in both versions\n\t */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = dirino;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tkey.on_disk_key.k_offset = 0;\n\tkey.on_disk_key.k_type = 0;\n\n\t/* look for the object's stat data */\n\tretval = search_item(inode->i_sb, &key, &path_to_sd);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-13070\",\n\t\t\t       \"i/o failure occurred trying to find \"\n\t\t\t       \"stat data of %K\", &key);\n\t\treiserfs_make_bad_inode(inode);\n\t\treturn;\n\t}\n\n\t/* a stale NFS handle can trigger this without it being an error */\n\tif (retval != ITEM_FOUND) {\n\t\tpathrelse(&path_to_sd);\n\t\treiserfs_make_bad_inode(inode);\n\t\tclear_nlink(inode);\n\t\treturn;\n\t}\n\n\tinit_inode(inode, &path_to_sd);\n\n\t/*\n\t * It is possible that knfsd is trying to access inode of a file\n\t * that is being removed from the disk by some other thread. As we\n\t * update sd on unlink all that is required is to check for nlink\n\t * here. This bug was first found by Sizif when debugging\n\t * SquidNG/Butterfly, forgotten, and found again after Philippe\n\t * Gramoulle <philippe.gramoulle@mmania.com> reproduced it.\n\n\t * More logical fix would require changes in fs/inode.c:iput() to\n\t * remove inode from hash-table _after_ fs cleaned disk stuff up and\n\t * in iget() to return NULL if I_FREEING inode is found in\n\t * hash-table.\n\t */\n\n\t/*\n\t * Currently there is one place where it's ok to meet inode with\n\t * nlink==0: processing of open-unlinked and half-truncated files\n\t * during mount (fs/reiserfs/super.c:finish_unfinished()).\n\t */\n\tif ((inode->i_nlink == 0) &&\n\t    !REISERFS_SB(inode->i_sb)->s_is_unlinked_ok) {\n\t\treiserfs_warning(inode->i_sb, \"vs-13075\",\n\t\t\t\t \"dead inode read from disk %K. \"\n\t\t\t\t \"This is likely to be race with knfsd. Ignore\",\n\t\t\t\t &key);\n\t\treiserfs_make_bad_inode(inode);\n\t}\n\n\t/* init inode should be relsing */\n\treiserfs_check_path(&path_to_sd);\n\n\t/*\n\t * Stat data v1 doesn't support ACLs.\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\tcache_no_acl(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "s",
            "key->on_disk_key.k_objectid",
            "reiserfs_find_actor",
            "reiserfs_init_locked_inode",
            "(void *)(&args)"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "reiserfs_find_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1632-1640",
    "snippet": "int reiserfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct reiserfs_iget_args *args;\n\n\targs = opaque;\n\t/* args is already in CPU order */\n\treturn (inode->i_ino == args->objectid) &&\n\t    (le32_to_cpu(INODE_PKEY(inode)->k_dir_id) == args->dirid);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(inode)->k_dir_id"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct reiserfs_iget_args *args;\n\n\targs = opaque;\n\t/* args is already in CPU order */\n\treturn (inode->i_ino == args->objectid) &&\n\t    (le32_to_cpu(INODE_PKEY(inode)->k_dir_id) == args->dirid);\n}"
  },
  {
    "function_name": "reiserfs_read_locked_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1542-1618",
    "snippet": "void reiserfs_read_locked_inode(struct inode *inode,\n\t\t\t\tstruct reiserfs_iget_args *args)\n{\n\tINITIALIZE_PATH(path_to_sd);\n\tstruct cpu_key key;\n\tunsigned long dirino;\n\tint retval;\n\n\tdirino = args->dirid;\n\n\t/*\n\t * set version 1, version 2 could be used too, because stat data\n\t * key is the same in both versions\n\t */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = dirino;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tkey.on_disk_key.k_offset = 0;\n\tkey.on_disk_key.k_type = 0;\n\n\t/* look for the object's stat data */\n\tretval = search_item(inode->i_sb, &key, &path_to_sd);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-13070\",\n\t\t\t       \"i/o failure occurred trying to find \"\n\t\t\t       \"stat data of %K\", &key);\n\t\treiserfs_make_bad_inode(inode);\n\t\treturn;\n\t}\n\n\t/* a stale NFS handle can trigger this without it being an error */\n\tif (retval != ITEM_FOUND) {\n\t\tpathrelse(&path_to_sd);\n\t\treiserfs_make_bad_inode(inode);\n\t\tclear_nlink(inode);\n\t\treturn;\n\t}\n\n\tinit_inode(inode, &path_to_sd);\n\n\t/*\n\t * It is possible that knfsd is trying to access inode of a file\n\t * that is being removed from the disk by some other thread. As we\n\t * update sd on unlink all that is required is to check for nlink\n\t * here. This bug was first found by Sizif when debugging\n\t * SquidNG/Butterfly, forgotten, and found again after Philippe\n\t * Gramoulle <philippe.gramoulle@mmania.com> reproduced it.\n\n\t * More logical fix would require changes in fs/inode.c:iput() to\n\t * remove inode from hash-table _after_ fs cleaned disk stuff up and\n\t * in iget() to return NULL if I_FREEING inode is found in\n\t * hash-table.\n\t */\n\n\t/*\n\t * Currently there is one place where it's ok to meet inode with\n\t * nlink==0: processing of open-unlinked and half-truncated files\n\t * during mount (fs/reiserfs/super.c:finish_unfinished()).\n\t */\n\tif ((inode->i_nlink == 0) &&\n\t    !REISERFS_SB(inode->i_sb)->s_is_unlinked_ok) {\n\t\treiserfs_warning(inode->i_sb, \"vs-13075\",\n\t\t\t\t \"dead inode read from disk %K. \"\n\t\t\t\t \"This is likely to be race with knfsd. Ignore\",\n\t\t\t\t &key);\n\t\treiserfs_make_bad_inode(inode);\n\t}\n\n\t/* init inode should be relsing */\n\treiserfs_check_path(&path_to_sd);\n\n\t/*\n\t * Stat data v1 doesn't support ACLs.\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\tcache_no_acl(inode);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_no_acl",
          "args": [
            "inode"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "inode"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&path_to_sd"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"vs-13075\"",
            "\"dead inode read from disk %K. \"\n\t\t\t\t \"This is likely to be race with knfsd. Ignore\"",
            "&key"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inode",
          "args": [
            "inode",
            "&path_to_sd"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1237-1370",
          "snippet": "static void init_inode(struct inode *inode, struct treepath *path)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\t__u32 rdev;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tcopy_key(INODE_PKEY(inode), &ih->ih_key);\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\treiserfs_init_xattr_rwsem(inode);\n\n\tif (stat_data_v1(ih)) {\n\t\tstruct stat_data_v1 *sd =\n\t\t    (struct stat_data_v1 *)ih_item_body(bh, ih);\n\t\tunsigned long blocks;\n\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\t\tinode->i_mode = sd_v1_mode(sd);\n\t\tset_nlink(inode, sd_v1_nlink(sd));\n\t\ti_uid_write(inode, sd_v1_uid(sd));\n\t\ti_gid_write(inode, sd_v1_gid(sd));\n\t\tinode->i_size = sd_v1_size(sd);\n\t\tinode->i_atime.tv_sec = sd_v1_atime(sd);\n\t\tinode->i_mtime.tv_sec = sd_v1_mtime(sd);\n\t\tinode->i_ctime.tv_sec = sd_v1_ctime(sd);\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_ctime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\n\t\tinode->i_blocks = sd_v1_blocks(sd);\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\tblocks = (inode->i_size + 511) >> 9;\n\t\tblocks = _ROUND_UP(blocks, inode->i_sb->s_blocksize >> 9);\n\n\t\t/*\n\t\t * there was a bug in <=3.5.23 when i_blocks could take\n\t\t * negative values. Starting from 3.5.17 this value could\n\t\t * even be stored in stat data. For such files we set\n\t\t * i_blocks based on file size. Just 2 notes: this can be\n\t\t * wrong for sparse files. On-disk value will be only\n\t\t * updated if file's inode will ever change\n\t\t */\n\t\tif (inode->i_blocks > blocks) {\n\t\t\tinode->i_blocks = blocks;\n\t\t}\n\n\t\trdev = sd_v1_rdev(sd);\n\t\tREISERFS_I(inode)->i_first_direct_byte =\n\t\t    sd_v1_first_direct_byte(sd);\n\n\t\t/*\n\t\t * an early bug in the quota code can give us an odd\n\t\t * number for the block count.  This is incorrect, fix it here.\n\t\t */\n\t\tif (inode->i_blocks & 1) {\n\t\t\tinode->i_blocks++;\n\t\t}\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V1_SIZE));\n\t\t/*\n\t\t * nopack is initially zero for v1 objects. For v2 objects,\n\t\t * nopack is initialised from sd_attrs\n\t\t */\n\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t} else {\n\t\t/*\n\t\t * new stat data found, but object may have old items\n\t\t * (directories and symlinks)\n\t\t */\n\t\tstruct stat_data *sd = (struct stat_data *)ih_item_body(bh, ih);\n\n\t\tinode->i_mode = sd_v2_mode(sd);\n\t\tset_nlink(inode, sd_v2_nlink(sd));\n\t\ti_uid_write(inode, sd_v2_uid(sd));\n\t\tinode->i_size = sd_v2_size(sd);\n\t\ti_gid_write(inode, sd_v2_gid(sd));\n\t\tinode->i_mtime.tv_sec = sd_v2_mtime(sd);\n\t\tinode->i_atime.tv_sec = sd_v2_atime(sd);\n\t\tinode->i_ctime.tv_sec = sd_v2_ctime(sd);\n\t\tinode->i_ctime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_blocks = sd_v2_blocks(sd);\n\t\trdev = sd_v2_rdev(sd);\n\t\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\t\tinode->i_generation =\n\t\t\t    le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\telse\n\t\t\tinode->i_generation = sd_v2_generation(sd);\n\n\t\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\telse\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\t\tREISERFS_I(inode)->i_first_direct_byte = 0;\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V2_SIZE));\n\t\t/*\n\t\t * read persistent inode attributes from sd and initialise\n\t\t * generic inode flags from them\n\t\t */\n\t\tREISERFS_I(inode)->i_attrs = sd_v2_attrs(sd);\n\t\tsd_attrs_to_i_attrs(sd_v2_attrs(sd), inode);\n\t}\n\n\tpathrelse(path);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_file_inode_operations;\n\t\tinode->i_fop = &reiserfs_file_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_dir_inode_operations;\n\t\tinode->i_fop = &reiserfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_op = &reiserfs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations reiserfs_address_space_operations = {\n\t.writepage = reiserfs_writepage,\n\t.readpage = reiserfs_readpage,\n\t.readpages = reiserfs_readpages,\n\t.releasepage = reiserfs_releasepage,\n\t.invalidatepage = reiserfs_invalidatepage,\n\t.write_begin = reiserfs_write_begin,\n\t.write_end = reiserfs_write_end,\n\t.bmap = reiserfs_aop_bmap,\n\t.direct_IO = reiserfs_direct_IO,\n\t.set_page_dirty = reiserfs_set_page_dirty,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nconst struct address_space_operations reiserfs_address_space_operations = {\n\t.writepage = reiserfs_writepage,\n\t.readpage = reiserfs_readpage,\n\t.readpages = reiserfs_readpages,\n\t.releasepage = reiserfs_releasepage,\n\t.invalidatepage = reiserfs_invalidatepage,\n\t.write_begin = reiserfs_write_begin,\n\t.write_end = reiserfs_write_end,\n\t.bmap = reiserfs_aop_bmap,\n\t.direct_IO = reiserfs_direct_IO,\n\t.set_page_dirty = reiserfs_set_page_dirty,\n};\n\nstatic void init_inode(struct inode *inode, struct treepath *path)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\t__u32 rdev;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tcopy_key(INODE_PKEY(inode), &ih->ih_key);\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\treiserfs_init_xattr_rwsem(inode);\n\n\tif (stat_data_v1(ih)) {\n\t\tstruct stat_data_v1 *sd =\n\t\t    (struct stat_data_v1 *)ih_item_body(bh, ih);\n\t\tunsigned long blocks;\n\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\t\tinode->i_mode = sd_v1_mode(sd);\n\t\tset_nlink(inode, sd_v1_nlink(sd));\n\t\ti_uid_write(inode, sd_v1_uid(sd));\n\t\ti_gid_write(inode, sd_v1_gid(sd));\n\t\tinode->i_size = sd_v1_size(sd);\n\t\tinode->i_atime.tv_sec = sd_v1_atime(sd);\n\t\tinode->i_mtime.tv_sec = sd_v1_mtime(sd);\n\t\tinode->i_ctime.tv_sec = sd_v1_ctime(sd);\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_ctime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\n\t\tinode->i_blocks = sd_v1_blocks(sd);\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\tblocks = (inode->i_size + 511) >> 9;\n\t\tblocks = _ROUND_UP(blocks, inode->i_sb->s_blocksize >> 9);\n\n\t\t/*\n\t\t * there was a bug in <=3.5.23 when i_blocks could take\n\t\t * negative values. Starting from 3.5.17 this value could\n\t\t * even be stored in stat data. For such files we set\n\t\t * i_blocks based on file size. Just 2 notes: this can be\n\t\t * wrong for sparse files. On-disk value will be only\n\t\t * updated if file's inode will ever change\n\t\t */\n\t\tif (inode->i_blocks > blocks) {\n\t\t\tinode->i_blocks = blocks;\n\t\t}\n\n\t\trdev = sd_v1_rdev(sd);\n\t\tREISERFS_I(inode)->i_first_direct_byte =\n\t\t    sd_v1_first_direct_byte(sd);\n\n\t\t/*\n\t\t * an early bug in the quota code can give us an odd\n\t\t * number for the block count.  This is incorrect, fix it here.\n\t\t */\n\t\tif (inode->i_blocks & 1) {\n\t\t\tinode->i_blocks++;\n\t\t}\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V1_SIZE));\n\t\t/*\n\t\t * nopack is initially zero for v1 objects. For v2 objects,\n\t\t * nopack is initialised from sd_attrs\n\t\t */\n\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t} else {\n\t\t/*\n\t\t * new stat data found, but object may have old items\n\t\t * (directories and symlinks)\n\t\t */\n\t\tstruct stat_data *sd = (struct stat_data *)ih_item_body(bh, ih);\n\n\t\tinode->i_mode = sd_v2_mode(sd);\n\t\tset_nlink(inode, sd_v2_nlink(sd));\n\t\ti_uid_write(inode, sd_v2_uid(sd));\n\t\tinode->i_size = sd_v2_size(sd);\n\t\ti_gid_write(inode, sd_v2_gid(sd));\n\t\tinode->i_mtime.tv_sec = sd_v2_mtime(sd);\n\t\tinode->i_atime.tv_sec = sd_v2_atime(sd);\n\t\tinode->i_ctime.tv_sec = sd_v2_ctime(sd);\n\t\tinode->i_ctime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_blocks = sd_v2_blocks(sd);\n\t\trdev = sd_v2_rdev(sd);\n\t\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\t\tinode->i_generation =\n\t\t\t    le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\telse\n\t\t\tinode->i_generation = sd_v2_generation(sd);\n\n\t\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\telse\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\t\tREISERFS_I(inode)->i_first_direct_byte = 0;\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V2_SIZE));\n\t\t/*\n\t\t * read persistent inode attributes from sd and initialise\n\t\t * generic inode flags from them\n\t\t */\n\t\tREISERFS_I(inode)->i_attrs = sd_v2_attrs(sd);\n\t\tsd_attrs_to_i_attrs(sd_v2_attrs(sd), inode);\n\t}\n\n\tpathrelse(path);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_file_inode_operations;\n\t\tinode->i_fop = &reiserfs_file_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_dir_inode_operations;\n\t\tinode->i_fop = &reiserfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_op = &reiserfs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path_to_sd"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"vs-13070\"",
            "\"i/o failure occurred trying to find \"\n\t\t\t       \"stat data of %K\"",
            "&key"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "inode->i_sb",
            "&key",
            "&path_to_sd"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path_to_sd"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nvoid reiserfs_read_locked_inode(struct inode *inode,\n\t\t\t\tstruct reiserfs_iget_args *args)\n{\n\tINITIALIZE_PATH(path_to_sd);\n\tstruct cpu_key key;\n\tunsigned long dirino;\n\tint retval;\n\n\tdirino = args->dirid;\n\n\t/*\n\t * set version 1, version 2 could be used too, because stat data\n\t * key is the same in both versions\n\t */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = dirino;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tkey.on_disk_key.k_offset = 0;\n\tkey.on_disk_key.k_type = 0;\n\n\t/* look for the object's stat data */\n\tretval = search_item(inode->i_sb, &key, &path_to_sd);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_error(inode->i_sb, \"vs-13070\",\n\t\t\t       \"i/o failure occurred trying to find \"\n\t\t\t       \"stat data of %K\", &key);\n\t\treiserfs_make_bad_inode(inode);\n\t\treturn;\n\t}\n\n\t/* a stale NFS handle can trigger this without it being an error */\n\tif (retval != ITEM_FOUND) {\n\t\tpathrelse(&path_to_sd);\n\t\treiserfs_make_bad_inode(inode);\n\t\tclear_nlink(inode);\n\t\treturn;\n\t}\n\n\tinit_inode(inode, &path_to_sd);\n\n\t/*\n\t * It is possible that knfsd is trying to access inode of a file\n\t * that is being removed from the disk by some other thread. As we\n\t * update sd on unlink all that is required is to check for nlink\n\t * here. This bug was first found by Sizif when debugging\n\t * SquidNG/Butterfly, forgotten, and found again after Philippe\n\t * Gramoulle <philippe.gramoulle@mmania.com> reproduced it.\n\n\t * More logical fix would require changes in fs/inode.c:iput() to\n\t * remove inode from hash-table _after_ fs cleaned disk stuff up and\n\t * in iget() to return NULL if I_FREEING inode is found in\n\t * hash-table.\n\t */\n\n\t/*\n\t * Currently there is one place where it's ok to meet inode with\n\t * nlink==0: processing of open-unlinked and half-truncated files\n\t * during mount (fs/reiserfs/super.c:finish_unfinished()).\n\t */\n\tif ((inode->i_nlink == 0) &&\n\t    !REISERFS_SB(inode->i_sb)->s_is_unlinked_ok) {\n\t\treiserfs_warning(inode->i_sb, \"vs-13075\",\n\t\t\t\t \"dead inode read from disk %K. \"\n\t\t\t\t \"This is likely to be race with knfsd. Ignore\",\n\t\t\t\t &key);\n\t\treiserfs_make_bad_inode(inode);\n\t}\n\n\t/* init inode should be relsing */\n\treiserfs_check_path(&path_to_sd);\n\n\t/*\n\t * Stat data v1 doesn't support ACLs.\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\tcache_no_acl(inode);\n}"
  },
  {
    "function_name": "reiserfs_init_locked_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1530-1536",
    "snippet": "int reiserfs_init_locked_inode(struct inode *inode, void *p)\n{\n\tstruct reiserfs_iget_args *args = (struct reiserfs_iget_args *)p;\n\tinode->i_ino = args->objectid;\n\tINODE_PKEY(inode)->k_dir_id = cpu_to_le32(args->dirid);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "args->dirid"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_init_locked_inode(struct inode *inode, void *p)\n{\n\tstruct reiserfs_iget_args *args = (struct reiserfs_iget_args *)p;\n\tinode->i_ino = args->objectid;\n\tINODE_PKEY(inode)->k_dir_id = cpu_to_le32(args->dirid);\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_make_bad_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1520-1524",
    "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "INODE_PKEY(inode)",
            "0",
            "KEY_SIZE"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
  },
  {
    "function_name": "reiserfs_update_sd_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1447-1511",
    "snippet": "void reiserfs_update_sd_size(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *inode, loff_t size)\n{\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct buffer_head *bh;\n\tint fs_gen;\n\tstruct item_head *ih, tmp_ih;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* key type is unimportant */\n\tmake_cpu_key(&key, inode, SD_OFFSET, TYPE_STAT_DATA, 3);\n\n\tfor (;;) {\n\t\tint pos;\n\t\t/* look for the object's stat data */\n\t\tretval = search_item(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(inode->i_sb, \"vs-13050\",\n\t\t\t\t       \"i/o failure occurred trying to \"\n\t\t\t\t       \"update %K stat data\", &key);\n\t\t\treturn;\n\t\t}\n\t\tif (retval == ITEM_NOT_FOUND) {\n\t\t\tpos = PATH_LAST_POSITION(&path);\n\t\t\tpathrelse(&path);\n\t\t\tif (inode->i_nlink == 0) {\n\t\t\t\t/*reiserfs_warning (inode->i_sb, \"vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found\"); */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treiserfs_warning(inode->i_sb, \"vs-13060\",\n\t\t\t\t\t \"stat data of object %k (nlink == %d) \"\n\t\t\t\t\t \"not found (pos %d)\",\n\t\t\t\t\t INODE_PKEY(inode), inode->i_nlink,\n\t\t\t\t\t pos);\n\t\t\treiserfs_check_path(&path);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * sigh, prepare_for_journal might schedule.  When it\n\t\t * schedules the FS might change.  We have to detect that,\n\t\t * and loop back to the search if the stat data item has moved\n\t\t */\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\tcopy_item_head(&tmp_ih, ih);\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\t/* Stat_data item has been moved after scheduling. */\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tupdate_stat_data(&path, inode, size);\n\tjournal_mark_dirty(th, bh);\n\tpathrelse(&path);\n\treturn;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "bh"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_stat_data",
          "args": [
            "&path",
            "inode",
            "size"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "update_stat_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1424-1445",
          "snippet": "static void update_stat_data(struct treepath *path, struct inode *inode,\n\t\t\t     loff_t size)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tif (!is_statdata_le_ih(ih))\n\t\treiserfs_panic(inode->i_sb, \"vs-13065\", \"key %k, found item %h\",\n\t\t\t       INODE_PKEY(inode), ih);\n\n\t/* path points to old stat data */\n\tif (stat_data_v1(ih)) {\n\t\tinode2sd_v1(ih_item_body(bh, ih), inode, size);\n\t} else {\n\t\tinode2sd(ih_item_body(bh, ih), inode, size);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic void update_stat_data(struct treepath *path, struct inode *inode,\n\t\t\t     loff_t size)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tif (!is_statdata_le_ih(ih))\n\t\treiserfs_panic(inode->i_sb, \"vs-13065\", \"key %k, found item %h\",\n\t\t\t       INODE_PKEY(inode), ih);\n\n\t/* path points to old stat data */\n\tif (stat_data_v1(ih)) {\n\t\tinode2sd_v1(ih_item_body(bh, ih), inode, size);\n\t} else {\n\t\tinode2sd(ih_item_body(bh, ih), inode, size);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "inode->i_sb",
            "bh"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&tmp_ih",
            "&path"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_changed",
          "args": [
            "fs_gen",
            "inode->i_sb"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "inode->i_sb",
            "bh",
            "1"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_generation",
          "args": [
            "inode->i_sb"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&tmp_ih",
            "ih"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "&path"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "&path"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&path"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"vs-13060\"",
            "\"stat data of object %k (nlink == %d) \"\n\t\t\t\t\t \"not found (pos %d)\"",
            "INODE_PKEY(inode)",
            "inode->i_nlink",
            "pos"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "&path"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"vs-13050\"",
            "\"i/o failure occurred trying to \"\n\t\t\t\t       \"update %K stat data\"",
            "&key"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "inode->i_sb",
            "&key",
            "&path"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&key",
            "inode",
            "SD_OFFSET",
            "TYPE_STAT_DATA",
            "3"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nvoid reiserfs_update_sd_size(struct reiserfs_transaction_handle *th,\n\t\t\t     struct inode *inode, loff_t size)\n{\n\tstruct cpu_key key;\n\tINITIALIZE_PATH(path);\n\tstruct buffer_head *bh;\n\tint fs_gen;\n\tstruct item_head *ih, tmp_ih;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* key type is unimportant */\n\tmake_cpu_key(&key, inode, SD_OFFSET, TYPE_STAT_DATA, 3);\n\n\tfor (;;) {\n\t\tint pos;\n\t\t/* look for the object's stat data */\n\t\tretval = search_item(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(inode->i_sb, \"vs-13050\",\n\t\t\t\t       \"i/o failure occurred trying to \"\n\t\t\t\t       \"update %K stat data\", &key);\n\t\t\treturn;\n\t\t}\n\t\tif (retval == ITEM_NOT_FOUND) {\n\t\t\tpos = PATH_LAST_POSITION(&path);\n\t\t\tpathrelse(&path);\n\t\t\tif (inode->i_nlink == 0) {\n\t\t\t\t/*reiserfs_warning (inode->i_sb, \"vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found\"); */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treiserfs_warning(inode->i_sb, \"vs-13060\",\n\t\t\t\t\t \"stat data of object %k (nlink == %d) \"\n\t\t\t\t\t \"not found (pos %d)\",\n\t\t\t\t\t INODE_PKEY(inode), inode->i_nlink,\n\t\t\t\t\t pos);\n\t\t\treiserfs_check_path(&path);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * sigh, prepare_for_journal might schedule.  When it\n\t\t * schedules the FS might change.  We have to detect that,\n\t\t * and loop back to the search if the stat data item has moved\n\t\t */\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\tcopy_item_head(&tmp_ih, ih);\n\t\tfs_gen = get_generation(inode->i_sb);\n\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\n\t\t/* Stat_data item has been moved after scheduling. */\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\treiserfs_restore_prepared_buffer(inode->i_sb, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tupdate_stat_data(&path, inode, size);\n\tjournal_mark_dirty(th, bh);\n\tpathrelse(&path);\n\treturn;\n}"
  },
  {
    "function_name": "update_stat_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1424-1445",
    "snippet": "static void update_stat_data(struct treepath *path, struct inode *inode,\n\t\t\t     loff_t size)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tif (!is_statdata_le_ih(ih))\n\t\treiserfs_panic(inode->i_sb, \"vs-13065\", \"key %k, found item %h\",\n\t\t\t       INODE_PKEY(inode), ih);\n\n\t/* path points to old stat data */\n\tif (stat_data_v1(ih)) {\n\t\tinode2sd_v1(ih_item_body(bh, ih), inode, size);\n\t} else {\n\t\tinode2sd(ih_item_body(bh, ih), inode, size);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode2sd",
          "args": [
            "ih_item_body(bh, ih)",
            "inode",
            "size"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "inode2sd_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1397-1418",
          "snippet": "static void inode2sd_v1(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data_v1 *sd_v1 = (struct stat_data_v1 *)sd;\n\n\tset_sd_v1_mode(sd_v1, inode->i_mode);\n\tset_sd_v1_uid(sd_v1, i_uid_read(inode));\n\tset_sd_v1_gid(sd_v1, i_gid_read(inode));\n\tset_sd_v1_nlink(sd_v1, inode->i_nlink);\n\tset_sd_v1_size(sd_v1, size);\n\tset_sd_v1_atime(sd_v1, inode->i_atime.tv_sec);\n\tset_sd_v1_ctime(sd_v1, inode->i_ctime.tv_sec);\n\tset_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v1_blocks(sd_v1, to_fake_used_blocks(inode, SD_V1_SIZE));\n\n\t/* Sigh. i_first_direct_byte is back */\n\tset_sd_v1_first_direct_byte(sd_v1,\n\t\t\t\t    REISERFS_I(inode)->i_first_direct_byte);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void inode2sd_v1(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data_v1 *sd_v1 = (struct stat_data_v1 *)sd;\n\n\tset_sd_v1_mode(sd_v1, inode->i_mode);\n\tset_sd_v1_uid(sd_v1, i_uid_read(inode));\n\tset_sd_v1_gid(sd_v1, i_gid_read(inode));\n\tset_sd_v1_nlink(sd_v1, inode->i_nlink);\n\tset_sd_v1_size(sd_v1, size);\n\tset_sd_v1_atime(sd_v1, inode->i_atime.tv_sec);\n\tset_sd_v1_ctime(sd_v1, inode->i_ctime.tv_sec);\n\tset_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v1_blocks(sd_v1, to_fake_used_blocks(inode, SD_V1_SIZE));\n\n\t/* Sigh. i_first_direct_byte is back */\n\tset_sd_v1_first_direct_byte(sd_v1,\n\t\t\t\t    REISERFS_I(inode)->i_first_direct_byte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "bh",
            "ih"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_data_v1",
          "args": [
            "ih"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "inode->i_sb",
            "\"vs-13065\"",
            "\"key %k, found item %h\"",
            "INODE_PKEY(inode)",
            "ih"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_statdata_le_ih",
          "args": [
            "ih"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1577-1580",
          "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic void update_stat_data(struct treepath *path, struct inode *inode,\n\t\t\t     loff_t size)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tif (!is_statdata_le_ih(ih))\n\t\treiserfs_panic(inode->i_sb, \"vs-13065\", \"key %k, found item %h\",\n\t\t\t       INODE_PKEY(inode), ih);\n\n\t/* path points to old stat data */\n\tif (stat_data_v1(ih)) {\n\t\tinode2sd_v1(ih_item_body(bh, ih), inode, size);\n\t} else {\n\t\tinode2sd(ih_item_body(bh, ih), inode, size);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "inode2sd_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1397-1418",
    "snippet": "static void inode2sd_v1(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data_v1 *sd_v1 = (struct stat_data_v1 *)sd;\n\n\tset_sd_v1_mode(sd_v1, inode->i_mode);\n\tset_sd_v1_uid(sd_v1, i_uid_read(inode));\n\tset_sd_v1_gid(sd_v1, i_gid_read(inode));\n\tset_sd_v1_nlink(sd_v1, inode->i_nlink);\n\tset_sd_v1_size(sd_v1, size);\n\tset_sd_v1_atime(sd_v1, inode->i_atime.tv_sec);\n\tset_sd_v1_ctime(sd_v1, inode->i_ctime.tv_sec);\n\tset_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v1_blocks(sd_v1, to_fake_used_blocks(inode, SD_V1_SIZE));\n\n\t/* Sigh. i_first_direct_byte is back */\n\tset_sd_v1_first_direct_byte(sd_v1,\n\t\t\t\t    REISERFS_I(inode)->i_first_direct_byte);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_sd_v1_first_direct_byte",
          "args": [
            "sd_v1",
            "REISERFS_I(inode)->i_first_direct_byte"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sd_v1_blocks",
          "args": [
            "sd_v1",
            "to_fake_used_blocks(inode, SD_V1_SIZE)"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_fake_used_blocks",
          "args": [
            "inode",
            "SD_V1_SIZE"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "to_fake_used_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1209-1227",
          "snippet": "static inline ulong to_fake_used_blocks(struct inode *inode, int sd_size)\n{\n\tloff_t bytes = inode_get_bytes(inode);\n\tloff_t real_space = real_space_diff(inode, sd_size);\n\n\t/* keeps fsck and non-quota versions of reiserfs happy */\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\tbytes += (loff_t) 511;\n\t}\n\n\t/*\n\t * files from before the quota patch might i_blocks such that\n\t * bytes < real_space.  Deal with that here to prevent it from\n\t * going negative.\n\t */\n\tif (bytes < real_space)\n\t\treturn 0;\n\treturn (bytes - real_space) >> 9;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic inline ulong to_fake_used_blocks(struct inode *inode, int sd_size)\n{\n\tloff_t bytes = inode_get_bytes(inode);\n\tloff_t real_space = real_space_diff(inode, sd_size);\n\n\t/* keeps fsck and non-quota versions of reiserfs happy */\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\tbytes += (loff_t) 511;\n\t}\n\n\t/*\n\t * files from before the quota patch might i_blocks such that\n\t * bytes < real_space.  Deal with that here to prevent it from\n\t * going negative.\n\t */\n\tif (bytes < real_space)\n\t\treturn 0;\n\treturn (bytes - real_space) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sd_v1_rdev",
          "args": [
            "sd_v1",
            "new_encode_dev(inode->i_rdev)"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v1_mtime",
          "args": [
            "sd_v1",
            "inode->i_mtime.tv_sec"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v1_ctime",
          "args": [
            "sd_v1",
            "inode->i_ctime.tv_sec"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v1_atime",
          "args": [
            "sd_v1",
            "inode->i_atime.tv_sec"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v1_size",
          "args": [
            "sd_v1",
            "size"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v1_nlink",
          "args": [
            "sd_v1",
            "inode->i_nlink"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v1_gid",
          "args": [
            "sd_v1",
            "i_gid_read(inode)"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v1_uid",
          "args": [
            "sd_v1",
            "i_uid_read(inode)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v1_mode",
          "args": [
            "sd_v1",
            "inode->i_mode"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void inode2sd_v1(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data_v1 *sd_v1 = (struct stat_data_v1 *)sd;\n\n\tset_sd_v1_mode(sd_v1, inode->i_mode);\n\tset_sd_v1_uid(sd_v1, i_uid_read(inode));\n\tset_sd_v1_gid(sd_v1, i_gid_read(inode));\n\tset_sd_v1_nlink(sd_v1, inode->i_nlink);\n\tset_sd_v1_size(sd_v1, size);\n\tset_sd_v1_atime(sd_v1, inode->i_atime.tv_sec);\n\tset_sd_v1_ctime(sd_v1, inode->i_ctime.tv_sec);\n\tset_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v1_blocks(sd_v1, to_fake_used_blocks(inode, SD_V1_SIZE));\n\n\t/* Sigh. i_first_direct_byte is back */\n\tset_sd_v1_first_direct_byte(sd_v1,\n\t\t\t\t    REISERFS_I(inode)->i_first_direct_byte);\n}"
  },
  {
    "function_name": "inode2sd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1373-1394",
    "snippet": "static void inode2sd(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data *sd_v2 = (struct stat_data *)sd;\n\t__u16 flags;\n\n\tset_sd_v2_mode(sd_v2, inode->i_mode);\n\tset_sd_v2_nlink(sd_v2, inode->i_nlink);\n\tset_sd_v2_uid(sd_v2, i_uid_read(inode));\n\tset_sd_v2_size(sd_v2, size);\n\tset_sd_v2_gid(sd_v2, i_gid_read(inode));\n\tset_sd_v2_mtime(sd_v2, inode->i_mtime.tv_sec);\n\tset_sd_v2_atime(sd_v2, inode->i_atime.tv_sec);\n\tset_sd_v2_ctime(sd_v2, inode->i_ctime.tv_sec);\n\tset_sd_v2_blocks(sd_v2, to_fake_used_blocks(inode, SD_V2_SIZE));\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v2_rdev(sd_v2, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v2_generation(sd_v2, inode->i_generation);\n\tflags = REISERFS_I(inode)->i_attrs;\n\ti_attrs_to_sd_attrs(inode, &flags);\n\tset_sd_v2_attrs(sd_v2, flags);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_sd_v2_attrs",
          "args": [
            "sd_v2",
            "flags"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_attrs_to_sd_attrs",
          "args": [
            "inode",
            "&flags"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "i_attrs_to_sd_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "3096-3116",
          "snippet": "void i_attrs_to_sd_attrs(struct inode *inode, __u16 * sd_attrs)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (inode->i_flags & S_IMMUTABLE)\n\t\t\t*sd_attrs |= REISERFS_IMMUTABLE_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_IMMUTABLE_FL;\n\t\tif (inode->i_flags & S_SYNC)\n\t\t\t*sd_attrs |= REISERFS_SYNC_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_SYNC_FL;\n\t\tif (inode->i_flags & S_NOATIME)\n\t\t\t*sd_attrs |= REISERFS_NOATIME_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOATIME_FL;\n\t\tif (REISERFS_I(inode)->i_flags & i_nopack_mask)\n\t\t\t*sd_attrs |= REISERFS_NOTAIL_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOTAIL_FL;\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid i_attrs_to_sd_attrs(struct inode *inode, __u16 * sd_attrs)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (inode->i_flags & S_IMMUTABLE)\n\t\t\t*sd_attrs |= REISERFS_IMMUTABLE_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_IMMUTABLE_FL;\n\t\tif (inode->i_flags & S_SYNC)\n\t\t\t*sd_attrs |= REISERFS_SYNC_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_SYNC_FL;\n\t\tif (inode->i_flags & S_NOATIME)\n\t\t\t*sd_attrs |= REISERFS_NOATIME_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOATIME_FL;\n\t\tif (REISERFS_I(inode)->i_flags & i_nopack_mask)\n\t\t\t*sd_attrs |= REISERFS_NOTAIL_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOTAIL_FL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sd_v2_generation",
          "args": [
            "sd_v2",
            "inode->i_generation"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_rdev",
          "args": [
            "sd_v2",
            "new_encode_dev(inode->i_rdev)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_blocks",
          "args": [
            "sd_v2",
            "to_fake_used_blocks(inode, SD_V2_SIZE)"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_fake_used_blocks",
          "args": [
            "inode",
            "SD_V2_SIZE"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "to_fake_used_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1209-1227",
          "snippet": "static inline ulong to_fake_used_blocks(struct inode *inode, int sd_size)\n{\n\tloff_t bytes = inode_get_bytes(inode);\n\tloff_t real_space = real_space_diff(inode, sd_size);\n\n\t/* keeps fsck and non-quota versions of reiserfs happy */\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\tbytes += (loff_t) 511;\n\t}\n\n\t/*\n\t * files from before the quota patch might i_blocks such that\n\t * bytes < real_space.  Deal with that here to prevent it from\n\t * going negative.\n\t */\n\tif (bytes < real_space)\n\t\treturn 0;\n\treturn (bytes - real_space) >> 9;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic inline ulong to_fake_used_blocks(struct inode *inode, int sd_size)\n{\n\tloff_t bytes = inode_get_bytes(inode);\n\tloff_t real_space = real_space_diff(inode, sd_size);\n\n\t/* keeps fsck and non-quota versions of reiserfs happy */\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\tbytes += (loff_t) 511;\n\t}\n\n\t/*\n\t * files from before the quota patch might i_blocks such that\n\t * bytes < real_space.  Deal with that here to prevent it from\n\t * going negative.\n\t */\n\tif (bytes < real_space)\n\t\treturn 0;\n\treturn (bytes - real_space) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sd_v2_ctime",
          "args": [
            "sd_v2",
            "inode->i_ctime.tv_sec"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_atime",
          "args": [
            "sd_v2",
            "inode->i_atime.tv_sec"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_mtime",
          "args": [
            "sd_v2",
            "inode->i_mtime.tv_sec"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_gid",
          "args": [
            "sd_v2",
            "i_gid_read(inode)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_size",
          "args": [
            "sd_v2",
            "size"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_uid",
          "args": [
            "sd_v2",
            "i_uid_read(inode)"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_nlink",
          "args": [
            "sd_v2",
            "inode->i_nlink"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sd_v2_mode",
          "args": [
            "sd_v2",
            "inode->i_mode"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void inode2sd(void *sd, struct inode *inode, loff_t size)\n{\n\tstruct stat_data *sd_v2 = (struct stat_data *)sd;\n\t__u16 flags;\n\n\tset_sd_v2_mode(sd_v2, inode->i_mode);\n\tset_sd_v2_nlink(sd_v2, inode->i_nlink);\n\tset_sd_v2_uid(sd_v2, i_uid_read(inode));\n\tset_sd_v2_size(sd_v2, size);\n\tset_sd_v2_gid(sd_v2, i_gid_read(inode));\n\tset_sd_v2_mtime(sd_v2, inode->i_mtime.tv_sec);\n\tset_sd_v2_atime(sd_v2, inode->i_atime.tv_sec);\n\tset_sd_v2_ctime(sd_v2, inode->i_ctime.tv_sec);\n\tset_sd_v2_blocks(sd_v2, to_fake_used_blocks(inode, SD_V2_SIZE));\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tset_sd_v2_rdev(sd_v2, new_encode_dev(inode->i_rdev));\n\telse\n\t\tset_sd_v2_generation(sd_v2, inode->i_generation);\n\tflags = REISERFS_I(inode)->i_attrs;\n\ti_attrs_to_sd_attrs(inode, &flags);\n\tset_sd_v2_attrs(sd_v2, flags);\n}"
  },
  {
    "function_name": "init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1237-1370",
    "snippet": "static void init_inode(struct inode *inode, struct treepath *path)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\t__u32 rdev;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tcopy_key(INODE_PKEY(inode), &ih->ih_key);\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\treiserfs_init_xattr_rwsem(inode);\n\n\tif (stat_data_v1(ih)) {\n\t\tstruct stat_data_v1 *sd =\n\t\t    (struct stat_data_v1 *)ih_item_body(bh, ih);\n\t\tunsigned long blocks;\n\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\t\tinode->i_mode = sd_v1_mode(sd);\n\t\tset_nlink(inode, sd_v1_nlink(sd));\n\t\ti_uid_write(inode, sd_v1_uid(sd));\n\t\ti_gid_write(inode, sd_v1_gid(sd));\n\t\tinode->i_size = sd_v1_size(sd);\n\t\tinode->i_atime.tv_sec = sd_v1_atime(sd);\n\t\tinode->i_mtime.tv_sec = sd_v1_mtime(sd);\n\t\tinode->i_ctime.tv_sec = sd_v1_ctime(sd);\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_ctime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\n\t\tinode->i_blocks = sd_v1_blocks(sd);\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\tblocks = (inode->i_size + 511) >> 9;\n\t\tblocks = _ROUND_UP(blocks, inode->i_sb->s_blocksize >> 9);\n\n\t\t/*\n\t\t * there was a bug in <=3.5.23 when i_blocks could take\n\t\t * negative values. Starting from 3.5.17 this value could\n\t\t * even be stored in stat data. For such files we set\n\t\t * i_blocks based on file size. Just 2 notes: this can be\n\t\t * wrong for sparse files. On-disk value will be only\n\t\t * updated if file's inode will ever change\n\t\t */\n\t\tif (inode->i_blocks > blocks) {\n\t\t\tinode->i_blocks = blocks;\n\t\t}\n\n\t\trdev = sd_v1_rdev(sd);\n\t\tREISERFS_I(inode)->i_first_direct_byte =\n\t\t    sd_v1_first_direct_byte(sd);\n\n\t\t/*\n\t\t * an early bug in the quota code can give us an odd\n\t\t * number for the block count.  This is incorrect, fix it here.\n\t\t */\n\t\tif (inode->i_blocks & 1) {\n\t\t\tinode->i_blocks++;\n\t\t}\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V1_SIZE));\n\t\t/*\n\t\t * nopack is initially zero for v1 objects. For v2 objects,\n\t\t * nopack is initialised from sd_attrs\n\t\t */\n\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t} else {\n\t\t/*\n\t\t * new stat data found, but object may have old items\n\t\t * (directories and symlinks)\n\t\t */\n\t\tstruct stat_data *sd = (struct stat_data *)ih_item_body(bh, ih);\n\n\t\tinode->i_mode = sd_v2_mode(sd);\n\t\tset_nlink(inode, sd_v2_nlink(sd));\n\t\ti_uid_write(inode, sd_v2_uid(sd));\n\t\tinode->i_size = sd_v2_size(sd);\n\t\ti_gid_write(inode, sd_v2_gid(sd));\n\t\tinode->i_mtime.tv_sec = sd_v2_mtime(sd);\n\t\tinode->i_atime.tv_sec = sd_v2_atime(sd);\n\t\tinode->i_ctime.tv_sec = sd_v2_ctime(sd);\n\t\tinode->i_ctime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_blocks = sd_v2_blocks(sd);\n\t\trdev = sd_v2_rdev(sd);\n\t\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\t\tinode->i_generation =\n\t\t\t    le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\telse\n\t\t\tinode->i_generation = sd_v2_generation(sd);\n\n\t\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\telse\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\t\tREISERFS_I(inode)->i_first_direct_byte = 0;\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V2_SIZE));\n\t\t/*\n\t\t * read persistent inode attributes from sd and initialise\n\t\t * generic inode flags from them\n\t\t */\n\t\tREISERFS_I(inode)->i_attrs = sd_v2_attrs(sd);\n\t\tsd_attrs_to_i_attrs(sd_v2_attrs(sd), inode);\n\t}\n\n\tpathrelse(path);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_file_inode_operations;\n\t\tinode->i_fop = &reiserfs_file_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_dir_inode_operations;\n\t\tinode->i_fop = &reiserfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_op = &reiserfs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations reiserfs_address_space_operations = {\n\t.writepage = reiserfs_writepage,\n\t.readpage = reiserfs_readpage,\n\t.readpages = reiserfs_readpages,\n\t.releasepage = reiserfs_releasepage,\n\t.invalidatepage = reiserfs_invalidatepage,\n\t.write_begin = reiserfs_write_begin,\n\t.write_end = reiserfs_write_end,\n\t.bmap = reiserfs_aop_bmap,\n\t.direct_IO = reiserfs_direct_IO,\n\t.set_page_dirty = reiserfs_set_page_dirty,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "new_decode_dev(rdev)"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "rdev"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "path"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_attrs_to_i_attrs",
          "args": [
            "sd_v2_attrs(sd)",
            "inode"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "sd_attrs_to_i_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "3070-3094",
          "snippet": "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_v2_attrs",
          "args": [
            "sd"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_attrs",
          "args": [
            "sd"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_set_bytes",
          "args": [
            "inode",
            "to_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V2_SIZE)"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "503-509",
          "snippet": "void inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_real_used_space",
          "args": [
            "inode",
            "inode->i_blocks",
            "SD_V2_SIZE"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "to_real_used_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1197-1206",
          "snippet": "static inline loff_t to_real_used_space(struct inode *inode, ulong blocks,\n\t\t\t\t\tint sd_size)\n{\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\treturn inode->i_size +\n\t\t    (loff_t) (real_space_diff(inode, sd_size));\n\t}\n\treturn ((loff_t) real_space_diff(inode, sd_size)) +\n\t    (((loff_t) blocks) << 9);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline loff_t to_real_used_space(struct inode *inode, ulong blocks,\n\t\t\t\t\tint sd_size)\n{\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\treturn inode->i_size +\n\t\t    (loff_t) (real_space_diff(inode, sd_size));\n\t}\n\treturn ((loff_t) real_space_diff(inode, sd_size)) +\n\t    (((loff_t) blocks) << 9);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_sd_version",
          "args": [
            "inode",
            "STAT_DATA_V2"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_item_key_version",
          "args": [
            "inode",
            "KEY_FORMAT_3_6"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_item_key_version",
          "args": [
            "inode",
            "KEY_FORMAT_3_5"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_generation",
          "args": [
            "sd"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(inode)->k_dir_id"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_rdev",
          "args": [
            "sd"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_blocks",
          "args": [
            "sd"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_ctime",
          "args": [
            "sd"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_atime",
          "args": [
            "sd"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_mtime",
          "args": [
            "sd"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "sd_v2_gid(sd)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_gid",
          "args": [
            "sd"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_size",
          "args": [
            "sd"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "sd_v2_uid(sd)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_uid",
          "args": [
            "sd"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "sd_v2_nlink(sd)"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_v2_nlink",
          "args": [
            "sd"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v2_mode",
          "args": [
            "sd"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "bh",
            "ih"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_v1_first_direct_byte",
          "args": [
            "sd"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_rdev",
          "args": [
            "sd"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ROUND_UP",
          "args": [
            "blocks",
            "inode->i_sb->s_blocksize >> 9"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_blocks",
          "args": [
            "sd"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_ctime",
          "args": [
            "sd"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_mtime",
          "args": [
            "sd"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_atime",
          "args": [
            "sd"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_size",
          "args": [
            "sd"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "sd_v1_gid(sd)"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_gid",
          "args": [
            "sd"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "sd_v1_uid(sd)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_uid",
          "args": [
            "sd"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_nlink",
          "args": [
            "sd"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_v1_mode",
          "args": [
            "sd"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_sd_version",
          "args": [
            "inode",
            "STAT_DATA_V1"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_item_key_version",
          "args": [
            "inode",
            "KEY_FORMAT_3_5"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat_data_v1",
          "args": [
            "ih"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_init_xattr_rwsem",
          "args": [
            "inode"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_init_xattr_rwsem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "100-102",
          "snippet": "static inline void reiserfs_init_xattr_rwsem(struct inode *inode)\n{\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline void reiserfs_init_xattr_rwsem(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&REISERFS_I(inode)->i_prealloc_list"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_key",
          "args": [
            "INODE_PKEY(inode)",
            "&ih->ih_key"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "copy_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2993-2997",
          "snippet": "static inline void copy_key(struct reiserfs_key *to,\n\t\t\t    const struct reiserfs_key *from)\n{\n\tmemcpy(to, from, KEY_SIZE);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_SIZE (sizeof(struct reiserfs_key))"
          ],
          "globals_used": [
            "int reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to);",
            "extern void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from);",
            "extern void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_SIZE (sizeof(struct reiserfs_key))\n\nint reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to);\nextern void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from);\nextern void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\n\nstatic inline void copy_key(struct reiserfs_key *to,\n\t\t\t    const struct reiserfs_key *from)\n{\n\tmemcpy(to, from, KEY_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "path"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nconst struct address_space_operations reiserfs_address_space_operations = {\n\t.writepage = reiserfs_writepage,\n\t.readpage = reiserfs_readpage,\n\t.readpages = reiserfs_readpages,\n\t.releasepage = reiserfs_releasepage,\n\t.invalidatepage = reiserfs_invalidatepage,\n\t.write_begin = reiserfs_write_begin,\n\t.write_end = reiserfs_write_end,\n\t.bmap = reiserfs_aop_bmap,\n\t.direct_IO = reiserfs_direct_IO,\n\t.set_page_dirty = reiserfs_set_page_dirty,\n};\n\nstatic void init_inode(struct inode *inode, struct treepath *path)\n{\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\t__u32 rdev;\n\n\tbh = PATH_PLAST_BUFFER(path);\n\tih = tp_item_head(path);\n\n\tcopy_key(INODE_PKEY(inode), &ih->ih_key);\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\treiserfs_init_xattr_rwsem(inode);\n\n\tif (stat_data_v1(ih)) {\n\t\tstruct stat_data_v1 *sd =\n\t\t    (struct stat_data_v1 *)ih_item_body(bh, ih);\n\t\tunsigned long blocks;\n\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\t\tinode->i_mode = sd_v1_mode(sd);\n\t\tset_nlink(inode, sd_v1_nlink(sd));\n\t\ti_uid_write(inode, sd_v1_uid(sd));\n\t\ti_gid_write(inode, sd_v1_gid(sd));\n\t\tinode->i_size = sd_v1_size(sd);\n\t\tinode->i_atime.tv_sec = sd_v1_atime(sd);\n\t\tinode->i_mtime.tv_sec = sd_v1_mtime(sd);\n\t\tinode->i_ctime.tv_sec = sd_v1_ctime(sd);\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_ctime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\n\t\tinode->i_blocks = sd_v1_blocks(sd);\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\tblocks = (inode->i_size + 511) >> 9;\n\t\tblocks = _ROUND_UP(blocks, inode->i_sb->s_blocksize >> 9);\n\n\t\t/*\n\t\t * there was a bug in <=3.5.23 when i_blocks could take\n\t\t * negative values. Starting from 3.5.17 this value could\n\t\t * even be stored in stat data. For such files we set\n\t\t * i_blocks based on file size. Just 2 notes: this can be\n\t\t * wrong for sparse files. On-disk value will be only\n\t\t * updated if file's inode will ever change\n\t\t */\n\t\tif (inode->i_blocks > blocks) {\n\t\t\tinode->i_blocks = blocks;\n\t\t}\n\n\t\trdev = sd_v1_rdev(sd);\n\t\tREISERFS_I(inode)->i_first_direct_byte =\n\t\t    sd_v1_first_direct_byte(sd);\n\n\t\t/*\n\t\t * an early bug in the quota code can give us an odd\n\t\t * number for the block count.  This is incorrect, fix it here.\n\t\t */\n\t\tif (inode->i_blocks & 1) {\n\t\t\tinode->i_blocks++;\n\t\t}\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V1_SIZE));\n\t\t/*\n\t\t * nopack is initially zero for v1 objects. For v2 objects,\n\t\t * nopack is initialised from sd_attrs\n\t\t */\n\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t} else {\n\t\t/*\n\t\t * new stat data found, but object may have old items\n\t\t * (directories and symlinks)\n\t\t */\n\t\tstruct stat_data *sd = (struct stat_data *)ih_item_body(bh, ih);\n\n\t\tinode->i_mode = sd_v2_mode(sd);\n\t\tset_nlink(inode, sd_v2_nlink(sd));\n\t\ti_uid_write(inode, sd_v2_uid(sd));\n\t\tinode->i_size = sd_v2_size(sd);\n\t\ti_gid_write(inode, sd_v2_gid(sd));\n\t\tinode->i_mtime.tv_sec = sd_v2_mtime(sd);\n\t\tinode->i_atime.tv_sec = sd_v2_atime(sd);\n\t\tinode->i_ctime.tv_sec = sd_v2_ctime(sd);\n\t\tinode->i_ctime.tv_nsec = 0;\n\t\tinode->i_mtime.tv_nsec = 0;\n\t\tinode->i_atime.tv_nsec = 0;\n\t\tinode->i_blocks = sd_v2_blocks(sd);\n\t\trdev = sd_v2_rdev(sd);\n\t\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\t\tinode->i_generation =\n\t\t\t    le32_to_cpu(INODE_PKEY(inode)->k_dir_id);\n\t\telse\n\t\t\tinode->i_generation = sd_v2_generation(sd);\n\n\t\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\t\telse\n\t\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\t\tREISERFS_I(inode)->i_first_direct_byte = 0;\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\t\tinode_set_bytes(inode,\n\t\t\t\tto_real_used_space(inode, inode->i_blocks,\n\t\t\t\t\t\t   SD_V2_SIZE));\n\t\t/*\n\t\t * read persistent inode attributes from sd and initialise\n\t\t * generic inode flags from them\n\t\t */\n\t\tREISERFS_I(inode)->i_attrs = sd_v2_attrs(sd);\n\t\tsd_attrs_to_i_attrs(sd_v2_attrs(sd), inode);\n\t}\n\n\tpathrelse(path);\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_file_inode_operations;\n\t\tinode->i_fop = &reiserfs_file_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_dir_inode_operations;\n\t\tinode->i_fop = &reiserfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &reiserfs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\t} else {\n\t\tinode->i_blocks = 0;\n\t\tinode->i_op = &reiserfs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\t}\n}"
  },
  {
    "function_name": "to_fake_used_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1209-1227",
    "snippet": "static inline ulong to_fake_used_blocks(struct inode *inode, int sd_size)\n{\n\tloff_t bytes = inode_get_bytes(inode);\n\tloff_t real_space = real_space_diff(inode, sd_size);\n\n\t/* keeps fsck and non-quota versions of reiserfs happy */\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\tbytes += (loff_t) 511;\n\t}\n\n\t/*\n\t * files from before the quota patch might i_blocks such that\n\t * bytes < real_space.  Deal with that here to prevent it from\n\t * going negative.\n\t */\n\tif (bytes < real_space)\n\t\treturn 0;\n\treturn (bytes - real_space) >> 9;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_space_diff",
          "args": [
            "inode",
            "sd_size"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "real_space_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1173-1195",
          "snippet": "static int real_space_diff(struct inode *inode, int sd_size)\n{\n\tint bytes;\n\tloff_t blocksize = inode->i_sb->s_blocksize;\n\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\treturn sd_size;\n\n\t/*\n\t * End of file is also in full block with indirect reference, so round\n\t * up to the next block.\n\t *\n\t * there is just no way to know if the tail is actually packed\n\t * on the file, so we have to assume it isn't.  When we pack the\n\t * tail, we add 4 bytes to pretend there really is an unformatted\n\t * node pointer\n\t */\n\tbytes =\n\t    ((inode->i_size +\n\t      (blocksize - 1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE +\n\t    sd_size;\n\treturn bytes;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int real_space_diff(struct inode *inode, int sd_size)\n{\n\tint bytes;\n\tloff_t blocksize = inode->i_sb->s_blocksize;\n\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\treturn sd_size;\n\n\t/*\n\t * End of file is also in full block with indirect reference, so round\n\t * up to the next block.\n\t *\n\t * there is just no way to know if the tail is actually packed\n\t * on the file, so we have to assume it isn't.  When we pack the\n\t * tail, we add 4 bytes to pretend there really is an unformatted\n\t * node pointer\n\t */\n\tbytes =\n\t    ((inode->i_size +\n\t      (blocksize - 1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE +\n\t    sd_size;\n\treturn bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_get_bytes",
          "args": [
            "inode"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "inode_get_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "491-499",
          "snippet": "loff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nloff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic inline ulong to_fake_used_blocks(struct inode *inode, int sd_size)\n{\n\tloff_t bytes = inode_get_bytes(inode);\n\tloff_t real_space = real_space_diff(inode, sd_size);\n\n\t/* keeps fsck and non-quota versions of reiserfs happy */\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\tbytes += (loff_t) 511;\n\t}\n\n\t/*\n\t * files from before the quota patch might i_blocks such that\n\t * bytes < real_space.  Deal with that here to prevent it from\n\t * going negative.\n\t */\n\tif (bytes < real_space)\n\t\treturn 0;\n\treturn (bytes - real_space) >> 9;\n}"
  },
  {
    "function_name": "to_real_used_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1197-1206",
    "snippet": "static inline loff_t to_real_used_space(struct inode *inode, ulong blocks,\n\t\t\t\t\tint sd_size)\n{\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\treturn inode->i_size +\n\t\t    (loff_t) (real_space_diff(inode, sd_size));\n\t}\n\treturn ((loff_t) real_space_diff(inode, sd_size)) +\n\t    (((loff_t) blocks) << 9);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "real_space_diff",
          "args": [
            "inode",
            "sd_size"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "real_space_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1173-1195",
          "snippet": "static int real_space_diff(struct inode *inode, int sd_size)\n{\n\tint bytes;\n\tloff_t blocksize = inode->i_sb->s_blocksize;\n\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\treturn sd_size;\n\n\t/*\n\t * End of file is also in full block with indirect reference, so round\n\t * up to the next block.\n\t *\n\t * there is just no way to know if the tail is actually packed\n\t * on the file, so we have to assume it isn't.  When we pack the\n\t * tail, we add 4 bytes to pretend there really is an unformatted\n\t * node pointer\n\t */\n\tbytes =\n\t    ((inode->i_size +\n\t      (blocksize - 1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE +\n\t    sd_size;\n\treturn bytes;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int real_space_diff(struct inode *inode, int sd_size)\n{\n\tint bytes;\n\tloff_t blocksize = inode->i_sb->s_blocksize;\n\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\treturn sd_size;\n\n\t/*\n\t * End of file is also in full block with indirect reference, so round\n\t * up to the next block.\n\t *\n\t * there is just no way to know if the tail is actually packed\n\t * on the file, so we have to assume it isn't.  When we pack the\n\t * tail, we add 4 bytes to pretend there really is an unformatted\n\t * node pointer\n\t */\n\tbytes =\n\t    ((inode->i_size +\n\t      (blocksize - 1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE +\n\t    sd_size;\n\treturn bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "real_space_diff(inode, sd_size)"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline loff_t to_real_used_space(struct inode *inode, ulong blocks,\n\t\t\t\t\tint sd_size)\n{\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {\n\t\treturn inode->i_size +\n\t\t    (loff_t) (real_space_diff(inode, sd_size));\n\t}\n\treturn ((loff_t) real_space_diff(inode, sd_size)) +\n\t    (((loff_t) blocks) << 9);\n}"
  },
  {
    "function_name": "real_space_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1173-1195",
    "snippet": "static int real_space_diff(struct inode *inode, int sd_size)\n{\n\tint bytes;\n\tloff_t blocksize = inode->i_sb->s_blocksize;\n\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\treturn sd_size;\n\n\t/*\n\t * End of file is also in full block with indirect reference, so round\n\t * up to the next block.\n\t *\n\t * there is just no way to know if the tail is actually packed\n\t * on the file, so we have to assume it isn't.  When we pack the\n\t * tail, we add 4 bytes to pretend there really is an unformatted\n\t * node pointer\n\t */\n\tbytes =\n\t    ((inode->i_size +\n\t      (blocksize - 1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE +\n\t    sd_size;\n\treturn bytes;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int real_space_diff(struct inode *inode, int sd_size)\n{\n\tint bytes;\n\tloff_t blocksize = inode->i_sb->s_blocksize;\n\n\tif (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\treturn sd_size;\n\n\t/*\n\t * End of file is also in full block with indirect reference, so round\n\t * up to the next block.\n\t *\n\t * there is just no way to know if the tail is actually packed\n\t * on the file, so we have to assume it isn't.  When we pack the\n\t * tail, we add 4 bytes to pretend there really is an unformatted\n\t * node pointer\n\t */\n\tbytes =\n\t    ((inode->i_size +\n\t      (blocksize - 1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE +\n\t    sd_size;\n\treturn bytes;\n}"
  },
  {
    "function_name": "reiserfs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "1161-1166",
    "snippet": "static int\nreiserfs_readpages(struct file *file, struct address_space *mapping,\n\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, reiserfs_get_block);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "reiserfs_get_block"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int\nreiserfs_readpages(struct file *file, struct address_space *mapping,\n\t\t   struct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, reiserfs_get_block);\n}"
  },
  {
    "function_name": "reiserfs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "656-1159",
    "snippet": "int reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&path"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_end_persistent_transaction",
          "args": [
            "th"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_end_persistent_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3174-3187",
          "snippet": "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "inode"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_body",
          "args": [
            "&path"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2230-2233",
          "snippet": "static inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "&path"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "&path"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_free_block",
          "args": [
            "th",
            "inode",
            "allocated_block_nr",
            "1"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "467-488",
          "snippet": "void reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"vs-825\"",
            "\"%K should not be found\"",
            "&key"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_for_position_by_key",
          "args": [
            "inode->i_sb",
            "&key",
            "&path"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "search_for_position_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "830-903",
          "snippet": "int search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_cond_resched",
          "args": [
            "inode->i_sb"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "843-852",
          "snippet": "static inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "restart_transaction",
          "args": [
            "th",
            "inode",
            "&path"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "restart_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "251-274",
          "snippet": "static int restart_transaction(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode, struct treepath *path)\n{\n\tstruct super_block *s = th->t_super;\n\tint err;\n\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_refcount);\n\n\tpathrelse(path);\n\n\t/* we cannot restart while nested */\n\tif (th->t_refcount > 1) {\n\t\treturn 0;\n\t}\n\treiserfs_update_sd(th, inode);\n\terr = journal_end(th);\n\tif (!err) {\n\t\terr = journal_begin(th, s, JOURNAL_PER_BALANCE_CNT * 6);\n\t\tif (!err)\n\t\t\treiserfs_update_inode_transaction(inode);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int restart_transaction(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode, struct treepath *path)\n{\n\tstruct super_block *s = th->t_super;\n\tint err;\n\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_refcount);\n\n\tpathrelse(path);\n\n\t/* we cannot restart while nested */\n\tif (th->t_refcount > 1) {\n\t\treturn 0;\n\t}\n\treiserfs_update_sd(th, inode);\n\terr = journal_end(th);\n\tif (!err) {\n\t\terr = journal_begin(th, s, JOURNAL_PER_BALANCE_CNT * 6);\n\t\tif (!err)\n\t\t\treiserfs_update_inode_transaction(inode);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_transaction_should_end",
          "args": [
            "th",
            "th->t_blocks_allocated"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "journal_transaction_should_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2911-2931",
          "snippet": "int journal_transaction_should_end(struct reiserfs_transaction_handle *th,\n\t\t\t\t   int new_alloc)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\ttime_t now = get_seconds();\n\t/* cannot restart while nested */\n\tBUG_ON(!th->t_trans_id);\n\tif (th->t_refcount > 1)\n\t\treturn 0;\n\tif (journal->j_must_wait > 0 ||\n\t    (journal->j_len_alloc + new_alloc) >= journal->j_max_batch ||\n\t    atomic_read(&journal->j_jlock) ||\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age ||\n\t    journal->j_cnode_free < (journal->j_trans_max * 3)) {\n\t\treturn 1;\n\t}\n\n\tjournal->j_len_alloc += new_alloc;\n\tth->t_blocks_allocated += new_alloc ;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_transaction_should_end(struct reiserfs_transaction_handle *th,\n\t\t\t\t   int new_alloc)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\ttime_t now = get_seconds();\n\t/* cannot restart while nested */\n\tBUG_ON(!th->t_trans_id);\n\tif (th->t_refcount > 1)\n\t\treturn 0;\n\tif (journal->j_must_wait > 0 ||\n\t    (journal->j_len_alloc + new_alloc) >= journal->j_max_batch ||\n\t    atomic_read(&journal->j_jlock) ||\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age ||\n\t    journal->j_cnode_free < (journal->j_trans_max * 3)) {\n\t\treturn 1;\n\t}\n\n\tjournal->j_len_alloc += new_alloc;\n\tth->t_blocks_allocated += new_alloc ;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "un"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_paste_into_item",
          "args": [
            "th",
            "&path",
            "&tmp_key",
            "inode",
            "(char *)un",
            "UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_block_dev_mapped",
          "args": [
            "bh_result",
            "allocated_block_nr",
            "inode"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "set_block_dev_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "230-234",
          "snippet": "static inline void set_block_dev_mapped(struct buffer_head *bh,\n\t\t\t\t\tb_blocknr_t block, struct inode *inode)\n{\n\tmap_bh(bh, inode->i_sb, block);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void set_block_dev_mapped(struct buffer_head *bh,\n\t\t\t\t\tb_blocknr_t block, struct inode *inode)\n{\n\tmap_bh(bh, inode->i_sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "allocated_block_nr"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "min(blocks_needed, max_to_insert) * UNFM_P_SIZE",
            "GFP_NOFS"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "blocks_needed",
            "max_to_insert"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "minix_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "603-624",
          "snippet": "static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "&tmp_key"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key)",
            "\"green-805: invalid offset\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&tmp_key",
            "inode",
            "le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize)",
            "TYPE_INDIRECT",
            "3"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "op_bytes_number",
          "args": [
            "ih",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_key_k_offset",
          "args": [
            "version",
            "&ih->ih_key"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1473-1479",
          "snippet": "static inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_FORMAT_3_5 0"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_FORMAT_3_5 0\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_key_k_offset(int version,\n\t\t\t\t     const struct reiserfs_key *key)\n{\n\treturn (version == KEY_FORMAT_3_5) ?\n\t    le32_to_cpu(key->u.k_offset_v1.k_offset) :\n\t    offset_v2_k_offset(&(key->u.k_offset_v2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "pos_in_item != ih_item_len(ih) / UNFM_P_SIZE",
            "\"vs-804: invalid position for append\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_ITEM_LEN",
          "args": [
            "inode->i_sb->s_blocksize"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "unbh"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_add_tail_list",
          "args": [
            "inode",
            "unbh"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_tail_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "784-787",
          "snippet": "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 1);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "unbh"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_unmap_buffer",
          "args": [
            "unbh"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_unmap_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
          "lines": "166-191",
          "snippet": "void reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nvoid reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "direct2indirect",
          "args": [
            "th",
            "inode",
            "&path",
            "unbh",
            "tail_offset"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "direct2indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
          "lines": "24-163",
          "snippet": "int direct2indirect(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t    struct treepath *path, struct buffer_head *unbh,\n\t\t    loff_t tail_offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *up_to_date_bh;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tunsigned long total_tail = 0;\n\n\t/* Key to search for the last byte of the converted item. */\n\tstruct cpu_key end_key;\n\n\t/*\n\t * new indirect item to be inserted or key\n\t * of unfm pointer to be pasted\n\t */\n\tstruct item_head ind_ih;\n\tint blk_size;\n\t/* returned value for reiserfs_insert_item and clones */\n\tint  retval;\n\t/* Handle on an unformatted node that will be inserted in the tree. */\n\tunp_t unfm_ptr;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_direct2indirect++;\n\n\tblk_size = sb->s_blocksize;\n\n\t/*\n\t * and key to search for append or insert pointer to the new\n\t * unformatted node.\n\t */\n\tcopy_item_head(&ind_ih, p_le_ih);\n\tset_le_ih_k_offset(&ind_ih, tail_offset);\n\tset_le_ih_k_type(&ind_ih, TYPE_INDIRECT);\n\n\t/* Set the key to search for the place for new unfm pointer */\n\tmake_cpu_key(&end_key, inode, tail_offset, TYPE_INDIRECT, 4);\n\n\t/* FIXME: we could avoid this */\n\tif (search_for_position_by_key(sb, &end_key, path) == POSITION_FOUND) {\n\t\treiserfs_error(sb, \"PAP-14030\",\n\t\t\t       \"pasted or inserted byte exists in \"\n\t\t\t       \"the tree %K. Use fsck to repair.\", &end_key);\n\t\tpathrelse(path);\n\t\treturn -EIO;\n\t}\n\n\tp_le_ih = tp_item_head(path);\n\n\tunfm_ptr = cpu_to_le32(unbh->b_blocknr);\n\n\tif (is_statdata_le_ih(p_le_ih)) {\n\t\t/* Insert new indirect item. */\n\t\tset_ih_free_space(&ind_ih, 0);\t/* delete at nearest future */\n\t\tput_ih_item_len(&ind_ih, UNFM_P_SIZE);\n\t\tPATH_LAST_POSITION(path)++;\n\t\tretval =\n\t\t    reiserfs_insert_item(th, path, &end_key, &ind_ih, inode,\n\t\t\t\t\t (char *)&unfm_ptr);\n\t} else {\n\t\t/* Paste into last indirect item of an object. */\n\t\tretval = reiserfs_paste_into_item(th, path, &end_key, inode,\n\t\t\t\t\t\t    (char *)&unfm_ptr,\n\t\t\t\t\t\t    UNFM_P_SIZE);\n\t}\n\tif (retval) {\n\t\treturn retval;\n\t}\n\t/*\n\t * note: from here there are two keys which have matching first\n\t *  three key components. They only differ by the fourth one.\n\t */\n\n\t/* Set the key to search for the direct items of the file */\n\tmake_cpu_key(&end_key, inode, max_reiserfs_offset(inode), TYPE_DIRECT,\n\t\t     4);\n\n\t/*\n\t * Move bytes from the direct items to the new unformatted node\n\t * and delete them.\n\t */\n\twhile (1) {\n\t\tint tail_size;\n\n\t\t/*\n\t\t * end_key.k_offset is set so, that we will always have found\n\t\t * last item of the file\n\t\t */\n\t\tif (search_for_position_by_key(sb, &end_key, path) ==\n\t\t    POSITION_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-14050\",\n\t\t\t\t       \"direct item (%K) not found\", &end_key);\n\t\tp_le_ih = tp_item_head(path);\n\t\tRFALSE(!is_direct_le_ih(p_le_ih),\n\t\t       \"vs-14055: direct item expected(%K), found %h\",\n\t\t       &end_key, p_le_ih);\n\t\ttail_size = (le_ih_k_offset(p_le_ih) & (blk_size - 1))\n\t\t    + ih_item_len(p_le_ih) - 1;\n\n\t\t/*\n\t\t * we only send the unbh pointer if the buffer is not\n\t\t * up to date.  this avoids overwriting good data from\n\t\t * writepage() with old data from the disk or buffer cache\n\t\t * Special case: unbh->b_page will be NULL if we are coming\n\t\t * through DIRECT_IO handler here.\n\t\t */\n\t\tif (!unbh->b_page || buffer_uptodate(unbh)\n\t\t    || PageUptodate(unbh->b_page)) {\n\t\t\tup_to_date_bh = NULL;\n\t\t} else {\n\t\t\tup_to_date_bh = unbh;\n\t\t}\n\t\tretval = reiserfs_delete_item(th, path, &end_key, inode,\n\t\t\t\t\t\tup_to_date_bh);\n\n\t\ttotal_tail += retval;\n\n\t\t/* done: file does not have direct items anymore */\n\t\tif (tail_size == retval)\n\t\t\tbreak;\n\n\t}\n\t/*\n\t * if we've copied bytes from disk into the page, we need to zero\n\t * out the unused part of the block (it was not up to date before)\n\t */\n\tif (up_to_date_bh) {\n\t\tunsigned pgoff =\n\t\t    (tail_offset + total_tail - 1) & (PAGE_CACHE_SIZE - 1);\n\t\tchar *kaddr = kmap_atomic(up_to_date_bh->b_page);\n\t\tmemset(kaddr + pgoff, 0, blk_size - total_tail);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t    struct treepath *path, struct buffer_head *unbh,\n\t\t    loff_t tail_offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *up_to_date_bh;\n\tstruct item_head *p_le_ih = tp_item_head(path);\n\tunsigned long total_tail = 0;\n\n\t/* Key to search for the last byte of the converted item. */\n\tstruct cpu_key end_key;\n\n\t/*\n\t * new indirect item to be inserted or key\n\t * of unfm pointer to be pasted\n\t */\n\tstruct item_head ind_ih;\n\tint blk_size;\n\t/* returned value for reiserfs_insert_item and clones */\n\tint  retval;\n\t/* Handle on an unformatted node that will be inserted in the tree. */\n\tunp_t unfm_ptr;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tREISERFS_SB(sb)->s_direct2indirect++;\n\n\tblk_size = sb->s_blocksize;\n\n\t/*\n\t * and key to search for append or insert pointer to the new\n\t * unformatted node.\n\t */\n\tcopy_item_head(&ind_ih, p_le_ih);\n\tset_le_ih_k_offset(&ind_ih, tail_offset);\n\tset_le_ih_k_type(&ind_ih, TYPE_INDIRECT);\n\n\t/* Set the key to search for the place for new unfm pointer */\n\tmake_cpu_key(&end_key, inode, tail_offset, TYPE_INDIRECT, 4);\n\n\t/* FIXME: we could avoid this */\n\tif (search_for_position_by_key(sb, &end_key, path) == POSITION_FOUND) {\n\t\treiserfs_error(sb, \"PAP-14030\",\n\t\t\t       \"pasted or inserted byte exists in \"\n\t\t\t       \"the tree %K. Use fsck to repair.\", &end_key);\n\t\tpathrelse(path);\n\t\treturn -EIO;\n\t}\n\n\tp_le_ih = tp_item_head(path);\n\n\tunfm_ptr = cpu_to_le32(unbh->b_blocknr);\n\n\tif (is_statdata_le_ih(p_le_ih)) {\n\t\t/* Insert new indirect item. */\n\t\tset_ih_free_space(&ind_ih, 0);\t/* delete at nearest future */\n\t\tput_ih_item_len(&ind_ih, UNFM_P_SIZE);\n\t\tPATH_LAST_POSITION(path)++;\n\t\tretval =\n\t\t    reiserfs_insert_item(th, path, &end_key, &ind_ih, inode,\n\t\t\t\t\t (char *)&unfm_ptr);\n\t} else {\n\t\t/* Paste into last indirect item of an object. */\n\t\tretval = reiserfs_paste_into_item(th, path, &end_key, inode,\n\t\t\t\t\t\t    (char *)&unfm_ptr,\n\t\t\t\t\t\t    UNFM_P_SIZE);\n\t}\n\tif (retval) {\n\t\treturn retval;\n\t}\n\t/*\n\t * note: from here there are two keys which have matching first\n\t *  three key components. They only differ by the fourth one.\n\t */\n\n\t/* Set the key to search for the direct items of the file */\n\tmake_cpu_key(&end_key, inode, max_reiserfs_offset(inode), TYPE_DIRECT,\n\t\t     4);\n\n\t/*\n\t * Move bytes from the direct items to the new unformatted node\n\t * and delete them.\n\t */\n\twhile (1) {\n\t\tint tail_size;\n\n\t\t/*\n\t\t * end_key.k_offset is set so, that we will always have found\n\t\t * last item of the file\n\t\t */\n\t\tif (search_for_position_by_key(sb, &end_key, path) ==\n\t\t    POSITION_FOUND)\n\t\t\treiserfs_panic(sb, \"PAP-14050\",\n\t\t\t\t       \"direct item (%K) not found\", &end_key);\n\t\tp_le_ih = tp_item_head(path);\n\t\tRFALSE(!is_direct_le_ih(p_le_ih),\n\t\t       \"vs-14055: direct item expected(%K), found %h\",\n\t\t       &end_key, p_le_ih);\n\t\ttail_size = (le_ih_k_offset(p_le_ih) & (blk_size - 1))\n\t\t    + ih_item_len(p_le_ih) - 1;\n\n\t\t/*\n\t\t * we only send the unbh pointer if the buffer is not\n\t\t * up to date.  this avoids overwriting good data from\n\t\t * writepage() with old data from the disk or buffer cache\n\t\t * Special case: unbh->b_page will be NULL if we are coming\n\t\t * through DIRECT_IO handler here.\n\t\t */\n\t\tif (!unbh->b_page || buffer_uptodate(unbh)\n\t\t    || PageUptodate(unbh->b_page)) {\n\t\t\tup_to_date_bh = NULL;\n\t\t} else {\n\t\t\tup_to_date_bh = unbh;\n\t\t}\n\t\tretval = reiserfs_delete_item(th, path, &end_key, inode,\n\t\t\t\t\t\tup_to_date_bh);\n\n\t\ttotal_tail += retval;\n\n\t\t/* done: file does not have direct items anymore */\n\t\tif (tail_size == retval)\n\t\t\tbreak;\n\n\t}\n\t/*\n\t * if we've copied bytes from disk into the page, we need to zero\n\t * out the unused part of the block (it was not up to date before)\n\t */\n\tif (up_to_date_bh) {\n\t\tunsigned pgoff =\n\t\t    (tail_offset + total_tail - 1) & (PAGE_CACHE_SIZE - 1);\n\t\tchar *kaddr = kmap_atomic(up_to_date_bh->b_page);\n\t\tmemset(kaddr + pgoff, 0, blk_size - total_tail);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tREISERFS_I(inode)->i_first_direct_byte = U32_MAX;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_persistent_transaction",
          "args": [
            "inode->i_sb",
            "3"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_persistent_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3142-3172",
          "snippet": "struct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\n\t\t\t\t\t\t\t\t    super_block\n\t\t\t\t\t\t\t\t    *s,\n\t\t\t\t\t\t\t\t    int nblocks)\n{\n\tint ret;\n\tstruct reiserfs_transaction_handle *th;\n\n\t/*\n\t * if we're nesting into an existing transaction.  It will be\n\t * persistent on its own\n\t */\n\tif (reiserfs_transaction_running(s)) {\n\t\tth = current->journal_info;\n\t\tth->t_refcount++;\n\t\tBUG_ON(th->t_refcount < 2);\n\n\t\treturn th;\n\t}\n\tth = kmalloc(sizeof(struct reiserfs_transaction_handle), GFP_NOFS);\n\tif (!th)\n\t\treturn NULL;\n\tret = journal_begin(th, s, nblocks);\n\tif (ret) {\n\t\tkfree(th);\n\t\treturn NULL;\n\t}\n\n\tSB_JOURNAL(s)->j_persistent_trans++;\n\treturn th;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nstruct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\n\t\t\t\t\t\t\t\t    super_block\n\t\t\t\t\t\t\t\t    *s,\n\t\t\t\t\t\t\t\t    int nblocks)\n{\n\tint ret;\n\tstruct reiserfs_transaction_handle *th;\n\n\t/*\n\t * if we're nesting into an existing transaction.  It will be\n\t * persistent on its own\n\t */\n\tif (reiserfs_transaction_running(s)) {\n\t\tth = current->journal_info;\n\t\tth->t_refcount++;\n\t\tBUG_ON(th->t_refcount < 2);\n\n\t\treturn th;\n\t}\n\tth = kmalloc(sizeof(struct reiserfs_transaction_handle), GFP_NOFS);\n\tif (!th)\n\t\treturn NULL;\n\tret = journal_begin(th, s, nblocks);\n\tif (ret) {\n\t\tkfree(th);\n\t\treturn NULL;\n\t}\n\n\tSB_JOURNAL(s)->j_persistent_trans++;\n\treturn th;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"clm-6004\"",
            "\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\"",
            "inode->i_ino",
            "retval"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_tail_for_hole",
          "args": [
            "inode",
            "bh_result",
            "tail_offset"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "convert_tail_for_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "575-636",
          "snippet": "static int convert_tail_for_hole(struct inode *inode,\n\t\t\t\t struct buffer_head *bh_result,\n\t\t\t\t loff_t tail_offset)\n{\n\tunsigned long index;\n\tunsigned long tail_end;\n\tunsigned long tail_start;\n\tstruct page *tail_page;\n\tstruct page *hole_page = bh_result->b_page;\n\tint retval = 0;\n\n\tif ((tail_offset & (bh_result->b_size - 1)) != 1)\n\t\treturn -EIO;\n\n\t/* always try to read until the end of the block */\n\ttail_start = tail_offset & (PAGE_CACHE_SIZE - 1);\n\ttail_end = (tail_start | (bh_result->b_size - 1)) + 1;\n\n\tindex = tail_offset >> PAGE_CACHE_SHIFT;\n\t/*\n\t * hole_page can be zero in case of direct_io, we are sure\n\t * that we cannot get here if we write with O_DIRECT into tail page\n\t */\n\tif (!hole_page || index != hole_page->index) {\n\t\ttail_page = grab_cache_page(inode->i_mapping, index);\n\t\tretval = -ENOMEM;\n\t\tif (!tail_page) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ttail_page = hole_page;\n\t}\n\n\t/*\n\t * we don't have to make sure the conversion did not happen while\n\t * we were locking the page because anyone that could convert\n\t * must first take i_mutex.\n\t *\n\t * We must fix the tail page for writing because it might have buffers\n\t * that are mapped, but have a block number of 0.  This indicates tail\n\t * data that has been read directly into the page, and\n\t * __block_write_begin won't trigger a get_block in this case.\n\t */\n\tfix_tail_page_for_writing(tail_page);\n\tretval = __reiserfs_write_begin(tail_page, tail_start,\n\t\t\t\t      tail_end - tail_start);\n\tif (retval)\n\t\tgoto unlock;\n\n\t/* tail conversion might change the data in the page */\n\tflush_dcache_page(tail_page);\n\n\tretval = reiserfs_commit_write(NULL, tail_page, tail_start, tail_end);\n\nunlock:\n\tif (tail_page != hole_page) {\n\t\tunlock_page(tail_page);\n\t\tpage_cache_release(tail_page);\n\t}\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int convert_tail_for_hole(struct inode *inode,\n\t\t\t\t struct buffer_head *bh_result,\n\t\t\t\t loff_t tail_offset)\n{\n\tunsigned long index;\n\tunsigned long tail_end;\n\tunsigned long tail_start;\n\tstruct page *tail_page;\n\tstruct page *hole_page = bh_result->b_page;\n\tint retval = 0;\n\n\tif ((tail_offset & (bh_result->b_size - 1)) != 1)\n\t\treturn -EIO;\n\n\t/* always try to read until the end of the block */\n\ttail_start = tail_offset & (PAGE_CACHE_SIZE - 1);\n\ttail_end = (tail_start | (bh_result->b_size - 1)) + 1;\n\n\tindex = tail_offset >> PAGE_CACHE_SHIFT;\n\t/*\n\t * hole_page can be zero in case of direct_io, we are sure\n\t * that we cannot get here if we write with O_DIRECT into tail page\n\t */\n\tif (!hole_page || index != hole_page->index) {\n\t\ttail_page = grab_cache_page(inode->i_mapping, index);\n\t\tretval = -ENOMEM;\n\t\tif (!tail_page) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ttail_page = hole_page;\n\t}\n\n\t/*\n\t * we don't have to make sure the conversion did not happen while\n\t * we were locking the page because anyone that could convert\n\t * must first take i_mutex.\n\t *\n\t * We must fix the tail page for writing because it might have buffers\n\t * that are mapped, but have a block number of 0.  This indicates tail\n\t * data that has been read directly into the page, and\n\t * __block_write_begin won't trigger a get_block in this case.\n\t */\n\tfix_tail_page_for_writing(tail_page);\n\tretval = __reiserfs_write_begin(tail_page, tail_start,\n\t\t\t\t      tail_end - tail_start);\n\tif (retval)\n\t\tgoto unlock;\n\n\t/* tail conversion might change the data in the page */\n\tflush_dcache_page(tail_page);\n\n\tretval = reiserfs_commit_write(NULL, tail_page, tail_start, tail_end);\n\nunlock:\n\tif (tail_page != hole_page) {\n\t\tunlock_page(tail_page);\n\t\tpage_cache_release(tail_page);\n\t}\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_refcount"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "ih"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "ih"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_insert_item",
          "args": [
            "th",
            "&path",
            "&tmp_key",
            "&tmp_ih",
            "inode",
            "(char *)&unp"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "&path"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&tmp_key",
            "1"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "allocated_block_nr"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_le_item_head",
          "args": [
            "&tmp_ih",
            "&key",
            "version",
            "1",
            "TYPE_INDIRECT",
            "UNFM_P_SIZE",
            "0/* free_space */"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "make_le_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "136-156",
          "snippet": "inline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\ninline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_statdata_le_ih",
          "args": [
            "ih"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "is_statdata_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1577-1580",
          "snippet": "static inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_statdata_le_ih(struct item_head *ih)\n{\n\treturn is_statdata_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "bh"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_block_num",
          "args": [
            "item",
            "pos_in_item",
            "allocated_block_nr"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_add_ordered_list",
          "args": [
            "inode",
            "bh_result"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_ordered_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "788-791",
          "snippet": "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_data_ordered",
          "args": [
            "inode->i_sb"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "inode->i_sb",
            "bh"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&tmp_ih",
            "&path"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_changed",
          "args": [
            "fs_gen",
            "inode->i_sb"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "inode->i_sb",
            "bh",
            "1"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_block_num",
          "args": [
            "item",
            "pos_in_item"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indirect_item_found",
          "args": [
            "retval",
            "ih"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "indirect_item_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "225-228",
          "snippet": "static inline int indirect_item_found(int retval, struct item_head *ih)\n{\n\treturn (retval == POSITION_FOUND) && is_indirect_le_ih(ih);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int indirect_item_found(int retval, struct item_head *ih)\n{\n\treturn (retval == POSITION_FOUND) && is_indirect_le_ih(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&tmp_ih",
            "&path"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_changed",
          "args": [
            "fs_gen",
            "inode->i_sb"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_allocate_block",
          "args": [
            "th",
            "block",
            "inode",
            "&allocated_block_nr",
            "NULL",
            "create"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "_allocate_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "638-654",
          "snippet": "static inline int _allocate_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t  sector_t block,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  b_blocknr_t * allocated_block_nr,\n\t\t\t\t  struct treepath *path, int flags)\n{\n\tBUG_ON(!th->t_trans_id);\n\n#ifdef REISERFS_PREALLOCATE\n\tif (!(flags & GET_BLOCK_NO_IMUX)) {\n\t\treturn reiserfs_new_unf_blocknrs2(th, inode, allocated_block_nr,\n\t\t\t\t\t\t  path, block);\n\t}\n#endif\n\treturn reiserfs_new_unf_blocknrs(th, inode, allocated_block_nr, path,\n\t\t\t\t\t block);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int _allocate_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t  sector_t block,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  b_blocknr_t * allocated_block_nr,\n\t\t\t\t  struct treepath *path, int flags)\n{\n\tBUG_ON(!th->t_trans_id);\n\n#ifdef REISERFS_PREALLOCATE\n\tif (!(flags & GET_BLOCK_NO_IMUX)) {\n\t\treturn reiserfs_new_unf_blocknrs2(th, inode, allocated_block_nr,\n\t\t\t\t\t\t  path, block);\n\t}\n#endif\n\treturn reiserfs_new_unf_blocknrs(th, inode, allocated_block_nr, path,\n\t\t\t\t\t block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "inode->i_sb"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocation_needed",
          "args": [
            "retval",
            "allocated_block_nr",
            "ih",
            "item",
            "pos_in_item"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "allocation_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "213-223",
          "snippet": "static inline int allocation_needed(int retval, b_blocknr_t allocated,\n\t\t\t\t    struct item_head *ih,\n\t\t\t\t    __le32 * item, int pos_in_item)\n{\n\tif (allocated)\n\t\treturn 0;\n\tif (retval == POSITION_FOUND && is_indirect_le_ih(ih) &&\n\t    get_block_num(item, pos_in_item))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int allocation_needed(int retval, b_blocknr_t allocated,\n\t\t\t\t    struct item_head *ih,\n\t\t\t\t    __le32 * item, int pos_in_item)\n{\n\tif (allocated)\n\t\treturn 0;\n\tif (retval == POSITION_FOUND && is_indirect_le_ih(ih) &&\n\t    get_block_num(item, pos_in_item))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&tmp_ih",
            "ih"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_generation",
          "args": [
            "inode->i_sb"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "&path"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_block_size",
          "args": [
            "inode"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_small_tails",
          "args": [
            "inode->i_sb"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_block_size",
          "args": [
            "inode"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_large_tails",
          "args": [
            "inode->i_sb"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_transaction_running",
          "args": [
            "inode->i_sb"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_transaction_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2896-2904",
          "snippet": "static inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_get_block_create_0",
          "args": [
            "inode",
            "block",
            "bh_result",
            "create | GET_BLOCK_READ_DIRECT"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_block_create_0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "502-507",
          "snippet": "static int reiserfs_get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t\t       struct buffer_head *bh_result,\n\t\t\t\t       int create)\n{\n\treturn reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t\t       struct buffer_head *bh_result,\n\t\t\t\t       int create)\n{\n\treturn reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_capable",
          "args": [
            "inode",
            "block"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "file_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "240-249",
          "snippet": "static int file_capable(struct inode *inode, sector_t block)\n{\n\t/* it is new file. */\n\tif (get_inode_item_key_version(inode) != KEY_FORMAT_3_5 ||\n\t    /* old file, but 'block' is inside of 2gb */\n\t    block < (1 << (31 - inode->i_sb->s_blocksize_bits)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int file_capable(struct inode *inode, sector_t block)\n{\n\t/* it is new file. */\n\tif (get_inode_item_key_version(inode) != KEY_FORMAT_3_5 ||\n\t    /* old file, but 'block' is inside of 2gb */\n\t    block < (1 << (31 - inode->i_sb->s_blocksize_bits)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_item_key_version",
          "args": [
            "inode"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}"
  },
  {
    "function_name": "_allocate_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "638-654",
    "snippet": "static inline int _allocate_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t  sector_t block,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  b_blocknr_t * allocated_block_nr,\n\t\t\t\t  struct treepath *path, int flags)\n{\n\tBUG_ON(!th->t_trans_id);\n\n#ifdef REISERFS_PREALLOCATE\n\tif (!(flags & GET_BLOCK_NO_IMUX)) {\n\t\treturn reiserfs_new_unf_blocknrs2(th, inode, allocated_block_nr,\n\t\t\t\t\t\t  path, block);\n\t}\n#endif\n\treturn reiserfs_new_unf_blocknrs(th, inode, allocated_block_nr, path,\n\t\t\t\t\t block);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_new_unf_blocknrs",
          "args": [
            "th",
            "inode",
            "allocated_block_nr",
            "path",
            "block"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_new_unf_blocknrs2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3363-3378",
          "snippet": "static inline int reiserfs_new_unf_blocknrs2(struct reiserfs_transaction_handle\n\t\t\t\t\t     *th, struct inode *inode,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     struct treepath *path,\n\t\t\t\t\t     sector_t block)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = th,\n\t\t.path = path,\n\t\t.inode = inode,\n\t\t.block = block,\n\t\t.formatted_node = 0,\n\t\t.preallocate = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, 1, 0);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);",
            "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t *, int,\n\t\t\t       int);\n\nstatic inline int reiserfs_new_unf_blocknrs2(struct reiserfs_transaction_handle\n\t\t\t\t\t     *th, struct inode *inode,\n\t\t\t\t\t     b_blocknr_t * new_blocknrs,\n\t\t\t\t\t     struct treepath *path,\n\t\t\t\t\t     sector_t block)\n{\n\treiserfs_blocknr_hint_t hint = {\n\t\t.th = th,\n\t\t.path = path,\n\t\t.inode = inode,\n\t\t.block = block,\n\t\t.formatted_node = 0,\n\t\t.preallocate = 1\n\t};\n\treturn reiserfs_allocate_blocknrs(&hint, new_blocknrs, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int _allocate_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t  sector_t block,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  b_blocknr_t * allocated_block_nr,\n\t\t\t\t  struct treepath *path, int flags)\n{\n\tBUG_ON(!th->t_trans_id);\n\n#ifdef REISERFS_PREALLOCATE\n\tif (!(flags & GET_BLOCK_NO_IMUX)) {\n\t\treturn reiserfs_new_unf_blocknrs2(th, inode, allocated_block_nr,\n\t\t\t\t\t\t  path, block);\n\t}\n#endif\n\treturn reiserfs_new_unf_blocknrs(th, inode, allocated_block_nr, path,\n\t\t\t\t\t block);\n}"
  },
  {
    "function_name": "convert_tail_for_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "575-636",
    "snippet": "static int convert_tail_for_hole(struct inode *inode,\n\t\t\t\t struct buffer_head *bh_result,\n\t\t\t\t loff_t tail_offset)\n{\n\tunsigned long index;\n\tunsigned long tail_end;\n\tunsigned long tail_start;\n\tstruct page *tail_page;\n\tstruct page *hole_page = bh_result->b_page;\n\tint retval = 0;\n\n\tif ((tail_offset & (bh_result->b_size - 1)) != 1)\n\t\treturn -EIO;\n\n\t/* always try to read until the end of the block */\n\ttail_start = tail_offset & (PAGE_CACHE_SIZE - 1);\n\ttail_end = (tail_start | (bh_result->b_size - 1)) + 1;\n\n\tindex = tail_offset >> PAGE_CACHE_SHIFT;\n\t/*\n\t * hole_page can be zero in case of direct_io, we are sure\n\t * that we cannot get here if we write with O_DIRECT into tail page\n\t */\n\tif (!hole_page || index != hole_page->index) {\n\t\ttail_page = grab_cache_page(inode->i_mapping, index);\n\t\tretval = -ENOMEM;\n\t\tif (!tail_page) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ttail_page = hole_page;\n\t}\n\n\t/*\n\t * we don't have to make sure the conversion did not happen while\n\t * we were locking the page because anyone that could convert\n\t * must first take i_mutex.\n\t *\n\t * We must fix the tail page for writing because it might have buffers\n\t * that are mapped, but have a block number of 0.  This indicates tail\n\t * data that has been read directly into the page, and\n\t * __block_write_begin won't trigger a get_block in this case.\n\t */\n\tfix_tail_page_for_writing(tail_page);\n\tretval = __reiserfs_write_begin(tail_page, tail_start,\n\t\t\t\t      tail_end - tail_start);\n\tif (retval)\n\t\tgoto unlock;\n\n\t/* tail conversion might change the data in the page */\n\tflush_dcache_page(tail_page);\n\n\tretval = reiserfs_commit_write(NULL, tail_page, tail_start, tail_end);\n\nunlock:\n\tif (tail_page != hole_page) {\n\t\tunlock_page(tail_page);\n\t\tpage_cache_release(tail_page);\n\t}\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "tail_page"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "tail_page"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_commit_write",
          "args": [
            "NULL",
            "tail_page",
            "tail_start",
            "tail_end"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2994-3068",
          "snippet": "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around\n\t\t * on the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around\n\t\t * on the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "tail_page"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reiserfs_write_begin",
          "args": [
            "tail_page",
            "tail_start",
            "tail_end - tail_start"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2831-2884",
          "snippet": "int __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fix_tail_page_for_writing",
          "args": [
            "tail_page"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "fix_tail_page_for_writing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "192-207",
          "snippet": "static inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int convert_tail_for_hole(struct inode *inode,\n\t\t\t\t struct buffer_head *bh_result,\n\t\t\t\t loff_t tail_offset)\n{\n\tunsigned long index;\n\tunsigned long tail_end;\n\tunsigned long tail_start;\n\tstruct page *tail_page;\n\tstruct page *hole_page = bh_result->b_page;\n\tint retval = 0;\n\n\tif ((tail_offset & (bh_result->b_size - 1)) != 1)\n\t\treturn -EIO;\n\n\t/* always try to read until the end of the block */\n\ttail_start = tail_offset & (PAGE_CACHE_SIZE - 1);\n\ttail_end = (tail_start | (bh_result->b_size - 1)) + 1;\n\n\tindex = tail_offset >> PAGE_CACHE_SHIFT;\n\t/*\n\t * hole_page can be zero in case of direct_io, we are sure\n\t * that we cannot get here if we write with O_DIRECT into tail page\n\t */\n\tif (!hole_page || index != hole_page->index) {\n\t\ttail_page = grab_cache_page(inode->i_mapping, index);\n\t\tretval = -ENOMEM;\n\t\tif (!tail_page) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ttail_page = hole_page;\n\t}\n\n\t/*\n\t * we don't have to make sure the conversion did not happen while\n\t * we were locking the page because anyone that could convert\n\t * must first take i_mutex.\n\t *\n\t * We must fix the tail page for writing because it might have buffers\n\t * that are mapped, but have a block number of 0.  This indicates tail\n\t * data that has been read directly into the page, and\n\t * __block_write_begin won't trigger a get_block in this case.\n\t */\n\tfix_tail_page_for_writing(tail_page);\n\tretval = __reiserfs_write_begin(tail_page, tail_start,\n\t\t\t\t      tail_end - tail_start);\n\tif (retval)\n\t\tgoto unlock;\n\n\t/* tail conversion might change the data in the page */\n\tflush_dcache_page(tail_page);\n\n\tretval = reiserfs_commit_write(NULL, tail_page, tail_start, tail_end);\n\nunlock:\n\tif (tail_page != hole_page) {\n\t\tunlock_page(tail_page);\n\t\tpage_cache_release(tail_page);\n\t}\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_get_blocks_direct_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "513-563",
    "snippet": "static int reiserfs_get_blocks_direct_io(struct inode *inode,\n\t\t\t\t\t sector_t iblock,\n\t\t\t\t\t struct buffer_head *bh_result,\n\t\t\t\t\t int create)\n{\n\tint ret;\n\n\tbh_result->b_page = NULL;\n\n\t/*\n\t * We set the b_size before reiserfs_get_block call since it is\n\t * referenced in convert_tail_for_hole() that may be called from\n\t * reiserfs_get_block()\n\t */\n\tbh_result->b_size = (1 << inode->i_blkbits);\n\n\tret = reiserfs_get_block(inode, iblock, bh_result,\n\t\t\t\t create | GET_BLOCK_NO_DANGLE);\n\tif (ret)\n\t\tgoto out;\n\n\t/* don't allow direct io onto tail pages */\n\tif (buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {\n\t\t/*\n\t\t * make sure future calls to the direct io funcs for this\n\t\t * offset in the file fail by unmapping the buffer\n\t\t */\n\t\tclear_buffer_mapped(bh_result);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Possible unpacked tail. Flush the data before pages have\n\t * disappeared\n\t */\n\tif (REISERFS_I(inode)->i_flags & i_pack_on_close_mask) {\n\t\tint err;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\n\t\terr = reiserfs_commit_for_inode(inode);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_commit_for_inode",
          "args": [
            "inode"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_commit_for_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3902-3918",
          "snippet": "int reiserfs_commit_for_inode(struct inode *inode)\n{\n\tunsigned int id = REISERFS_I(inode)->i_trans_id;\n\tstruct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;\n\n\t/*\n\t * for the whole inode, assume unset id means it was\n\t * changed in the current transaction.  More conservative\n\t */\n\tif (!id || !jl) {\n\t\treiserfs_update_inode_transaction(inode);\n\t\tid = REISERFS_I(inode)->i_trans_id;\n\t\t/* jl will be updated in __commit_trans_jl */\n\t}\n\n\treturn __commit_trans_jl(inode, id, jl);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nint reiserfs_commit_for_inode(struct inode *inode)\n{\n\tunsigned int id = REISERFS_I(inode)->i_trans_id;\n\tstruct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;\n\n\t/*\n\t * for the whole inode, assume unset id means it was\n\t * changed in the current transaction.  More conservative\n\t */\n\tif (!id || !jl) {\n\t\treiserfs_update_inode_transaction(inode);\n\t\tid = REISERFS_I(inode)->i_trans_id;\n\t\t/* jl will be updated in __commit_trans_jl */\n\t}\n\n\treturn __commit_trans_jl(inode, id, jl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh_result"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh_result"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_get_block",
          "args": [
            "inode",
            "iblock",
            "bh_result",
            "create | GET_BLOCK_NO_DANGLE"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "656-1159",
          "snippet": "int reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int reiserfs_get_blocks_direct_io(struct inode *inode,\n\t\t\t\t\t sector_t iblock,\n\t\t\t\t\t struct buffer_head *bh_result,\n\t\t\t\t\t int create)\n{\n\tint ret;\n\n\tbh_result->b_page = NULL;\n\n\t/*\n\t * We set the b_size before reiserfs_get_block call since it is\n\t * referenced in convert_tail_for_hole() that may be called from\n\t * reiserfs_get_block()\n\t */\n\tbh_result->b_size = (1 << inode->i_blkbits);\n\n\tret = reiserfs_get_block(inode, iblock, bh_result,\n\t\t\t\t create | GET_BLOCK_NO_DANGLE);\n\tif (ret)\n\t\tgoto out;\n\n\t/* don't allow direct io onto tail pages */\n\tif (buffer_mapped(bh_result) && bh_result->b_blocknr == 0) {\n\t\t/*\n\t\t * make sure future calls to the direct io funcs for this\n\t\t * offset in the file fail by unmapping the buffer\n\t\t */\n\t\tclear_buffer_mapped(bh_result);\n\t\tret = -EINVAL;\n\t}\n\n\t/*\n\t * Possible unpacked tail. Flush the data before pages have\n\t * disappeared\n\t */\n\tif (REISERFS_I(inode)->i_flags & i_pack_on_close_mask) {\n\t\tint err;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\n\t\terr = reiserfs_commit_for_inode(inode);\n\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_get_block_create_0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "502-507",
    "snippet": "static int reiserfs_get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t\t       struct buffer_head *bh_result,\n\t\t\t\t       int create)\n{\n\treturn reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_get_block",
          "args": [
            "inode",
            "block",
            "bh_result",
            "GET_BLOCK_NO_HOLE"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "656-1159",
          "snippet": "int reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_get_block(struct inode *inode, sector_t block,\n\t\t       struct buffer_head *bh_result, int create)\n{\n\tint repeat, retval = 0;\n\t/* b_blocknr_t is (unsigned) 32 bit int*/\n\tb_blocknr_t allocated_block_nr = 0;\n\tINITIALIZE_PATH(path);\n\tint pos_in_item;\n\tstruct cpu_key key;\n\tstruct buffer_head *bh, *unbh = NULL;\n\tstruct item_head *ih, tmp_ih;\n\t__le32 *item;\n\tint done;\n\tint fs_gen;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\t/*\n\t * space reserved in transaction batch:\n\t * . 3 balancings in direct->indirect conversion\n\t * . 1 block involved into reiserfs_update_sd()\n\t * XXX in practically impossible worst case direct2indirect()\n\t * can incur (much) more than 3 balancings.\n\t * quota update for user, group\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 1 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\tint version;\n\tint dangle = 1;\n\tloff_t new_offset =\n\t    (((loff_t) block) << inode->i_sb->s_blocksize_bits) + 1;\n\n\treiserfs_write_lock(inode->i_sb);\n\tversion = get_inode_item_key_version(inode);\n\n\tif (!file_capable(inode, block)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn -EFBIG;\n\t}\n\n\t/*\n\t * if !create, we aren't changing the FS, so we don't need to\n\t * log anything, so we don't need to start a transaction\n\t */\n\tif (!(create & GET_BLOCK_CREATE)) {\n\t\tint ret;\n\t\t/* find number of block-th logical block of the file */\n\t\tret = _get_block_create_0(inode, block, bh_result,\n\t\t\t\t\t  create | GET_BLOCK_READ_DIRECT);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * if we're already in a transaction, make sure to close\n\t * any new transactions we start in this func\n\t */\n\tif ((create & GET_BLOCK_NO_DANGLE) ||\n\t    reiserfs_transaction_running(inode->i_sb))\n\t\tdangle = 0;\n\n\t/*\n\t * If file is of such a size, that it might have a tail and\n\t * tails are enabled  we should mark it as possibly needing\n\t * tail packing on close\n\t */\n\tif ((have_large_tails(inode->i_sb)\n\t     && inode->i_size < i_block_size(inode) * 4)\n\t    || (have_small_tails(inode->i_sb)\n\t\t&& inode->i_size < i_block_size(inode)))\n\t\tREISERFS_I(inode)->i_flags |= i_pack_on_close_mask;\n\n\t/* set the key of the first byte in the 'block'-th block of file */\n\tmake_cpu_key(&key, inode, new_offset, TYPE_ANY, 3 /*key length */ );\n\tif ((new_offset + inode->i_sb->s_blocksize - 1) > inode->i_size) {\nstart_trans:\n\t\tth = reiserfs_persistent_transaction(inode->i_sb, jbegin_count);\n\t\tif (!th) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\t\treiserfs_update_inode_transaction(inode);\n\t}\nresearch:\n\n\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto failure;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\titem = tp_item_body(&path);\n\tpos_in_item = path.pos_in_item;\n\n\tfs_gen = get_generation(inode->i_sb);\n\tcopy_item_head(&tmp_ih, ih);\n\n\tif (allocation_needed\n\t    (retval, allocated_block_nr, ih, item, pos_in_item)) {\n\t\t/* we have to allocate block for the unformatted node */\n\t\tif (!th) {\n\t\t\tpathrelse(&path);\n\t\t\tgoto start_trans;\n\t\t}\n\n\t\trepeat =\n\t\t    _allocate_block(th, block, inode, &allocated_block_nr,\n\t\t\t\t    &path, create);\n\n\t\t/*\n\t\t * restart the transaction to give the journal a chance to free\n\t\t * some blocks.  releases the path, so we have to go back to\n\t\t * research if we succeed on the second try\n\t\t */\n\t\tif (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {\n\t\t\tSB_JOURNAL(inode->i_sb)->j_next_async_flush = 1;\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t\trepeat =\n\t\t\t    _allocate_block(th, block, inode,\n\t\t\t\t\t    &allocated_block_nr, NULL, create);\n\n\t\t\tif (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tif (repeat == QUOTA_EXCEEDED)\n\t\t\t\tretval = -EDQUOT;\n\t\t\telse\n\t\t\t\tretval = -ENOSPC;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\tgoto research;\n\t\t}\n\t}\n\n\tif (indirect_item_found(retval, ih)) {\n\t\tb_blocknr_t unfm_ptr;\n\t\t/*\n\t\t * 'block'-th block is in the file already (there is\n\t\t * corresponding cell in some indirect item). But it may be\n\t\t * zero unformatted node pointer (hole)\n\t\t */\n\t\tunfm_ptr = get_block_num(item, pos_in_item);\n\t\tif (unfm_ptr == 0) {\n\t\t\t/* use allocated block to plug the hole */\n\t\t\treiserfs_prepare_for_journal(inode->i_sb, bh, 1);\n\t\t\tif (fs_changed(fs_gen, inode->i_sb)\n\t\t\t    && item_moved(&tmp_ih, &path)) {\n\t\t\t\treiserfs_restore_prepared_buffer(inode->i_sb,\n\t\t\t\t\t\t\t\t bh);\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tset_buffer_new(bh_result);\n\t\t\tif (buffer_dirty(bh_result)\n\t\t\t    && reiserfs_data_ordered(inode->i_sb))\n\t\t\t\treiserfs_add_ordered_list(inode, bh_result);\n\t\t\tput_block_num(item, pos_in_item, allocated_block_nr);\n\t\t\tunfm_ptr = allocated_block_nr;\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\treiserfs_update_sd(th, inode);\n\t\t}\n\t\tset_block_dev_mapped(bh_result, unfm_ptr, inode);\n\t\tpathrelse(&path);\n\t\tretval = 0;\n\t\tif (!dangle && th)\n\t\t\tretval = reiserfs_end_persistent_transaction(th);\n\n\t\treiserfs_write_unlock(inode->i_sb);\n\n\t\t/*\n\t\t * the item was found, so new blocks were not added to the file\n\t\t * there is no need to make sure the inode is updated with this\n\t\t * transaction\n\t\t */\n\t\treturn retval;\n\t}\n\n\tif (!th) {\n\t\tpathrelse(&path);\n\t\tgoto start_trans;\n\t}\n\n\t/*\n\t * desired position is not found or is in the direct item. We have\n\t * to append file with holes up to 'block'-th block converting\n\t * direct items to indirect one if necessary\n\t */\n\tdone = 0;\n\tdo {\n\t\tif (is_statdata_le_ih(ih)) {\n\t\t\t__le32 unp = 0;\n\t\t\tstruct cpu_key tmp_key;\n\n\t\t\t/* indirect item has to be inserted */\n\t\t\tmake_le_item_head(&tmp_ih, &key, version, 1,\n\t\t\t\t\t  TYPE_INDIRECT, UNFM_P_SIZE,\n\t\t\t\t\t  0 /* free_space */ );\n\n\t\t\t/*\n\t\t\t * we are going to add 'block'-th block to the file.\n\t\t\t * Use allocated block for that\n\t\t\t */\n\t\t\tif (cpu_key_k_offset(&key) == 1) {\n\t\t\t\tunp = cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\ttmp_key = key;\t/* ;) */\n\t\t\tset_cpu_key_k_offset(&tmp_key, 1);\n\t\t\tPATH_LAST_POSITION(&path)++;\n\n\t\t\tretval =\n\t\t\t    reiserfs_insert_item(th, &path, &tmp_key, &tmp_ih,\n\t\t\t\t\t\t inode, (char *)&unp);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\t/*\n\t\t\t\t * retval == -ENOSPC, -EDQUOT or -EIO\n\t\t\t\t * or -EEXIST\n\t\t\t\t */\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t} else if (is_direct_le_ih(ih)) {\n\t\t\t/* direct item has to be converted */\n\t\t\tloff_t tail_offset;\n\n\t\t\ttail_offset =\n\t\t\t    ((le_ih_k_offset(ih) -\n\t\t\t      1) & ~(inode->i_sb->s_blocksize - 1)) + 1;\n\n\t\t\t/*\n\t\t\t * direct item we just found fits into block we have\n\t\t\t * to map. Convert it into unformatted node: use\n\t\t\t * bh_result for the conversion\n\t\t\t */\n\t\t\tif (tail_offset == cpu_key_k_offset(&key)) {\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tunbh = bh_result;\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * we have to pad file tail stored in direct\n\t\t\t\t * item(s) up to block size and convert it\n\t\t\t\t * to unformatted node. FIXME: this should\n\t\t\t\t * also get into page cache\n\t\t\t\t */\n\n\t\t\t\tpathrelse(&path);\n\t\t\t\t/*\n\t\t\t\t * ugly, but we can only end the transaction if\n\t\t\t\t * we aren't nested\n\t\t\t\t */\n\t\t\t\tBUG_ON(!th->t_refcount);\n\t\t\t\tif (th->t_refcount == 1) {\n\t\t\t\t\tretval =\n\t\t\t\t\t    reiserfs_end_persistent_transaction\n\t\t\t\t\t    (th);\n\t\t\t\t\tth = NULL;\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\n\t\t\t\tretval =\n\t\t\t\t    convert_tail_for_hole(inode, bh_result,\n\t\t\t\t\t\t\t  tail_offset);\n\t\t\t\tif (retval) {\n\t\t\t\t\tif (retval != -ENOSPC)\n\t\t\t\t\t\treiserfs_error(inode->i_sb,\n\t\t\t\t\t\t\t\"clm-6004\",\n\t\t\t\t\t\t\t\"convert tail failed \"\n\t\t\t\t\t\t\t\"inode %lu, error %d\",\n\t\t\t\t\t\t\tinode->i_ino,\n\t\t\t\t\t\t\tretval);\n\t\t\t\t\tif (allocated_block_nr) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the bitmap, the super,\n\t\t\t\t\t\t * and the stat data == 3\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!th)\n\t\t\t\t\t\t\tth = reiserfs_persistent_transaction(inode->i_sb, 3);\n\t\t\t\t\t\tif (th)\n\t\t\t\t\t\t\treiserfs_free_block(th,\n\t\t\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t\t\t    allocated_block_nr,\n\t\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\t}\n\t\t\t\t\tgoto failure;\n\t\t\t\t}\n\t\t\t\tgoto research;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    direct2indirect(th, inode, &path, unbh,\n\t\t\t\t\t    tail_offset);\n\t\t\tif (retval) {\n\t\t\t\treiserfs_unmap_buffer(unbh);\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/*\n\t\t\t * it is important the set_buffer_uptodate is done\n\t\t\t * after the direct2indirect.  The buffer might\n\t\t\t * contain valid data newer than the data on disk\n\t\t\t * (read by readpage, changed, and then sent here by\n\t\t\t * writepage).  direct2indirect needs to know if unbh\n\t\t\t * was already up to date, so it can decide if the\n\t\t\t * data in unbh needs to be replaced with data from\n\t\t\t * the disk\n\t\t\t */\n\t\t\tset_buffer_uptodate(unbh);\n\n\t\t\t/*\n\t\t\t * unbh->b_page == NULL in case of DIRECT_IO request,\n\t\t\t * this means buffer will disappear shortly, so it\n\t\t\t * should not be added to\n\t\t\t */\n\t\t\tif (unbh->b_page) {\n\t\t\t\t/*\n\t\t\t\t * we've converted the tail, so we must\n\t\t\t\t * flush unbh before the transaction commits\n\t\t\t\t */\n\t\t\t\treiserfs_add_tail_list(inode, unbh);\n\n\t\t\t\t/*\n\t\t\t\t * mark it dirty now to prevent commit_write\n\t\t\t\t * from adding this buffer to the inode's\n\t\t\t\t * dirty buffer list\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t * AKPM: changed __mark_buffer_dirty to\n\t\t\t\t * mark_buffer_dirty().  It's still atomic,\n\t\t\t\t * but it sets the page dirty too, which makes\n\t\t\t\t * it eligible for writeback at any time by the\n\t\t\t\t * VM (which was also the case with\n\t\t\t\t * __mark_buffer_dirty())\n\t\t\t\t */\n\t\t\t\tmark_buffer_dirty(unbh);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * append indirect item with holes if needed, when\n\t\t\t * appending pointer to 'block'-th block use block,\n\t\t\t * which is already allocated\n\t\t\t */\n\t\t\tstruct cpu_key tmp_key;\n\t\t\t/*\n\t\t\t * We use this in case we need to allocate\n\t\t\t * only one block which is a fastpath\n\t\t\t */\n\t\t\tunp_t unf_single = 0;\n\t\t\tunp_t *un;\n\t\t\t__u64 max_to_insert =\n\t\t\t    MAX_ITEM_LEN(inode->i_sb->s_blocksize) /\n\t\t\t    UNFM_P_SIZE;\n\t\t\t__u64 blocks_needed;\n\n\t\t\tRFALSE(pos_in_item != ih_item_len(ih) / UNFM_P_SIZE,\n\t\t\t       \"vs-804: invalid position for append\");\n\t\t\t/*\n\t\t\t * indirect item has to be appended,\n\t\t\t * set up key of that position\n\t\t\t * (key type is unimportant)\n\t\t\t */\n\t\t\tmake_cpu_key(&tmp_key, inode,\n\t\t\t\t     le_key_k_offset(version,\n\t\t\t\t\t\t     &ih->ih_key) +\n\t\t\t\t     op_bytes_number(ih,\n\t\t\t\t\t\t     inode->i_sb->s_blocksize),\n\t\t\t\t     TYPE_INDIRECT, 3);\n\n\t\t\tRFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),\n\t\t\t       \"green-805: invalid offset\");\n\t\t\tblocks_needed =\n\t\t\t    1 +\n\t\t\t    ((cpu_key_k_offset(&key) -\n\t\t\t      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->\n\t\t\t     s_blocksize_bits);\n\n\t\t\tif (blocks_needed == 1) {\n\t\t\t\tun = &unf_single;\n\t\t\t} else {\n\t\t\t\tun = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);\n\t\t\t\tif (!un) {\n\t\t\t\t\tun = &unf_single;\n\t\t\t\t\tblocks_needed = 1;\n\t\t\t\t\tmax_to_insert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (blocks_needed <= max_to_insert) {\n\t\t\t\t/*\n\t\t\t\t * we are going to add target block to\n\t\t\t\t * the file. Use allocated block for that\n\t\t\t\t */\n\t\t\t\tun[blocks_needed - 1] =\n\t\t\t\t    cpu_to_le32(allocated_block_nr);\n\t\t\t\tset_block_dev_mapped(bh_result,\n\t\t\t\t\t\t     allocated_block_nr, inode);\n\t\t\t\tset_buffer_new(bh_result);\n\t\t\t\tdone = 1;\n\t\t\t} else {\n\t\t\t\t/* paste hole to the indirect item */\n\t\t\t\t/*\n\t\t\t\t * If kmalloc failed, max_to_insert becomes\n\t\t\t\t * zero and it means we only have space for\n\t\t\t\t * one block\n\t\t\t\t */\n\t\t\t\tblocks_needed =\n\t\t\t\t    max_to_insert ? max_to_insert : 1;\n\t\t\t}\n\t\t\tretval =\n\t\t\t    reiserfs_paste_into_item(th, &path, &tmp_key, inode,\n\t\t\t\t\t\t     (char *)un,\n\t\t\t\t\t\t     UNFM_P_SIZE *\n\t\t\t\t\t\t     blocks_needed);\n\n\t\t\tif (blocks_needed != 1)\n\t\t\t\tkfree(un);\n\n\t\t\tif (retval) {\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\t/*\n\t\t\t\t * We need to mark new file size in case\n\t\t\t\t * this function will be interrupted/aborted\n\t\t\t\t * later on. And we may do this only for\n\t\t\t\t * holes.\n\t\t\t\t */\n\t\t\t\tinode->i_size +=\n\t\t\t\t    inode->i_sb->s_blocksize * blocks_needed;\n\t\t\t}\n\t\t}\n\n\t\tif (done == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this loop could log more blocks than we had originally\n\t\t * asked for.  So, we have to allow the transaction to end\n\t\t * if it is too big or too full.  Update the inode so things\n\t\t * are consistent if we crash before the function returns\n\t\t * release the path so that anybody waiting on the path before\n\t\t * ending their transaction will be able to continue.\n\t\t */\n\t\tif (journal_transaction_should_end(th, th->t_blocks_allocated)) {\n\t\t\tretval = restart_transaction(th, inode, &path);\n\t\t\tif (retval)\n\t\t\t\tgoto failure;\n\t\t}\n\t\t/*\n\t\t * inserting indirect pointers for a hole can take a\n\t\t * long time.  reschedule if needed and also release the write\n\t\t * lock for others.\n\t\t */\n\t\treiserfs_cond_resched(inode->i_sb);\n\n\t\tretval = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (retval == IO_ERROR) {\n\t\t\tretval = -EIO;\n\t\t\tgoto failure;\n\t\t}\n\t\tif (retval == POSITION_FOUND) {\n\t\t\treiserfs_warning(inode->i_sb, \"vs-825\",\n\t\t\t\t\t \"%K should not be found\", &key);\n\t\t\tretval = -EEXIST;\n\t\t\tif (allocated_block_nr)\n\t\t\t\treiserfs_free_block(th, inode,\n\t\t\t\t\t\t    allocated_block_nr, 1);\n\t\t\tpathrelse(&path);\n\t\t\tgoto failure;\n\t\t}\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t\titem = tp_item_body(&path);\n\t\tpos_in_item = path.pos_in_item;\n\t} while (1);\n\n\tretval = 0;\n\nfailure:\n\tif (th && (!dangle || (retval && !th->t_trans_id))) {\n\t\tint err;\n\t\tif (th->t_trans_id)\n\t\t\treiserfs_update_sd(th, inode);\n\t\terr = reiserfs_end_persistent_transaction(th);\n\t\tif (err)\n\t\t\tretval = err;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\treiserfs_check_path(&path);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t\t       struct buffer_head *bh_result,\n\t\t\t\t       int create)\n{\n\treturn reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE);\n}"
  },
  {
    "function_name": "reiserfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "471-482",
    "snippet": "static int reiserfs_bmap(struct inode *inode, sector_t block,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tif (!file_capable(inode, block))\n\t\treturn -EFBIG;\n\n\treiserfs_write_lock(inode->i_sb);\n\t/* do not read the direct item */\n\t_get_block_create_0(inode, block, bh_result, 0);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_get_block_create_0",
          "args": [
            "inode",
            "block",
            "bh_result",
            "0"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_block_create_0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "502-507",
          "snippet": "static int reiserfs_get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t\t       struct buffer_head *bh_result,\n\t\t\t\t       int create)\n{\n\treturn reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t\t       struct buffer_head *bh_result,\n\t\t\t\t       int create)\n{\n\treturn reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_capable",
          "args": [
            "inode",
            "block"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "file_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "240-249",
          "snippet": "static int file_capable(struct inode *inode, sector_t block)\n{\n\t/* it is new file. */\n\tif (get_inode_item_key_version(inode) != KEY_FORMAT_3_5 ||\n\t    /* old file, but 'block' is inside of 2gb */\n\t    block < (1 << (31 - inode->i_sb->s_blocksize_bits)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int file_capable(struct inode *inode, sector_t block)\n{\n\t/* it is new file. */\n\tif (get_inode_item_key_version(inode) != KEY_FORMAT_3_5 ||\n\t    /* old file, but 'block' is inside of 2gb */\n\t    block < (1 << (31 - inode->i_sb->s_blocksize_bits)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int reiserfs_bmap(struct inode *inode, sector_t block,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tif (!file_capable(inode, block))\n\t\treturn -EFBIG;\n\n\treiserfs_write_lock(inode->i_sb);\n\t/* do not read the direct item */\n\t_get_block_create_0(inode, block, bh_result, 0);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn 0;\n}"
  },
  {
    "function_name": "_get_block_create_0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "284-465",
    "snippet": "static int _get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t       struct buffer_head *bh_result, int args)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key key;\n\tstruct buffer_head *bh;\n\tstruct item_head *ih, tmp_ih;\n\tb_blocknr_t blocknr;\n\tchar *p = NULL;\n\tint chars;\n\tint ret;\n\tint result;\n\tint done = 0;\n\tunsigned long offset;\n\n\t/* prepare the key to look for the 'block'-th block of file */\n\tmake_cpu_key(&key, inode,\n\t\t     (loff_t) block * inode->i_sb->s_blocksize + 1, TYPE_ANY,\n\t\t     3);\n\n\tresult = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (result != POSITION_FOUND) {\n\t\tpathrelse(&path);\n\t\tif (p)\n\t\t\tkunmap(bh_result->b_page);\n\t\tif (result == IO_ERROR)\n\t\t\treturn -EIO;\n\t\t/*\n\t\t * We do not return -ENOENT if there is a hole but page is\n\t\t * uptodate, because it means that there is some MMAPED data\n\t\t * associated with it that is yet to be written to disk.\n\t\t */\n\t\tif ((args & GET_BLOCK_NO_HOLE)\n\t\t    && !PageUptodate(bh_result->b_page)) {\n\t\t\treturn -ENOENT;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\tif (is_indirect_le_ih(ih)) {\n\t\t__le32 *ind_item = (__le32 *) ih_item_body(bh, ih);\n\n\t\t/*\n\t\t * FIXME: here we could cache indirect item or part of it in\n\t\t * the inode to avoid search_by_key in case of subsequent\n\t\t * access to file\n\t\t */\n\t\tblocknr = get_block_num(ind_item, path.pos_in_item);\n\t\tret = 0;\n\t\tif (blocknr) {\n\t\t\tmap_bh(bh_result, inode->i_sb, blocknr);\n\t\t\tif (path.pos_in_item ==\n\t\t\t    ((ih_item_len(ih) / UNFM_P_SIZE) - 1)) {\n\t\t\t\tset_buffer_boundary(bh_result);\n\t\t\t}\n\t\t} else\n\t\t\t/*\n\t\t\t * We do not return -ENOENT if there is a hole but\n\t\t\t * page is uptodate, because it means that there is\n\t\t\t * some MMAPED data associated with it that is\n\t\t\t * yet to be written to disk.\n\t\t\t */\n\t\tif ((args & GET_BLOCK_NO_HOLE)\n\t\t\t    && !PageUptodate(bh_result->b_page)) {\n\t\t\tret = -ENOENT;\n\t\t}\n\n\t\tpathrelse(&path);\n\t\tif (p)\n\t\t\tkunmap(bh_result->b_page);\n\t\treturn ret;\n\t}\n\t/* requested data are in direct item(s) */\n\tif (!(args & GET_BLOCK_READ_DIRECT)) {\n\t\t/*\n\t\t * we are called by bmap. FIXME: we can not map block of file\n\t\t * when it is stored in direct item(s)\n\t\t */\n\t\tpathrelse(&path);\n\t\tif (p)\n\t\t\tkunmap(bh_result->b_page);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * if we've got a direct item, and the buffer or page was uptodate,\n\t * we don't want to pull data off disk again.  skip to the\n\t * end, where we map the buffer and return\n\t */\n\tif (buffer_uptodate(bh_result)) {\n\t\tgoto finished;\n\t} else\n\t\t/*\n\t\t * grab_tail_page can trigger calls to reiserfs_get_block on\n\t\t * up to date pages without any buffers.  If the page is up\n\t\t * to date, we don't want read old data off disk.  Set the up\n\t\t * to date bit on the buffer instead and jump to the end\n\t\t */\n\tif (!bh_result->b_page || PageUptodate(bh_result->b_page)) {\n\t\tset_buffer_uptodate(bh_result);\n\t\tgoto finished;\n\t}\n\t/* read file tail into part of page */\n\toffset = (cpu_key_k_offset(&key) - 1) & (PAGE_CACHE_SIZE - 1);\n\tcopy_item_head(&tmp_ih, ih);\n\n\t/*\n\t * we only want to kmap if we are reading the tail into the page.\n\t * this is not the common case, so we don't kmap until we are\n\t * sure we need to.  But, this means the item might move if\n\t * kmap schedules\n\t */\n\tif (!p)\n\t\tp = (char *)kmap(bh_result->b_page);\n\n\tp += offset;\n\tmemset(p, 0, inode->i_sb->s_blocksize);\n\tdo {\n\t\tif (!is_direct_le_ih(ih)) {\n\t\t\tBUG();\n\t\t}\n\t\t/*\n\t\t * make sure we don't read more bytes than actually exist in\n\t\t * the file.  This can happen in odd cases where i_size isn't\n\t\t * correct, and when direct item padding results in a few\n\t\t * extra bytes at the end of the direct item\n\t\t */\n\t\tif ((le_ih_k_offset(ih) + path.pos_in_item) > inode->i_size)\n\t\t\tbreak;\n\t\tif ((le_ih_k_offset(ih) - 1 + ih_item_len(ih)) > inode->i_size) {\n\t\t\tchars =\n\t\t\t    inode->i_size - (le_ih_k_offset(ih) - 1) -\n\t\t\t    path.pos_in_item;\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\tchars = ih_item_len(ih) - path.pos_in_item;\n\t\t}\n\t\tmemcpy(p, ih_item_body(bh, ih) + path.pos_in_item, chars);\n\n\t\tif (done)\n\t\t\tbreak;\n\n\t\tp += chars;\n\n\t\t/*\n\t\t * we done, if read direct item is not the last item of\n\t\t * node FIXME: we could try to check right delimiting key\n\t\t * to see whether direct item continues in the right\n\t\t * neighbor or rely on i_size\n\t\t */\n\t\tif (PATH_LAST_POSITION(&path) != (B_NR_ITEMS(bh) - 1))\n\t\t\tbreak;\n\n\t\t/* update key to look for the next piece */\n\t\tset_cpu_key_k_offset(&key, cpu_key_k_offset(&key) + chars);\n\t\tresult = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (result != POSITION_FOUND)\n\t\t\t/* i/o error most likely */\n\t\t\tbreak;\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t} while (1);\n\n\tflush_dcache_page(bh_result->b_page);\n\tkunmap(bh_result->b_page);\n\nfinished:\n\tpathrelse(&path);\n\n\tif (result == IO_ERROR)\n\t\treturn -EIO;\n\n\t/*\n\t * this buffer has valid data, but isn't valid for io.  mapping it to\n\t * block #0 tells the rest of reiserfs it just has a tail in it\n\t */\n\tmap_bh(bh_result, inode->i_sb, 0);\n\tset_buffer_uptodate(bh_result);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh_result"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "0"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bh_result->b_page"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "bh_result->b_page"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "&path"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "&path"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_for_position_by_key",
          "args": [
            "inode->i_sb",
            "&key",
            "&path"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "search_for_position_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "830-903",
          "snippet": "int search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint search_for_position_by_key(struct super_block *sb,\n\t\t\t       /* Key to search (cpu variable) */\n\t\t\t       const struct cpu_key *p_cpu_key,\n\t\t\t       /* Filled up by this function. */\n\t\t\t       struct treepath *search_path)\n{\n\tstruct item_head *p_le_ih;\t/* pointer to on-disk structure */\n\tint blk_size;\n\tloff_t item_offset, offset;\n\tstruct reiserfs_dir_entry de;\n\tint retval;\n\n\t/* If searching for directory entry. */\n\tif (is_direntry_cpu_key(p_cpu_key))\n\t\treturn search_by_entry_key(sb, p_cpu_key, search_path,\n\t\t\t\t\t   &de);\n\n\t/* If not searching for directory entry. */\n\n\t/* If item is found. */\n\tretval = search_item(sb, p_cpu_key, search_path);\n\tif (retval == IO_ERROR)\n\t\treturn retval;\n\tif (retval == ITEM_FOUND) {\n\n\t\tRFALSE(!ih_item_len\n\t\t       (item_head\n\t\t\t(PATH_PLAST_BUFFER(search_path),\n\t\t\t PATH_LAST_POSITION(search_path))),\n\t\t       \"PAP-5165: item length equals zero\");\n\n\t\tpos_in_item(search_path) = 0;\n\t\treturn POSITION_FOUND;\n\t}\n\n\tRFALSE(!PATH_LAST_POSITION(search_path),\n\t       \"PAP-5170: position equals zero\");\n\n\t/* Item is not found. Set path to the previous item. */\n\tp_le_ih =\n\t    item_head(PATH_PLAST_BUFFER(search_path),\n\t\t\t   --PATH_LAST_POSITION(search_path));\n\tblk_size = sb->s_blocksize;\n\n\tif (comp_short_keys(&p_le_ih->ih_key, p_cpu_key))\n\t\treturn FILE_NOT_FOUND;\n\n\t/* FIXME: quite ugly this far */\n\n\titem_offset = le_ih_k_offset(p_le_ih);\n\toffset = cpu_key_k_offset(p_cpu_key);\n\n\t/* Needed byte is contained in the item pointed to by the path. */\n\tif (item_offset <= offset &&\n\t    item_offset + op_bytes_number(p_le_ih, blk_size) > offset) {\n\t\tpos_in_item(search_path) = offset - item_offset;\n\t\tif (is_indirect_le_ih(p_le_ih)) {\n\t\t\tpos_in_item(search_path) /= blk_size;\n\t\t}\n\t\treturn POSITION_FOUND;\n\t}\n\n\t/*\n\t * Needed byte is not contained in the item pointed to by the\n\t * path. Set pos_in_item out of the item.\n\t */\n\tif (is_indirect_le_ih(p_le_ih))\n\t\tpos_in_item(search_path) =\n\t\t    ih_item_len(p_le_ih) / UNFM_P_SIZE;\n\telse\n\t\tpos_in_item(search_path) = ih_item_len(p_le_ih);\n\n\treturn POSITION_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&key",
            "cpu_key_k_offset(&key) + chars"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "&key"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "&path"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "ih_item_body(bh, ih) + path.pos_in_item",
            "chars"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "bh",
            "ih"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "ih"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direct_le_ih",
          "args": [
            "ih"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "is_direct_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1567-1570",
          "snippet": "static inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direct_le_ih(struct item_head *ih)\n{\n\treturn is_direct_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "inode->i_sb->s_blocksize"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "bh_result->b_page"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&tmp_ih",
            "ih"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "bh_result->b_page"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bh_result->b_page"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bh_result->b_page"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "bh_result->b_page"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_boundary",
          "args": [
            "bh_result"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "blocknr"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block_num",
          "args": [
            "ind_item",
            "path.pos_in_item"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "&path"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "bh_result->b_page"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bh_result->b_page"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&key",
            "inode",
            "(loff_t) block * inode->i_sb->s_blocksize + 1",
            "TYPE_ANY",
            "3"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstatic int _get_block_create_0(struct inode *inode, sector_t block,\n\t\t\t       struct buffer_head *bh_result, int args)\n{\n\tINITIALIZE_PATH(path);\n\tstruct cpu_key key;\n\tstruct buffer_head *bh;\n\tstruct item_head *ih, tmp_ih;\n\tb_blocknr_t blocknr;\n\tchar *p = NULL;\n\tint chars;\n\tint ret;\n\tint result;\n\tint done = 0;\n\tunsigned long offset;\n\n\t/* prepare the key to look for the 'block'-th block of file */\n\tmake_cpu_key(&key, inode,\n\t\t     (loff_t) block * inode->i_sb->s_blocksize + 1, TYPE_ANY,\n\t\t     3);\n\n\tresult = search_for_position_by_key(inode->i_sb, &key, &path);\n\tif (result != POSITION_FOUND) {\n\t\tpathrelse(&path);\n\t\tif (p)\n\t\t\tkunmap(bh_result->b_page);\n\t\tif (result == IO_ERROR)\n\t\t\treturn -EIO;\n\t\t/*\n\t\t * We do not return -ENOENT if there is a hole but page is\n\t\t * uptodate, because it means that there is some MMAPED data\n\t\t * associated with it that is yet to be written to disk.\n\t\t */\n\t\tif ((args & GET_BLOCK_NO_HOLE)\n\t\t    && !PageUptodate(bh_result->b_page)) {\n\t\t\treturn -ENOENT;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbh = get_last_bh(&path);\n\tih = tp_item_head(&path);\n\tif (is_indirect_le_ih(ih)) {\n\t\t__le32 *ind_item = (__le32 *) ih_item_body(bh, ih);\n\n\t\t/*\n\t\t * FIXME: here we could cache indirect item or part of it in\n\t\t * the inode to avoid search_by_key in case of subsequent\n\t\t * access to file\n\t\t */\n\t\tblocknr = get_block_num(ind_item, path.pos_in_item);\n\t\tret = 0;\n\t\tif (blocknr) {\n\t\t\tmap_bh(bh_result, inode->i_sb, blocknr);\n\t\t\tif (path.pos_in_item ==\n\t\t\t    ((ih_item_len(ih) / UNFM_P_SIZE) - 1)) {\n\t\t\t\tset_buffer_boundary(bh_result);\n\t\t\t}\n\t\t} else\n\t\t\t/*\n\t\t\t * We do not return -ENOENT if there is a hole but\n\t\t\t * page is uptodate, because it means that there is\n\t\t\t * some MMAPED data associated with it that is\n\t\t\t * yet to be written to disk.\n\t\t\t */\n\t\tif ((args & GET_BLOCK_NO_HOLE)\n\t\t\t    && !PageUptodate(bh_result->b_page)) {\n\t\t\tret = -ENOENT;\n\t\t}\n\n\t\tpathrelse(&path);\n\t\tif (p)\n\t\t\tkunmap(bh_result->b_page);\n\t\treturn ret;\n\t}\n\t/* requested data are in direct item(s) */\n\tif (!(args & GET_BLOCK_READ_DIRECT)) {\n\t\t/*\n\t\t * we are called by bmap. FIXME: we can not map block of file\n\t\t * when it is stored in direct item(s)\n\t\t */\n\t\tpathrelse(&path);\n\t\tif (p)\n\t\t\tkunmap(bh_result->b_page);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * if we've got a direct item, and the buffer or page was uptodate,\n\t * we don't want to pull data off disk again.  skip to the\n\t * end, where we map the buffer and return\n\t */\n\tif (buffer_uptodate(bh_result)) {\n\t\tgoto finished;\n\t} else\n\t\t/*\n\t\t * grab_tail_page can trigger calls to reiserfs_get_block on\n\t\t * up to date pages without any buffers.  If the page is up\n\t\t * to date, we don't want read old data off disk.  Set the up\n\t\t * to date bit on the buffer instead and jump to the end\n\t\t */\n\tif (!bh_result->b_page || PageUptodate(bh_result->b_page)) {\n\t\tset_buffer_uptodate(bh_result);\n\t\tgoto finished;\n\t}\n\t/* read file tail into part of page */\n\toffset = (cpu_key_k_offset(&key) - 1) & (PAGE_CACHE_SIZE - 1);\n\tcopy_item_head(&tmp_ih, ih);\n\n\t/*\n\t * we only want to kmap if we are reading the tail into the page.\n\t * this is not the common case, so we don't kmap until we are\n\t * sure we need to.  But, this means the item might move if\n\t * kmap schedules\n\t */\n\tif (!p)\n\t\tp = (char *)kmap(bh_result->b_page);\n\n\tp += offset;\n\tmemset(p, 0, inode->i_sb->s_blocksize);\n\tdo {\n\t\tif (!is_direct_le_ih(ih)) {\n\t\t\tBUG();\n\t\t}\n\t\t/*\n\t\t * make sure we don't read more bytes than actually exist in\n\t\t * the file.  This can happen in odd cases where i_size isn't\n\t\t * correct, and when direct item padding results in a few\n\t\t * extra bytes at the end of the direct item\n\t\t */\n\t\tif ((le_ih_k_offset(ih) + path.pos_in_item) > inode->i_size)\n\t\t\tbreak;\n\t\tif ((le_ih_k_offset(ih) - 1 + ih_item_len(ih)) > inode->i_size) {\n\t\t\tchars =\n\t\t\t    inode->i_size - (le_ih_k_offset(ih) - 1) -\n\t\t\t    path.pos_in_item;\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\tchars = ih_item_len(ih) - path.pos_in_item;\n\t\t}\n\t\tmemcpy(p, ih_item_body(bh, ih) + path.pos_in_item, chars);\n\n\t\tif (done)\n\t\t\tbreak;\n\n\t\tp += chars;\n\n\t\t/*\n\t\t * we done, if read direct item is not the last item of\n\t\t * node FIXME: we could try to check right delimiting key\n\t\t * to see whether direct item continues in the right\n\t\t * neighbor or rely on i_size\n\t\t */\n\t\tif (PATH_LAST_POSITION(&path) != (B_NR_ITEMS(bh) - 1))\n\t\t\tbreak;\n\n\t\t/* update key to look for the next piece */\n\t\tset_cpu_key_k_offset(&key, cpu_key_k_offset(&key) + chars);\n\t\tresult = search_for_position_by_key(inode->i_sb, &key, &path);\n\t\tif (result != POSITION_FOUND)\n\t\t\t/* i/o error most likely */\n\t\t\tbreak;\n\t\tbh = get_last_bh(&path);\n\t\tih = tp_item_head(&path);\n\t} while (1);\n\n\tflush_dcache_page(bh_result->b_page);\n\tkunmap(bh_result->b_page);\n\nfinished:\n\tpathrelse(&path);\n\n\tif (result == IO_ERROR)\n\t\treturn -EIO;\n\n\t/*\n\t * this buffer has valid data, but isn't valid for io.  mapping it to\n\t * block #0 tells the rest of reiserfs it just has a tail in it\n\t */\n\tmap_bh(bh_result, inode->i_sb, 0);\n\tset_buffer_uptodate(bh_result);\n\treturn 0;\n}"
  },
  {
    "function_name": "restart_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "251-274",
    "snippet": "static int restart_transaction(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode, struct treepath *path)\n{\n\tstruct super_block *s = th->t_super;\n\tint err;\n\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_refcount);\n\n\tpathrelse(path);\n\n\t/* we cannot restart while nested */\n\tif (th->t_refcount > 1) {\n\t\treturn 0;\n\t}\n\treiserfs_update_sd(th, inode);\n\terr = journal_end(th);\n\tif (!err) {\n\t\terr = journal_begin(th, s, JOURNAL_PER_BALANCE_CNT * 6);\n\t\tif (!err)\n\t\t\treiserfs_update_inode_transaction(inode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "th",
            "s",
            "JOURNAL_PER_BALANCE_CNT * 6"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "th"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "inode"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "path"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_refcount"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int restart_transaction(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode, struct treepath *path)\n{\n\tstruct super_block *s = th->t_super;\n\tint err;\n\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_refcount);\n\n\tpathrelse(path);\n\n\t/* we cannot restart while nested */\n\tif (th->t_refcount > 1) {\n\t\treturn 0;\n\t}\n\treiserfs_update_sd(th, inode);\n\terr = journal_end(th);\n\tif (!err) {\n\t\terr = journal_begin(th, s, JOURNAL_PER_BALANCE_CNT * 6);\n\t\tif (!err)\n\t\t\treiserfs_update_inode_transaction(inode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "file_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "240-249",
    "snippet": "static int file_capable(struct inode *inode, sector_t block)\n{\n\t/* it is new file. */\n\tif (get_inode_item_key_version(inode) != KEY_FORMAT_3_5 ||\n\t    /* old file, but 'block' is inside of 2gb */\n\t    block < (1 << (31 - inode->i_sb->s_blocksize_bits)))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_inode_item_key_version",
          "args": [
            "inode"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int file_capable(struct inode *inode, sector_t block)\n{\n\t/* it is new file. */\n\tif (get_inode_item_key_version(inode) != KEY_FORMAT_3_5 ||\n\t    /* old file, but 'block' is inside of 2gb */\n\t    block < (1 << (31 - inode->i_sb->s_blocksize_bits)))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_block_dev_mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "230-234",
    "snippet": "static inline void set_block_dev_mapped(struct buffer_head *bh,\n\t\t\t\t\tb_blocknr_t block, struct inode *inode)\n{\n\tmap_bh(bh, inode->i_sb, block);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "block"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void set_block_dev_mapped(struct buffer_head *bh,\n\t\t\t\t\tb_blocknr_t block, struct inode *inode)\n{\n\tmap_bh(bh, inode->i_sb, block);\n}"
  },
  {
    "function_name": "indirect_item_found",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "225-228",
    "snippet": "static inline int indirect_item_found(int retval, struct item_head *ih)\n{\n\treturn (retval == POSITION_FOUND) && is_indirect_le_ih(ih);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int indirect_item_found(int retval, struct item_head *ih)\n{\n\treturn (retval == POSITION_FOUND) && is_indirect_le_ih(ih);\n}"
  },
  {
    "function_name": "allocation_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "213-223",
    "snippet": "static inline int allocation_needed(int retval, b_blocknr_t allocated,\n\t\t\t\t    struct item_head *ih,\n\t\t\t\t    __le32 * item, int pos_in_item)\n{\n\tif (allocated)\n\t\treturn 0;\n\tif (retval == POSITION_FOUND && is_indirect_le_ih(ih) &&\n\t    get_block_num(item, pos_in_item))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_block_num",
          "args": [
            "item",
            "pos_in_item"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline int allocation_needed(int retval, b_blocknr_t allocated,\n\t\t\t\t    struct item_head *ih,\n\t\t\t\t    __le32 * item, int pos_in_item)\n{\n\tif (allocated)\n\t\treturn 0;\n\tif (retval == POSITION_FOUND && is_indirect_le_ih(ih) &&\n\t    get_block_num(item, pos_in_item))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "fix_tail_page_for_writing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "192-207",
    "snippet": "static inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_unmap_buffer",
          "args": [
            "bh"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_unmap_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/tail_conversion.c",
          "lines": "166-191",
          "snippet": "void reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n\nvoid reiserfs_unmap_buffer(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_journaled(bh) || buffer_journal_dirty(bh)) {\n\t\tBUG();\n\t}\n\tclear_buffer_dirty(bh);\n\t/*\n\t * Remove the buffer from whatever list it belongs to. We are mostly\n\t * interested in removing it from per-sb j_dirty_buffers list, to avoid\n\t * BUG() on attempt to write not mapped buffer\n\t */\n\tif ((!list_empty(&bh->b_assoc_buffers) || bh->b_private) && bh->b_page) {\n\t\tstruct inode *inode = bh->b_page->mapping->host;\n\t\tstruct reiserfs_journal *j = SB_JOURNAL(inode->i_sb);\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\treiserfs_free_jh(bh);\n\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t}\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tbh->b_bdev = NULL;\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void fix_tail_page_for_writing(struct page *page)\n{\n\tstruct buffer_head *head, *next, *bh;\n\n\tif (page && page_has_buffers(page)) {\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tdo {\n\t\t\tnext = bh->b_this_page;\n\t\t\tif (buffer_mapped(bh) && bh->b_blocknr == 0) {\n\t\t\t\treiserfs_unmap_buffer(bh);\n\t\t\t}\n\t\t\tbh = next;\n\t\t} while (bh != head);\n\t}\n}"
  },
  {
    "function_name": "make_le_item_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "136-156",
    "snippet": "inline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ih_entry_count",
          "args": [
            "ih",
            "entry_count"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "length"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_type",
          "args": [
            "ih",
            "type"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1536-1539",
          "snippet": "static inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline void set_le_ih_k_type(struct item_head *ih, int type)\n{\n\tset_le_key_k_type(ih_version(ih), &(ih->ih_key), type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "ih",
            "offset"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_version",
          "args": [
            "ih",
            "version"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "key->on_disk_key.k_objectid"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "key->on_disk_key.k_dir_id"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\ninline void make_le_item_head(struct item_head *ih, const struct cpu_key *key,\n\t\t\t      int version,\n\t\t\t      loff_t offset, int type, int length,\n\t\t\t      int entry_count /*or ih_free_space */ )\n{\n\tif (key) {\n\t\tih->ih_key.k_dir_id = cpu_to_le32(key->on_disk_key.k_dir_id);\n\t\tih->ih_key.k_objectid =\n\t\t    cpu_to_le32(key->on_disk_key.k_objectid);\n\t}\n\tput_ih_version(ih, version);\n\tset_le_ih_k_offset(ih, offset);\n\tset_le_ih_k_type(ih, type);\n\tput_ih_item_len(ih, length);\n\t/*    set_ih_free_space (ih, 0); */\n\t/*\n\t * for directory items it is entry count, for directs and stat\n\t * datas - 0xffff, for indirects - 0\n\t */\n\tput_ih_entry_count(ih, entry_count);\n}"
  },
  {
    "function_name": "make_cpu_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "126-133",
    "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_make_cpu_key",
          "args": [
            "key",
            "get_inode_item_key_version(inode)",
            "le32_to_cpu(INODE_PKEY(inode)->k_dir_id)",
            "le32_to_cpu(INODE_PKEY(inode)->k_objectid)",
            "offset",
            "type",
            "length"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "_make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "110-120",
          "snippet": "static void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(inode)->k_objectid"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_item_key_version",
          "args": [
            "inode"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
  },
  {
    "function_name": "_make_cpu_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "110-120",
    "snippet": "static void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpu_key_k_type",
          "args": [
            "key",
            "type"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1598-1601",
          "snippet": "static inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "key",
            "offset"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void _make_cpu_key(struct cpu_key *key, int version, __u32 dirid,\n\t\t\t  __u32 objectid, loff_t offset, int type, int length)\n{\n\tkey->version = version;\n\n\tkey->on_disk_key.k_dir_id = dirid;\n\tkey->on_disk_key.k_objectid = objectid;\n\tset_cpu_key_k_offset(key, offset);\n\tset_cpu_key_k_type(key, type);\n\tkey->key_length = length;\n}"
  },
  {
    "function_name": "reiserfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
    "lines": "26-108",
    "snippet": "void reiserfs_evict_inode(struct inode *inode)\n{\n\t/*\n\t * We need blocks for transaction + (user+group) quota\n\t * update (possibly delete)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 +\n\t    2 * REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb);\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode))\n\t\tdquot_initialize(inode);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (inode->i_nlink)\n\t\tgoto no_delete;\n\n\t/*\n\t * The = 0 happens when we abort creating a new inode\n\t * for some reason like lack of space..\n\t * also handles bad_inode case\n\t */\n\tif (!(inode->i_state & I_NEW) && INODE_PKEY(inode)->k_objectid != 0) {\n\n\t\treiserfs_delete_xattrs(inode);\n\n\t\treiserfs_write_lock(inode->i_sb);\n\n\t\tif (journal_begin(&th, inode->i_sb, jbegin_count))\n\t\t\tgoto out;\n\t\treiserfs_update_inode_transaction(inode);\n\n\t\treiserfs_discard_prealloc(&th, inode);\n\n\t\terr = reiserfs_delete_object(&th, inode);\n\n\t\t/*\n\t\t * Do quota update inside a transaction for journaled quotas.\n\t\t * We must do that after delete_object so that quota updates\n\t\t * go into the same transaction as stat data deletion\n\t\t */\n\t\tif (!err) {\n\t\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\tdquot_free_inode(inode);\n\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t}\n\n\t\tif (journal_end(&th))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * check return value from reiserfs_delete_object after\n\t\t * ending the transaction\n\t\t */\n\t\tif (err)\n\t\t    goto out;\n\n\t\t/*\n\t\t * all items of file are deleted, so we can remove\n\t\t * \"save\" link\n\t\t * we can't do anything about an error here\n\t\t */\n\t\tremove_save_link(inode, 0 /* not truncate */);\nout:\n\t\treiserfs_write_unlock(inode->i_sb);\n\t} else {\n\t\t/* no object items are in the tree */\n\t\t;\n\t}\n\n\t/* note this must go after the journal_end to prevent deadlock */\n\tclear_inode(inode);\n\n\tdquot_drop(inode);\n\tinode->i_blocks = 0;\n\treturn;\n\nno_delete:\n\tclear_inode(inode);\n\tdquot_drop(inode);\n}",
    "includes": [
      "#include <linux/aio.h>",
      "#include <linux/swap.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>",
      "#include <asm/unaligned.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/exportfs.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_save_link",
          "args": [
            "inode",
            "0/* not truncate */"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "remove_save_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "476-514",
          "snippet": "int remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t/* we are going to do one balancing only */\n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t/* setup key of \"save\" link */\n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t/* truncate */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t/* don't take quota bytes from anywhere */\n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint remove_save_link(struct inode *inode, int truncate)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_key key;\n\tint err;\n\n\t/* we are going to do one balancing only */\n\terr = journal_begin(&th, inode->i_sb, JOURNAL_PER_BALANCE_CNT);\n\tif (err)\n\t\treturn err;\n\n\t/* setup key of \"save\" link */\n\tkey.k_dir_id = cpu_to_le32(MAX_KEY_OBJECTID);\n\tkey.k_objectid = INODE_PKEY(inode)->k_objectid;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key,\n\t\t\t\t    1 + inode->i_sb->s_blocksize);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_DIRECT);\n\t} else {\n\t\t/* truncate */\n\t\tset_le_key_k_offset(KEY_FORMAT_3_5, &key, 1);\n\t\tset_le_key_k_type(KEY_FORMAT_3_5, &key, TYPE_INDIRECT);\n\t}\n\n\tif ((truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask)) ||\n\t    (!truncate &&\n\t     (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask)))\n\t\t/* don't take quota bytes from anywhere */\n\t\treiserfs_delete_solid_item(&th, NULL, &key);\n\tif (!truncate) {\n\t\treiserfs_release_objectid(&th, inode->i_ino);\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_unlink_mask;\n\t} else\n\t\tREISERFS_I(inode)->i_flags &= ~i_link_saved_truncate_mask;\n\n\treturn journal_end(&th);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "inode->i_sb",
            "depth"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_delete_object",
          "args": [
            "&th",
            "inode"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_discard_prealloc",
          "args": [
            "&th",
            "inode"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_discard_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "528-536",
          "snippet": "void reiserfs_discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tstruct reiserfs_inode_info *ei = REISERFS_I(inode);\n\n\tBUG_ON(!th->t_trans_id);\n\tif (ei->i_prealloc_count)\n\t\t__discard_prealloc(th, ei);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tstruct reiserfs_inode_info *ei = REISERFS_I(inode);\n\n\tBUG_ON(!th->t_trans_id);\n\tif (ei->i_prealloc_count)\n\t\t__discard_prealloc(th, ei);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "jbegin_count"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_delete_xattrs",
          "args": [
            "inode"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_delete_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "350-358",
          "snippet": "int reiserfs_delete_xattrs(struct inode *inode)\n{\n\tint err = reiserfs_for_each_xattr(inode, delete_one_xattr, NULL);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20004\",\n\t\t\t\t \"Couldn't delete all xattrs (%d)\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_delete_xattrs(struct inode *inode)\n{\n\tint err = reiserfs_for_each_xattr(inode, delete_one_xattr, NULL);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20004\",\n\t\t\t\t \"Couldn't delete all xattrs (%d)\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_INIT_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nvoid reiserfs_evict_inode(struct inode *inode)\n{\n\t/*\n\t * We need blocks for transaction + (user+group) quota\n\t * update (possibly delete)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 +\n\t    2 * REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb);\n\tstruct reiserfs_transaction_handle th;\n\tint err;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode))\n\t\tdquot_initialize(inode);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (inode->i_nlink)\n\t\tgoto no_delete;\n\n\t/*\n\t * The = 0 happens when we abort creating a new inode\n\t * for some reason like lack of space..\n\t * also handles bad_inode case\n\t */\n\tif (!(inode->i_state & I_NEW) && INODE_PKEY(inode)->k_objectid != 0) {\n\n\t\treiserfs_delete_xattrs(inode);\n\n\t\treiserfs_write_lock(inode->i_sb);\n\n\t\tif (journal_begin(&th, inode->i_sb, jbegin_count))\n\t\t\tgoto out;\n\t\treiserfs_update_inode_transaction(inode);\n\n\t\treiserfs_discard_prealloc(&th, inode);\n\n\t\terr = reiserfs_delete_object(&th, inode);\n\n\t\t/*\n\t\t * Do quota update inside a transaction for journaled quotas.\n\t\t * We must do that after delete_object so that quota updates\n\t\t * go into the same transaction as stat data deletion\n\t\t */\n\t\tif (!err) {\n\t\t\tint depth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\tdquot_free_inode(inode);\n\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t}\n\n\t\tif (journal_end(&th))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * check return value from reiserfs_delete_object after\n\t\t * ending the transaction\n\t\t */\n\t\tif (err)\n\t\t    goto out;\n\n\t\t/*\n\t\t * all items of file are deleted, so we can remove\n\t\t * \"save\" link\n\t\t * we can't do anything about an error here\n\t\t */\n\t\tremove_save_link(inode, 0 /* not truncate */);\nout:\n\t\treiserfs_write_unlock(inode->i_sb);\n\t} else {\n\t\t/* no object items are in the tree */\n\t\t;\n\t}\n\n\t/* note this must go after the journal_end to prevent deadlock */\n\tclear_inode(inode);\n\n\tdquot_drop(inode);\n\tinode->i_blocks = 0;\n\treturn;\n\nno_delete:\n\tclear_inode(inode);\n\tdquot_drop(inode);\n}"
  }
]