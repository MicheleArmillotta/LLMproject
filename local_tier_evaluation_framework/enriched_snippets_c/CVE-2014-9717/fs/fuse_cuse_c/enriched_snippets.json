[
  {
    "function_name": "cuse_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "634-638",
    "snippet": "static void __exit cuse_exit(void)\n{\n\tmisc_deregister(&cuse_miscdev);\n\tclass_destroy(cuse_class);\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct class *cuse_class;",
      "static struct miscdevice cuse_miscdev = {\n\t.minor\t\t= CUSE_MINOR,\n\t.name\t\t= \"cuse\",\n\t.fops\t\t= &cuse_channel_fops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_destroy",
          "args": [
            "cuse_class"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&cuse_miscdev"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic struct class *cuse_class;\nstatic struct miscdevice cuse_miscdev = {\n\t.minor\t\t= CUSE_MINOR,\n\t.name\t\t= \"cuse\",\n\t.fops\t\t= &cuse_channel_fops,\n};\n\nstatic void __exit cuse_exit(void)\n{\n\tmisc_deregister(&cuse_miscdev);\n\tclass_destroy(cuse_class);\n}"
  },
  {
    "function_name": "cuse_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "605-632",
    "snippet": "static int __init cuse_init(void)\n{\n\tint i, rc;\n\n\t/* init conntbl */\n\tfor (i = 0; i < CUSE_CONNTBL_LEN; i++)\n\t\tINIT_LIST_HEAD(&cuse_conntbl[i]);\n\n\t/* inherit and extend fuse_dev_operations */\n\tcuse_channel_fops\t\t= fuse_dev_operations;\n\tcuse_channel_fops.owner\t\t= THIS_MODULE;\n\tcuse_channel_fops.open\t\t= cuse_channel_open;\n\tcuse_channel_fops.release\t= cuse_channel_release;\n\n\tcuse_class = class_create(THIS_MODULE, \"cuse\");\n\tif (IS_ERR(cuse_class))\n\t\treturn PTR_ERR(cuse_class);\n\n\tcuse_class->dev_groups = cuse_class_dev_groups;\n\n\trc = misc_register(&cuse_miscdev);\n\tif (rc) {\n\t\tclass_destroy(cuse_class);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [
      "#define CUSE_CONNTBL_LEN\t64"
    ],
    "globals_used": [
      "static struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];",
      "static struct class *cuse_class;",
      "static struct file_operations cuse_channel_fops;",
      "static struct miscdevice cuse_miscdev = {\n\t.minor\t\t= CUSE_MINOR,\n\t.name\t\t= \"cuse\",\n\t.fops\t\t= &cuse_channel_fops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_destroy",
          "args": [
            "cuse_class"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&cuse_miscdev"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cuse_class"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cuse_class"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "class_create",
          "args": [
            "THIS_MODULE",
            "\"cuse\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cuse_conntbl[i]"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\n#define CUSE_CONNTBL_LEN\t64\n\nstatic struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];\nstatic struct class *cuse_class;\nstatic struct file_operations cuse_channel_fops;\nstatic struct miscdevice cuse_miscdev = {\n\t.minor\t\t= CUSE_MINOR,\n\t.name\t\t= \"cuse\",\n\t.fops\t\t= &cuse_channel_fops,\n};\n\nstatic int __init cuse_init(void)\n{\n\tint i, rc;\n\n\t/* init conntbl */\n\tfor (i = 0; i < CUSE_CONNTBL_LEN; i++)\n\t\tINIT_LIST_HEAD(&cuse_conntbl[i]);\n\n\t/* inherit and extend fuse_dev_operations */\n\tcuse_channel_fops\t\t= fuse_dev_operations;\n\tcuse_channel_fops.owner\t\t= THIS_MODULE;\n\tcuse_channel_fops.open\t\t= cuse_channel_open;\n\tcuse_channel_fops.release\t= cuse_channel_release;\n\n\tcuse_class = class_create(THIS_MODULE, \"cuse\");\n\tif (IS_ERR(cuse_class))\n\t\treturn PTR_ERR(cuse_class);\n\n\tcuse_class->dev_groups = cuse_class_dev_groups;\n\n\trc = misc_register(&cuse_miscdev);\n\tif (rc) {\n\t\tclass_destroy(cuse_class);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cuse_class_abort_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "578-586",
    "snippet": "static ssize_t cuse_class_abort_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\tfuse_abort_conn(&cc->fc);\n\treturn count;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEVICE_ATTR(abort, 0200, NULL, cuse_class_abort_store);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_abort_conn",
          "args": [
            "&cc->fc"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_abort_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2185-2200",
          "snippet": "void fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_get_drvdata",
          "args": [
            "dev"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic DEVICE_ATTR(abort, 0200, NULL, cuse_class_abort_store);\n\nstatic ssize_t cuse_class_abort_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\tfuse_abort_conn(&cc->fc);\n\treturn count;\n}"
  },
  {
    "function_name": "cuse_class_waiting_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "569-575",
    "snippet": "static ssize_t cuse_class_waiting_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&cc->fc.num_waiting));\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "atomic_read(&cc->fc.num_waiting)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cc->fc.num_waiting"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_get_drvdata",
          "args": [
            "dev"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic ssize_t cuse_class_waiting_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&cc->fc.num_waiting));\n}"
  },
  {
    "function_name": "cuse_channel_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "537-558",
    "snippet": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct cuse_conn *cc = fc_to_cc(file->private_data);\n\tint rc;\n\n\t/* remove from the conntbl, no more access from this point on */\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\n\t/* remove device */\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\n\trc = fuse_dev_release(inode, file);\t/* puts the base reference */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(cuse_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_dev_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dev_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2203-2219",
          "snippet": "int fuse_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (fc) {\n\t\tspin_lock(&fc->lock);\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_conn_put(fc);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nint fuse_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (fc) {\n\t\tspin_lock(&fc->lock);\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_conn_put(fc);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cdev_del",
          "args": [
            "cc->cdev"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "cdev_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "481-485",
          "snippet": "void cdev_del(struct cdev *p)\n{\n\tcdev_unmap(p->dev, p->count);\n\tkobject_put(&p->kobj);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid cdev_del(struct cdev *p)\n{\n\tcdev_unmap(p->dev, p->count);\n\tkobject_put(&p->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_chrdev_region",
          "args": [
            "cc->cdev->dev",
            "1"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "285-296",
          "snippet": "void unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_unregister",
          "args": [
            "cc->dev"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cuse_lock"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cc->list"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cuse_lock"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fc_to_cc",
          "args": [
            "file->private_data"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "fc_to_cc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "70-73",
          "snippet": "static struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic DEFINE_MUTEX(cuse_lock);\n\nstatic int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct cuse_conn *cc = fc_to_cc(file->private_data);\n\tint rc;\n\n\t/* remove from the conntbl, no more access from this point on */\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\n\t/* remove device */\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\n\trc = fuse_dev_release(inode, file);\t/* puts the base reference */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cuse_channel_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "499-524",
    "snippet": "static int cuse_channel_open(struct inode *inode, struct file *file)\n{\n\tstruct cuse_conn *cc;\n\tint rc;\n\n\t/* set up cuse_conn */\n\tcc = kzalloc(sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\tfuse_conn_init(&cc->fc);\n\n\tINIT_LIST_HEAD(&cc->list);\n\tcc->fc.release = cuse_fc_release;\n\n\tcc->fc.connected = 1;\n\tcc->fc.initialized = 1;\n\trc = cuse_send_init(cc);\n\tif (rc) {\n\t\tfuse_conn_put(&cc->fc);\n\t\treturn rc;\n\t}\n\tfile->private_data = &cc->fc;\t/* channel owns base reference to cc */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "&cc->fc"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cuse_send_init",
          "args": [
            "cc"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "cuse_send_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "422-476",
          "snippet": "static int cuse_send_init(struct cuse_conn *cc)\n{\n\tint rc;\n\tstruct fuse_req *req;\n\tstruct page *page;\n\tstruct fuse_conn *fc = &cc->fc;\n\tstruct cuse_init_in *arg;\n\tvoid *outarg;\n\n\tBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\n\n\treq = fuse_get_req_for_background(fc, 1);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\tgoto err;\n\t}\n\n\trc = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\tgoto err_put_req;\n\n\toutarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);\n\tif (!outarg)\n\t\tgoto err_free_page;\n\n\targ = &req->misc.cuse_init_in;\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->flags |= CUSE_UNRESTRICTED_IOCTL;\n\treq->in.h.opcode = CUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct cuse_init_in);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(struct cuse_init_out);\n\treq->out.args[0].value = outarg;\n\treq->out.args[1].size = CUSE_INIT_INFO_MAX;\n\treq->out.argvar = 1;\n\treq->out.argpages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = req->out.args[1].size;\n\treq->num_pages = 1;\n\treq->end = cuse_process_init_reply;\n\tfuse_request_send_background(fc, req);\n\n\treturn 0;\n\nerr_free_page:\n\t__free_page(page);\nerr_put_req:\n\tfuse_put_request(fc, req);\nerr:\n\treturn rc;\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic int cuse_send_init(struct cuse_conn *cc)\n{\n\tint rc;\n\tstruct fuse_req *req;\n\tstruct page *page;\n\tstruct fuse_conn *fc = &cc->fc;\n\tstruct cuse_init_in *arg;\n\tvoid *outarg;\n\n\tBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\n\n\treq = fuse_get_req_for_background(fc, 1);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\tgoto err;\n\t}\n\n\trc = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\tgoto err_put_req;\n\n\toutarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);\n\tif (!outarg)\n\t\tgoto err_free_page;\n\n\targ = &req->misc.cuse_init_in;\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->flags |= CUSE_UNRESTRICTED_IOCTL;\n\treq->in.h.opcode = CUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct cuse_init_in);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(struct cuse_init_out);\n\treq->out.args[0].value = outarg;\n\treq->out.args[1].size = CUSE_INIT_INFO_MAX;\n\treq->out.argvar = 1;\n\treq->out.argpages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = req->out.args[1].size;\n\treq->num_pages = 1;\n\treq->end = cuse_process_init_reply;\n\tfuse_request_send_background(fc, req);\n\n\treturn 0;\n\nerr_free_page:\n\t__free_page(page);\nerr_put_req:\n\tfuse_put_request(fc, req);\nerr:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cc->list"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_conn_init",
          "args": [
            "&cc->fc"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "570-596",
          "snippet": "void fuse_conn_init(struct fuse_conn *fc)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tspin_lock_init(&fc->lock);\n\tinit_rwsem(&fc->killsb);\n\tatomic_set(&fc->count, 1);\n\tinit_waitqueue_head(&fc->waitq);\n\tinit_waitqueue_head(&fc->blocked_waitq);\n\tinit_waitqueue_head(&fc->reserved_req_waitq);\n\tINIT_LIST_HEAD(&fc->pending);\n\tINIT_LIST_HEAD(&fc->processing);\n\tINIT_LIST_HEAD(&fc->io);\n\tINIT_LIST_HEAD(&fc->interrupts);\n\tINIT_LIST_HEAD(&fc->bg_queue);\n\tINIT_LIST_HEAD(&fc->entry);\n\tfc->forget_list_tail = &fc->forget_list_head;\n\tatomic_set(&fc->num_waiting, 0);\n\tfc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;\n\tfc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;\n\tfc->khctr = 0;\n\tfc->polled_files = RB_ROOT;\n\tfc->reqctr = 0;\n\tfc->blocked = 0;\n\tfc->initialized = 0;\n\tfc->attr_version = 1;\n\tget_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [
            "#define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)",
            "#define FUSE_DEFAULT_MAX_BACKGROUND 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\n#define FUSE_DEFAULT_CONGESTION_THRESHOLD (FUSE_DEFAULT_MAX_BACKGROUND * 3 / 4)\n#define FUSE_DEFAULT_MAX_BACKGROUND 12\n\nvoid fuse_conn_init(struct fuse_conn *fc)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tspin_lock_init(&fc->lock);\n\tinit_rwsem(&fc->killsb);\n\tatomic_set(&fc->count, 1);\n\tinit_waitqueue_head(&fc->waitq);\n\tinit_waitqueue_head(&fc->blocked_waitq);\n\tinit_waitqueue_head(&fc->reserved_req_waitq);\n\tINIT_LIST_HEAD(&fc->pending);\n\tINIT_LIST_HEAD(&fc->processing);\n\tINIT_LIST_HEAD(&fc->io);\n\tINIT_LIST_HEAD(&fc->interrupts);\n\tINIT_LIST_HEAD(&fc->bg_queue);\n\tINIT_LIST_HEAD(&fc->entry);\n\tfc->forget_list_tail = &fc->forget_list_head;\n\tatomic_set(&fc->num_waiting, 0);\n\tfc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;\n\tfc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;\n\tfc->khctr = 0;\n\tfc->polled_files = RB_ROOT;\n\tfc->reqctr = 0;\n\tfc->blocked = 0;\n\tfc->initialized = 0;\n\tfc->attr_version = 1;\n\tget_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cc)",
            "GFP_KERNEL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic int cuse_channel_open(struct inode *inode, struct file *file)\n{\n\tstruct cuse_conn *cc;\n\tint rc;\n\n\t/* set up cuse_conn */\n\tcc = kzalloc(sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\tfuse_conn_init(&cc->fc);\n\n\tINIT_LIST_HEAD(&cc->list);\n\tcc->fc.release = cuse_fc_release;\n\n\tcc->fc.connected = 1;\n\tcc->fc.initialized = 1;\n\trc = cuse_send_init(cc);\n\tif (rc) {\n\t\tfuse_conn_put(&cc->fc);\n\t\treturn rc;\n\t}\n\tfile->private_data = &cc->fc;\t/* channel owns base reference to cc */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cuse_fc_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "478-482",
    "snippet": "static void cuse_fc_release(struct fuse_conn *fc)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc);\n\tkfree_rcu(cc, fc.rcu);\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "cc",
            "fc.rcu"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fc_to_cc",
          "args": [
            "fc"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "fc_to_cc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "70-73",
          "snippet": "static struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic void cuse_fc_release(struct fuse_conn *fc)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc);\n\tkfree_rcu(cc, fc.rcu);\n}"
  },
  {
    "function_name": "cuse_send_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "422-476",
    "snippet": "static int cuse_send_init(struct cuse_conn *cc)\n{\n\tint rc;\n\tstruct fuse_req *req;\n\tstruct page *page;\n\tstruct fuse_conn *fc = &cc->fc;\n\tstruct cuse_init_in *arg;\n\tvoid *outarg;\n\n\tBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\n\n\treq = fuse_get_req_for_background(fc, 1);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\tgoto err;\n\t}\n\n\trc = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\tgoto err_put_req;\n\n\toutarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);\n\tif (!outarg)\n\t\tgoto err_free_page;\n\n\targ = &req->misc.cuse_init_in;\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->flags |= CUSE_UNRESTRICTED_IOCTL;\n\treq->in.h.opcode = CUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct cuse_init_in);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(struct cuse_init_out);\n\treq->out.args[0].value = outarg;\n\treq->out.args[1].size = CUSE_INIT_INFO_MAX;\n\treq->out.argvar = 1;\n\treq->out.argpages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = req->out.args[1].size;\n\treq->num_pages = 1;\n\treq->end = cuse_process_init_reply;\n\tfuse_request_send_background(fc, req);\n\n\treturn 0;\n\nerr_free_page:\n\t__free_page(page);\nerr_put_req:\n\tfuse_put_request(fc, req);\nerr:\n\treturn rc;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_request_send_background",
          "args": [
            "fc",
            "req"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cuse_init_out)",
            "GFP_KERNEL"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req_for_background",
          "args": [
            "fc",
            "1"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_for_background",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "196-200",
          "snippet": "struct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_for_background(struct fuse_conn *fc,\n\t\t\t\t\t     unsigned npages)\n{\n\treturn __fuse_get_req(fc, npages, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "CUSE_INIT_INFO_MAX > PAGE_SIZE"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic int cuse_send_init(struct cuse_conn *cc)\n{\n\tint rc;\n\tstruct fuse_req *req;\n\tstruct page *page;\n\tstruct fuse_conn *fc = &cc->fc;\n\tstruct cuse_init_in *arg;\n\tvoid *outarg;\n\n\tBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\n\n\treq = fuse_get_req_for_background(fc, 1);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\tgoto err;\n\t}\n\n\trc = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\tgoto err_put_req;\n\n\toutarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);\n\tif (!outarg)\n\t\tgoto err_free_page;\n\n\targ = &req->misc.cuse_init_in;\n\targ->major = FUSE_KERNEL_VERSION;\n\targ->minor = FUSE_KERNEL_MINOR_VERSION;\n\targ->flags |= CUSE_UNRESTRICTED_IOCTL;\n\treq->in.h.opcode = CUSE_INIT;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct cuse_init_in);\n\treq->in.args[0].value = arg;\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(struct cuse_init_out);\n\treq->out.args[0].value = outarg;\n\treq->out.args[1].size = CUSE_INIT_INFO_MAX;\n\treq->out.argvar = 1;\n\treq->out.argpages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = req->out.args[1].size;\n\treq->num_pages = 1;\n\treq->end = cuse_process_init_reply;\n\tfuse_request_send_background(fc, req);\n\n\treturn 0;\n\nerr_free_page:\n\t__free_page(page);\nerr_put_req:\n\tfuse_put_request(fc, req);\nerr:\n\treturn rc;\n}"
  },
  {
    "function_name": "cuse_process_init_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "316-420",
    "snippet": "static void cuse_process_init_reply(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc), *pos;\n\tstruct cuse_init_out *arg = req->out.args[0].value;\n\tstruct page *page = req->pages[0];\n\tstruct cuse_devinfo devinfo = { };\n\tstruct device *dev;\n\tstruct cdev *cdev;\n\tdev_t devt;\n\tint rc, i;\n\n\tif (req->out.h.error ||\n\t    arg->major != FUSE_KERNEL_VERSION || arg->minor < 11) {\n\t\tgoto err;\n\t}\n\n\tfc->minor = arg->minor;\n\tfc->max_read = max_t(unsigned, arg->max_read, 4096);\n\tfc->max_write = max_t(unsigned, arg->max_write, 4096);\n\n\t/* parse init reply */\n\tcc->unrestricted_ioctl = arg->flags & CUSE_UNRESTRICTED_IOCTL;\n\n\trc = cuse_parse_devinfo(page_address(page), req->out.args[1].size,\n\t\t\t\t&devinfo);\n\tif (rc)\n\t\tgoto err;\n\n\t/* determine and reserve devt */\n\tdevt = MKDEV(arg->dev_major, arg->dev_minor);\n\tif (!MAJOR(devt))\n\t\trc = alloc_chrdev_region(&devt, MINOR(devt), 1, devinfo.name);\n\telse\n\t\trc = register_chrdev_region(devt, 1, devinfo.name);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"CUSE: failed to register chrdev region\\n\");\n\t\tgoto err;\n\t}\n\n\t/* devt determined, create device */\n\trc = -ENOMEM;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto err_region;\n\n\tdevice_initialize(dev);\n\tdev_set_uevent_suppress(dev, 1);\n\tdev->class = cuse_class;\n\tdev->devt = devt;\n\tdev->release = cuse_gendev_release;\n\tdev_set_drvdata(dev, cc);\n\tdev_set_name(dev, \"%s\", devinfo.name);\n\n\tmutex_lock(&cuse_lock);\n\n\t/* make sure the device-name is unique */\n\tfor (i = 0; i < CUSE_CONNTBL_LEN; ++i) {\n\t\tlist_for_each_entry(pos, &cuse_conntbl[i], list)\n\t\t\tif (!strcmp(dev_name(pos->dev), dev_name(dev)))\n\t\t\t\tgoto err_unlock;\n\t}\n\n\trc = device_add(dev);\n\tif (rc)\n\t\tgoto err_unlock;\n\n\t/* register cdev */\n\trc = -ENOMEM;\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto err_unlock;\n\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &cuse_frontend_fops;\n\n\trc = cdev_add(cdev, devt, 1);\n\tif (rc)\n\t\tgoto err_cdev;\n\n\tcc->dev = dev;\n\tcc->cdev = cdev;\n\n\t/* make the device available */\n\tlist_add(&cc->list, cuse_conntbl_head(devt));\n\tmutex_unlock(&cuse_lock);\n\n\t/* announce device availability */\n\tdev_set_uevent_suppress(dev, 0);\n\tkobject_uevent(&dev->kobj, KOBJ_ADD);\nout:\n\tkfree(arg);\n\t__free_page(page);\n\treturn;\n\nerr_cdev:\n\tcdev_del(cdev);\nerr_unlock:\n\tmutex_unlock(&cuse_lock);\n\tput_device(dev);\nerr_region:\n\tunregister_chrdev_region(devt, 1);\nerr:\n\tfuse_abort_conn(fc);\n\tgoto out;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [
      "#define CUSE_CONNTBL_LEN\t64"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(cuse_lock);",
      "static struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];",
      "static struct class *cuse_class;",
      "static const struct file_operations cuse_frontend_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.read\t\t\t= cuse_read,\n\t.write\t\t\t= cuse_write,\n\t.open\t\t\t= cuse_open,\n\t.release\t\t= cuse_release,\n\t.unlocked_ioctl\t\t= cuse_file_ioctl,\n\t.compat_ioctl\t\t= cuse_file_compat_ioctl,\n\t.poll\t\t\t= fuse_file_poll,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_abort_conn",
          "args": [
            "fc"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_abort_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2185-2200",
          "snippet": "void fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_chrdev_region",
          "args": [
            "devt",
            "1"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "285-296",
          "snippet": "void unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "dev"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mtd_put_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "229-232",
          "snippet": "static void logfs_mtd_put_device(struct logfs_super *s)\n{\n\tput_mtd_device(s->s_mtd);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/completion.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic void logfs_mtd_put_device(struct logfs_super *s)\n{\n\tput_mtd_device(s->s_mtd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cuse_lock"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cdev_del",
          "args": [
            "cdev"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "cdev_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "481-485",
          "snippet": "void cdev_del(struct cdev *p)\n{\n\tcdev_unmap(p->dev, p->count);\n\tkobject_put(&p->kobj);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid cdev_del(struct cdev *p)\n{\n\tcdev_unmap(p->dev, p->count);\n\tkobject_put(&p->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "arg"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&dev->kobj",
            "KOBJ_ADD"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobject_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "113-124",
          "snippet": "static void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_set_uevent_suppress",
          "args": [
            "dev",
            "0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cuse_lock"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cc->list",
            "cuse_conntbl_head(devt)"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cuse_conntbl_head",
          "args": [
            "devt"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "cuse_conntbl_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "75-78",
          "snippet": "static struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [
            "#define CUSE_CONNTBL_LEN\t64"
          ],
          "globals_used": [
            "static struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\n#define CUSE_CONNTBL_LEN\t64\n\nstatic struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];\n\nstatic struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cdev_add",
          "args": [
            "cdev",
            "devt",
            "1"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "cdev_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "452-467",
          "snippet": "int cdev_add(struct cdev *p, dev_t dev, unsigned count)\n{\n\tint error;\n\n\tp->dev = dev;\n\tp->count = count;\n\n\terror = kobj_map(cdev_map, dev, count, NULL,\n\t\t\t exact_match, exact_lock, p);\n\tif (error)\n\t\treturn error;\n\n\tkobject_get(p->kobj.parent);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobj_map *cdev_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic struct kobj_map *cdev_map;\n\nint cdev_add(struct cdev *p, dev_t dev, unsigned count)\n{\n\tint error;\n\n\tp->dev = dev;\n\tp->count = count;\n\n\terror = kobj_map(cdev_map, dev, count, NULL,\n\t\t\t exact_match, exact_lock, p);\n\tif (error)\n\t\treturn error;\n\n\tkobject_get(p->kobj.parent);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cdev_alloc",
          "args": [],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "cdev_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "520-528",
          "snippet": "struct cdev *cdev_alloc(void)\n{\n\tstruct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);\n\tif (p) {\n\t\tINIT_LIST_HEAD(&p->list);\n\t\tkobject_init(&p->kobj, &ktype_cdev_dynamic);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobj_type ktype_cdev_dynamic = {\n\t.release\t= cdev_dynamic_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic struct kobj_type ktype_cdev_dynamic = {\n\t.release\t= cdev_dynamic_release,\n};\n\nstruct cdev *cdev_alloc(void)\n{\n\tstruct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);\n\tif (p) {\n\t\tINIT_LIST_HEAD(&p->list);\n\t\tkobject_init(&p->kobj, &ktype_cdev_dynamic);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_add",
          "args": [
            "dev"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dev_name(pos->dev)",
            "dev_name(dev)"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "pos->dev"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&cuse_conntbl[i]",
            "list"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cuse_lock"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_name",
          "args": [
            "dev",
            "\"%s\"",
            "devinfo.name"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_drvdata",
          "args": [
            "dev",
            "cc"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_uevent_suppress",
          "args": [
            "dev",
            "1"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_initialize",
          "args": [
            "dev"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dev)",
            "GFP_KERNEL"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CUSE: failed to register chrdev region\\n\""
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_chrdev_region",
          "args": [
            "devt",
            "1",
            "devinfo.name"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "register_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "174-197",
          "snippet": "int register_chrdev_region(dev_t from, unsigned count, const char *name)\n{\n\tstruct char_device_struct *cd;\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tcd = __register_chrdev_region(MAJOR(n), MINOR(n),\n\t\t\t       next - n, name);\n\t\tif (IS_ERR(cd))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tto = n;\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n\treturn PTR_ERR(cd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];\n\nint register_chrdev_region(dev_t from, unsigned count, const char *name)\n{\n\tstruct char_device_struct *cd;\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tcd = __register_chrdev_region(MAJOR(n), MINOR(n),\n\t\t\t       next - n, name);\n\t\tif (IS_ERR(cd))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tto = n;\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n\treturn PTR_ERR(cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_chrdev_region",
          "args": [
            "&devt",
            "MINOR(devt)",
            "1",
            "devinfo.name"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "210-219",
          "snippet": "int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,\n\t\t\tconst char *name)\n{\n\tstruct char_device_struct *cd;\n\tcd = __register_chrdev_region(0, baseminor, count, name);\n\tif (IS_ERR(cd))\n\t\treturn PTR_ERR(cd);\n\t*dev = MKDEV(cd->major, cd->baseminor);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];\n\nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,\n\t\t\tconst char *name)\n{\n\tstruct char_device_struct *cd;\n\tcd = __register_chrdev_region(0, baseminor, count, name);\n\tif (IS_ERR(cd))\n\t\treturn PTR_ERR(cd);\n\t*dev = MKDEV(cd->major, cd->baseminor);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "devt"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "devt"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "arg->dev_major",
            "arg->dev_minor"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cuse_parse_devinfo",
          "args": [
            "page_address(page)",
            "req->out.args[1].size",
            "&devinfo"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "cuse_parse_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "277-302",
          "snippet": "static int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)\n{\n\tchar *end = p + len;\n\tchar *uninitialized_var(key), *uninitialized_var(val);\n\tint rc;\n\n\twhile (true) {\n\t\trc = cuse_parse_one(&p, end, &key, &val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (!rc)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"DEVNAME\") == 0)\n\t\t\tdevinfo->name = val;\n\t\telse\n\t\t\tprintk(KERN_WARNING \"CUSE: unknown device info \\\"%s\\\"\\n\",\n\t\t\t       key);\n\t}\n\n\tif (!devinfo->name || !strlen(devinfo->name)) {\n\t\tprintk(KERN_ERR \"CUSE: DEVNAME unspecified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)\n{\n\tchar *end = p + len;\n\tchar *uninitialized_var(key), *uninitialized_var(val);\n\tint rc;\n\n\twhile (true) {\n\t\trc = cuse_parse_one(&p, end, &key, &val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (!rc)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"DEVNAME\") == 0)\n\t\t\tdevinfo->name = val;\n\t\telse\n\t\t\tprintk(KERN_WARNING \"CUSE: unknown device info \\\"%s\\\"\\n\",\n\t\t\t       key);\n\t}\n\n\tif (!devinfo->name || !strlen(devinfo->name)) {\n\t\tprintk(KERN_ERR \"CUSE: DEVNAME unspecified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsigned",
            "arg->max_write",
            "4096"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsigned",
            "arg->max_read",
            "4096"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fc_to_cc",
          "args": [
            "fc"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "fc_to_cc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "70-73",
          "snippet": "static struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\n#define CUSE_CONNTBL_LEN\t64\n\nstatic DEFINE_MUTEX(cuse_lock);\nstatic struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];\nstatic struct class *cuse_class;\nstatic const struct file_operations cuse_frontend_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.read\t\t\t= cuse_read,\n\t.write\t\t\t= cuse_write,\n\t.open\t\t\t= cuse_open,\n\t.release\t\t= cuse_release,\n\t.unlocked_ioctl\t\t= cuse_file_ioctl,\n\t.compat_ioctl\t\t= cuse_file_compat_ioctl,\n\t.poll\t\t\t= fuse_file_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic void cuse_process_init_reply(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc), *pos;\n\tstruct cuse_init_out *arg = req->out.args[0].value;\n\tstruct page *page = req->pages[0];\n\tstruct cuse_devinfo devinfo = { };\n\tstruct device *dev;\n\tstruct cdev *cdev;\n\tdev_t devt;\n\tint rc, i;\n\n\tif (req->out.h.error ||\n\t    arg->major != FUSE_KERNEL_VERSION || arg->minor < 11) {\n\t\tgoto err;\n\t}\n\n\tfc->minor = arg->minor;\n\tfc->max_read = max_t(unsigned, arg->max_read, 4096);\n\tfc->max_write = max_t(unsigned, arg->max_write, 4096);\n\n\t/* parse init reply */\n\tcc->unrestricted_ioctl = arg->flags & CUSE_UNRESTRICTED_IOCTL;\n\n\trc = cuse_parse_devinfo(page_address(page), req->out.args[1].size,\n\t\t\t\t&devinfo);\n\tif (rc)\n\t\tgoto err;\n\n\t/* determine and reserve devt */\n\tdevt = MKDEV(arg->dev_major, arg->dev_minor);\n\tif (!MAJOR(devt))\n\t\trc = alloc_chrdev_region(&devt, MINOR(devt), 1, devinfo.name);\n\telse\n\t\trc = register_chrdev_region(devt, 1, devinfo.name);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"CUSE: failed to register chrdev region\\n\");\n\t\tgoto err;\n\t}\n\n\t/* devt determined, create device */\n\trc = -ENOMEM;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto err_region;\n\n\tdevice_initialize(dev);\n\tdev_set_uevent_suppress(dev, 1);\n\tdev->class = cuse_class;\n\tdev->devt = devt;\n\tdev->release = cuse_gendev_release;\n\tdev_set_drvdata(dev, cc);\n\tdev_set_name(dev, \"%s\", devinfo.name);\n\n\tmutex_lock(&cuse_lock);\n\n\t/* make sure the device-name is unique */\n\tfor (i = 0; i < CUSE_CONNTBL_LEN; ++i) {\n\t\tlist_for_each_entry(pos, &cuse_conntbl[i], list)\n\t\t\tif (!strcmp(dev_name(pos->dev), dev_name(dev)))\n\t\t\t\tgoto err_unlock;\n\t}\n\n\trc = device_add(dev);\n\tif (rc)\n\t\tgoto err_unlock;\n\n\t/* register cdev */\n\trc = -ENOMEM;\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto err_unlock;\n\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &cuse_frontend_fops;\n\n\trc = cdev_add(cdev, devt, 1);\n\tif (rc)\n\t\tgoto err_cdev;\n\n\tcc->dev = dev;\n\tcc->cdev = cdev;\n\n\t/* make the device available */\n\tlist_add(&cc->list, cuse_conntbl_head(devt));\n\tmutex_unlock(&cuse_lock);\n\n\t/* announce device availability */\n\tdev_set_uevent_suppress(dev, 0);\n\tkobject_uevent(&dev->kobj, KOBJ_ADD);\nout:\n\tkfree(arg);\n\t__free_page(page);\n\treturn;\n\nerr_cdev:\n\tcdev_del(cdev);\nerr_unlock:\n\tmutex_unlock(&cuse_lock);\n\tput_device(dev);\nerr_region:\n\tunregister_chrdev_region(devt, 1);\nerr:\n\tfuse_abort_conn(fc);\n\tgoto out;\n}"
  },
  {
    "function_name": "cuse_gendev_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "304-307",
    "snippet": "static void cuse_gendev_release(struct device *dev)\n{\n\tkfree(dev);\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic void cuse_gendev_release(struct device *dev)\n{\n\tkfree(dev);\n}"
  },
  {
    "function_name": "cuse_parse_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "277-302",
    "snippet": "static int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)\n{\n\tchar *end = p + len;\n\tchar *uninitialized_var(key), *uninitialized_var(val);\n\tint rc;\n\n\twhile (true) {\n\t\trc = cuse_parse_one(&p, end, &key, &val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (!rc)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"DEVNAME\") == 0)\n\t\t\tdevinfo->name = val;\n\t\telse\n\t\t\tprintk(KERN_WARNING \"CUSE: unknown device info \\\"%s\\\"\\n\",\n\t\t\t       key);\n\t}\n\n\tif (!devinfo->name || !strlen(devinfo->name)) {\n\t\tprintk(KERN_ERR \"CUSE: DEVNAME unspecified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CUSE: DEVNAME unspecified\\n\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "devinfo->name"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "\"DEVNAME\""
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cuse_parse_one",
          "args": [
            "&p",
            "end",
            "&key",
            "&val"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "cuse_parse_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "224-262",
          "snippet": "static int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)\n{\n\tchar *p = *pp;\n\tchar *key, *val;\n\n\twhile (p < end && *p == '\\0')\n\t\tp++;\n\tif (p == end)\n\t\treturn 0;\n\n\tif (end[-1] != '\\0') {\n\t\tprintk(KERN_ERR \"CUSE: info not properly terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkey = val = p;\n\tp += strlen(p);\n\n\tif (valp) {\n\t\tstrsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tval = key + strlen(key);\n\t\tkey = strstrip(key);\n\t\tval = strstrip(val);\n\t} else\n\t\tkey = strstrip(key);\n\n\tif (!strlen(key)) {\n\t\tprintk(KERN_ERR \"CUSE: zero length info key specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pp = p;\n\t*keyp = key;\n\tif (valp)\n\t\t*valp = val;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)\n{\n\tchar *p = *pp;\n\tchar *key, *val;\n\n\twhile (p < end && *p == '\\0')\n\t\tp++;\n\tif (p == end)\n\t\treturn 0;\n\n\tif (end[-1] != '\\0') {\n\t\tprintk(KERN_ERR \"CUSE: info not properly terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkey = val = p;\n\tp += strlen(p);\n\n\tif (valp) {\n\t\tstrsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tval = key + strlen(key);\n\t\tkey = strstrip(key);\n\t\tval = strstrip(val);\n\t} else\n\t\tkey = strstrip(key);\n\n\tif (!strlen(key)) {\n\t\tprintk(KERN_ERR \"CUSE: zero length info key specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pp = p;\n\t*keyp = key;\n\tif (valp)\n\t\t*valp = val;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)\n{\n\tchar *end = p + len;\n\tchar *uninitialized_var(key), *uninitialized_var(val);\n\tint rc;\n\n\twhile (true) {\n\t\trc = cuse_parse_one(&p, end, &key, &val);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (!rc)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"DEVNAME\") == 0)\n\t\t\tdevinfo->name = val;\n\t\telse\n\t\t\tprintk(KERN_WARNING \"CUSE: unknown device info \\\"%s\\\"\\n\",\n\t\t\t       key);\n\t}\n\n\tif (!devinfo->name || !strlen(devinfo->name)) {\n\t\tprintk(KERN_ERR \"CUSE: DEVNAME unspecified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cuse_parse_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "224-262",
    "snippet": "static int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)\n{\n\tchar *p = *pp;\n\tchar *key, *val;\n\n\twhile (p < end && *p == '\\0')\n\t\tp++;\n\tif (p == end)\n\t\treturn 0;\n\n\tif (end[-1] != '\\0') {\n\t\tprintk(KERN_ERR \"CUSE: info not properly terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkey = val = p;\n\tp += strlen(p);\n\n\tif (valp) {\n\t\tstrsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tval = key + strlen(key);\n\t\tkey = strstrip(key);\n\t\tval = strstrip(val);\n\t} else\n\t\tkey = strstrip(key);\n\n\tif (!strlen(key)) {\n\t\tprintk(KERN_ERR \"CUSE: zero length info key specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pp = p;\n\t*keyp = key;\n\tif (valp)\n\t\t*valp = val;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CUSE: zero length info key specified\\n\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "key"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "val"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "key"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&val",
            "\"=\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)\n{\n\tchar *p = *pp;\n\tchar *key, *val;\n\n\twhile (p < end && *p == '\\0')\n\t\tp++;\n\tif (p == end)\n\t\treturn 0;\n\n\tif (end[-1] != '\\0') {\n\t\tprintk(KERN_ERR \"CUSE: info not properly terminated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkey = val = p;\n\tp += strlen(p);\n\n\tif (valp) {\n\t\tstrsep(&val, \"=\");\n\t\tif (!val)\n\t\t\tval = key + strlen(key);\n\t\tkey = strstrip(key);\n\t\tval = strstrip(val);\n\t} else\n\t\tkey = strstrip(key);\n\n\tif (!strlen(key)) {\n\t\tprintk(KERN_ERR \"CUSE: zero length info key specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pp = p;\n\t*keyp = key;\n\tif (valp)\n\t\t*valp = val;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cuse_file_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "174-185",
    "snippet": "static long cuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fc);\n\tunsigned int flags = FUSE_IOCTL_COMPAT;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_do_ioctl",
          "args": [
            "file",
            "cmd",
            "arg",
            "flags"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2453-2632",
          "snippet": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fc_to_cc",
          "args": [
            "ff->fc"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "fc_to_cc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "70-73",
          "snippet": "static struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic long cuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fc);\n\tunsigned int flags = FUSE_IOCTL_COMPAT;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}"
  },
  {
    "function_name": "cuse_file_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "161-172",
    "snippet": "static long cuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fc);\n\tunsigned int flags = 0;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_do_ioctl",
          "args": [
            "file",
            "cmd",
            "arg",
            "flags"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2453-2632",
          "snippet": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct iovec *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n#if BITS_PER_LONG == 32\n\tinarg.flags |= FUSE_IOCTL_32BIT;\n#else\n\tif (flags & FUSE_IOCTL_COMPAT)\n\t\tinarg.flags |= FUSE_IOCTL_32BIT;\n#endif\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct fuse_ioctl_iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kcalloc(FUSE_MAX_PAGES_PER_REQ, sizeof(pages[0]), GFP_KERNEL);\n\tiov_page = (struct iovec *) __get_free_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = iov_page;\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc, num_pages);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\tfuse_page_descs_length_init(req, 0, req->num_pages);\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tvoid *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0]);\n\t\terr = fuse_copy_ioctl_iovec(fc, iov_page, vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = iov_page;\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tfree_page((unsigned long) iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fc_to_cc",
          "args": [
            "ff->fc"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "fc_to_cc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "70-73",
          "snippet": "static struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic long cuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(ff->fc);\n\tunsigned int flags = 0;\n\n\tif (cc->unrestricted_ioctl)\n\t\tflags |= FUSE_IOCTL_UNRESTRICTED;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}"
  },
  {
    "function_name": "cuse_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "150-159",
    "snippet": "static int cuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_sync_release(ff, file->f_flags);\n\tfuse_conn_put(fc);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_sync_release",
          "args": [
            "ff",
            "file->f_flags"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sync_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "298-307",
          "snippet": "void fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tff->reserved_req->background = 0;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tff->reserved_req->background = 0;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic int cuse_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_sync_release(ff, file->f_flags);\n\tfuse_conn_put(fc);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cuse_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "120-148",
    "snippet": "static int cuse_open(struct inode *inode, struct file *file)\n{\n\tdev_t devt = inode->i_cdev->dev;\n\tstruct cuse_conn *cc = NULL, *pos;\n\tint rc;\n\n\t/* look up and get the connection */\n\tmutex_lock(&cuse_lock);\n\tlist_for_each_entry(pos, cuse_conntbl_head(devt), list)\n\t\tif (pos->dev->devt == devt) {\n\t\t\tfuse_conn_get(&pos->fc);\n\t\t\tcc = pos;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&cuse_lock);\n\n\t/* dead? */\n\tif (!cc)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Generic permission check is already done against the chrdev\n\t * file, proceed to open.\n\t */\n\trc = fuse_do_open(&cc->fc, 0, file, 0);\n\tif (rc)\n\t\tfuse_conn_put(&cc->fc);\n\treturn rc;\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(cuse_lock);",
      "static DEVICE_ATTR(waiting, 0400, cuse_class_waiting_show, NULL);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "&cc->fc"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_do_open",
          "args": [
            "&cc->fc",
            "0",
            "file",
            "0"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "116-152",
          "snippet": "int fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->fh = 0;\n\tff->open_flags = FOPEN_KEEP_CACHE; /* Default for no-open */\n\tif (!fc->no_open || isdir) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS || isdir) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_file *ff;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\tff->fh = 0;\n\tff->open_flags = FOPEN_KEEP_CACHE; /* Default for no-open */\n\tif (!fc->no_open || isdir) {\n\t\tstruct fuse_open_out outarg;\n\t\tint err;\n\n\t\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\t\tif (!err) {\n\t\t\tff->fh = outarg.fh;\n\t\t\tff->open_flags = outarg.open_flags;\n\n\t\t} else if (err != -ENOSYS || isdir) {\n\t\t\tfuse_file_free(ff);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tfc->no_open = 1;\n\t\t}\n\t}\n\n\tif (isdir)\n\t\tff->open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->nodeid = nodeid;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cuse_lock"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_conn_get",
          "args": [
            "&pos->fc"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "609-613",
          "snippet": "struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\tatomic_inc(&fc->count);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\tatomic_inc(&fc->count);\n\treturn fc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "cuse_conntbl_head(devt)",
            "list"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cuse_conntbl_head",
          "args": [
            "devt"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "cuse_conntbl_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
          "lines": "75-78",
          "snippet": "static struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}",
          "includes": [
            "#include \"fuse_i.h\"",
            "#include <linux/module.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/magic.h>",
            "#include <linux/list.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/aio.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/device.h>",
            "#include <linux/cdev.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [
            "#define CUSE_CONNTBL_LEN\t64"
          ],
          "globals_used": [
            "static struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\n#define CUSE_CONNTBL_LEN\t64\n\nstatic struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];\n\nstatic struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cuse_lock"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic DEFINE_MUTEX(cuse_lock);\nstatic DEVICE_ATTR(waiting, 0400, cuse_class_waiting_show, NULL);\n\nstatic int cuse_open(struct inode *inode, struct file *file)\n{\n\tdev_t devt = inode->i_cdev->dev;\n\tstruct cuse_conn *cc = NULL, *pos;\n\tint rc;\n\n\t/* look up and get the connection */\n\tmutex_lock(&cuse_lock);\n\tlist_for_each_entry(pos, cuse_conntbl_head(devt), list)\n\t\tif (pos->dev->devt == devt) {\n\t\t\tfuse_conn_get(&pos->fc);\n\t\t\tcc = pos;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&cuse_lock);\n\n\t/* dead? */\n\tif (!cc)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Generic permission check is already done against the chrdev\n\t * file, proceed to open.\n\t */\n\trc = fuse_do_open(&cc->fc, 0, file, 0);\n\tif (rc)\n\t\tfuse_conn_put(&cc->fc);\n\treturn rc;\n}"
  },
  {
    "function_name": "cuse_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "103-118",
    "snippet": "static ssize_t cuse_write(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tloff_t pos = 0;\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = count };\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct iov_iter ii;\n\tiov_iter_init(&ii, WRITE, &iov, 1, count);\n\n\t/*\n\t * No locking or generic_write_checks(), the server is\n\t * responsible for locking and sanity checks.\n\t */\n\treturn fuse_direct_io(&io, &ii, &pos,\n\t\t\t      FUSE_DIO_WRITE | FUSE_DIO_CUSE);\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_direct_io",
          "args": [
            "&io",
            "&ii",
            "&pos",
            "FUSE_DIO_WRITE | FUSE_DIO_CUSE"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_direct_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1298-1377",
          "snippet": "ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&ii",
            "WRITE",
            "&iov",
            "1",
            "count"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic ssize_t cuse_write(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tloff_t pos = 0;\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = count };\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct iov_iter ii;\n\tiov_iter_init(&ii, WRITE, &iov, 1, count);\n\n\t/*\n\t * No locking or generic_write_checks(), the server is\n\t * responsible for locking and sanity checks.\n\t */\n\treturn fuse_direct_io(&io, &ii, &pos,\n\t\t\t      FUSE_DIO_WRITE | FUSE_DIO_CUSE);\n}"
  },
  {
    "function_name": "cuse_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "91-101",
    "snippet": "static ssize_t cuse_read(struct file *file, char __user *buf, size_t count,\n\t\t\t loff_t *ppos)\n{\n\tloff_t pos = 0;\n\tstruct iovec iov = { .iov_base = buf, .iov_len = count };\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct iov_iter ii;\n\tiov_iter_init(&ii, READ, &iov, 1, count);\n\n\treturn fuse_direct_io(&io, &ii, &pos, FUSE_DIO_CUSE);\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_direct_io",
          "args": [
            "&io",
            "&ii",
            "&pos",
            "FUSE_DIO_CUSE"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_direct_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1298-1377",
          "snippet": "ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,\n\t\t       loff_t *ppos, int flags)\n{\n\tint write = flags & FUSE_DIO_WRITE;\n\tint cuse = flags & FUSE_DIO_CUSE;\n\tstruct file *file = io->file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tsize_t count = iov_iter_count(iter);\n\tpgoff_t idx_from = pos >> PAGE_CACHE_SHIFT;\n\tpgoff_t idx_to = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\tif (io->async)\n\t\treq = fuse_get_req_for_background(fc, fuse_iter_npages(iter));\n\telse\n\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (!cuse && fuse_range_is_writeback(inode, idx_from, idx_to)) {\n\t\tif (!write)\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\tfuse_sync_writes(inode);\n\t\tif (!write)\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, iter, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, io, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, io, pos, nbytes, owner);\n\n\t\tif (!io->async)\n\t\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\tif (io->async)\n\t\t\t\treq = fuse_get_req_for_background(fc,\n\t\t\t\t\tfuse_iter_npages(iter));\n\t\t\telse\n\t\t\t\treq = fuse_get_req(fc, fuse_iter_npages(iter));\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&ii",
            "READ",
            "&iov",
            "1",
            "count"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic ssize_t cuse_read(struct file *file, char __user *buf, size_t count,\n\t\t\t loff_t *ppos)\n{\n\tloff_t pos = 0;\n\tstruct iovec iov = { .iov_base = buf, .iov_len = count };\n\tstruct fuse_io_priv io = { .async = 0, .file = file };\n\tstruct iov_iter ii;\n\tiov_iter_init(&ii, READ, &iov, 1, count);\n\n\treturn fuse_direct_io(&io, &ii, &pos, FUSE_DIO_CUSE);\n}"
  },
  {
    "function_name": "cuse_conntbl_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "75-78",
    "snippet": "static struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [
      "#define CUSE_CONNTBL_LEN\t64"
    ],
    "globals_used": [
      "static struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "devt"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "devt"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\n#define CUSE_CONNTBL_LEN\t64\n\nstatic struct list_head cuse_conntbl[CUSE_CONNTBL_LEN];\n\nstatic struct list_head *cuse_conntbl_head(dev_t devt)\n{\n\treturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\n}"
  },
  {
    "function_name": "fc_to_cc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/cuse.c",
    "lines": "70-73",
    "snippet": "static struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}",
    "includes": [
      "#include \"fuse_i.h\"",
      "#include <linux/module.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/magic.h>",
      "#include <linux/list.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/aio.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>",
      "#include <linux/fuse.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fc",
            "structcuse_conn",
            "fc"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fuse_i.h\"\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/magic.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/kdev_t.h>\n#include <linux/aio.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/fuse.h>\n\nstatic struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\n{\n\treturn container_of(fc, struct cuse_conn, fc);\n}"
  }
]