[
  {
    "function_name": "ntfs_truncate_vfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
    "lines": "321-321",
    "snippet": "static inline void ntfs_truncate_vfs(struct inode *vi) {}",
    "includes": [
      "#include \"debug.h\"",
      "#include \"runlist.h\"",
      "#include \"types.h\"",
      "#include \"volume.h\"",
      "#include \"layout.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_truncate_vfs(struct inode *vi) {}"
  },
  {
    "function_name": "ntfs_commit_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
    "lines": "312-317",
    "snippet": "static inline void ntfs_commit_inode(struct inode *vi)\n{\n\tif (!is_bad_inode(vi))\n\t\t__ntfs_write_inode(vi, 1);\n\treturn;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include \"runlist.h\"",
      "#include \"types.h\"",
      "#include \"volume.h\"",
      "#include \"layout.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ntfs_write_inode",
          "args": [
            "vi",
            "1"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2967-3110",
          "snippet": "int __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nint __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "vi"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_commit_inode(struct inode *vi)\n{\n\tif (!is_bad_inode(vi))\n\t\t__ntfs_write_inode(vi, 1);\n\treturn;\n}"
  },
  {
    "function_name": "ntfs_init_big_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
    "lines": "286-293",
    "snippet": "static inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include \"runlist.h\"",
      "#include \"types.h\"",
      "#include \"volume.h\"",
      "#include \"layout.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ntfs_init_inode",
          "args": [
            "vi->i_sb",
            "ni"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "394-419",
          "snippet": "void __ntfs_init_inode(struct super_block *sb, ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\trwlock_init(&ni->size_lock);\n\tni->initialized_size = ni->allocated_size = 0;\n\tni->seq_no = 0;\n\tatomic_set(&ni->count, 1);\n\tni->vol = NTFS_SB(sb);\n\tntfs_init_runlist(&ni->runlist);\n\tmutex_init(&ni->mrec_lock);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\tni->attr_list_size = 0;\n\tni->attr_list = NULL;\n\tntfs_init_runlist(&ni->attr_list_rl);\n\tlockdep_set_class(&ni->attr_list_rl.lock,\n\t\t\t\t&attr_list_rl_lock_class);\n\tni->itype.index.block_size = 0;\n\tni->itype.index.vcn_size = 0;\n\tni->itype.index.collation_rule = 0;\n\tni->itype.index.block_size_bits = 0;\n\tni->itype.index.vcn_size_bits = 0;\n\tmutex_init(&ni->extent_lock);\n\tni->nr_extents = 0;\n\tni->ext.base_ntfs_ino = NULL;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_class_key attr_list_rl_lock_class;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic struct lock_class_key attr_list_rl_lock_class;\n\nvoid __ntfs_init_inode(struct super_block *sb, ntfs_inode *ni)\n{\n\tntfs_debug(\"Entering.\");\n\trwlock_init(&ni->size_lock);\n\tni->initialized_size = ni->allocated_size = 0;\n\tni->seq_no = 0;\n\tatomic_set(&ni->count, 1);\n\tni->vol = NTFS_SB(sb);\n\tntfs_init_runlist(&ni->runlist);\n\tmutex_init(&ni->mrec_lock);\n\tni->page = NULL;\n\tni->page_ofs = 0;\n\tni->attr_list_size = 0;\n\tni->attr_list = NULL;\n\tntfs_init_runlist(&ni->attr_list_rl);\n\tlockdep_set_class(&ni->attr_list_rl.lock,\n\t\t\t\t&attr_list_rl_lock_class);\n\tni->itype.index.block_size = 0;\n\tni->itype.index.vcn_size = 0;\n\tni->itype.index.collation_rule = 0;\n\tni->itype.index.block_size_bits = 0;\n\tni->itype.index.vcn_size_bits = 0;\n\tmutex_init(&ni->extent_lock);\n\tni->nr_extents = 0;\n\tni->ext.base_ntfs_ino = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline void ntfs_init_big_inode(struct inode *vi)\n{\n\tntfs_inode *ni = NTFS_I(vi);\n\n\tntfs_debug(\"Entering.\");\n\t__ntfs_init_inode(vi->i_sb, ni);\n\tni->mft_no = vi->i_ino;\n}"
  },
  {
    "function_name": "VFS_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
    "lines": "245-248",
    "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include \"runlist.h\"",
      "#include \"types.h\"",
      "#include \"volume.h\"",
      "#include \"layout.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
  },
  {
    "function_name": "NTFS_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
    "lines": "240-243",
    "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include \"runlist.h\"",
      "#include \"types.h\"",
      "#include \"volume.h\"",
      "#include \"layout.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "inode",
            "big_ntfs_inode",
            "vfs_inode"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
  },
  {
    "function_name": "TAS_NINO_FNS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
    "lines": "210-232",
    "snippet": "NINO_FNS(Dirty)\nTAS_NINO_FNS(Dirty)\nNINO_FNS(AttrList)\nNINO_FNS(AttrListNonResident)\nNINO_FNS(Attr)\nNINO_FNS(MstProtected)\nNINO_FNS(NonResident)\nNINO_FNS(IndexAllocPresent)\nNINO_FNS(Compressed)\nNINO_FNS(Encrypted)\nNINO_FNS(Sparse)\nNINO_FNS(SparseDisabled)\nNINO_FNS(TruncateFailed)\n\n/*\n * The full structure containing a ntfs_inode and a vfs struct inode. Used for\n * all real and fake inodes but not for extent inodes which lack the vfs struct\n * inode.\n */\ntypedef struct {\n\tntfs_inode ntfs_inode;\n\tstruct inode vfs_inode;\t\t/* The vfs inode structure. */\n}",
    "includes": [
      "#include \"debug.h\"",
      "#include \"runlist.h\"",
      "#include \"types.h\"",
      "#include \"volume.h\"",
      "#include \"layout.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NINO_FNS",
          "args": [
            "TruncateFailed"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "TAS_NINO_FNS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "210-232",
          "snippet": "NINO_FNS(Dirty)\nTAS_NINO_FNS(Dirty)\nNINO_FNS(AttrList)\nNINO_FNS(AttrListNonResident)\nNINO_FNS(Attr)\nNINO_FNS(MstProtected)\nNINO_FNS(NonResident)\nNINO_FNS(IndexAllocPresent)\nNINO_FNS(Compressed)\nNINO_FNS(Encrypted)\nNINO_FNS(Sparse)\nNINO_FNS(SparseDisabled)\nNINO_FNS(TruncateFailed)\n\n/*\n * The full structure containing a ntfs_inode and a vfs struct inode. Used for\n * all real and fake inodes but not for extent inodes which lack the vfs struct\n * inode.\n */\ntypedef struct {\n\tntfs_inode ntfs_inode;\n\tstruct inode vfs_inode;\t\t/* The vfs inode structure. */\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nNINO_FNS(Dirty)\nTAS_NINO_FNS(Dirty)\nNINO_FNS(AttrList)\nNINO_FNS(AttrListNonResident)\nNINO_FNS(Attr)\nNINO_FNS(MstProtected)\nNINO_FNS(NonResident)\nNINO_FNS(IndexAllocPresent)\nNINO_FNS(Compressed)\nNINO_FNS(Encrypted)\nNINO_FNS(Sparse)\nNINO_FNS(SparseDisabled)\nNINO_FNS(TruncateFailed)\n\n/*\n * The full structure containing a ntfs_inode and a vfs struct inode. Used for\n * all real and fake inodes but not for extent inodes which lack the vfs struct\n * inode.\n */\ntypedef struct {\n\tntfs_inode ntfs_inode;\n\tstruct inode vfs_inode;\t\t/* The vfs inode structure. */\n}"
  }
]