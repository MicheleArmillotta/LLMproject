[
  {
    "function_name": "kernfs_iop_put_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/symlink.c",
    "lines": "128-134",
    "snippet": "static void kernfs_iop_put_link(struct dentry *dentry, struct nameidata *nd,\n\t\t\t\tvoid *cookie)\n{\n\tchar *page = nd_get_link(nd);\n\tif (!IS_ERR(page))\n\t\tfree_page((unsigned long)page);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_get_link",
          "args": [
            "nd"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "nd_get_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "723-726",
          "snippet": "char *nd_get_link(struct nameidata *nd)\n{\n\treturn nd->saved_names[nd->depth];\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nchar *nd_get_link(struct nameidata *nd)\n{\n\treturn nd->saved_names[nd->depth];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic void kernfs_iop_put_link(struct dentry *dentry, struct nameidata *nd,\n\t\t\t\tvoid *cookie)\n{\n\tchar *page = nd_get_link(nd);\n\tif (!IS_ERR(page))\n\t\tfree_page((unsigned long)page);\n}"
  },
  {
    "function_name": "kernfs_iop_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/symlink.c",
    "lines": "115-126",
    "snippet": "static void *kernfs_iop_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tint error = -ENOMEM;\n\tunsigned long page = get_zeroed_page(GFP_KERNEL);\n\tif (page) {\n\t\terror = kernfs_getlink(dentry, (char *) page);\n\t\tif (error < 0)\n\t\t\tfree_page((unsigned long)page);\n\t}\n\tnd_set_link(nd, error ? ERR_PTR(error) : (char *)page);\n\treturn NULL;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "error ? ERR_PTR(error) : (char *)page"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_getlink",
          "args": [
            "dentry",
            "(char *) page"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_getlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/symlink.c",
          "lines": "101-113",
          "snippet": "static int kernfs_getlink(struct dentry *dentry, char *path)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_node *target = kn->symlink.target_kn;\n\tint error;\n\n\tmutex_lock(&kernfs_mutex);\n\terror = kernfs_get_target_path(parent, target, path);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn error;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int kernfs_getlink(struct dentry *dentry, char *path)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_node *target = kn->symlink.target_kn;\n\tint error;\n\n\tmutex_lock(&kernfs_mutex);\n\terror = kernfs_get_target_path(parent, target, path);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic void *kernfs_iop_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tint error = -ENOMEM;\n\tunsigned long page = get_zeroed_page(GFP_KERNEL);\n\tif (page) {\n\t\terror = kernfs_getlink(dentry, (char *) page);\n\t\tif (error < 0)\n\t\t\tfree_page((unsigned long)page);\n\t}\n\tnd_set_link(nd, error ? ERR_PTR(error) : (char *)page);\n\treturn NULL;\n}"
  },
  {
    "function_name": "kernfs_getlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/symlink.c",
    "lines": "101-113",
    "snippet": "static int kernfs_getlink(struct dentry *dentry, char *path)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_node *target = kn->symlink.target_kn;\n\tint error;\n\n\tmutex_lock(&kernfs_mutex);\n\terror = kernfs_get_target_path(parent, target, path);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn error;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_target_path",
          "args": [
            "parent",
            "target",
            "path"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_target_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/symlink.c",
          "lines": "49-99",
          "snippet": "static int kernfs_get_target_path(struct kernfs_node *parent,\n\t\t\t\t  struct kernfs_node *target, char *path)\n{\n\tstruct kernfs_node *base, *kn;\n\tchar *s = path;\n\tint len = 0;\n\n\t/* go up to the root, stop at the base */\n\tbase = parent;\n\twhile (base->parent) {\n\t\tkn = target->parent;\n\t\twhile (kn->parent && base != kn)\n\t\t\tkn = kn->parent;\n\n\t\tif (base == kn)\n\t\t\tbreak;\n\n\t\tstrcpy(s, \"../\");\n\t\ts += 3;\n\t\tbase = base->parent;\n\t}\n\n\t/* determine end of target string for reverse fillup */\n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tlen += strlen(kn->name) + 1;\n\t\tkn = kn->parent;\n\t}\n\n\t/* check limits */\n\tif (len < 2)\n\t\treturn -EINVAL;\n\tlen--;\n\tif ((s - path) + len > PATH_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\t/* reverse fillup of target string from target to base */\n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tint slen = strlen(kn->name);\n\n\t\tlen -= slen;\n\t\tstrncpy(s + len, kn->name, slen);\n\t\tif (len)\n\t\t\ts[--len] = '/';\n\n\t\tkn = kn->parent;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int kernfs_get_target_path(struct kernfs_node *parent,\n\t\t\t\t  struct kernfs_node *target, char *path)\n{\n\tstruct kernfs_node *base, *kn;\n\tchar *s = path;\n\tint len = 0;\n\n\t/* go up to the root, stop at the base */\n\tbase = parent;\n\twhile (base->parent) {\n\t\tkn = target->parent;\n\t\twhile (kn->parent && base != kn)\n\t\t\tkn = kn->parent;\n\n\t\tif (base == kn)\n\t\t\tbreak;\n\n\t\tstrcpy(s, \"../\");\n\t\ts += 3;\n\t\tbase = base->parent;\n\t}\n\n\t/* determine end of target string for reverse fillup */\n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tlen += strlen(kn->name) + 1;\n\t\tkn = kn->parent;\n\t}\n\n\t/* check limits */\n\tif (len < 2)\n\t\treturn -EINVAL;\n\tlen--;\n\tif ((s - path) + len > PATH_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\t/* reverse fillup of target string from target to base */\n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tint slen = strlen(kn->name);\n\n\t\tlen -= slen;\n\t\tstrncpy(s + len, kn->name, slen);\n\t\tif (len)\n\t\t\ts[--len] = '/';\n\n\t\tkn = kn->parent;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int kernfs_getlink(struct dentry *dentry, char *path)\n{\n\tstruct kernfs_node *kn = dentry->d_fsdata;\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_node *target = kn->symlink.target_kn;\n\tint error;\n\n\tmutex_lock(&kernfs_mutex);\n\terror = kernfs_get_target_path(parent, target, path);\n\tmutex_unlock(&kernfs_mutex);\n\n\treturn error;\n}"
  },
  {
    "function_name": "kernfs_get_target_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/symlink.c",
    "lines": "49-99",
    "snippet": "static int kernfs_get_target_path(struct kernfs_node *parent,\n\t\t\t\t  struct kernfs_node *target, char *path)\n{\n\tstruct kernfs_node *base, *kn;\n\tchar *s = path;\n\tint len = 0;\n\n\t/* go up to the root, stop at the base */\n\tbase = parent;\n\twhile (base->parent) {\n\t\tkn = target->parent;\n\t\twhile (kn->parent && base != kn)\n\t\t\tkn = kn->parent;\n\n\t\tif (base == kn)\n\t\t\tbreak;\n\n\t\tstrcpy(s, \"../\");\n\t\ts += 3;\n\t\tbase = base->parent;\n\t}\n\n\t/* determine end of target string for reverse fillup */\n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tlen += strlen(kn->name) + 1;\n\t\tkn = kn->parent;\n\t}\n\n\t/* check limits */\n\tif (len < 2)\n\t\treturn -EINVAL;\n\tlen--;\n\tif ((s - path) + len > PATH_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\t/* reverse fillup of target string from target to base */\n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tint slen = strlen(kn->name);\n\n\t\tlen -= slen;\n\t\tstrncpy(s + len, kn->name, slen);\n\t\tif (len)\n\t\t\ts[--len] = '/';\n\n\t\tkn = kn->parent;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "s + len",
            "kn->name",
            "slen"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kn->name"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "s",
            "\"../\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int kernfs_get_target_path(struct kernfs_node *parent,\n\t\t\t\t  struct kernfs_node *target, char *path)\n{\n\tstruct kernfs_node *base, *kn;\n\tchar *s = path;\n\tint len = 0;\n\n\t/* go up to the root, stop at the base */\n\tbase = parent;\n\twhile (base->parent) {\n\t\tkn = target->parent;\n\t\twhile (kn->parent && base != kn)\n\t\t\tkn = kn->parent;\n\n\t\tif (base == kn)\n\t\t\tbreak;\n\n\t\tstrcpy(s, \"../\");\n\t\ts += 3;\n\t\tbase = base->parent;\n\t}\n\n\t/* determine end of target string for reverse fillup */\n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tlen += strlen(kn->name) + 1;\n\t\tkn = kn->parent;\n\t}\n\n\t/* check limits */\n\tif (len < 2)\n\t\treturn -EINVAL;\n\tlen--;\n\tif ((s - path) + len > PATH_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\t/* reverse fillup of target string from target to base */\n\tkn = target;\n\twhile (kn->parent && kn != base) {\n\t\tint slen = strlen(kn->name);\n\n\t\tlen -= slen;\n\t\tstrncpy(s + len, kn->name, slen);\n\t\tif (len)\n\t\t\ts[--len] = '/';\n\n\t\tkn = kn->parent;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_create_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/symlink.c",
    "lines": "25-47",
    "snippet": "struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,\n\t\t\t\t       const char *name,\n\t\t\t\t       struct kernfs_node *target)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tkn = kernfs_new_node(parent, name, S_IFLNK|S_IRWXUGO, KERNFS_LINK);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tkn->ns = target->ns;\n\tkn->symlink.target_kn = target;\n\tkernfs_get(target);\t/* ref owned by symlink */\n\n\terror = kernfs_add_one(kn);\n\tif (!error)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/namei.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_add_one",
          "args": [
            "kn"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_add_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "569-620",
          "snippet": "int kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif ((parent->flags & KERNFS_ACTIVATED) && !kernfs_active(parent))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* Update timestamps on the parent */\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tstruct iattr *ps_iattrs = &ps_iattr->ia_iattr;\n\t\tps_iattrs->ia_ctime = ps_iattrs->ia_mtime = CURRENT_TIME;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Activate the new node unless CREATE_DEACTIVATED is requested.\n\t * If not activated here, the kernfs user is responsible for\n\t * activating the node with kernfs_activate().  A node which hasn't\n\t * been activated is not visible to userland and its removal won't\n\t * trigger deactivation.\n\t */\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nint kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif ((parent->flags & KERNFS_ACTIVATED) && !kernfs_active(parent))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* Update timestamps on the parent */\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tstruct iattr *ps_iattrs = &ps_iattr->ia_iattr;\n\t\tps_iattrs->ia_ctime = ps_iattrs->ia_mtime = CURRENT_TIME;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Activate the new node unless CREATE_DEACTIVATED is requested.\n\t * If not activated here, the kernfs user is responsible for\n\t * activating the node with kernfs_activate().  A node which hasn't\n\t * been activated is not visible to userland and its removal won't\n\t * trigger deactivation.\n\t */\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "target"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_ns_enabled",
          "args": [
            "parent"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_new_node",
          "args": [
            "parent",
            "name",
            "S_IFLNK|S_IRWXUGO",
            "KERNFS_LINK"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_new_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "543-555",
          "snippet": "struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), name, mode, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), name, mode, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/namei.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstruct kernfs_node *kernfs_create_link(struct kernfs_node *parent,\n\t\t\t\t       const char *name,\n\t\t\t\t       struct kernfs_node *target)\n{\n\tstruct kernfs_node *kn;\n\tint error;\n\n\tkn = kernfs_new_node(parent, name, S_IFLNK|S_IRWXUGO, KERNFS_LINK);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (kernfs_ns_enabled(parent))\n\t\tkn->ns = target->ns;\n\tkn->symlink.target_kn = target;\n\tkernfs_get(target);\t/* ref owned by symlink */\n\n\terror = kernfs_add_one(kn);\n\tif (!error)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(error);\n}"
  }
]