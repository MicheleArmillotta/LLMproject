[
  {
    "function_name": "ecryptfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "541-553",
    "snippet": "static sector_t ecryptfs_bmap(struct address_space *mapping, sector_t block)\n{\n\tint rc = 0;\n\tstruct inode *inode;\n\tstruct inode *lower_inode;\n\n\tinode = (struct inode *)mapping->host;\n\tlower_inode = ecryptfs_inode_to_lower(inode);\n\tif (lower_inode->i_mapping->a_ops->bmap)\n\t\trc = lower_inode->i_mapping->a_ops->bmap(lower_inode->i_mapping,\n\t\t\t\t\t\t\t block);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lower_inode->i_mapping->a_ops->bmap",
          "args": [
            "lower_inode->i_mapping",
            "block"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1502-1508",
          "snippet": "sector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nsector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "inode"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic sector_t ecryptfs_bmap(struct address_space *mapping, sector_t block)\n{\n\tint rc = 0;\n\tstruct inode *inode;\n\tstruct inode *lower_inode;\n\n\tinode = (struct inode *)mapping->host;\n\tlower_inode = ecryptfs_inode_to_lower(inode);\n\tif (lower_inode->i_mapping->a_ops->bmap)\n\t\trc = lower_inode->i_mapping->a_ops->bmap(lower_inode->i_mapping,\n\t\t\t\t\t\t\t block);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "478-539",
    "snippet": "static int ecryptfs_write_end(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + copied;\n\tstruct inode *ecryptfs_inode = mapping->host;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc;\n\n\tecryptfs_printk(KERN_DEBUG, \"Calling fill_zeros_to_end_of_page\"\n\t\t\t\"(page w/ index = [0x%.16lx], to = [%d])\\n\", index, to);\n\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\trc = ecryptfs_write_lower_page_segment(ecryptfs_inode, page, 0,\n\t\t\t\t\t\t       to);\n\t\tif (!rc) {\n\t\t\trc = copied;\n\t\t\tfsstack_copy_inode_size(ecryptfs_inode,\n\t\t\t\tecryptfs_inode_to_lower(ecryptfs_inode));\n\t\t}\n\t\tgoto out;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tif (copied < PAGE_CACHE_SIZE) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\t/* Fills in zeros if 'to' goes beyond inode size */\n\trc = fill_zeros_to_end_of_page(page, to);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to fill \"\n\t\t\t\"zeros in page with index = [0x%.16lx]\\n\", index);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_encrypt_page(page);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error encrypting page (upper \"\n\t\t\t\t\"index [0x%.16lx])\\n\", index);\n\t\tgoto out;\n\t}\n\tif (pos + copied > i_size_read(ecryptfs_inode)) {\n\t\ti_size_write(ecryptfs_inode, pos + copied);\n\t\tecryptfs_printk(KERN_DEBUG, \"Expanded file size to \"\n\t\t\t\"[0x%.16llx]\\n\",\n\t\t\t(unsigned long long)i_size_read(ecryptfs_inode));\n\t}\n\trc = ecryptfs_write_inode_size_to_metadata(ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing inode size to metadata; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\telse\n\t\trc = copied;\nout:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error writing inode size to metadata; \"\n\t\t       \"rc = [%d]\\n\"",
            "rc"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_inode_size_to_metadata",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_inode_size_to_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "456-466",
          "snippet": "int ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "ecryptfs_inode",
            "pos + copied"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_encrypt_page",
          "args": [
            "page"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_encrypt_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "486-537",
          "snippet": "int ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_CACHE_SIZE);\n\tkunmap(enc_extent_page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ENCRYPT\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nint ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_CACHE_SIZE);\n\tkunmap(enc_extent_page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_zeros_to_end_of_page",
          "args": [
            "page",
            "to"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "fill_zeros_to_end_of_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "249-262",
          "snippet": "static int fill_zeros_to_end_of_page(struct page *page, unsigned int to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint end_byte_in_page;\n\n\tif ((i_size_read(inode) / PAGE_CACHE_SIZE) != page->index)\n\t\tgoto out;\n\tend_byte_in_page = i_size_read(inode) % PAGE_CACHE_SIZE;\n\tif (to > end_byte_in_page)\n\t\tend_byte_in_page = to;\n\tzero_user_segment(page, end_byte_in_page, PAGE_CACHE_SIZE);\nout:\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int fill_zeros_to_end_of_page(struct page *page, unsigned int to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint end_byte_in_page;\n\n\tif ((i_size_read(inode) / PAGE_CACHE_SIZE) != page->index)\n\t\tgoto out;\n\tend_byte_in_page = i_size_read(inode) % PAGE_CACHE_SIZE;\n\tif (to > end_byte_in_page)\n\t\tend_byte_in_page = to;\n\tzero_user_segment(page, end_byte_in_page, PAGE_CACHE_SIZE);\nout:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsstack_copy_inode_size",
          "args": [
            "ecryptfs_inode",
            "ecryptfs_inode_to_lower(ecryptfs_inode)"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "fsstack_copy_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stack.c",
          "lines": "10-59",
          "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
          "includes": [
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_lower_page_segment",
          "args": [
            "ecryptfs_inode",
            "page",
            "0",
            "to"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "69-85",
          "snippet": "int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int ecryptfs_write_end(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + copied;\n\tstruct inode *ecryptfs_inode = mapping->host;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tint rc;\n\n\tecryptfs_printk(KERN_DEBUG, \"Calling fill_zeros_to_end_of_page\"\n\t\t\t\"(page w/ index = [0x%.16lx], to = [%d])\\n\", index, to);\n\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\trc = ecryptfs_write_lower_page_segment(ecryptfs_inode, page, 0,\n\t\t\t\t\t\t       to);\n\t\tif (!rc) {\n\t\t\trc = copied;\n\t\t\tfsstack_copy_inode_size(ecryptfs_inode,\n\t\t\t\tecryptfs_inode_to_lower(ecryptfs_inode));\n\t\t}\n\t\tgoto out;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tif (copied < PAGE_CACHE_SIZE) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\t/* Fills in zeros if 'to' goes beyond inode size */\n\trc = fill_zeros_to_end_of_page(page, to);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to fill \"\n\t\t\t\"zeros in page with index = [0x%.16lx]\\n\", index);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_encrypt_page(page);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error encrypting page (upper \"\n\t\t\t\t\"index [0x%.16lx])\\n\", index);\n\t\tgoto out;\n\t}\n\tif (pos + copied > i_size_read(ecryptfs_inode)) {\n\t\ti_size_write(ecryptfs_inode, pos + copied);\n\t\tecryptfs_printk(KERN_DEBUG, \"Expanded file size to \"\n\t\t\t\"[0x%.16llx]\\n\",\n\t\t\t(unsigned long long)i_size_read(ecryptfs_inode));\n\t}\n\trc = ecryptfs_write_inode_size_to_metadata(ecryptfs_inode);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error writing inode size to metadata; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\telse\n\t\trc = copied;\nout:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_inode_size_to_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "456-466",
    "snippet": "int ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_write_inode_size_to_header",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_inode_size_to_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "392-413",
          "snippet": "static int ecryptfs_write_inode_size_to_header(struct inode *ecryptfs_inode)\n{\n\tchar *file_size_virt;\n\tint rc;\n\n\tfile_size_virt = kmalloc(sizeof(u64), GFP_KERNEL);\n\tif (!file_size_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), file_size_virt);\n\trc = ecryptfs_write_lower(ecryptfs_inode, file_size_virt, 0,\n\t\t\t\t  sizeof(u64));\n\tkfree(file_size_virt);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error writing file size to header; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int ecryptfs_write_inode_size_to_header(struct inode *ecryptfs_inode)\n{\n\tchar *file_size_virt;\n\tint rc;\n\n\tfile_size_virt = kmalloc(sizeof(u64), GFP_KERNEL);\n\tif (!file_size_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), file_size_virt);\n\trc = ecryptfs_write_lower(ecryptfs_inode, file_size_virt, 0,\n\t\t\t\t  sizeof(u64));\n\tkfree(file_size_virt);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error writing file size to header; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_inode_size_to_xattr",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_inode_size_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "417-454",
          "snippet": "static int ecryptfs_write_inode_size_to_xattr(struct inode *ecryptfs_inode)\n{\n\tssize_t size;\n\tvoid *xattr_virt;\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tstruct inode *lower_inode = lower_dentry->d_inode;\n\tint rc;\n\n\tif (!lower_inode->i_op->getxattr || !lower_inode->i_op->setxattr) {\n\t\tprintk(KERN_WARNING\n\t\t       \"No support for setting xattr in lower filesystem\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\txattr_virt = kmem_cache_alloc(ecryptfs_xattr_cache, GFP_KERNEL);\n\tif (!xattr_virt) {\n\t\tprintk(KERN_ERR \"Out of memory whilst attempting to write \"\n\t\t       \"inode size to xattr\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_inode->i_mutex);\n\tsize = lower_inode->i_op->getxattr(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t\t   xattr_virt, PAGE_CACHE_SIZE);\n\tif (size < 0)\n\t\tsize = 8;\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), xattr_virt);\n\trc = lower_inode->i_op->setxattr(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t\t xattr_virt, size, 0);\n\tmutex_unlock(&lower_inode->i_mutex);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error whilst attempting to write inode size \"\n\t\t       \"to lower file xattr; rc = [%d]\\n\", rc);\n\tkmem_cache_free(ecryptfs_xattr_cache, xattr_virt);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct kmem_cache *ecryptfs_xattr_cache;\n\nstatic int ecryptfs_write_inode_size_to_xattr(struct inode *ecryptfs_inode)\n{\n\tssize_t size;\n\tvoid *xattr_virt;\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tstruct inode *lower_inode = lower_dentry->d_inode;\n\tint rc;\n\n\tif (!lower_inode->i_op->getxattr || !lower_inode->i_op->setxattr) {\n\t\tprintk(KERN_WARNING\n\t\t       \"No support for setting xattr in lower filesystem\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\txattr_virt = kmem_cache_alloc(ecryptfs_xattr_cache, GFP_KERNEL);\n\tif (!xattr_virt) {\n\t\tprintk(KERN_ERR \"Out of memory whilst attempting to write \"\n\t\t       \"inode size to xattr\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_inode->i_mutex);\n\tsize = lower_inode->i_op->getxattr(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t\t   xattr_virt, PAGE_CACHE_SIZE);\n\tif (size < 0)\n\t\tsize = 8;\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), xattr_virt);\n\trc = lower_inode->i_op->setxattr(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t\t xattr_virt, size, 0);\n\tmutex_unlock(&lower_inode->i_mutex);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error whilst attempting to write inode size \"\n\t\t       \"to lower file xattr; rc = [%d]\\n\", rc);\n\tkmem_cache_free(ecryptfs_xattr_cache, xattr_virt);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}"
  },
  {
    "function_name": "ecryptfs_write_inode_size_to_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "417-454",
    "snippet": "static int ecryptfs_write_inode_size_to_xattr(struct inode *ecryptfs_inode)\n{\n\tssize_t size;\n\tvoid *xattr_virt;\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tstruct inode *lower_inode = lower_dentry->d_inode;\n\tint rc;\n\n\tif (!lower_inode->i_op->getxattr || !lower_inode->i_op->setxattr) {\n\t\tprintk(KERN_WARNING\n\t\t       \"No support for setting xattr in lower filesystem\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\txattr_virt = kmem_cache_alloc(ecryptfs_xattr_cache, GFP_KERNEL);\n\tif (!xattr_virt) {\n\t\tprintk(KERN_ERR \"Out of memory whilst attempting to write \"\n\t\t       \"inode size to xattr\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_inode->i_mutex);\n\tsize = lower_inode->i_op->getxattr(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t\t   xattr_virt, PAGE_CACHE_SIZE);\n\tif (size < 0)\n\t\tsize = 8;\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), xattr_virt);\n\trc = lower_inode->i_op->setxattr(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t\t xattr_virt, size, 0);\n\tmutex_unlock(&lower_inode->i_mutex);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error whilst attempting to write inode size \"\n\t\t       \"to lower file xattr; rc = [%d]\\n\", rc);\n\tkmem_cache_free(ecryptfs_xattr_cache, xattr_virt);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_xattr_cache",
            "xattr_virt"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error whilst attempting to write inode size \"\n\t\t       \"to lower file xattr; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lower_inode->i_mutex"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_inode->i_op->setxattr",
          "args": [
            "lower_dentry",
            "ECRYPTFS_XATTR_NAME",
            "xattr_virt",
            "size",
            "0"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "321-365",
          "snippet": "static long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\t/* If non-NULL, we used vmalloc() */\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\t/* If non-NULL, we used vmalloc() */\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unaligned_be64",
          "args": [
            "i_size_read(ecryptfs_inode)",
            "xattr_virt"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_inode->i_op->getxattr",
          "args": [
            "lower_dentry",
            "ECRYPTFS_XATTR_NAME",
            "xattr_virt",
            "PAGE_CACHE_SIZE"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "425-469",
          "snippet": "static ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lower_inode->i_mutex"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ecryptfs_xattr_cache",
            "GFP_KERNEL"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct kmem_cache *ecryptfs_xattr_cache;\n\nstatic int ecryptfs_write_inode_size_to_xattr(struct inode *ecryptfs_inode)\n{\n\tssize_t size;\n\tvoid *xattr_virt;\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tstruct inode *lower_inode = lower_dentry->d_inode;\n\tint rc;\n\n\tif (!lower_inode->i_op->getxattr || !lower_inode->i_op->setxattr) {\n\t\tprintk(KERN_WARNING\n\t\t       \"No support for setting xattr in lower filesystem\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\txattr_virt = kmem_cache_alloc(ecryptfs_xattr_cache, GFP_KERNEL);\n\tif (!xattr_virt) {\n\t\tprintk(KERN_ERR \"Out of memory whilst attempting to write \"\n\t\t       \"inode size to xattr\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_inode->i_mutex);\n\tsize = lower_inode->i_op->getxattr(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t\t   xattr_virt, PAGE_CACHE_SIZE);\n\tif (size < 0)\n\t\tsize = 8;\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), xattr_virt);\n\trc = lower_inode->i_op->setxattr(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t\t xattr_virt, size, 0);\n\tmutex_unlock(&lower_inode->i_mutex);\n\tif (rc)\n\t\tprintk(KERN_ERR \"Error whilst attempting to write inode size \"\n\t\t       \"to lower file xattr; rc = [%d]\\n\", rc);\n\tkmem_cache_free(ecryptfs_xattr_cache, xattr_virt);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_inode_size_to_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "392-413",
    "snippet": "static int ecryptfs_write_inode_size_to_header(struct inode *ecryptfs_inode)\n{\n\tchar *file_size_virt;\n\tint rc;\n\n\tfile_size_virt = kmalloc(sizeof(u64), GFP_KERNEL);\n\tif (!file_size_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), file_size_virt);\n\trc = ecryptfs_write_lower(ecryptfs_inode, file_size_virt, 0,\n\t\t\t\t  sizeof(u64));\n\tkfree(file_size_virt);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error writing file size to header; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error writing file size to header; \"\n\t\t       \"rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "file_size_virt"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_lower",
          "args": [
            "ecryptfs_inode",
            "file_size_virt",
            "0",
            "sizeof(u64)"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "69-85",
          "snippet": "int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unaligned_be64",
          "args": [
            "i_size_read(ecryptfs_inode)",
            "file_size_virt"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(u64)",
            "GFP_KERNEL"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int ecryptfs_write_inode_size_to_header(struct inode *ecryptfs_inode)\n{\n\tchar *file_size_virt;\n\tint rc;\n\n\tfile_size_virt = kmalloc(sizeof(u64), GFP_KERNEL);\n\tif (!file_size_virt) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tput_unaligned_be64(i_size_read(ecryptfs_inode), file_size_virt);\n\trc = ecryptfs_write_lower(ecryptfs_inode, file_size_virt, 0,\n\t\t\t\t  sizeof(u64));\n\tkfree(file_size_virt);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error writing file size to header; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "278-383",
    "snippet": "static int ecryptfs_write_begin(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tloff_t prev_page_end_size;\n\tint rc = 0;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tprev_page_end_size = ((loff_t)index << PAGE_CACHE_SHIFT);\n\tif (!PageUptodate(page)) {\n\t\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t\t&ecryptfs_inode_to_private(mapping->host)->crypt_stat;\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, index, 0, PAGE_CACHE_SIZE, mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attemping to read \"\n\t\t\t\t       \"lower page segment; rc = [%d]\\n\",\n\t\t\t\t       __func__, rc);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\tSetPageUptodate(page);\n\t\t} else if (crypt_stat->flags & ECRYPTFS_VIEW_AS_ENCRYPTED) {\n\t\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\t\t\trc = ecryptfs_copy_up_encrypted_with_header(\n\t\t\t\t\tpage, crypt_stat);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error attempting \"\n\t\t\t\t\t       \"to copy the encrypted content \"\n\t\t\t\t\t       \"from the lower file whilst \"\n\t\t\t\t\t       \"inserting the metadata from \"\n\t\t\t\t\t       \"the xattr into the header; rc \"\n\t\t\t\t\t       \"= [%d]\\n\", __func__, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t} else {\n\t\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\t\tpage, index, 0, PAGE_CACHE_SIZE,\n\t\t\t\t\tmapping->host);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error reading \"\n\t\t\t\t\t       \"page; rc = [%d]\\n\",\n\t\t\t\t\t       __func__, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t}\n\t\t} else {\n\t\t\tif (prev_page_end_size\n\t\t\t    >= i_size_read(page->mapping->host)) {\n\t\t\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t} else if (len < PAGE_CACHE_SIZE) {\n\t\t\t\trc = ecryptfs_decrypt_page(page);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error decrypting \"\n\t\t\t\t\t       \"page at index [%ld]; \"\n\t\t\t\t\t       \"rc = [%d]\\n\",\n\t\t\t\t\t       __func__, page->index, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t}\n\t\t}\n\t}\n\t/* If creating a page or more of holes, zero them out via truncate.\n\t * Note, this will increase i_size. */\n\tif (index != 0) {\n\t\tif (prev_page_end_size > i_size_read(page->mapping->host)) {\n\t\t\trc = ecryptfs_truncate(file->f_path.dentry,\n\t\t\t\t\t       prev_page_end_size);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error on attempt to \"\n\t\t\t\t       \"truncate to (higher) offset [%lld];\"\n\t\t\t\t       \" rc = [%d]\\n\", __func__,\n\t\t\t\t       prev_page_end_size, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t/* Writing to a new page, and creating a small hole from start\n\t * of page?  Zero it out. */\n\tif ((i_size_read(mapping->host) == prev_page_end_size)\n\t    && (pos != 0))\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\nout:\n\tif (unlikely(rc)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\t*pagep = NULL;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error on attempt to \"\n\t\t\t\t       \"truncate to (higher) offset [%lld];\"\n\t\t\t\t       \" rc = [%d]\\n\"",
            "__func__",
            "prev_page_end_size",
            "rc"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_truncate",
          "args": [
            "file->f_path.dentry",
            "prev_page_end_size"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "855-874",
          "snippet": "int ecryptfs_truncate(struct dentry *dentry, loff_t new_length)\n{\n\tstruct iattr ia = { .ia_valid = ATTR_SIZE, .ia_size = new_length };\n\tstruct iattr lower_ia = { .ia_valid = 0 };\n\tint rc;\n\n\trc = ecryptfs_inode_newsize_ok(dentry->d_inode, new_length);\n\tif (rc)\n\t\treturn rc;\n\n\trc = truncate_upper(dentry, &ia, &lower_ia);\n\tif (!rc && lower_ia.ia_valid & ATTR_SIZE) {\n\t\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\n\t\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\t\trc = notify_change(lower_dentry, &lower_ia, NULL);\n\t\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nint ecryptfs_truncate(struct dentry *dentry, loff_t new_length)\n{\n\tstruct iattr ia = { .ia_valid = ATTR_SIZE, .ia_size = new_length };\n\tstruct iattr lower_ia = { .ia_valid = 0 };\n\tint rc;\n\n\trc = ecryptfs_inode_newsize_ok(dentry->d_inode, new_length);\n\tif (rc)\n\t\treturn rc;\n\n\trc = truncate_upper(dentry, &ia, &lower_ia);\n\tif (!rc && lower_ia.ia_valid & ATTR_SIZE) {\n\t\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\n\t\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\t\trc = notify_change(lower_dentry, &lower_ia, NULL);\n\t\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "page->mapping->host"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_decrypt_page",
          "args": [
            "page"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_decrypt_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "555-594",
          "snippet": "int ecryptfs_decrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *page_virt;\n\tunsigned long extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tpage_virt = kmap(page);\n\trc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_CACHE_SIZE,\n\t\t\t\t ecryptfs_inode);\n\tkunmap(page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to read lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, page, page,\n\t\t\t\t  extent_offset, DECRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define DECRYPT\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define DECRYPT\t\t0\n\nint ecryptfs_decrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *page_virt;\n\tunsigned long extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tpage_virt = kmap(page);\n\trc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_CACHE_SIZE,\n\t\t\t\t ecryptfs_inode);\n\tkunmap(page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to read lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, page, page,\n\t\t\t\t  extent_offset, DECRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "page->mapping->host"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_lower_page_segment",
          "args": [
            "page",
            "index",
            "0",
            "PAGE_CACHE_SIZE",
            "mapping->host"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "256-273",
          "snippet": "int ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);\n\tvirt = kmap(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_ecryptfs);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);\n\tvirt = kmap(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_ecryptfs);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_copy_up_encrypted_with_header",
          "args": [
            "page",
            "crypt_stat"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_copy_up_encrypted_with_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "121-183",
          "snippet": "static int\necryptfs_copy_up_encrypted_with_header(struct page *page,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tloff_t extent_num_in_page = 0;\n\tloff_t num_extents_per_page = (PAGE_CACHE_SIZE\n\t\t\t\t       / crypt_stat->extent_size);\n\tint rc = 0;\n\n\twhile (extent_num_in_page < num_extents_per_page) {\n\t\tloff_t view_extent_num = ((((loff_t)page->index)\n\t\t\t\t\t   * num_extents_per_page)\n\t\t\t\t\t  + extent_num_in_page);\n\t\tsize_t num_header_extents_at_front =\n\t\t\t(crypt_stat->metadata_size / crypt_stat->extent_size);\n\n\t\tif (view_extent_num < num_header_extents_at_front) {\n\t\t\t/* This is a header extent */\n\t\t\tchar *page_virt;\n\n\t\t\tpage_virt = kmap_atomic(page);\n\t\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\t\t/* TODO: Support more than one header extent */\n\t\t\tif (view_extent_num == 0) {\n\t\t\t\tsize_t written;\n\n\t\t\t\trc = ecryptfs_read_xattr_region(\n\t\t\t\t\tpage_virt, page->mapping->host);\n\t\t\t\tstrip_xattr_flag(page_virt + 16, crypt_stat);\n\t\t\t\tecryptfs_write_header_metadata(page_virt + 20,\n\t\t\t\t\t\t\t       crypt_stat,\n\t\t\t\t\t\t\t       &written);\n\t\t\t}\n\t\t\tkunmap_atomic(page_virt);\n\t\t\tflush_dcache_page(page);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error reading xattr \"\n\t\t\t\t       \"region; rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This is an encrypted data extent */\n\t\t\tloff_t lower_offset =\n\t\t\t\t((view_extent_num * crypt_stat->extent_size)\n\t\t\t\t - crypt_stat->metadata_size);\n\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, (lower_offset >> PAGE_CACHE_SHIFT),\n\t\t\t\t(lower_offset & ~PAGE_CACHE_MASK),\n\t\t\t\tcrypt_stat->extent_size, page->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"extent at offset [%lld] in the lower \"\n\t\t\t\t       \"file; rc = [%d]\\n\", __func__,\n\t\t\t\t       lower_offset, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\textent_num_in_page++;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int\necryptfs_copy_up_encrypted_with_header(struct page *page,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tloff_t extent_num_in_page = 0;\n\tloff_t num_extents_per_page = (PAGE_CACHE_SIZE\n\t\t\t\t       / crypt_stat->extent_size);\n\tint rc = 0;\n\n\twhile (extent_num_in_page < num_extents_per_page) {\n\t\tloff_t view_extent_num = ((((loff_t)page->index)\n\t\t\t\t\t   * num_extents_per_page)\n\t\t\t\t\t  + extent_num_in_page);\n\t\tsize_t num_header_extents_at_front =\n\t\t\t(crypt_stat->metadata_size / crypt_stat->extent_size);\n\n\t\tif (view_extent_num < num_header_extents_at_front) {\n\t\t\t/* This is a header extent */\n\t\t\tchar *page_virt;\n\n\t\t\tpage_virt = kmap_atomic(page);\n\t\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\t\t/* TODO: Support more than one header extent */\n\t\t\tif (view_extent_num == 0) {\n\t\t\t\tsize_t written;\n\n\t\t\t\trc = ecryptfs_read_xattr_region(\n\t\t\t\t\tpage_virt, page->mapping->host);\n\t\t\t\tstrip_xattr_flag(page_virt + 16, crypt_stat);\n\t\t\t\tecryptfs_write_header_metadata(page_virt + 20,\n\t\t\t\t\t\t\t       crypt_stat,\n\t\t\t\t\t\t\t       &written);\n\t\t\t}\n\t\t\tkunmap_atomic(page_virt);\n\t\t\tflush_dcache_page(page);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error reading xattr \"\n\t\t\t\t       \"region; rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This is an encrypted data extent */\n\t\t\tloff_t lower_offset =\n\t\t\t\t((view_extent_num * crypt_stat->extent_size)\n\t\t\t\t - crypt_stat->metadata_size);\n\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, (lower_offset >> PAGE_CACHE_SHIFT),\n\t\t\t\t(lower_offset & ~PAGE_CACHE_MASK),\n\t\t\t\tcrypt_stat->extent_size, page->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"extent at offset [%lld] in the lower \"\n\t\t\t\t       \"file; rc = [%d]\\n\", __func__,\n\t\t\t\t       lower_offset, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\textent_num_in_page++;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "mapping->host"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int ecryptfs_write_begin(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tloff_t prev_page_end_size;\n\tint rc = 0;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tprev_page_end_size = ((loff_t)index << PAGE_CACHE_SHIFT);\n\tif (!PageUptodate(page)) {\n\t\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t\t&ecryptfs_inode_to_private(mapping->host)->crypt_stat;\n\n\t\tif (!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, index, 0, PAGE_CACHE_SIZE, mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attemping to read \"\n\t\t\t\t       \"lower page segment; rc = [%d]\\n\",\n\t\t\t\t       __func__, rc);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\tSetPageUptodate(page);\n\t\t} else if (crypt_stat->flags & ECRYPTFS_VIEW_AS_ENCRYPTED) {\n\t\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\t\t\trc = ecryptfs_copy_up_encrypted_with_header(\n\t\t\t\t\tpage, crypt_stat);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error attempting \"\n\t\t\t\t\t       \"to copy the encrypted content \"\n\t\t\t\t\t       \"from the lower file whilst \"\n\t\t\t\t\t       \"inserting the metadata from \"\n\t\t\t\t\t       \"the xattr into the header; rc \"\n\t\t\t\t\t       \"= [%d]\\n\", __func__, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t} else {\n\t\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\t\tpage, index, 0, PAGE_CACHE_SIZE,\n\t\t\t\t\tmapping->host);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error reading \"\n\t\t\t\t\t       \"page; rc = [%d]\\n\",\n\t\t\t\t\t       __func__, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t}\n\t\t} else {\n\t\t\tif (prev_page_end_size\n\t\t\t    >= i_size_read(page->mapping->host)) {\n\t\t\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\t\t\tSetPageUptodate(page);\n\t\t\t} else if (len < PAGE_CACHE_SIZE) {\n\t\t\t\trc = ecryptfs_decrypt_page(page);\n\t\t\t\tif (rc) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error decrypting \"\n\t\t\t\t\t       \"page at index [%ld]; \"\n\t\t\t\t\t       \"rc = [%d]\\n\",\n\t\t\t\t\t       __func__, page->index, rc);\n\t\t\t\t\tClearPageUptodate(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSetPageUptodate(page);\n\t\t\t}\n\t\t}\n\t}\n\t/* If creating a page or more of holes, zero them out via truncate.\n\t * Note, this will increase i_size. */\n\tif (index != 0) {\n\t\tif (prev_page_end_size > i_size_read(page->mapping->host)) {\n\t\t\trc = ecryptfs_truncate(file->f_path.dentry,\n\t\t\t\t\t       prev_page_end_size);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error on attempt to \"\n\t\t\t\t       \"truncate to (higher) offset [%lld];\"\n\t\t\t\t       \" rc = [%d]\\n\", __func__,\n\t\t\t\t       prev_page_end_size, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t/* Writing to a new page, and creating a small hole from start\n\t * of page?  Zero it out. */\n\tif ((i_size_read(mapping->host) == prev_page_end_size)\n\t    && (pos != 0))\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\nout:\n\tif (unlikely(rc)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\t*pagep = NULL;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "fill_zeros_to_end_of_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "249-262",
    "snippet": "static int fill_zeros_to_end_of_page(struct page *page, unsigned int to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint end_byte_in_page;\n\n\tif ((i_size_read(inode) / PAGE_CACHE_SIZE) != page->index)\n\t\tgoto out;\n\tend_byte_in_page = i_size_read(inode) % PAGE_CACHE_SIZE;\n\tif (to > end_byte_in_page)\n\t\tend_byte_in_page = to;\n\tzero_user_segment(page, end_byte_in_page, PAGE_CACHE_SIZE);\nout:\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "end_byte_in_page",
            "PAGE_CACHE_SIZE"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int fill_zeros_to_end_of_page(struct page *page, unsigned int to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint end_byte_in_page;\n\n\tif ((i_size_read(inode) / PAGE_CACHE_SIZE) != page->index)\n\t\tgoto out;\n\tend_byte_in_page = i_size_read(inode) % PAGE_CACHE_SIZE;\n\tif (to > end_byte_in_page)\n\t\tend_byte_in_page = to;\n\tzero_user_segment(page, end_byte_in_page, PAGE_CACHE_SIZE);\nout:\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "194-244",
    "snippet": "static int ecryptfs_readpage(struct file *file, struct page *page)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(page->mapping->host)->crypt_stat;\n\tint rc = 0;\n\n\tif (!crypt_stat || !(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\trc = ecryptfs_read_lower_page_segment(page, page->index, 0,\n\t\t\t\t\t\t      PAGE_CACHE_SIZE,\n\t\t\t\t\t\t      page->mapping->host);\n\t} else if (crypt_stat->flags & ECRYPTFS_VIEW_AS_ENCRYPTED) {\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\t\trc = ecryptfs_copy_up_encrypted_with_header(page,\n\t\t\t\t\t\t\t\t    crypt_stat);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to copy \"\n\t\t\t\t       \"the encrypted content from the lower \"\n\t\t\t\t       \"file whilst inserting the metadata \"\n\t\t\t\t       \"from the xattr into the header; rc = \"\n\t\t\t\t       \"[%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} else {\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, page->index, 0, PAGE_CACHE_SIZE,\n\t\t\t\tpage->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error reading page; rc = \"\n\t\t\t\t       \"[%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = ecryptfs_decrypt_page(page);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_ERR, \"Error decrypting page; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tif (rc)\n\t\tClearPageUptodate(page);\n\telse\n\t\tSetPageUptodate(page);\n\tecryptfs_printk(KERN_DEBUG, \"Unlocking page with index = [0x%.16lx]\\n\",\n\t\t\tpage->index);\n\tunlock_page(page);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_DEBUG",
            "\"Unlocking page with index = [0x%.16lx]\\n\"",
            "page->index"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_decrypt_page",
          "args": [
            "page"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_decrypt_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "555-594",
          "snippet": "int ecryptfs_decrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *page_virt;\n\tunsigned long extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tpage_virt = kmap(page);\n\trc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_CACHE_SIZE,\n\t\t\t\t ecryptfs_inode);\n\tkunmap(page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to read lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, page, page,\n\t\t\t\t  extent_offset, DECRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define DECRYPT\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define DECRYPT\t\t0\n\nint ecryptfs_decrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *page_virt;\n\tunsigned long extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tpage_virt = kmap(page);\n\trc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_CACHE_SIZE,\n\t\t\t\t ecryptfs_inode);\n\tkunmap(page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to read lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, page, page,\n\t\t\t\t  extent_offset, DECRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_lower_page_segment",
          "args": [
            "page",
            "page->index",
            "0",
            "PAGE_CACHE_SIZE",
            "page->mapping->host"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "256-273",
          "snippet": "int ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);\n\tvirt = kmap(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_ecryptfs);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);\n\tvirt = kmap(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_ecryptfs);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_copy_up_encrypted_with_header",
          "args": [
            "page",
            "crypt_stat"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_copy_up_encrypted_with_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "121-183",
          "snippet": "static int\necryptfs_copy_up_encrypted_with_header(struct page *page,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tloff_t extent_num_in_page = 0;\n\tloff_t num_extents_per_page = (PAGE_CACHE_SIZE\n\t\t\t\t       / crypt_stat->extent_size);\n\tint rc = 0;\n\n\twhile (extent_num_in_page < num_extents_per_page) {\n\t\tloff_t view_extent_num = ((((loff_t)page->index)\n\t\t\t\t\t   * num_extents_per_page)\n\t\t\t\t\t  + extent_num_in_page);\n\t\tsize_t num_header_extents_at_front =\n\t\t\t(crypt_stat->metadata_size / crypt_stat->extent_size);\n\n\t\tif (view_extent_num < num_header_extents_at_front) {\n\t\t\t/* This is a header extent */\n\t\t\tchar *page_virt;\n\n\t\t\tpage_virt = kmap_atomic(page);\n\t\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\t\t/* TODO: Support more than one header extent */\n\t\t\tif (view_extent_num == 0) {\n\t\t\t\tsize_t written;\n\n\t\t\t\trc = ecryptfs_read_xattr_region(\n\t\t\t\t\tpage_virt, page->mapping->host);\n\t\t\t\tstrip_xattr_flag(page_virt + 16, crypt_stat);\n\t\t\t\tecryptfs_write_header_metadata(page_virt + 20,\n\t\t\t\t\t\t\t       crypt_stat,\n\t\t\t\t\t\t\t       &written);\n\t\t\t}\n\t\t\tkunmap_atomic(page_virt);\n\t\t\tflush_dcache_page(page);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error reading xattr \"\n\t\t\t\t       \"region; rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This is an encrypted data extent */\n\t\t\tloff_t lower_offset =\n\t\t\t\t((view_extent_num * crypt_stat->extent_size)\n\t\t\t\t - crypt_stat->metadata_size);\n\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, (lower_offset >> PAGE_CACHE_SHIFT),\n\t\t\t\t(lower_offset & ~PAGE_CACHE_MASK),\n\t\t\t\tcrypt_stat->extent_size, page->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"extent at offset [%lld] in the lower \"\n\t\t\t\t       \"file; rc = [%d]\\n\", __func__,\n\t\t\t\t       lower_offset, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\textent_num_in_page++;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int\necryptfs_copy_up_encrypted_with_header(struct page *page,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tloff_t extent_num_in_page = 0;\n\tloff_t num_extents_per_page = (PAGE_CACHE_SIZE\n\t\t\t\t       / crypt_stat->extent_size);\n\tint rc = 0;\n\n\twhile (extent_num_in_page < num_extents_per_page) {\n\t\tloff_t view_extent_num = ((((loff_t)page->index)\n\t\t\t\t\t   * num_extents_per_page)\n\t\t\t\t\t  + extent_num_in_page);\n\t\tsize_t num_header_extents_at_front =\n\t\t\t(crypt_stat->metadata_size / crypt_stat->extent_size);\n\n\t\tif (view_extent_num < num_header_extents_at_front) {\n\t\t\t/* This is a header extent */\n\t\t\tchar *page_virt;\n\n\t\t\tpage_virt = kmap_atomic(page);\n\t\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\t\t/* TODO: Support more than one header extent */\n\t\t\tif (view_extent_num == 0) {\n\t\t\t\tsize_t written;\n\n\t\t\t\trc = ecryptfs_read_xattr_region(\n\t\t\t\t\tpage_virt, page->mapping->host);\n\t\t\t\tstrip_xattr_flag(page_virt + 16, crypt_stat);\n\t\t\t\tecryptfs_write_header_metadata(page_virt + 20,\n\t\t\t\t\t\t\t       crypt_stat,\n\t\t\t\t\t\t\t       &written);\n\t\t\t}\n\t\t\tkunmap_atomic(page_virt);\n\t\t\tflush_dcache_page(page);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error reading xattr \"\n\t\t\t\t       \"region; rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This is an encrypted data extent */\n\t\t\tloff_t lower_offset =\n\t\t\t\t((view_extent_num * crypt_stat->extent_size)\n\t\t\t\t - crypt_stat->metadata_size);\n\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, (lower_offset >> PAGE_CACHE_SHIFT),\n\t\t\t\t(lower_offset & ~PAGE_CACHE_MASK),\n\t\t\t\tcrypt_stat->extent_size, page->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"extent at offset [%lld] in the lower \"\n\t\t\t\t       \"file; rc = [%d]\\n\", __func__,\n\t\t\t\t       lower_offset, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\textent_num_in_page++;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "page->mapping->host"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int ecryptfs_readpage(struct file *file, struct page *page)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(page->mapping->host)->crypt_stat;\n\tint rc = 0;\n\n\tif (!crypt_stat || !(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\trc = ecryptfs_read_lower_page_segment(page, page->index, 0,\n\t\t\t\t\t\t      PAGE_CACHE_SIZE,\n\t\t\t\t\t\t      page->mapping->host);\n\t} else if (crypt_stat->flags & ECRYPTFS_VIEW_AS_ENCRYPTED) {\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\t\trc = ecryptfs_copy_up_encrypted_with_header(page,\n\t\t\t\t\t\t\t\t    crypt_stat);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to copy \"\n\t\t\t\t       \"the encrypted content from the lower \"\n\t\t\t\t       \"file whilst inserting the metadata \"\n\t\t\t\t       \"from the xattr into the header; rc = \"\n\t\t\t\t       \"[%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} else {\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, page->index, 0, PAGE_CACHE_SIZE,\n\t\t\t\tpage->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error reading page; rc = \"\n\t\t\t\t       \"[%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = ecryptfs_decrypt_page(page);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_ERR, \"Error decrypting page; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tif (rc)\n\t\tClearPageUptodate(page);\n\telse\n\t\tSetPageUptodate(page);\n\tecryptfs_printk(KERN_DEBUG, \"Unlocking page with index = [0x%.16lx]\\n\",\n\t\t\tpage->index);\n\tunlock_page(page);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_copy_up_encrypted_with_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "121-183",
    "snippet": "static int\necryptfs_copy_up_encrypted_with_header(struct page *page,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tloff_t extent_num_in_page = 0;\n\tloff_t num_extents_per_page = (PAGE_CACHE_SIZE\n\t\t\t\t       / crypt_stat->extent_size);\n\tint rc = 0;\n\n\twhile (extent_num_in_page < num_extents_per_page) {\n\t\tloff_t view_extent_num = ((((loff_t)page->index)\n\t\t\t\t\t   * num_extents_per_page)\n\t\t\t\t\t  + extent_num_in_page);\n\t\tsize_t num_header_extents_at_front =\n\t\t\t(crypt_stat->metadata_size / crypt_stat->extent_size);\n\n\t\tif (view_extent_num < num_header_extents_at_front) {\n\t\t\t/* This is a header extent */\n\t\t\tchar *page_virt;\n\n\t\t\tpage_virt = kmap_atomic(page);\n\t\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\t\t/* TODO: Support more than one header extent */\n\t\t\tif (view_extent_num == 0) {\n\t\t\t\tsize_t written;\n\n\t\t\t\trc = ecryptfs_read_xattr_region(\n\t\t\t\t\tpage_virt, page->mapping->host);\n\t\t\t\tstrip_xattr_flag(page_virt + 16, crypt_stat);\n\t\t\t\tecryptfs_write_header_metadata(page_virt + 20,\n\t\t\t\t\t\t\t       crypt_stat,\n\t\t\t\t\t\t\t       &written);\n\t\t\t}\n\t\t\tkunmap_atomic(page_virt);\n\t\t\tflush_dcache_page(page);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error reading xattr \"\n\t\t\t\t       \"region; rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This is an encrypted data extent */\n\t\t\tloff_t lower_offset =\n\t\t\t\t((view_extent_num * crypt_stat->extent_size)\n\t\t\t\t - crypt_stat->metadata_size);\n\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, (lower_offset >> PAGE_CACHE_SHIFT),\n\t\t\t\t(lower_offset & ~PAGE_CACHE_MASK),\n\t\t\t\tcrypt_stat->extent_size, page->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"extent at offset [%lld] in the lower \"\n\t\t\t\t       \"file; rc = [%d]\\n\", __func__,\n\t\t\t\t       lower_offset, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\textent_num_in_page++;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"extent at offset [%lld] in the lower \"\n\t\t\t\t       \"file; rc = [%d]\\n\"",
            "__func__",
            "lower_offset",
            "rc"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_lower_page_segment",
          "args": [
            "page",
            "(lower_offset >> PAGE_CACHE_SHIFT)",
            "(lower_offset & ~PAGE_CACHE_MASK)",
            "crypt_stat->extent_size",
            "page->mapping->host"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "256-273",
          "snippet": "int ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);\n\tvirt = kmap(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_ecryptfs);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);\n\tvirt = kmap(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_ecryptfs);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "page_virt"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_header_metadata",
          "args": [
            "page_virt + 20",
            "crypt_stat",
            "&written"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_header_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1053-1068",
          "snippet": "void\necryptfs_write_header_metadata(char *virt,\n\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t       size_t *written)\n{\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = (u32)crypt_stat->extent_size;\n\tnum_header_extents_at_front =\n\t\t(u16)(crypt_stat->metadata_size / crypt_stat->extent_size);\n\tput_unaligned_be32(header_extent_size, virt);\n\tvirt += 4;\n\tput_unaligned_be16(num_header_extents_at_front, virt);\n\t(*written) = 6;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid\necryptfs_write_header_metadata(char *virt,\n\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t       size_t *written)\n{\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = (u32)crypt_stat->extent_size;\n\tnum_header_extents_at_front =\n\t\t(u16)(crypt_stat->metadata_size / crypt_stat->extent_size);\n\tput_unaligned_be32(header_extent_size, virt);\n\tvirt += 4;\n\tput_unaligned_be16(num_header_extents_at_front, virt);\n\t(*written) = 6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strip_xattr_flag",
          "args": [
            "page_virt + 16",
            "crypt_stat"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "strip_xattr_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "82-93",
          "snippet": "static void strip_xattr_flag(char *page_virt,\n\t\t\t     struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\tsize_t written;\n\n\t\tcrypt_stat->flags &= ~ECRYPTFS_METADATA_IN_XATTR;\n\t\tecryptfs_write_crypt_stat_flags(page_virt, crypt_stat,\n\t\t\t\t\t\t&written);\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic void strip_xattr_flag(char *page_virt,\n\t\t\t     struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\tsize_t written;\n\n\t\tcrypt_stat->flags &= ~ECRYPTFS_METADATA_IN_XATTR;\n\t\tecryptfs_write_crypt_stat_flags(page_virt, crypt_stat,\n\t\t\t\t\t\t&written);\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_xattr_region",
          "args": [
            "page_virt",
            "page->mapping->host"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_xattr_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1373-1392",
          "snippet": "int ecryptfs_read_xattr_region(char *page_virt, struct inode *ecryptfs_inode)\n{\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tssize_t size;\n\tint rc = 0;\n\n\tsize = ecryptfs_getxattr_lower(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t       page_virt, ECRYPTFS_DEFAULT_EXTENT_SIZE);\n\tif (size < 0) {\n\t\tif (unlikely(ecryptfs_verbosity > 0))\n\t\t\tprintk(KERN_INFO \"Error attempting to read the [%s] \"\n\t\t\t       \"xattr from the lower file; return value = \"\n\t\t\t       \"[%zd]\\n\", ECRYPTFS_XATTR_NAME, size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_xattr_region(char *page_virt, struct inode *ecryptfs_inode)\n{\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tssize_t size;\n\tint rc = 0;\n\n\tsize = ecryptfs_getxattr_lower(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t       page_virt, ECRYPTFS_DEFAULT_EXTENT_SIZE);\n\tif (size < 0) {\n\t\tif (unlikely(ecryptfs_verbosity > 0))\n\t\t\tprintk(KERN_INFO \"Error attempting to read the [%s] \"\n\t\t\t       \"xattr from the lower file; return value = \"\n\t\t\t       \"[%zd]\\n\", ECRYPTFS_XATTR_NAME, size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_virt",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int\necryptfs_copy_up_encrypted_with_header(struct page *page,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tloff_t extent_num_in_page = 0;\n\tloff_t num_extents_per_page = (PAGE_CACHE_SIZE\n\t\t\t\t       / crypt_stat->extent_size);\n\tint rc = 0;\n\n\twhile (extent_num_in_page < num_extents_per_page) {\n\t\tloff_t view_extent_num = ((((loff_t)page->index)\n\t\t\t\t\t   * num_extents_per_page)\n\t\t\t\t\t  + extent_num_in_page);\n\t\tsize_t num_header_extents_at_front =\n\t\t\t(crypt_stat->metadata_size / crypt_stat->extent_size);\n\n\t\tif (view_extent_num < num_header_extents_at_front) {\n\t\t\t/* This is a header extent */\n\t\t\tchar *page_virt;\n\n\t\t\tpage_virt = kmap_atomic(page);\n\t\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\t\t/* TODO: Support more than one header extent */\n\t\t\tif (view_extent_num == 0) {\n\t\t\t\tsize_t written;\n\n\t\t\t\trc = ecryptfs_read_xattr_region(\n\t\t\t\t\tpage_virt, page->mapping->host);\n\t\t\t\tstrip_xattr_flag(page_virt + 16, crypt_stat);\n\t\t\t\tecryptfs_write_header_metadata(page_virt + 20,\n\t\t\t\t\t\t\t       crypt_stat,\n\t\t\t\t\t\t\t       &written);\n\t\t\t}\n\t\t\tkunmap_atomic(page_virt);\n\t\t\tflush_dcache_page(page);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error reading xattr \"\n\t\t\t\t       \"region; rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This is an encrypted data extent */\n\t\t\tloff_t lower_offset =\n\t\t\t\t((view_extent_num * crypt_stat->extent_size)\n\t\t\t\t - crypt_stat->metadata_size);\n\n\t\t\trc = ecryptfs_read_lower_page_segment(\n\t\t\t\tpage, (lower_offset >> PAGE_CACHE_SHIFT),\n\t\t\t\t(lower_offset & ~PAGE_CACHE_MASK),\n\t\t\t\tcrypt_stat->extent_size, page->mapping->host);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"%s: Error attempting to read \"\n\t\t\t\t       \"extent at offset [%lld] in the lower \"\n\t\t\t\t       \"file; rc = [%d]\\n\", __func__,\n\t\t\t\t       lower_offset, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\textent_num_in_page++;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "strip_xattr_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "82-93",
    "snippet": "static void strip_xattr_flag(char *page_virt,\n\t\t\t     struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\tsize_t written;\n\n\t\tcrypt_stat->flags &= ~ECRYPTFS_METADATA_IN_XATTR;\n\t\tecryptfs_write_crypt_stat_flags(page_virt, crypt_stat,\n\t\t\t\t\t\t&written);\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_write_crypt_stat_flags",
          "args": [
            "page_virt",
            "crypt_stat",
            "&written"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_crypt_stat_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "941-956",
          "snippet": "void ecryptfs_write_crypt_stat_flags(char *page_virt,\n\t\t\t\t     struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t     size_t *written)\n{\n\tu32 flags = 0;\n\tint i;\n\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (crypt_stat->flags & ecryptfs_flag_map[i].local_flag)\n\t\t\tflags |= ecryptfs_flag_map[i].file_flag;\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tflags |= ((((u8)crypt_stat->file_version) << 24) & 0xFF000000);\n\tput_unaligned_be32(flags, page_virt);\n\t(*written) = 4;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};\n\nvoid ecryptfs_write_crypt_stat_flags(char *page_virt,\n\t\t\t\t     struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t     size_t *written)\n{\n\tu32 flags = 0;\n\tint i;\n\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (crypt_stat->flags & ecryptfs_flag_map[i].local_flag)\n\t\t\tflags |= ecryptfs_flag_map[i].file_flag;\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tflags |= ((((u8)crypt_stat->file_version) << 24) & 0xFF000000);\n\tput_unaligned_be32(flags, page_virt);\n\t(*written) = 4;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic void strip_xattr_flag(char *page_virt,\n\t\t\t     struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR) {\n\t\tsize_t written;\n\n\t\tcrypt_stat->flags &= ~ECRYPTFS_METADATA_IN_XATTR;\n\t\tecryptfs_write_crypt_stat_flags(page_virt, crypt_stat,\n\t\t\t\t\t\t&written);\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t}\n}"
  },
  {
    "function_name": "ecryptfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "65-80",
    "snippet": "static int ecryptfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\n\trc = ecryptfs_encrypt_page(page);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error encrypting \"\n\t\t\t\t\"page (upper index [0x%.16lx])\\n\", page->index);\n\t\tClearPageUptodate(page);\n\t\tgoto out;\n\t}\n\tSetPageUptodate(page);\nout:\n\tunlock_page(page);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Error encrypting \"\n\t\t\t\t\"page (upper index [0x%.16lx])\\n\"",
            "page->index"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_encrypt_page",
          "args": [
            "page"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_encrypt_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "486-537",
          "snippet": "int ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_CACHE_SIZE);\n\tkunmap(enc_extent_page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ENCRYPT\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nint ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_CACHE_SIZE);\n\tkunmap(enc_extent_page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstatic int ecryptfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\n\trc = ecryptfs_encrypt_page(page);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error encrypting \"\n\t\t\t\t\"page (upper index [0x%.16lx])\\n\", page->index);\n\t\tClearPageUptodate(page);\n\t\tgoto out;\n\t}\n\tSetPageUptodate(page);\nout:\n\tunlock_page(page);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_get_locked_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
    "lines": "47-53",
    "snippet": "struct page *ecryptfs_get_locked_page(struct inode *inode, loff_t index)\n{\n\tstruct page *page = read_mapping_page(inode->i_mapping, index, NULL);\n\tif (!IS_ERR(page))\n\t\tlock_page(page);\n\treturn page;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "inode->i_mapping",
            "index",
            "NULL"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct page *ecryptfs_get_locked_page(struct inode *inode, loff_t index)\n{\n\tstruct page *page = read_mapping_page(inode->i_mapping, index, NULL);\n\tif (!IS_ERR(page))\n\t\tlock_page(page);\n\treturn page;\n}"
  }
]