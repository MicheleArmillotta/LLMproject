[
  {
    "function_name": "objlayout_autologin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "682-706",
    "snippet": "int objlayout_autologin(struct pnfs_osd_deviceaddr *deviceaddr)\n{\n\tint rc;\n\tstruct __auto_login login;\n\n\tif (!deviceaddr->oda_targetaddr.ota_netaddr.r_addr.len)\n\t\treturn -ENODEV;\n\n\tmemset(&login, 0, sizeof(login));\n\t__copy_nfsS_and_zero_terminate(\n\t\tdeviceaddr->oda_targetaddr.ota_netaddr.r_addr,\n\t\tlogin.uri, sizeof(login.uri), \"URI\");\n\n\t__copy_nfsS_and_zero_terminate(\n\t\tdeviceaddr->oda_osdname,\n\t\tlogin.osdname, sizeof(login.osdname), \"OSDNAME\");\n\n\t_sysid_2_hex(deviceaddr->oda_systemid, login.systemid_hex);\n\n\trc = __objlayout_upcall(&login);\n\tif (rc > 0) /* script returns positive values */\n\t\trc = -ENODEV;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__objlayout_upcall",
          "args": [
            "&login"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__objlayout_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "595-639",
          "snippet": "static int __objlayout_upcall(struct __auto_login *login)\n{\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint ret;\n\n\tif (unlikely(!osd_login_prog[0])) {\n\t\tdprintk(\"%s: osd_login_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s uri: %s\\n\", __func__, login->uri);\n\tdprintk(\"%s osdname %s\\n\", __func__, login->osdname);\n\tdprintk(\"%s systemid_hex %s\\n\", __func__, login->systemid_hex);\n\n\targv[0] = (char *)osd_login_prog;\n\targv[1] = \"-u\";\n\targv[2] = login->uri;\n\targv[3] = \"-o\";\n\targv[4] = login->osdname;\n\targv[5] = \"-s\";\n\targv[6] = login->systemid_hex;\n\targv[7] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or\n\t * EACCES error. The admin can re-enable it on the fly by using\n\t * sysfs to set the objlayoutdriver.osd_login_prog module parameter once\n\t * the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tprintk(KERN_ERR \"PNFS-OBJ: %s was not found please set \"\n\t\t\t\"objlayoutdriver.osd_login_prog kernel parameter!\\n\",\n\t\t\tosd_login_prog);\n\t\tosd_login_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s %s return value: %d\\n\", __func__, osd_login_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char osd_login_prog[OSD_LOGIN_UPCALL_PATHLEN] = \"/sbin/osd_login\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic char osd_login_prog[OSD_LOGIN_UPCALL_PATHLEN] = \"/sbin/osd_login\";\n\nstatic int __objlayout_upcall(struct __auto_login *login)\n{\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint ret;\n\n\tif (unlikely(!osd_login_prog[0])) {\n\t\tdprintk(\"%s: osd_login_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s uri: %s\\n\", __func__, login->uri);\n\tdprintk(\"%s osdname %s\\n\", __func__, login->osdname);\n\tdprintk(\"%s systemid_hex %s\\n\", __func__, login->systemid_hex);\n\n\targv[0] = (char *)osd_login_prog;\n\targv[1] = \"-u\";\n\targv[2] = login->uri;\n\targv[3] = \"-o\";\n\targv[4] = login->osdname;\n\targv[5] = \"-s\";\n\targv[6] = login->systemid_hex;\n\targv[7] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or\n\t * EACCES error. The admin can re-enable it on the fly by using\n\t * sysfs to set the objlayoutdriver.osd_login_prog module parameter once\n\t * the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tprintk(KERN_ERR \"PNFS-OBJ: %s was not found please set \"\n\t\t\t\"objlayoutdriver.osd_login_prog kernel parameter!\\n\",\n\t\t\tosd_login_prog);\n\t\tosd_login_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s %s return value: %d\\n\", __func__, osd_login_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sysid_2_hex",
          "args": [
            "deviceaddr->oda_systemid",
            "login.systemid_hex"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "_sysid_2_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "660-680",
          "snippet": "static void _sysid_2_hex(struct nfs4_string s,\n\t\t  char sysid[OBJLAYOUT_MAX_SYSID_HEX_LEN])\n{\n\tint i;\n\tchar *cur;\n\n\tif (!s.len)\n\t\treturn;\n\n\tif (s.len != OSD_SYSTEMID_LEN) {\n\t\tpr_warn_ratelimited(\n\t\t    \"objlayout_autologin: systemid_len(%d) != OSD_SYSTEMID_LEN\",\n\t\t    s.len);\n\t\tif (s.len > OSD_SYSTEMID_LEN)\n\t\t\ts.len = OSD_SYSTEMID_LEN;\n\t}\n\n\tcur = sysid;\n\tfor (i = 0; i < s.len; i++)\n\t\tcur = hex_byte_pack(cur, s.data[i]);\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void _sysid_2_hex(struct nfs4_string s,\n\t\t  char sysid[OBJLAYOUT_MAX_SYSID_HEX_LEN])\n{\n\tint i;\n\tchar *cur;\n\n\tif (!s.len)\n\t\treturn;\n\n\tif (s.len != OSD_SYSTEMID_LEN) {\n\t\tpr_warn_ratelimited(\n\t\t    \"objlayout_autologin: systemid_len(%d) != OSD_SYSTEMID_LEN\",\n\t\t    s.len);\n\t\tif (s.len > OSD_SYSTEMID_LEN)\n\t\t\ts.len = OSD_SYSTEMID_LEN;\n\t}\n\n\tcur = sysid;\n\tfor (i = 0; i < s.len; i++)\n\t\tcur = hex_byte_pack(cur, s.data[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_nfsS_and_zero_terminate",
          "args": [
            "deviceaddr->oda_osdname",
            "login.osdname",
            "sizeof(login.osdname)",
            "\"OSDNAME\""
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_nfsS_and_zero_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "642-657",
          "snippet": "static void __copy_nfsS_and_zero_terminate(struct nfs4_string s,\n\t\t\t\t\t   char *dest, int max_len,\n\t\t\t\t\t   const char *var_name)\n{\n\tif (!s.len)\n\t\treturn;\n\n\tif (s.len >= max_len) {\n\t\tpr_warn_ratelimited(\n\t\t\t\"objlayout_autologin: %s: s.len(%d) >= max_len(%d)\",\n\t\t\tvar_name, s.len, max_len);\n\t\ts.len = max_len - 1; /* space for null terminator */\n\t}\n\n\tmemcpy(dest, s.data, s.len);\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void __copy_nfsS_and_zero_terminate(struct nfs4_string s,\n\t\t\t\t\t   char *dest, int max_len,\n\t\t\t\t\t   const char *var_name)\n{\n\tif (!s.len)\n\t\treturn;\n\n\tif (s.len >= max_len) {\n\t\tpr_warn_ratelimited(\n\t\t\t\"objlayout_autologin: %s: s.len(%d) >= max_len(%d)\",\n\t\t\tvar_name, s.len, max_len);\n\t\ts.len = max_len - 1; /* space for null terminator */\n\t}\n\n\tmemcpy(dest, s.data, s.len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&login",
            "0",
            "sizeof(login)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nint objlayout_autologin(struct pnfs_osd_deviceaddr *deviceaddr)\n{\n\tint rc;\n\tstruct __auto_login login;\n\n\tif (!deviceaddr->oda_targetaddr.ota_netaddr.r_addr.len)\n\t\treturn -ENODEV;\n\n\tmemset(&login, 0, sizeof(login));\n\t__copy_nfsS_and_zero_terminate(\n\t\tdeviceaddr->oda_targetaddr.ota_netaddr.r_addr,\n\t\tlogin.uri, sizeof(login.uri), \"URI\");\n\n\t__copy_nfsS_and_zero_terminate(\n\t\tdeviceaddr->oda_osdname,\n\t\tlogin.osdname, sizeof(login.osdname), \"OSDNAME\");\n\n\t_sysid_2_hex(deviceaddr->oda_systemid, login.systemid_hex);\n\n\trc = __objlayout_upcall(&login);\n\tif (rc > 0) /* script returns positive values */\n\t\trc = -ENODEV;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "_sysid_2_hex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "660-680",
    "snippet": "static void _sysid_2_hex(struct nfs4_string s,\n\t\t  char sysid[OBJLAYOUT_MAX_SYSID_HEX_LEN])\n{\n\tint i;\n\tchar *cur;\n\n\tif (!s.len)\n\t\treturn;\n\n\tif (s.len != OSD_SYSTEMID_LEN) {\n\t\tpr_warn_ratelimited(\n\t\t    \"objlayout_autologin: systemid_len(%d) != OSD_SYSTEMID_LEN\",\n\t\t    s.len);\n\t\tif (s.len > OSD_SYSTEMID_LEN)\n\t\t\ts.len = OSD_SYSTEMID_LEN;\n\t}\n\n\tcur = sysid;\n\tfor (i = 0; i < s.len; i++)\n\t\tcur = hex_byte_pack(cur, s.data[i]);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "cur",
            "s.data[i]"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"objlayout_autologin: systemid_len(%d) != OSD_SYSTEMID_LEN\"",
            "s.len"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void _sysid_2_hex(struct nfs4_string s,\n\t\t  char sysid[OBJLAYOUT_MAX_SYSID_HEX_LEN])\n{\n\tint i;\n\tchar *cur;\n\n\tif (!s.len)\n\t\treturn;\n\n\tif (s.len != OSD_SYSTEMID_LEN) {\n\t\tpr_warn_ratelimited(\n\t\t    \"objlayout_autologin: systemid_len(%d) != OSD_SYSTEMID_LEN\",\n\t\t    s.len);\n\t\tif (s.len > OSD_SYSTEMID_LEN)\n\t\t\ts.len = OSD_SYSTEMID_LEN;\n\t}\n\n\tcur = sysid;\n\tfor (i = 0; i < s.len; i++)\n\t\tcur = hex_byte_pack(cur, s.data[i]);\n}"
  },
  {
    "function_name": "__copy_nfsS_and_zero_terminate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "642-657",
    "snippet": "static void __copy_nfsS_and_zero_terminate(struct nfs4_string s,\n\t\t\t\t\t   char *dest, int max_len,\n\t\t\t\t\t   const char *var_name)\n{\n\tif (!s.len)\n\t\treturn;\n\n\tif (s.len >= max_len) {\n\t\tpr_warn_ratelimited(\n\t\t\t\"objlayout_autologin: %s: s.len(%d) >= max_len(%d)\",\n\t\t\tvar_name, s.len, max_len);\n\t\ts.len = max_len - 1; /* space for null terminator */\n\t}\n\n\tmemcpy(dest, s.data, s.len);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "s.data",
            "s.len"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"objlayout_autologin: %s: s.len(%d) >= max_len(%d)\"",
            "var_name",
            "s.len",
            "max_len"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void __copy_nfsS_and_zero_terminate(struct nfs4_string s,\n\t\t\t\t\t   char *dest, int max_len,\n\t\t\t\t\t   const char *var_name)\n{\n\tif (!s.len)\n\t\treturn;\n\n\tif (s.len >= max_len) {\n\t\tpr_warn_ratelimited(\n\t\t\t\"objlayout_autologin: %s: s.len(%d) >= max_len(%d)\",\n\t\t\tvar_name, s.len, max_len);\n\t\ts.len = max_len - 1; /* space for null terminator */\n\t}\n\n\tmemcpy(dest, s.data, s.len);\n}"
  },
  {
    "function_name": "__objlayout_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "595-639",
    "snippet": "static int __objlayout_upcall(struct __auto_login *login)\n{\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint ret;\n\n\tif (unlikely(!osd_login_prog[0])) {\n\t\tdprintk(\"%s: osd_login_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s uri: %s\\n\", __func__, login->uri);\n\tdprintk(\"%s osdname %s\\n\", __func__, login->osdname);\n\tdprintk(\"%s systemid_hex %s\\n\", __func__, login->systemid_hex);\n\n\targv[0] = (char *)osd_login_prog;\n\targv[1] = \"-u\";\n\targv[2] = login->uri;\n\targv[3] = \"-o\";\n\targv[4] = login->osdname;\n\targv[5] = \"-s\";\n\targv[6] = login->systemid_hex;\n\targv[7] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or\n\t * EACCES error. The admin can re-enable it on the fly by using\n\t * sysfs to set the objlayoutdriver.osd_login_prog module parameter once\n\t * the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tprintk(KERN_ERR \"PNFS-OBJ: %s was not found please set \"\n\t\t\t\"objlayoutdriver.osd_login_prog kernel parameter!\\n\",\n\t\t\tosd_login_prog);\n\t\tosd_login_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s %s return value: %d\\n\", __func__, osd_login_prog, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char osd_login_prog[OSD_LOGIN_UPCALL_PATHLEN] = \"/sbin/osd_login\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s %s return value: %d\\n\"",
            "__func__",
            "osd_login_prog",
            "ret"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"PNFS-OBJ: %s was not found please set \"\n\t\t\t\"objlayoutdriver.osd_login_prog kernel parameter!\\n\"",
            "osd_login_prog"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper",
          "args": [
            "argv[0]",
            "argv",
            "envp",
            "UMH_WAIT_PROC"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s systemid_hex %s\\n\"",
            "__func__",
            "login->systemid_hex"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s osdname %s\\n\"",
            "__func__",
            "login->osdname"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s uri: %s\\n\"",
            "__func__",
            "login->uri"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: osd_login_prog is disabled\\n\"",
            "__func__"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!osd_login_prog[0]"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic char osd_login_prog[OSD_LOGIN_UPCALL_PATHLEN] = \"/sbin/osd_login\";\n\nstatic int __objlayout_upcall(struct __auto_login *login)\n{\n\tstatic char *envp[] = { \"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint ret;\n\n\tif (unlikely(!osd_login_prog[0])) {\n\t\tdprintk(\"%s: osd_login_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s uri: %s\\n\", __func__, login->uri);\n\tdprintk(\"%s osdname %s\\n\", __func__, login->osdname);\n\tdprintk(\"%s systemid_hex %s\\n\", __func__, login->systemid_hex);\n\n\targv[0] = (char *)osd_login_prog;\n\targv[1] = \"-u\";\n\targv[2] = login->uri;\n\targv[3] = \"-o\";\n\targv[4] = login->osdname;\n\targv[5] = \"-s\";\n\targv[6] = login->systemid_hex;\n\targv[7] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or\n\t * EACCES error. The admin can re-enable it on the fly by using\n\t * sysfs to set the objlayoutdriver.osd_login_prog module parameter once\n\t * the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tprintk(KERN_ERR \"PNFS-OBJ: %s was not found please set \"\n\t\t\t\"objlayoutdriver.osd_login_prog kernel parameter!\\n\",\n\t\t\tosd_login_prog);\n\t\tosd_login_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s %s return value: %d\\n\", __func__, osd_login_prog, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "objlayout_encode_layoutreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "506-575",
    "snippet": "void\nobjlayout_encode_layoutreturn(struct pnfs_layout_hdr *pnfslay,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      const struct nfs4_layoutreturn_args *args)\n{\n\tstruct objlayout *objlay = OBJLAYOUT(pnfslay);\n\tstruct objlayout_io_res *oir, *tmp;\n\t__be32 *start;\n\n\tdprintk(\"%s: Begin\\n\", __func__);\n\tstart = xdr_reserve_space(xdr, 4);\n\tBUG_ON(!start);\n\n\tspin_lock(&objlay->lock);\n\n\tlist_for_each_entry_safe(oir, tmp, &objlay->err_list, err_list) {\n\t\t__be32 *last_xdr = NULL, *p;\n\t\tunsigned i;\n\t\tint res = 0;\n\n\t\tfor (i = 0; i < oir->num_comps; i++) {\n\t\t\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[i];\n\n\t\t\tif (!ioerr->oer_errno)\n\t\t\t\tcontinue;\n\n\t\t\tdprintk(\"%s: err[%d]: errno=%d is_write=%d \"\n\t\t\t\t\"dev(%llx:%llx) par=0x%llx obj=0x%llx \"\n\t\t\t\t\"offset=0x%llx length=0x%llx\\n\",\n\t\t\t\t__func__, i, ioerr->oer_errno,\n\t\t\t\tioerr->oer_iswrite,\n\t\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\t\tioerr->oer_component.oid_object_id,\n\t\t\t\tioerr->oer_comp_offset,\n\t\t\t\tioerr->oer_comp_length);\n\n\t\t\tp = pnfs_osd_xdr_ioerr_reserve_space(xdr);\n\t\t\tif (unlikely(!p)) {\n\t\t\t\tres = -E2BIG;\n\t\t\t\tbreak; /* accumulated_error */\n\t\t\t}\n\n\t\t\tlast_xdr = p;\n\t\t\tpnfs_osd_xdr_encode_ioerr(p, &oir->ioerrs[i]);\n\t\t}\n\n\t\t/* TODO: use xdr_write_pages */\n\t\tif (unlikely(res)) {\n\t\t\t/* no space for even one error descriptor */\n\t\t\tBUG_ON(!last_xdr);\n\n\t\t\t/* we've encountered a situation with lots and lots of\n\t\t\t * errors and no space to encode them all. Use the last\n\t\t\t * available slot to report the union of all the\n\t\t\t * remaining errors.\n\t\t\t */\n\t\t\tencode_accumulated_error(objlay, last_xdr);\n\t\t\tgoto loop_done;\n\t\t}\n\t\tlist_del(&oir->err_list);\n\t\tobjio_free_result(oir);\n\t}\nloop_done:\n\tspin_unlock(&objlay->lock);\n\n\t*start = cpu_to_be32((xdr->p - start - 1) * 4);\n\tdprintk(\"%s: Return\\n\", __func__);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Return\\n\"",
            "__func__"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(xdr->p - start - 1) * 4"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&objlay->lock"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "objio_free_result",
          "args": [
            "oir"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "objio_free_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "332-338",
          "snippet": "void objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nvoid objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&oir->err_list"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_accumulated_error",
          "args": [
            "objlay",
            "last_xdr"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "encode_accumulated_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "470-504",
          "snippet": "static void\nencode_accumulated_error(struct objlayout *objlay, __be32 *p)\n{\n\tstruct objlayout_io_res *oir, *tmp;\n\tstruct pnfs_osd_ioerr accumulated_err = {.oer_errno = 0};\n\n\tlist_for_each_entry_safe(oir, tmp, &objlay->err_list, err_list) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < oir->num_comps; i++) {\n\t\t\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[i];\n\n\t\t\tif (!ioerr->oer_errno)\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_ERR \"NFS: %s: err[%d]: errno=%d \"\n\t\t\t\t\"is_write=%d dev(%llx:%llx) par=0x%llx \"\n\t\t\t\t\"obj=0x%llx offset=0x%llx length=0x%llx\\n\",\n\t\t\t\t__func__, i, ioerr->oer_errno,\n\t\t\t\tioerr->oer_iswrite,\n\t\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\t\tioerr->oer_component.oid_object_id,\n\t\t\t\tioerr->oer_comp_offset,\n\t\t\t\tioerr->oer_comp_length);\n\n\t\t\tmerge_ioerr(&accumulated_err, ioerr);\n\t\t}\n\t\tlist_del(&oir->err_list);\n\t\tobjio_free_result(oir);\n\t}\n\n\tpnfs_osd_xdr_encode_ioerr(p, &accumulated_err);\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void\nencode_accumulated_error(struct objlayout *objlay, __be32 *p)\n{\n\tstruct objlayout_io_res *oir, *tmp;\n\tstruct pnfs_osd_ioerr accumulated_err = {.oer_errno = 0};\n\n\tlist_for_each_entry_safe(oir, tmp, &objlay->err_list, err_list) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < oir->num_comps; i++) {\n\t\t\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[i];\n\n\t\t\tif (!ioerr->oer_errno)\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_ERR \"NFS: %s: err[%d]: errno=%d \"\n\t\t\t\t\"is_write=%d dev(%llx:%llx) par=0x%llx \"\n\t\t\t\t\"obj=0x%llx offset=0x%llx length=0x%llx\\n\",\n\t\t\t\t__func__, i, ioerr->oer_errno,\n\t\t\t\tioerr->oer_iswrite,\n\t\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\t\tioerr->oer_component.oid_object_id,\n\t\t\t\tioerr->oer_comp_offset,\n\t\t\t\tioerr->oer_comp_length);\n\n\t\t\tmerge_ioerr(&accumulated_err, ioerr);\n\t\t}\n\t\tlist_del(&oir->err_list);\n\t\tobjio_free_result(oir);\n\t}\n\n\tpnfs_osd_xdr_encode_ioerr(p, &accumulated_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!last_xdr"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "res"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_osd_xdr_encode_ioerr",
          "args": [
            "p",
            "&oir->ioerrs[i]"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_osd_xdr_encode_ioerr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/pnfs_osd_xdr_cli.c",
          "lines": "397-404",
          "snippet": "void pnfs_osd_xdr_encode_ioerr(__be32 *p, struct pnfs_osd_ioerr *ioerr)\n{\n\tp = pnfs_osd_xdr_encode_objid(p, &ioerr->oer_component);\n\tp = xdr_encode_hyper(p, ioerr->oer_comp_offset);\n\tp = xdr_encode_hyper(p, ioerr->oer_comp_length);\n\t*p++ = cpu_to_be32(ioerr->oer_iswrite);\n\t*p   = cpu_to_be32(ioerr->oer_errno);\n}",
          "includes": [
            "#include <linux/pnfs_osd_xdr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pnfs_osd_xdr.h>\n\nvoid pnfs_osd_xdr_encode_ioerr(__be32 *p, struct pnfs_osd_ioerr *ioerr)\n{\n\tp = pnfs_osd_xdr_encode_objid(p, &ioerr->oer_component);\n\tp = xdr_encode_hyper(p, ioerr->oer_comp_offset);\n\tp = xdr_encode_hyper(p, ioerr->oer_comp_length);\n\t*p++ = cpu_to_be32(ioerr->oer_iswrite);\n\t*p   = cpu_to_be32(ioerr->oer_errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_osd_xdr_ioerr_reserve_space",
          "args": [
            "xdr"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_osd_xdr_ioerr_reserve_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/pnfs_osd_xdr_cli.c",
          "lines": "406-415",
          "snippet": "__be32 *pnfs_osd_xdr_ioerr_reserve_space(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 32 + 24);\n\tif (unlikely(!p))\n\t\tdprintk(\"%s: out of xdr space\\n\", __func__);\n\n\treturn p;\n}",
          "includes": [
            "#include <linux/pnfs_osd_xdr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pnfs_osd_xdr.h>\n\n__be32 *pnfs_osd_xdr_ioerr_reserve_space(struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 32 + 24);\n\tif (unlikely(!p))\n\t\tdprintk(\"%s: out of xdr space\\n\", __func__);\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: err[%d]: errno=%d is_write=%d \"\n\t\t\t\t\"dev(%llx:%llx) par=0x%llx obj=0x%llx \"\n\t\t\t\t\"offset=0x%llx length=0x%llx\\n\"",
            "__func__",
            "i",
            "ioerr->oer_errno",
            "ioerr->oer_iswrite",
            "_DEVID_LO(&ioerr->oer_component.oid_device_id)",
            "_DEVID_HI(&ioerr->oer_component.oid_device_id)",
            "ioerr->oer_component.oid_partition_id",
            "ioerr->oer_component.oid_object_id",
            "ioerr->oer_comp_offset",
            "ioerr->oer_comp_length"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DEVID_HI",
          "args": [
            "&ioerr->oer_component.oid_device_id"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DEVID_LO",
          "args": [
            "&ioerr->oer_component.oid_device_id"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "oir",
            "tmp",
            "&objlay->err_list",
            "err_list"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&objlay->lock"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!start"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Begin\\n\"",
            "__func__"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OBJLAYOUT",
          "args": [
            "pnfslay"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "OBJLAYOUT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.h",
          "lines": "67-71",
          "snippet": "static inline struct objlayout *\nOBJLAYOUT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct objlayout, pnfs_layout);\n}",
          "includes": [
            "#include \"../pnfs.h\"",
            "#include <linux/pnfs_osd_xdr.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n#include <linux/pnfs_osd_xdr.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct objlayout *\nOBJLAYOUT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct objlayout, pnfs_layout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_encode_layoutreturn(struct pnfs_layout_hdr *pnfslay,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      const struct nfs4_layoutreturn_args *args)\n{\n\tstruct objlayout *objlay = OBJLAYOUT(pnfslay);\n\tstruct objlayout_io_res *oir, *tmp;\n\t__be32 *start;\n\n\tdprintk(\"%s: Begin\\n\", __func__);\n\tstart = xdr_reserve_space(xdr, 4);\n\tBUG_ON(!start);\n\n\tspin_lock(&objlay->lock);\n\n\tlist_for_each_entry_safe(oir, tmp, &objlay->err_list, err_list) {\n\t\t__be32 *last_xdr = NULL, *p;\n\t\tunsigned i;\n\t\tint res = 0;\n\n\t\tfor (i = 0; i < oir->num_comps; i++) {\n\t\t\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[i];\n\n\t\t\tif (!ioerr->oer_errno)\n\t\t\t\tcontinue;\n\n\t\t\tdprintk(\"%s: err[%d]: errno=%d is_write=%d \"\n\t\t\t\t\"dev(%llx:%llx) par=0x%llx obj=0x%llx \"\n\t\t\t\t\"offset=0x%llx length=0x%llx\\n\",\n\t\t\t\t__func__, i, ioerr->oer_errno,\n\t\t\t\tioerr->oer_iswrite,\n\t\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\t\tioerr->oer_component.oid_object_id,\n\t\t\t\tioerr->oer_comp_offset,\n\t\t\t\tioerr->oer_comp_length);\n\n\t\t\tp = pnfs_osd_xdr_ioerr_reserve_space(xdr);\n\t\t\tif (unlikely(!p)) {\n\t\t\t\tres = -E2BIG;\n\t\t\t\tbreak; /* accumulated_error */\n\t\t\t}\n\n\t\t\tlast_xdr = p;\n\t\t\tpnfs_osd_xdr_encode_ioerr(p, &oir->ioerrs[i]);\n\t\t}\n\n\t\t/* TODO: use xdr_write_pages */\n\t\tif (unlikely(res)) {\n\t\t\t/* no space for even one error descriptor */\n\t\t\tBUG_ON(!last_xdr);\n\n\t\t\t/* we've encountered a situation with lots and lots of\n\t\t\t * errors and no space to encode them all. Use the last\n\t\t\t * available slot to report the union of all the\n\t\t\t * remaining errors.\n\t\t\t */\n\t\t\tencode_accumulated_error(objlay, last_xdr);\n\t\t\tgoto loop_done;\n\t\t}\n\t\tlist_del(&oir->err_list);\n\t\tobjio_free_result(oir);\n\t}\nloop_done:\n\tspin_unlock(&objlay->lock);\n\n\t*start = cpu_to_be32((xdr->p - start - 1) * 4);\n\tdprintk(\"%s: Return\\n\", __func__);\n}"
  },
  {
    "function_name": "encode_accumulated_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "470-504",
    "snippet": "static void\nencode_accumulated_error(struct objlayout *objlay, __be32 *p)\n{\n\tstruct objlayout_io_res *oir, *tmp;\n\tstruct pnfs_osd_ioerr accumulated_err = {.oer_errno = 0};\n\n\tlist_for_each_entry_safe(oir, tmp, &objlay->err_list, err_list) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < oir->num_comps; i++) {\n\t\t\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[i];\n\n\t\t\tif (!ioerr->oer_errno)\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_ERR \"NFS: %s: err[%d]: errno=%d \"\n\t\t\t\t\"is_write=%d dev(%llx:%llx) par=0x%llx \"\n\t\t\t\t\"obj=0x%llx offset=0x%llx length=0x%llx\\n\",\n\t\t\t\t__func__, i, ioerr->oer_errno,\n\t\t\t\tioerr->oer_iswrite,\n\t\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\t\tioerr->oer_component.oid_object_id,\n\t\t\t\tioerr->oer_comp_offset,\n\t\t\t\tioerr->oer_comp_length);\n\n\t\t\tmerge_ioerr(&accumulated_err, ioerr);\n\t\t}\n\t\tlist_del(&oir->err_list);\n\t\tobjio_free_result(oir);\n\t}\n\n\tpnfs_osd_xdr_encode_ioerr(p, &accumulated_err);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_osd_xdr_encode_ioerr",
          "args": [
            "p",
            "&accumulated_err"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_osd_xdr_encode_ioerr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/pnfs_osd_xdr_cli.c",
          "lines": "397-404",
          "snippet": "void pnfs_osd_xdr_encode_ioerr(__be32 *p, struct pnfs_osd_ioerr *ioerr)\n{\n\tp = pnfs_osd_xdr_encode_objid(p, &ioerr->oer_component);\n\tp = xdr_encode_hyper(p, ioerr->oer_comp_offset);\n\tp = xdr_encode_hyper(p, ioerr->oer_comp_length);\n\t*p++ = cpu_to_be32(ioerr->oer_iswrite);\n\t*p   = cpu_to_be32(ioerr->oer_errno);\n}",
          "includes": [
            "#include <linux/pnfs_osd_xdr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pnfs_osd_xdr.h>\n\nvoid pnfs_osd_xdr_encode_ioerr(__be32 *p, struct pnfs_osd_ioerr *ioerr)\n{\n\tp = pnfs_osd_xdr_encode_objid(p, &ioerr->oer_component);\n\tp = xdr_encode_hyper(p, ioerr->oer_comp_offset);\n\tp = xdr_encode_hyper(p, ioerr->oer_comp_length);\n\t*p++ = cpu_to_be32(ioerr->oer_iswrite);\n\t*p   = cpu_to_be32(ioerr->oer_errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "objio_free_result",
          "args": [
            "oir"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "objio_free_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "332-338",
          "snippet": "void objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nvoid objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&oir->err_list"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_ioerr",
          "args": [
            "&accumulated_err",
            "ioerr"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "merge_ioerr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "426-468",
          "snippet": "static void\nmerge_ioerr(struct pnfs_osd_ioerr *dest_err,\n\t    const struct pnfs_osd_ioerr *src_err)\n{\n\tu64 dest_end, src_end;\n\n\tif (!dest_err->oer_errno) {\n\t\t*dest_err = *src_err;\n\t\t/* accumulated device must be blank */\n\t\tmemset(&dest_err->oer_component.oid_device_id, 0,\n\t\t\tsizeof(dest_err->oer_component.oid_device_id));\n\n\t\treturn;\n\t}\n\n\tif (dest_err->oer_component.oid_partition_id !=\n\t\t\t\tsrc_err->oer_component.oid_partition_id)\n\t\tdest_err->oer_component.oid_partition_id = 0;\n\n\tif (dest_err->oer_component.oid_object_id !=\n\t\t\t\tsrc_err->oer_component.oid_object_id)\n\t\tdest_err->oer_component.oid_object_id = 0;\n\n\tif (dest_err->oer_comp_offset > src_err->oer_comp_offset)\n\t\tdest_err->oer_comp_offset = src_err->oer_comp_offset;\n\n\tdest_end = end_offset(dest_err->oer_comp_offset,\n\t\t\t      dest_err->oer_comp_length);\n\tsrc_end =  end_offset(src_err->oer_comp_offset,\n\t\t\t      src_err->oer_comp_length);\n\tif (dest_end < src_end)\n\t\tdest_end = src_end;\n\n\tdest_err->oer_comp_length = dest_end - dest_err->oer_comp_offset;\n\n\tif ((src_err->oer_iswrite == dest_err->oer_iswrite) &&\n\t    (err_prio(src_err->oer_errno) > err_prio(dest_err->oer_errno))) {\n\t\t\tdest_err->oer_errno = src_err->oer_errno;\n\t} else if (src_err->oer_iswrite) {\n\t\tdest_err->oer_iswrite = true;\n\t\tdest_err->oer_errno = src_err->oer_errno;\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void\nmerge_ioerr(struct pnfs_osd_ioerr *dest_err,\n\t    const struct pnfs_osd_ioerr *src_err)\n{\n\tu64 dest_end, src_end;\n\n\tif (!dest_err->oer_errno) {\n\t\t*dest_err = *src_err;\n\t\t/* accumulated device must be blank */\n\t\tmemset(&dest_err->oer_component.oid_device_id, 0,\n\t\t\tsizeof(dest_err->oer_component.oid_device_id));\n\n\t\treturn;\n\t}\n\n\tif (dest_err->oer_component.oid_partition_id !=\n\t\t\t\tsrc_err->oer_component.oid_partition_id)\n\t\tdest_err->oer_component.oid_partition_id = 0;\n\n\tif (dest_err->oer_component.oid_object_id !=\n\t\t\t\tsrc_err->oer_component.oid_object_id)\n\t\tdest_err->oer_component.oid_object_id = 0;\n\n\tif (dest_err->oer_comp_offset > src_err->oer_comp_offset)\n\t\tdest_err->oer_comp_offset = src_err->oer_comp_offset;\n\n\tdest_end = end_offset(dest_err->oer_comp_offset,\n\t\t\t      dest_err->oer_comp_length);\n\tsrc_end =  end_offset(src_err->oer_comp_offset,\n\t\t\t      src_err->oer_comp_length);\n\tif (dest_end < src_end)\n\t\tdest_end = src_end;\n\n\tdest_err->oer_comp_length = dest_end - dest_err->oer_comp_offset;\n\n\tif ((src_err->oer_iswrite == dest_err->oer_iswrite) &&\n\t    (err_prio(src_err->oer_errno) > err_prio(dest_err->oer_errno))) {\n\t\t\tdest_err->oer_errno = src_err->oer_errno;\n\t} else if (src_err->oer_iswrite) {\n\t\tdest_err->oer_iswrite = true;\n\t\tdest_err->oer_errno = src_err->oer_errno;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS: %s: err[%d]: errno=%d \"\n\t\t\t\t\"is_write=%d dev(%llx:%llx) par=0x%llx \"\n\t\t\t\t\"obj=0x%llx offset=0x%llx length=0x%llx\\n\"",
            "__func__",
            "i",
            "ioerr->oer_errno",
            "ioerr->oer_iswrite",
            "_DEVID_LO(&ioerr->oer_component.oid_device_id)",
            "_DEVID_HI(&ioerr->oer_component.oid_device_id)",
            "ioerr->oer_component.oid_partition_id",
            "ioerr->oer_component.oid_object_id",
            "ioerr->oer_comp_offset",
            "ioerr->oer_comp_length"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_DEVID_HI",
          "args": [
            "&ioerr->oer_component.oid_device_id"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DEVID_LO",
          "args": [
            "&ioerr->oer_component.oid_device_id"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "oir",
            "tmp",
            "&objlay->err_list",
            "err_list"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void\nencode_accumulated_error(struct objlayout *objlay, __be32 *p)\n{\n\tstruct objlayout_io_res *oir, *tmp;\n\tstruct pnfs_osd_ioerr accumulated_err = {.oer_errno = 0};\n\n\tlist_for_each_entry_safe(oir, tmp, &objlay->err_list, err_list) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < oir->num_comps; i++) {\n\t\t\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[i];\n\n\t\t\tif (!ioerr->oer_errno)\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_ERR \"NFS: %s: err[%d]: errno=%d \"\n\t\t\t\t\"is_write=%d dev(%llx:%llx) par=0x%llx \"\n\t\t\t\t\"obj=0x%llx offset=0x%llx length=0x%llx\\n\",\n\t\t\t\t__func__, i, ioerr->oer_errno,\n\t\t\t\tioerr->oer_iswrite,\n\t\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\t\tioerr->oer_component.oid_object_id,\n\t\t\t\tioerr->oer_comp_offset,\n\t\t\t\tioerr->oer_comp_length);\n\n\t\t\tmerge_ioerr(&accumulated_err, ioerr);\n\t\t}\n\t\tlist_del(&oir->err_list);\n\t\tobjio_free_result(oir);\n\t}\n\n\tpnfs_osd_xdr_encode_ioerr(p, &accumulated_err);\n}"
  },
  {
    "function_name": "merge_ioerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "426-468",
    "snippet": "static void\nmerge_ioerr(struct pnfs_osd_ioerr *dest_err,\n\t    const struct pnfs_osd_ioerr *src_err)\n{\n\tu64 dest_end, src_end;\n\n\tif (!dest_err->oer_errno) {\n\t\t*dest_err = *src_err;\n\t\t/* accumulated device must be blank */\n\t\tmemset(&dest_err->oer_component.oid_device_id, 0,\n\t\t\tsizeof(dest_err->oer_component.oid_device_id));\n\n\t\treturn;\n\t}\n\n\tif (dest_err->oer_component.oid_partition_id !=\n\t\t\t\tsrc_err->oer_component.oid_partition_id)\n\t\tdest_err->oer_component.oid_partition_id = 0;\n\n\tif (dest_err->oer_component.oid_object_id !=\n\t\t\t\tsrc_err->oer_component.oid_object_id)\n\t\tdest_err->oer_component.oid_object_id = 0;\n\n\tif (dest_err->oer_comp_offset > src_err->oer_comp_offset)\n\t\tdest_err->oer_comp_offset = src_err->oer_comp_offset;\n\n\tdest_end = end_offset(dest_err->oer_comp_offset,\n\t\t\t      dest_err->oer_comp_length);\n\tsrc_end =  end_offset(src_err->oer_comp_offset,\n\t\t\t      src_err->oer_comp_length);\n\tif (dest_end < src_end)\n\t\tdest_end = src_end;\n\n\tdest_err->oer_comp_length = dest_end - dest_err->oer_comp_offset;\n\n\tif ((src_err->oer_iswrite == dest_err->oer_iswrite) &&\n\t    (err_prio(src_err->oer_errno) > err_prio(dest_err->oer_errno))) {\n\t\t\tdest_err->oer_errno = src_err->oer_errno;\n\t} else if (src_err->oer_iswrite) {\n\t\tdest_err->oer_iswrite = true;\n\t\tdest_err->oer_errno = src_err->oer_errno;\n\t}\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_prio",
          "args": [
            "dest_err->oer_errno"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "err_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "399-424",
          "snippet": "static int\nerr_prio(u32 oer_errno)\n{\n\tswitch (oer_errno) {\n\tcase 0:\n\t\treturn 0;\n\n\tcase PNFS_OSD_ERR_RESOURCE:\n\t\treturn OSD_ERR_PRI_RESOURCE;\n\tcase PNFS_OSD_ERR_BAD_CRED:\n\t\treturn OSD_ERR_PRI_BAD_CRED;\n\tcase PNFS_OSD_ERR_NO_ACCESS:\n\t\treturn OSD_ERR_PRI_NO_ACCESS;\n\tcase PNFS_OSD_ERR_UNREACHABLE:\n\t\treturn OSD_ERR_PRI_UNREACHABLE;\n\tcase PNFS_OSD_ERR_NOT_FOUND:\n\t\treturn OSD_ERR_PRI_NOT_FOUND;\n\tcase PNFS_OSD_ERR_NO_SPACE:\n\t\treturn OSD_ERR_PRI_NO_SPACE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fallthrough */\n\tcase PNFS_OSD_ERR_EIO:\n\t\treturn OSD_ERR_PRI_EIO;\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic int\nerr_prio(u32 oer_errno)\n{\n\tswitch (oer_errno) {\n\tcase 0:\n\t\treturn 0;\n\n\tcase PNFS_OSD_ERR_RESOURCE:\n\t\treturn OSD_ERR_PRI_RESOURCE;\n\tcase PNFS_OSD_ERR_BAD_CRED:\n\t\treturn OSD_ERR_PRI_BAD_CRED;\n\tcase PNFS_OSD_ERR_NO_ACCESS:\n\t\treturn OSD_ERR_PRI_NO_ACCESS;\n\tcase PNFS_OSD_ERR_UNREACHABLE:\n\t\treturn OSD_ERR_PRI_UNREACHABLE;\n\tcase PNFS_OSD_ERR_NOT_FOUND:\n\t\treturn OSD_ERR_PRI_NOT_FOUND;\n\tcase PNFS_OSD_ERR_NO_SPACE:\n\t\treturn OSD_ERR_PRI_NO_SPACE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fallthrough */\n\tcase PNFS_OSD_ERR_EIO:\n\t\treturn OSD_ERR_PRI_EIO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_offset",
          "args": [
            "src_err->oer_comp_offset",
            "src_err->oer_comp_length"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "end_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "142-149",
          "snippet": "static inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dest_err->oer_component.oid_device_id",
            "0",
            "sizeof(dest_err->oer_component.oid_device_id)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void\nmerge_ioerr(struct pnfs_osd_ioerr *dest_err,\n\t    const struct pnfs_osd_ioerr *src_err)\n{\n\tu64 dest_end, src_end;\n\n\tif (!dest_err->oer_errno) {\n\t\t*dest_err = *src_err;\n\t\t/* accumulated device must be blank */\n\t\tmemset(&dest_err->oer_component.oid_device_id, 0,\n\t\t\tsizeof(dest_err->oer_component.oid_device_id));\n\n\t\treturn;\n\t}\n\n\tif (dest_err->oer_component.oid_partition_id !=\n\t\t\t\tsrc_err->oer_component.oid_partition_id)\n\t\tdest_err->oer_component.oid_partition_id = 0;\n\n\tif (dest_err->oer_component.oid_object_id !=\n\t\t\t\tsrc_err->oer_component.oid_object_id)\n\t\tdest_err->oer_component.oid_object_id = 0;\n\n\tif (dest_err->oer_comp_offset > src_err->oer_comp_offset)\n\t\tdest_err->oer_comp_offset = src_err->oer_comp_offset;\n\n\tdest_end = end_offset(dest_err->oer_comp_offset,\n\t\t\t      dest_err->oer_comp_length);\n\tsrc_end =  end_offset(src_err->oer_comp_offset,\n\t\t\t      src_err->oer_comp_length);\n\tif (dest_end < src_end)\n\t\tdest_end = src_end;\n\n\tdest_err->oer_comp_length = dest_end - dest_err->oer_comp_offset;\n\n\tif ((src_err->oer_iswrite == dest_err->oer_iswrite) &&\n\t    (err_prio(src_err->oer_errno) > err_prio(dest_err->oer_errno))) {\n\t\t\tdest_err->oer_errno = src_err->oer_errno;\n\t} else if (src_err->oer_iswrite) {\n\t\tdest_err->oer_iswrite = true;\n\t\tdest_err->oer_errno = src_err->oer_errno;\n\t}\n}"
  },
  {
    "function_name": "err_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "399-424",
    "snippet": "static int\nerr_prio(u32 oer_errno)\n{\n\tswitch (oer_errno) {\n\tcase 0:\n\t\treturn 0;\n\n\tcase PNFS_OSD_ERR_RESOURCE:\n\t\treturn OSD_ERR_PRI_RESOURCE;\n\tcase PNFS_OSD_ERR_BAD_CRED:\n\t\treturn OSD_ERR_PRI_BAD_CRED;\n\tcase PNFS_OSD_ERR_NO_ACCESS:\n\t\treturn OSD_ERR_PRI_NO_ACCESS;\n\tcase PNFS_OSD_ERR_UNREACHABLE:\n\t\treturn OSD_ERR_PRI_UNREACHABLE;\n\tcase PNFS_OSD_ERR_NOT_FOUND:\n\t\treturn OSD_ERR_PRI_NOT_FOUND;\n\tcase PNFS_OSD_ERR_NO_SPACE:\n\t\treturn OSD_ERR_PRI_NO_SPACE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fallthrough */\n\tcase PNFS_OSD_ERR_EIO:\n\t\treturn OSD_ERR_PRI_EIO;\n\t}\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic int\nerr_prio(u32 oer_errno)\n{\n\tswitch (oer_errno) {\n\tcase 0:\n\t\treturn 0;\n\n\tcase PNFS_OSD_ERR_RESOURCE:\n\t\treturn OSD_ERR_PRI_RESOURCE;\n\tcase PNFS_OSD_ERR_BAD_CRED:\n\t\treturn OSD_ERR_PRI_BAD_CRED;\n\tcase PNFS_OSD_ERR_NO_ACCESS:\n\t\treturn OSD_ERR_PRI_NO_ACCESS;\n\tcase PNFS_OSD_ERR_UNREACHABLE:\n\t\treturn OSD_ERR_PRI_UNREACHABLE;\n\tcase PNFS_OSD_ERR_NOT_FOUND:\n\t\treturn OSD_ERR_PRI_NOT_FOUND;\n\tcase PNFS_OSD_ERR_NO_SPACE:\n\t\treturn OSD_ERR_PRI_NO_SPACE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fallthrough */\n\tcase PNFS_OSD_ERR_EIO:\n\t\treturn OSD_ERR_PRI_EIO;\n\t}\n}"
  },
  {
    "function_name": "objlayout_encode_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "370-397",
    "snippet": "void\nobjlayout_encode_layoutcommit(struct pnfs_layout_hdr *pnfslay,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      const struct nfs4_layoutcommit_args *args)\n{\n\tstruct objlayout *objlay = OBJLAYOUT(pnfslay);\n\tstruct pnfs_osd_layoutupdate lou;\n\t__be32 *start;\n\n\tdprintk(\"%s: Begin\\n\", __func__);\n\n\tspin_lock(&objlay->lock);\n\tlou.dsu_valid = (objlay->delta_space_valid == OBJ_DSU_VALID);\n\tlou.dsu_delta = objlay->delta_space_used;\n\tobjlay->delta_space_used = 0;\n\tobjlay->delta_space_valid = OBJ_DSU_INIT;\n\tlou.olu_ioerr_flag = !list_empty(&objlay->err_list);\n\tspin_unlock(&objlay->lock);\n\n\tstart = xdr_reserve_space(xdr, 4);\n\n\tBUG_ON(pnfs_osd_xdr_encode_layoutupdate(xdr, &lou));\n\n\t*start = cpu_to_be32((xdr->p - start - 1) * 4);\n\n\tdprintk(\"%s: Return delta_space_used %lld err %d\\n\", __func__,\n\t\tlou.dsu_delta, lou.olu_ioerr_flag);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Return delta_space_used %lld err %d\\n\"",
            "__func__",
            "lou.dsu_delta",
            "lou.olu_ioerr_flag"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(xdr->p - start - 1) * 4"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pnfs_osd_xdr_encode_layoutupdate(xdr, &lou)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_osd_xdr_encode_layoutupdate",
          "args": [
            "xdr",
            "&lou"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_osd_xdr_encode_layoutupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/pnfs_osd_xdr_cli.c",
          "lines": "354-368",
          "snippet": "int\npnfs_osd_xdr_encode_layoutupdate(struct xdr_stream *xdr,\n\t\t\t\t struct pnfs_osd_layoutupdate *lou)\n{\n\t__be32 *p = xdr_reserve_space(xdr,  4 + 8 + 4);\n\n\tif (!p)\n\t\treturn -E2BIG;\n\n\t*p++ = cpu_to_be32(lou->dsu_valid);\n\tif (lou->dsu_valid)\n\t\tp = xdr_encode_hyper(p, lou->dsu_delta);\n\t*p++ = cpu_to_be32(lou->olu_ioerr_flag);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/pnfs_osd_xdr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pnfs_osd_xdr.h>\n\nint\npnfs_osd_xdr_encode_layoutupdate(struct xdr_stream *xdr,\n\t\t\t\t struct pnfs_osd_layoutupdate *lou)\n{\n\t__be32 *p = xdr_reserve_space(xdr,  4 + 8 + 4);\n\n\tif (!p)\n\t\treturn -E2BIG;\n\n\t*p++ = cpu_to_be32(lou->dsu_valid);\n\tif (lou->dsu_valid)\n\t\tp = xdr_encode_hyper(p, lou->dsu_delta);\n\t*p++ = cpu_to_be32(lou->olu_ioerr_flag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&objlay->lock"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&objlay->err_list"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&objlay->lock"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Begin\\n\"",
            "__func__"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OBJLAYOUT",
          "args": [
            "pnfslay"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "OBJLAYOUT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.h",
          "lines": "67-71",
          "snippet": "static inline struct objlayout *\nOBJLAYOUT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct objlayout, pnfs_layout);\n}",
          "includes": [
            "#include \"../pnfs.h\"",
            "#include <linux/pnfs_osd_xdr.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n#include <linux/pnfs_osd_xdr.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct objlayout *\nOBJLAYOUT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct objlayout, pnfs_layout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_encode_layoutcommit(struct pnfs_layout_hdr *pnfslay,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      const struct nfs4_layoutcommit_args *args)\n{\n\tstruct objlayout *objlay = OBJLAYOUT(pnfslay);\n\tstruct pnfs_osd_layoutupdate lou;\n\t__be32 *start;\n\n\tdprintk(\"%s: Begin\\n\", __func__);\n\n\tspin_lock(&objlay->lock);\n\tlou.dsu_valid = (objlay->delta_space_valid == OBJ_DSU_VALID);\n\tlou.dsu_delta = objlay->delta_space_used;\n\tobjlay->delta_space_used = 0;\n\tobjlay->delta_space_valid = OBJ_DSU_INIT;\n\tlou.olu_ioerr_flag = !list_empty(&objlay->err_list);\n\tspin_unlock(&objlay->lock);\n\n\tstart = xdr_reserve_space(xdr, 4);\n\n\tBUG_ON(pnfs_osd_xdr_encode_layoutupdate(xdr, &lou));\n\n\t*start = cpu_to_be32((xdr->p - start - 1) * 4);\n\n\tdprintk(\"%s: Return delta_space_used %lld err %d\\n\", __func__,\n\t\tlou.dsu_delta, lou.olu_ioerr_flag);\n}"
  },
  {
    "function_name": "objlayout_write_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "352-368",
    "snippet": "enum pnfs_try_status\nobjlayout_write_pagelist(struct nfs_pgio_header *hdr, int how)\n{\n\tint err;\n\n\t_fix_verify_io_params(hdr->lseg, &hdr->args.pages,\n\t\t\t      &hdr->args.pgbase,\n\t\t\t      hdr->args.offset, hdr->args.count);\n\n\terr = objio_write_pagelist(hdr, how);\n\tif (unlikely(err)) {\n\t\thdr->pnfs_error = err;\n\t\tdprintk(\"%s: Returned Error %d\\n\", __func__, err);\n\t\treturn PNFS_NOT_ATTEMPTED;\n\t}\n\treturn PNFS_ATTEMPTED;\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Returned Error %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objio_write_pagelist",
          "args": [
            "hdr",
            "how"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "objio_write_pagelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "501-531",
          "snippet": "int objio_write_pagelist(struct nfs_pgio_header *hdr, int how)\n{\n\tstruct objio_state *objios;\n\tint ret;\n\n\tret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, false,\n\t\t\thdr->lseg, hdr->args.pages, hdr->args.pgbase,\n\t\t\thdr->args.offset, hdr->args.count, hdr, GFP_NOFS,\n\t\t\t&objios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tobjios->sync = 0 != (how & FLUSH_SYNC);\n\tobjios->ios->r4w = &_r4w_op;\n\n\tif (!objios->sync)\n\t\tobjios->ios->done = _write_done;\n\n\tdprintk(\"%s: offset=0x%llx length=0x%x\\n\", __func__,\n\t\thdr->args.offset, hdr->args.count);\n\tret = ore_write(objios->ios);\n\tif (unlikely(ret)) {\n\t\tobjio_free_result(&objios->oir);\n\t\treturn ret;\n\t}\n\n\tif (objios->sync)\n\t\t_write_done(objios->ios, objios);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};\n\nint objio_write_pagelist(struct nfs_pgio_header *hdr, int how)\n{\n\tstruct objio_state *objios;\n\tint ret;\n\n\tret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, false,\n\t\t\thdr->lseg, hdr->args.pages, hdr->args.pgbase,\n\t\t\thdr->args.offset, hdr->args.count, hdr, GFP_NOFS,\n\t\t\t&objios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tobjios->sync = 0 != (how & FLUSH_SYNC);\n\tobjios->ios->r4w = &_r4w_op;\n\n\tif (!objios->sync)\n\t\tobjios->ios->done = _write_done;\n\n\tdprintk(\"%s: offset=0x%llx length=0x%x\\n\", __func__,\n\t\thdr->args.offset, hdr->args.count);\n\tret = ore_write(objios->ios);\n\tif (unlikely(ret)) {\n\t\tobjio_free_result(&objios->oir);\n\t\treturn ret;\n\t}\n\n\tif (objios->sync)\n\t\t_write_done(objios->ios, objios);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_fix_verify_io_params",
          "args": [
            "hdr->lseg",
            "&hdr->args.pages",
            "&hdr->args.pgbase",
            "hdr->args.offset",
            "hdr->args.count"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "_fix_verify_io_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "151-168",
          "snippet": "static void _fix_verify_io_params(struct pnfs_layout_segment *lseg,\n\t\t\t   struct page ***p_pages, unsigned *p_pgbase,\n\t\t\t   u64 offset, unsigned long count)\n{\n\tu64 lseg_end_offset;\n\n\tBUG_ON(offset < lseg->pls_range.offset);\n\tlseg_end_offset = end_offset(lseg->pls_range.offset,\n\t\t\t\t     lseg->pls_range.length);\n\tBUG_ON(offset >= lseg_end_offset);\n\tWARN_ON(offset + count > lseg_end_offset);\n\n\tif (*p_pgbase > PAGE_SIZE) {\n\t\tdprintk(\"%s: pgbase(0x%x) > PAGE_SIZE\\n\", __func__, *p_pgbase);\n\t\t*p_pages += *p_pgbase >> PAGE_SHIFT;\n\t\t*p_pgbase &= ~PAGE_MASK;\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void _fix_verify_io_params(struct pnfs_layout_segment *lseg,\n\t\t\t   struct page ***p_pages, unsigned *p_pgbase,\n\t\t\t   u64 offset, unsigned long count)\n{\n\tu64 lseg_end_offset;\n\n\tBUG_ON(offset < lseg->pls_range.offset);\n\tlseg_end_offset = end_offset(lseg->pls_range.offset,\n\t\t\t\t     lseg->pls_range.length);\n\tBUG_ON(offset >= lseg_end_offset);\n\tWARN_ON(offset + count > lseg_end_offset);\n\n\tif (*p_pgbase > PAGE_SIZE) {\n\t\tdprintk(\"%s: pgbase(0x%x) > PAGE_SIZE\\n\", __func__, *p_pgbase);\n\t\t*p_pages += *p_pgbase >> PAGE_SHIFT;\n\t\t*p_pgbase &= ~PAGE_MASK;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nenum pnfs_try_status\nobjlayout_write_pagelist(struct nfs_pgio_header *hdr, int how)\n{\n\tint err;\n\n\t_fix_verify_io_params(hdr->lseg, &hdr->args.pages,\n\t\t\t      &hdr->args.pgbase,\n\t\t\t      hdr->args.offset, hdr->args.count);\n\n\terr = objio_write_pagelist(hdr, how);\n\tif (unlikely(err)) {\n\t\thdr->pnfs_error = err;\n\t\tdprintk(\"%s: Returned Error %d\\n\", __func__, err);\n\t\treturn PNFS_NOT_ATTEMPTED;\n\t}\n\treturn PNFS_ATTEMPTED;\n}"
  },
  {
    "function_name": "objlayout_write_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "323-347",
    "snippet": "void\nobjlayout_write_done(struct objlayout_io_res *oir, ssize_t status, bool sync)\n{\n\tstruct nfs_pgio_header *hdr = oir->rpcdata;\n\n\toir->status = hdr->task.tk_status = status;\n\tif (status >= 0) {\n\t\thdr->res.count = status;\n\t\thdr->verf.committed = oir->committed;\n\t} else {\n\t\thdr->pnfs_error = status;\n\t}\n\tobjlayout_iodone(oir);\n\t/* must not use oir after this point */\n\n\tdprintk(\"%s: Return status %zd committed %d sync=%d\\n\", __func__,\n\t\tstatus, hdr->verf.committed, sync);\n\n\tif (sync)\n\t\tpnfs_ld_write_done(hdr);\n\telse {\n\t\tINIT_WORK(&hdr->task.u.tk_work, _rpc_write_complete);\n\t\tschedule_work(&hdr->task.u.tk_work);\n\t}\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&hdr->task.u.tk_work"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&hdr->task.u.tk_work",
            "_rpc_write_complete"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_ld_write_done",
          "args": [
            "hdr"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_write_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1840-1849",
          "snippet": "void pnfs_ld_write_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\n\tif (!hdr->pnfs_error) {\n\t\tpnfs_set_layoutcommit(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_write_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_ld_write_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\n\tif (!hdr->pnfs_error) {\n\t\tpnfs_set_layoutcommit(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_write_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Return status %zd committed %d sync=%d\\n\"",
            "__func__",
            "status",
            "hdr->verf.committed",
            "sync"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objlayout_iodone",
          "args": [
            "oir"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "objlayout_iodone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "173-186",
          "snippet": "static void\nobjlayout_iodone(struct objlayout_io_res *oir)\n{\n\tif (likely(oir->status >= 0)) {\n\t\tobjio_free_result(oir);\n\t} else {\n\t\tstruct objlayout *objlay = oir->objlay;\n\n\t\tspin_lock(&objlay->lock);\n\t\tobjlay->delta_space_valid = OBJ_DSU_INVALID;\n\t\tlist_add(&objlay->err_list, &oir->err_list);\n\t\tspin_unlock(&objlay->lock);\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void\nobjlayout_iodone(struct objlayout_io_res *oir)\n{\n\tif (likely(oir->status >= 0)) {\n\t\tobjio_free_result(oir);\n\t} else {\n\t\tstruct objlayout *objlay = oir->objlay;\n\n\t\tspin_lock(&objlay->lock);\n\t\tobjlay->delta_space_valid = OBJ_DSU_INVALID;\n\t\tlist_add(&objlay->err_list, &oir->err_list);\n\t\tspin_unlock(&objlay->lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_write_done(struct objlayout_io_res *oir, ssize_t status, bool sync)\n{\n\tstruct nfs_pgio_header *hdr = oir->rpcdata;\n\n\toir->status = hdr->task.tk_status = status;\n\tif (status >= 0) {\n\t\thdr->res.count = status;\n\t\thdr->verf.committed = oir->committed;\n\t} else {\n\t\thdr->pnfs_error = status;\n\t}\n\tobjlayout_iodone(oir);\n\t/* must not use oir after this point */\n\n\tdprintk(\"%s: Return status %zd committed %d sync=%d\\n\", __func__,\n\t\tstatus, hdr->verf.committed, sync);\n\n\tif (sync)\n\t\tpnfs_ld_write_done(hdr);\n\telse {\n\t\tINIT_WORK(&hdr->task.u.tk_work, _rpc_write_complete);\n\t\tschedule_work(&hdr->task.u.tk_work);\n\t}\n}"
  },
  {
    "function_name": "_rpc_write_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "311-321",
    "snippet": "static void _rpc_write_complete(struct work_struct *work)\n{\n\tstruct rpc_task *task;\n\tstruct nfs_pgio_header *hdr;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\ttask = container_of(work, struct rpc_task, u.tk_work);\n\thdr = container_of(task, struct nfs_pgio_header, task);\n\n\tpnfs_ld_write_done(hdr);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_ld_write_done",
          "args": [
            "hdr"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_write_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1840-1849",
          "snippet": "void pnfs_ld_write_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\n\tif (!hdr->pnfs_error) {\n\t\tpnfs_set_layoutcommit(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_write_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_ld_write_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\n\tif (!hdr->pnfs_error) {\n\t\tpnfs_set_layoutcommit(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_write_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "task",
            "structnfs_pgio_header",
            "task"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structrpc_task",
            "u.tk_work"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void _rpc_write_complete(struct work_struct *work)\n{\n\tstruct rpc_task *task;\n\tstruct nfs_pgio_header *hdr;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\ttask = container_of(work, struct rpc_task, u.tk_work);\n\thdr = container_of(task, struct nfs_pgio_header, task);\n\n\tpnfs_ld_write_done(hdr);\n}"
  },
  {
    "function_name": "objlayout_read_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "268-305",
    "snippet": "enum pnfs_try_status\nobjlayout_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tloff_t offset = hdr->args.offset;\n\tsize_t count = hdr->args.count;\n\tint err;\n\tloff_t eof;\n\n\teof = i_size_read(inode);\n\tif (unlikely(offset + count > eof)) {\n\t\tif (offset >= eof) {\n\t\t\terr = 0;\n\t\t\thdr->res.count = 0;\n\t\t\thdr->res.eof = 1;\n\t\t\t/*FIXME: do we need to call pnfs_ld_read_done() */\n\t\t\tgoto out;\n\t\t}\n\t\tcount = eof - offset;\n\t}\n\n\thdr->res.eof = (offset + count) >= eof;\n\t_fix_verify_io_params(hdr->lseg, &hdr->args.pages,\n\t\t\t      &hdr->args.pgbase,\n\t\t\t      hdr->args.offset, hdr->args.count);\n\n\tdprintk(\"%s: inode(%lx) offset 0x%llx count 0x%Zx eof=%d\\n\",\n\t\t__func__, inode->i_ino, offset, count, hdr->res.eof);\n\n\terr = objio_read_pagelist(hdr);\n out:\n\tif (unlikely(err)) {\n\t\thdr->pnfs_error = err;\n\t\tdprintk(\"%s: Returned Error %d\\n\", __func__, err);\n\t\treturn PNFS_NOT_ATTEMPTED;\n\t}\n\treturn PNFS_ATTEMPTED;\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Returned Error %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objio_read_pagelist",
          "args": [
            "hdr"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "objio_read_pagelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "410-429",
          "snippet": "int objio_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct objio_state *objios;\n\tint ret;\n\n\tret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, true,\n\t\t\thdr->lseg, hdr->args.pages, hdr->args.pgbase,\n\t\t\thdr->args.offset, hdr->args.count, hdr,\n\t\t\tGFP_KERNEL, &objios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tobjios->ios->done = _read_done;\n\tdprintk(\"%s: offset=0x%llx length=0x%x\\n\", __func__,\n\t\thdr->args.offset, hdr->args.count);\n\tret = ore_read(objios->ios);\n\tif (unlikely(ret))\n\t\tobjio_free_result(&objios->oir);\n\treturn ret;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nint objio_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct objio_state *objios;\n\tint ret;\n\n\tret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, true,\n\t\t\thdr->lseg, hdr->args.pages, hdr->args.pgbase,\n\t\t\thdr->args.offset, hdr->args.count, hdr,\n\t\t\tGFP_KERNEL, &objios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tobjios->ios->done = _read_done;\n\tdprintk(\"%s: offset=0x%llx length=0x%x\\n\", __func__,\n\t\thdr->args.offset, hdr->args.count);\n\tret = ore_read(objios->ios);\n\tif (unlikely(ret))\n\t\tobjio_free_result(&objios->oir);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: inode(%lx) offset 0x%llx count 0x%Zx eof=%d\\n\"",
            "__func__",
            "inode->i_ino",
            "offset",
            "count",
            "hdr->res.eof"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_fix_verify_io_params",
          "args": [
            "hdr->lseg",
            "&hdr->args.pages",
            "&hdr->args.pgbase",
            "hdr->args.offset",
            "hdr->args.count"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "_fix_verify_io_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "151-168",
          "snippet": "static void _fix_verify_io_params(struct pnfs_layout_segment *lseg,\n\t\t\t   struct page ***p_pages, unsigned *p_pgbase,\n\t\t\t   u64 offset, unsigned long count)\n{\n\tu64 lseg_end_offset;\n\n\tBUG_ON(offset < lseg->pls_range.offset);\n\tlseg_end_offset = end_offset(lseg->pls_range.offset,\n\t\t\t\t     lseg->pls_range.length);\n\tBUG_ON(offset >= lseg_end_offset);\n\tWARN_ON(offset + count > lseg_end_offset);\n\n\tif (*p_pgbase > PAGE_SIZE) {\n\t\tdprintk(\"%s: pgbase(0x%x) > PAGE_SIZE\\n\", __func__, *p_pgbase);\n\t\t*p_pages += *p_pgbase >> PAGE_SHIFT;\n\t\t*p_pgbase &= ~PAGE_MASK;\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void _fix_verify_io_params(struct pnfs_layout_segment *lseg,\n\t\t\t   struct page ***p_pages, unsigned *p_pgbase,\n\t\t\t   u64 offset, unsigned long count)\n{\n\tu64 lseg_end_offset;\n\n\tBUG_ON(offset < lseg->pls_range.offset);\n\tlseg_end_offset = end_offset(lseg->pls_range.offset,\n\t\t\t\t     lseg->pls_range.length);\n\tBUG_ON(offset >= lseg_end_offset);\n\tWARN_ON(offset + count > lseg_end_offset);\n\n\tif (*p_pgbase > PAGE_SIZE) {\n\t\tdprintk(\"%s: pgbase(0x%x) > PAGE_SIZE\\n\", __func__, *p_pgbase);\n\t\t*p_pages += *p_pgbase >> PAGE_SHIFT;\n\t\t*p_pgbase &= ~PAGE_MASK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset + count > eof"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nenum pnfs_try_status\nobjlayout_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tloff_t offset = hdr->args.offset;\n\tsize_t count = hdr->args.count;\n\tint err;\n\tloff_t eof;\n\n\teof = i_size_read(inode);\n\tif (unlikely(offset + count > eof)) {\n\t\tif (offset >= eof) {\n\t\t\terr = 0;\n\t\t\thdr->res.count = 0;\n\t\t\thdr->res.eof = 1;\n\t\t\t/*FIXME: do we need to call pnfs_ld_read_done() */\n\t\t\tgoto out;\n\t\t}\n\t\tcount = eof - offset;\n\t}\n\n\thdr->res.eof = (offset + count) >= eof;\n\t_fix_verify_io_params(hdr->lseg, &hdr->args.pages,\n\t\t\t      &hdr->args.pgbase,\n\t\t\t      hdr->args.offset, hdr->args.count);\n\n\tdprintk(\"%s: inode(%lx) offset 0x%llx count 0x%Zx eof=%d\\n\",\n\t\t__func__, inode->i_ino, offset, count, hdr->res.eof);\n\n\terr = objio_read_pagelist(hdr);\n out:\n\tif (unlikely(err)) {\n\t\thdr->pnfs_error = err;\n\t\tdprintk(\"%s: Returned Error %d\\n\", __func__, err);\n\t\treturn PNFS_NOT_ATTEMPTED;\n\t}\n\treturn PNFS_ATTEMPTED;\n}"
  },
  {
    "function_name": "objlayout_read_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "241-263",
    "snippet": "void\nobjlayout_read_done(struct objlayout_io_res *oir, ssize_t status, bool sync)\n{\n\tstruct nfs_pgio_header *hdr = oir->rpcdata;\n\n\toir->status = hdr->task.tk_status = status;\n\tif (status >= 0)\n\t\thdr->res.count = status;\n\telse\n\t\thdr->pnfs_error = status;\n\tobjlayout_iodone(oir);\n\t/* must not use oir after this point */\n\n\tdprintk(\"%s: Return status=%zd eof=%d sync=%d\\n\", __func__,\n\t\tstatus, hdr->res.eof, sync);\n\n\tif (sync)\n\t\tpnfs_ld_read_done(hdr);\n\telse {\n\t\tINIT_WORK(&hdr->task.u.tk_work, _rpc_read_complete);\n\t\tschedule_work(&hdr->task.u.tk_work);\n\t}\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&hdr->task.u.tk_work"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&hdr->task.u.tk_work",
            "_rpc_read_complete"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_ld_read_done",
          "args": [
            "hdr"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_read_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1955-1964",
          "snippet": "void pnfs_ld_read_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\n\tif (likely(!hdr->pnfs_error)) {\n\t\t__nfs4_read_done_cb(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_read_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_ld_read_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\n\tif (likely(!hdr->pnfs_error)) {\n\t\t__nfs4_read_done_cb(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_read_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Return status=%zd eof=%d sync=%d\\n\"",
            "__func__",
            "status",
            "hdr->res.eof",
            "sync"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objlayout_iodone",
          "args": [
            "oir"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "objlayout_iodone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "173-186",
          "snippet": "static void\nobjlayout_iodone(struct objlayout_io_res *oir)\n{\n\tif (likely(oir->status >= 0)) {\n\t\tobjio_free_result(oir);\n\t} else {\n\t\tstruct objlayout *objlay = oir->objlay;\n\n\t\tspin_lock(&objlay->lock);\n\t\tobjlay->delta_space_valid = OBJ_DSU_INVALID;\n\t\tlist_add(&objlay->err_list, &oir->err_list);\n\t\tspin_unlock(&objlay->lock);\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void\nobjlayout_iodone(struct objlayout_io_res *oir)\n{\n\tif (likely(oir->status >= 0)) {\n\t\tobjio_free_result(oir);\n\t} else {\n\t\tstruct objlayout *objlay = oir->objlay;\n\n\t\tspin_lock(&objlay->lock);\n\t\tobjlay->delta_space_valid = OBJ_DSU_INVALID;\n\t\tlist_add(&objlay->err_list, &oir->err_list);\n\t\tspin_unlock(&objlay->lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_read_done(struct objlayout_io_res *oir, ssize_t status, bool sync)\n{\n\tstruct nfs_pgio_header *hdr = oir->rpcdata;\n\n\toir->status = hdr->task.tk_status = status;\n\tif (status >= 0)\n\t\thdr->res.count = status;\n\telse\n\t\thdr->pnfs_error = status;\n\tobjlayout_iodone(oir);\n\t/* must not use oir after this point */\n\n\tdprintk(\"%s: Return status=%zd eof=%d sync=%d\\n\", __func__,\n\t\tstatus, hdr->res.eof, sync);\n\n\tif (sync)\n\t\tpnfs_ld_read_done(hdr);\n\telse {\n\t\tINIT_WORK(&hdr->task.u.tk_work, _rpc_read_complete);\n\t\tschedule_work(&hdr->task.u.tk_work);\n\t}\n}"
  },
  {
    "function_name": "_rpc_read_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "229-239",
    "snippet": "static void _rpc_read_complete(struct work_struct *work)\n{\n\tstruct rpc_task *task;\n\tstruct nfs_pgio_header *hdr;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\ttask = container_of(work, struct rpc_task, u.tk_work);\n\thdr = container_of(task, struct nfs_pgio_header, task);\n\n\tpnfs_ld_read_done(hdr);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_ld_read_done",
          "args": [
            "hdr"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_read_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1955-1964",
          "snippet": "void pnfs_ld_read_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\n\tif (likely(!hdr->pnfs_error)) {\n\t\t__nfs4_read_done_cb(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_read_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_ld_read_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\n\tif (likely(!hdr->pnfs_error)) {\n\t\t__nfs4_read_done_cb(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_read_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "task",
            "structnfs_pgio_header",
            "task"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structrpc_task",
            "u.tk_work"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void _rpc_read_complete(struct work_struct *work)\n{\n\tstruct rpc_task *task;\n\tstruct nfs_pgio_header *hdr;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\ttask = container_of(work, struct rpc_task, u.tk_work);\n\thdr = container_of(task, struct nfs_pgio_header, task);\n\n\tpnfs_ld_read_done(hdr);\n}"
  },
  {
    "function_name": "objlayout_io_set_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "194-223",
    "snippet": "void\nobjlayout_io_set_result(struct objlayout_io_res *oir, unsigned index,\n\t\t\tstruct pnfs_osd_objid *pooid, int osd_error,\n\t\t\tu64 offset, u64 length, bool is_write)\n{\n\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[index];\n\n\tBUG_ON(index >= oir->num_comps);\n\tif (osd_error) {\n\t\tioerr->oer_component = *pooid;\n\t\tioerr->oer_comp_offset = offset;\n\t\tioerr->oer_comp_length = length;\n\t\tioerr->oer_iswrite = is_write;\n\t\tioerr->oer_errno = osd_error;\n\n\t\tdprintk(\"%s: err[%d]: errno=%d is_write=%d dev(%llx:%llx) \"\n\t\t\t\"par=0x%llx obj=0x%llx offset=0x%llx length=0x%llx\\n\",\n\t\t\t__func__, index, ioerr->oer_errno,\n\t\t\tioerr->oer_iswrite,\n\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\tioerr->oer_component.oid_object_id,\n\t\t\tioerr->oer_comp_offset,\n\t\t\tioerr->oer_comp_length);\n\t} else {\n\t\t/* User need not call if no error is reported */\n\t\tioerr->oer_errno = 0;\n\t}\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: err[%d]: errno=%d is_write=%d dev(%llx:%llx) \"\n\t\t\t\"par=0x%llx obj=0x%llx offset=0x%llx length=0x%llx\\n\"",
            "__func__",
            "index",
            "ioerr->oer_errno",
            "ioerr->oer_iswrite",
            "_DEVID_LO(&ioerr->oer_component.oid_device_id)",
            "_DEVID_HI(&ioerr->oer_component.oid_device_id)",
            "ioerr->oer_component.oid_partition_id",
            "ioerr->oer_component.oid_object_id",
            "ioerr->oer_comp_offset",
            "ioerr->oer_comp_length"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DEVID_HI",
          "args": [
            "&ioerr->oer_component.oid_device_id"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DEVID_LO",
          "args": [
            "&ioerr->oer_component.oid_device_id"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index >= oir->num_comps"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_io_set_result(struct objlayout_io_res *oir, unsigned index,\n\t\t\tstruct pnfs_osd_objid *pooid, int osd_error,\n\t\t\tu64 offset, u64 length, bool is_write)\n{\n\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[index];\n\n\tBUG_ON(index >= oir->num_comps);\n\tif (osd_error) {\n\t\tioerr->oer_component = *pooid;\n\t\tioerr->oer_comp_offset = offset;\n\t\tioerr->oer_comp_length = length;\n\t\tioerr->oer_iswrite = is_write;\n\t\tioerr->oer_errno = osd_error;\n\n\t\tdprintk(\"%s: err[%d]: errno=%d is_write=%d dev(%llx:%llx) \"\n\t\t\t\"par=0x%llx obj=0x%llx offset=0x%llx length=0x%llx\\n\",\n\t\t\t__func__, index, ioerr->oer_errno,\n\t\t\tioerr->oer_iswrite,\n\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\tioerr->oer_component.oid_object_id,\n\t\t\tioerr->oer_comp_offset,\n\t\t\tioerr->oer_comp_length);\n\t} else {\n\t\t/* User need not call if no error is reported */\n\t\tioerr->oer_errno = 0;\n\t}\n}"
  },
  {
    "function_name": "objlayout_iodone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "173-186",
    "snippet": "static void\nobjlayout_iodone(struct objlayout_io_res *oir)\n{\n\tif (likely(oir->status >= 0)) {\n\t\tobjio_free_result(oir);\n\t} else {\n\t\tstruct objlayout *objlay = oir->objlay;\n\n\t\tspin_lock(&objlay->lock);\n\t\tobjlay->delta_space_valid = OBJ_DSU_INVALID;\n\t\tlist_add(&objlay->err_list, &oir->err_list);\n\t\tspin_unlock(&objlay->lock);\n\t}\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&objlay->lock"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&objlay->err_list",
            "&oir->err_list"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&objlay->lock"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "objio_free_result",
          "args": [
            "oir"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "objio_free_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "332-338",
          "snippet": "void objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nvoid objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "oir->status >= 0"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void\nobjlayout_iodone(struct objlayout_io_res *oir)\n{\n\tif (likely(oir->status >= 0)) {\n\t\tobjio_free_result(oir);\n\t} else {\n\t\tstruct objlayout *objlay = oir->objlay;\n\n\t\tspin_lock(&objlay->lock);\n\t\tobjlay->delta_space_valid = OBJ_DSU_INVALID;\n\t\tlist_add(&objlay->err_list, &oir->err_list);\n\t\tspin_unlock(&objlay->lock);\n\t}\n}"
  },
  {
    "function_name": "_fix_verify_io_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "151-168",
    "snippet": "static void _fix_verify_io_params(struct pnfs_layout_segment *lseg,\n\t\t\t   struct page ***p_pages, unsigned *p_pgbase,\n\t\t\t   u64 offset, unsigned long count)\n{\n\tu64 lseg_end_offset;\n\n\tBUG_ON(offset < lseg->pls_range.offset);\n\tlseg_end_offset = end_offset(lseg->pls_range.offset,\n\t\t\t\t     lseg->pls_range.length);\n\tBUG_ON(offset >= lseg_end_offset);\n\tWARN_ON(offset + count > lseg_end_offset);\n\n\tif (*p_pgbase > PAGE_SIZE) {\n\t\tdprintk(\"%s: pgbase(0x%x) > PAGE_SIZE\\n\", __func__, *p_pgbase);\n\t\t*p_pages += *p_pgbase >> PAGE_SHIFT;\n\t\t*p_pgbase &= ~PAGE_MASK;\n\t}\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: pgbase(0x%x) > PAGE_SIZE\\n\"",
            "__func__",
            "*p_pgbase"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "offset + count > lseg_end_offset"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset >= lseg_end_offset"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_offset",
          "args": [
            "lseg->pls_range.offset",
            "lseg->pls_range.length"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "end_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "142-149",
          "snippet": "static inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset < lseg->pls_range.offset"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic void _fix_verify_io_params(struct pnfs_layout_segment *lseg,\n\t\t\t   struct page ***p_pages, unsigned *p_pgbase,\n\t\t\t   u64 offset, unsigned long count)\n{\n\tu64 lseg_end_offset;\n\n\tBUG_ON(offset < lseg->pls_range.offset);\n\tlseg_end_offset = end_offset(lseg->pls_range.offset,\n\t\t\t\t     lseg->pls_range.length);\n\tBUG_ON(offset >= lseg_end_offset);\n\tWARN_ON(offset + count > lseg_end_offset);\n\n\tif (*p_pgbase > PAGE_SIZE) {\n\t\tdprintk(\"%s: pgbase(0x%x) > PAGE_SIZE\\n\", __func__, *p_pgbase);\n\t\t*p_pages += *p_pgbase >> PAGE_SHIFT;\n\t\t*p_pgbase &= ~PAGE_MASK;\n\t}\n}"
  },
  {
    "function_name": "end_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "142-149",
    "snippet": "static inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstatic inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end : NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "objlayout_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "128-137",
    "snippet": "void\nobjlayout_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tdprintk(\"%s: freeing layout segment %p\\n\", __func__, lseg);\n\n\tif (unlikely(!lseg))\n\t\treturn;\n\n\tobjio_free_lseg(lseg);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "objio_free_lseg",
          "args": [
            "lseg"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "objio_free_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "276-291",
          "snippet": "void objio_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tint i;\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\n\tfor (i = 0; i < objio_seg->oc.numdevs; i++) {\n\t\tstruct ore_dev *od = objio_seg->oc.ods[i];\n\t\tstruct objio_dev_ent *ode;\n\n\t\tif (!od)\n\t\t\tbreak;\n\t\tode = container_of(od, typeof(*ode), od);\n\t\tnfs4_put_deviceid_node(&ode->id_node);\n\t}\n\tkfree(objio_seg);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nvoid objio_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tint i;\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\n\tfor (i = 0; i < objio_seg->oc.numdevs; i++) {\n\t\tstruct ore_dev *od = objio_seg->oc.ods[i];\n\t\tstruct objio_dev_ent *ode;\n\n\t\tif (!od)\n\t\t\tbreak;\n\t\tode = container_of(od, typeof(*ode), od);\n\t\tnfs4_put_deviceid_node(&ode->id_node);\n\t}\n\tkfree(objio_seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lseg"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: freeing layout segment %p\\n\"",
            "__func__",
            "lseg"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tdprintk(\"%s: freeing layout segment %p\\n\", __func__, lseg);\n\n\tif (unlikely(!lseg))\n\t\treturn;\n\n\tobjio_free_lseg(lseg);\n}"
  },
  {
    "function_name": "objlayout_alloc_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "81-123",
    "snippet": "struct pnfs_layout_segment *\nobjlayout_alloc_lseg(struct pnfs_layout_hdr *pnfslay,\n\t\t     struct nfs4_layoutget_res *lgr,\n\t\t     gfp_t gfp_flags)\n{\n\tint status = -ENOMEM;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf = {\n\t\t.pages =  lgr->layoutp->pages,\n\t\t.page_len =  lgr->layoutp->len,\n\t\t.buflen =  lgr->layoutp->len,\n\t\t.len = lgr->layoutp->len,\n\t};\n\tstruct page *scratch;\n\tstruct pnfs_layout_segment *lseg;\n\n\tdprintk(\"%s: Begin pnfslay %p\\n\", __func__, pnfslay);\n\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto err_nofree;\n\n\txdr_init_decode(&stream, &buf, NULL);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\tstatus = objio_alloc_lseg(&lseg, pnfslay, &lgr->range, &stream, gfp_flags);\n\tif (unlikely(status)) {\n\t\tdprintk(\"%s: objio_alloc_lseg Return err %d\\n\", __func__,\n\t\t\tstatus);\n\t\tgoto err;\n\t}\n\n\t__free_page(scratch);\n\n\tdprintk(\"%s: Return %p\\n\", __func__, lseg);\n\treturn lseg;\n\nerr:\n\t__free_page(scratch);\nerr_nofree:\n\tdprintk(\"%s: Err Return=>%d\\n\", __func__, status);\n\treturn ERR_PTR(status);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Err Return=>%d\\n\"",
            "__func__",
            "status"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Return %p\\n\"",
            "__func__",
            "lseg"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: objio_alloc_lseg Return err %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objio_alloc_lseg",
          "args": [
            "&lseg",
            "pnfslay",
            "&lgr->range",
            "&stream",
            "gfp_flags"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "objio_alloc_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "210-274",
          "snippet": "int objio_alloc_lseg(struct pnfs_layout_segment **outp,\n\tstruct pnfs_layout_hdr *pnfslay,\n\tstruct pnfs_layout_range *range,\n\tstruct xdr_stream *xdr,\n\tgfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(pnfslay->plh_inode);\n\tstruct objio_segment *objio_seg;\n\tstruct pnfs_osd_xdr_decode_layout_iter iter;\n\tstruct pnfs_osd_layout layout;\n\tstruct pnfs_osd_object_cred src_comp;\n\tunsigned cur_comp;\n\tint err;\n\n\terr = pnfs_osd_xdr_decode_layout_map(&layout, &iter, xdr);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = __alloc_objio_seg(layout.olo_num_comps, gfp_flags, &objio_seg);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tobjio_seg->layout.stripe_unit = layout.olo_map.odm_stripe_unit;\n\tobjio_seg->layout.group_width = layout.olo_map.odm_group_width;\n\tobjio_seg->layout.group_depth = layout.olo_map.odm_group_depth;\n\tobjio_seg->layout.mirrors_p1 = layout.olo_map.odm_mirror_cnt + 1;\n\tobjio_seg->layout.raid_algorithm = layout.olo_map.odm_raid_algorithm;\n\n\terr = ore_verify_layout(layout.olo_map.odm_num_comps,\n\t\t\t\t\t  &objio_seg->layout);\n\tif (unlikely(err))\n\t\tgoto err;\n\n\tobjio_seg->oc.first_dev = layout.olo_comps_index;\n\tcur_comp = 0;\n\twhile (pnfs_osd_xdr_decode_layout_comp(&src_comp, &iter, xdr, &err)) {\n\t\tstruct nfs4_deviceid_node *d;\n\t\tstruct objio_dev_ent *ode;\n\n\t\tcopy_single_comp(&objio_seg->oc, cur_comp, &src_comp);\n\n\t\td = nfs4_find_get_deviceid(server,\n\t\t\t\t&src_comp.oc_object_id.oid_device_id,\n\t\t\t\tpnfslay->plh_lc_cred, gfp_flags);\n\t\tif (!d) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tode = container_of(d, struct objio_dev_ent, id_node);\n\t\tobjio_seg->oc.ods[cur_comp++] = &ode->od;\n\t}\n\t/* pnfs_osd_xdr_decode_layout_comp returns false on error */\n\tif (unlikely(err))\n\t\tgoto err;\n\n\t*outp = &objio_seg->lseg;\n\treturn 0;\n\nerr:\n\tkfree(objio_seg);\n\tdprintk(\"%s: Error: return %d\\n\", __func__, err);\n\t*outp = NULL;\n\treturn err;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nint objio_alloc_lseg(struct pnfs_layout_segment **outp,\n\tstruct pnfs_layout_hdr *pnfslay,\n\tstruct pnfs_layout_range *range,\n\tstruct xdr_stream *xdr,\n\tgfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(pnfslay->plh_inode);\n\tstruct objio_segment *objio_seg;\n\tstruct pnfs_osd_xdr_decode_layout_iter iter;\n\tstruct pnfs_osd_layout layout;\n\tstruct pnfs_osd_object_cred src_comp;\n\tunsigned cur_comp;\n\tint err;\n\n\terr = pnfs_osd_xdr_decode_layout_map(&layout, &iter, xdr);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = __alloc_objio_seg(layout.olo_num_comps, gfp_flags, &objio_seg);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tobjio_seg->layout.stripe_unit = layout.olo_map.odm_stripe_unit;\n\tobjio_seg->layout.group_width = layout.olo_map.odm_group_width;\n\tobjio_seg->layout.group_depth = layout.olo_map.odm_group_depth;\n\tobjio_seg->layout.mirrors_p1 = layout.olo_map.odm_mirror_cnt + 1;\n\tobjio_seg->layout.raid_algorithm = layout.olo_map.odm_raid_algorithm;\n\n\terr = ore_verify_layout(layout.olo_map.odm_num_comps,\n\t\t\t\t\t  &objio_seg->layout);\n\tif (unlikely(err))\n\t\tgoto err;\n\n\tobjio_seg->oc.first_dev = layout.olo_comps_index;\n\tcur_comp = 0;\n\twhile (pnfs_osd_xdr_decode_layout_comp(&src_comp, &iter, xdr, &err)) {\n\t\tstruct nfs4_deviceid_node *d;\n\t\tstruct objio_dev_ent *ode;\n\n\t\tcopy_single_comp(&objio_seg->oc, cur_comp, &src_comp);\n\n\t\td = nfs4_find_get_deviceid(server,\n\t\t\t\t&src_comp.oc_object_id.oid_device_id,\n\t\t\t\tpnfslay->plh_lc_cred, gfp_flags);\n\t\tif (!d) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tode = container_of(d, struct objio_dev_ent, id_node);\n\t\tobjio_seg->oc.ods[cur_comp++] = &ode->od;\n\t}\n\t/* pnfs_osd_xdr_decode_layout_comp returns false on error */\n\tif (unlikely(err))\n\t\tgoto err;\n\n\t*outp = &objio_seg->lseg;\n\treturn 0;\n\nerr:\n\tkfree(objio_seg);\n\tdprintk(\"%s: Error: return %d\\n\", __func__, err);\n\t*outp = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_set_scratch_buffer",
          "args": [
            "&stream",
            "page_address(scratch)",
            "PAGE_SIZE"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "scratch"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode",
          "args": [
            "&stream",
            "&buf",
            "NULL"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_flags"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Begin pnfslay %p\\n\"",
            "__func__",
            "pnfslay"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstruct pnfs_layout_segment *\nobjlayout_alloc_lseg(struct pnfs_layout_hdr *pnfslay,\n\t\t     struct nfs4_layoutget_res *lgr,\n\t\t     gfp_t gfp_flags)\n{\n\tint status = -ENOMEM;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf = {\n\t\t.pages =  lgr->layoutp->pages,\n\t\t.page_len =  lgr->layoutp->len,\n\t\t.buflen =  lgr->layoutp->len,\n\t\t.len = lgr->layoutp->len,\n\t};\n\tstruct page *scratch;\n\tstruct pnfs_layout_segment *lseg;\n\n\tdprintk(\"%s: Begin pnfslay %p\\n\", __func__, pnfslay);\n\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto err_nofree;\n\n\txdr_init_decode(&stream, &buf, NULL);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\tstatus = objio_alloc_lseg(&lseg, pnfslay, &lgr->range, &stream, gfp_flags);\n\tif (unlikely(status)) {\n\t\tdprintk(\"%s: objio_alloc_lseg Return err %d\\n\", __func__,\n\t\t\tstatus);\n\t\tgoto err;\n\t}\n\n\t__free_page(scratch);\n\n\tdprintk(\"%s: Return %p\\n\", __func__, lseg);\n\treturn lseg;\n\nerr:\n\t__free_page(scratch);\nerr_nofree:\n\tdprintk(\"%s: Err Return=>%d\\n\", __func__, status);\n\treturn ERR_PTR(status);\n}"
  },
  {
    "function_name": "objlayout_free_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "67-76",
    "snippet": "void\nobjlayout_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct objlayout *objlay = OBJLAYOUT(lo);\n\n\tdprintk(\"%s: objlay %p\\n\", __func__, objlay);\n\n\tWARN_ON(!list_empty(&objlay->err_list));\n\tkfree(objlay);\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "objlay"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&objlay->err_list)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&objlay->err_list"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: objlay %p\\n\"",
            "__func__",
            "objlay"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OBJLAYOUT",
          "args": [
            "lo"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "OBJLAYOUT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.h",
          "lines": "67-71",
          "snippet": "static inline struct objlayout *\nOBJLAYOUT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct objlayout, pnfs_layout);\n}",
          "includes": [
            "#include \"../pnfs.h\"",
            "#include <linux/pnfs_osd_xdr.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n#include <linux/pnfs_osd_xdr.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct objlayout *\nOBJLAYOUT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct objlayout, pnfs_layout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct objlayout *objlay = OBJLAYOUT(lo);\n\n\tdprintk(\"%s: objlay %p\\n\", __func__, objlay);\n\n\tWARN_ON(!list_empty(&objlay->err_list));\n\tkfree(objlay);\n}"
  },
  {
    "function_name": "objlayout_alloc_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
    "lines": "50-62",
    "snippet": "struct pnfs_layout_hdr *\nobjlayout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct objlayout *objlay;\n\n\tobjlay = kzalloc(sizeof(struct objlayout), gfp_flags);\n\tif (!objlay)\n\t\treturn NULL;\n\tspin_lock_init(&objlay->lock);\n\tINIT_LIST_HEAD(&objlay->err_list);\n\tdprintk(\"%s: Return %p\\n\", __func__, objlay);\n\treturn &objlay->pnfs_layout;\n}",
    "includes": [
      "#include \"objlayout.h\"",
      "#include <scsi/osd_initiator.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kmod.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Return %p\\n\"",
            "__func__",
            "objlay"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&objlay->err_list"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&objlay->lock"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct objlayout)",
            "gfp_flags"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nstruct pnfs_layout_hdr *\nobjlayout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct objlayout *objlay;\n\n\tobjlay = kzalloc(sizeof(struct objlayout), gfp_flags);\n\tif (!objlay)\n\t\treturn NULL;\n\tspin_lock_init(&objlay->lock);\n\tINIT_LIST_HEAD(&objlay->err_list);\n\tdprintk(\"%s: Return %p\\n\", __func__, objlay);\n\treturn &objlay->pnfs_layout;\n}"
  }
]