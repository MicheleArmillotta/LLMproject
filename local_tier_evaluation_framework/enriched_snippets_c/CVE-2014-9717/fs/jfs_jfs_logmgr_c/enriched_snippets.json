[
  {
    "function_name": "jfs_lmstats_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2521-2524",
    "snippet": "static int jfs_lmstats_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_lmstats_proc_show, NULL);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "jfs_lmstats_proc_show",
            "NULL"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int jfs_lmstats_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_lmstats_proc_show, NULL);\n}"
  },
  {
    "function_name": "jfs_lmstats_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2503-2519",
    "snippet": "static int jfs_lmstats_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Logmgr stats\\n\"\n\t\t       \"================\\n\"\n\t\t       \"commits = %d\\n\"\n\t\t       \"writes submitted = %d\\n\"\n\t\t       \"writes completed = %d\\n\"\n\t\t       \"full pages submitted = %d\\n\"\n\t\t       \"partial pages submitted = %d\\n\",\n\t\t       lmStat.commit,\n\t\t       lmStat.submitted,\n\t\t       lmStat.pagedone,\n\t\t       lmStat.full_page,\n\t\t       lmStat.partial_page);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"JFS Logmgr stats\\n\"\n\t\t       \"================\\n\"\n\t\t       \"commits = %d\\n\"\n\t\t       \"writes submitted = %d\\n\"\n\t\t       \"writes completed = %d\\n\"\n\t\t       \"full pages submitted = %d\\n\"\n\t\t       \"partial pages submitted = %d\\n\"",
            "lmStat.commit",
            "lmStat.submitted",
            "lmStat.pagedone",
            "lmStat.full_page",
            "lmStat.partial_page"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int jfs_lmstats_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Logmgr stats\\n\"\n\t\t       \"================\\n\"\n\t\t       \"commits = %d\\n\"\n\t\t       \"writes submitted = %d\\n\"\n\t\t       \"writes completed = %d\\n\"\n\t\t       \"full pages submitted = %d\\n\"\n\t\t       \"partial pages submitted = %d\\n\",\n\t\t       lmStat.commit,\n\t\t       lmStat.submitted,\n\t\t       lmStat.pagedone,\n\t\t       lmStat.full_page,\n\t\t       lmStat.partial_page);\n\treturn 0;\n}"
  },
  {
    "function_name": "lmLogFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2384-2500",
    "snippet": "int lmLogFormat(struct jfs_log *log, s64 logAddress, int logSize)\n{\n\tint rc = -EIO;\n\tstruct jfs_sb_info *sbi;\n\tstruct logsuper *logsuper;\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tstruct lrd *lrd_ptr;\n\tint npages = 0;\n\tstruct lbuf *bp;\n\n\tjfs_info(\"lmLogFormat: logAddress:%Ld logSize:%d\",\n\t\t (long long)logAddress, logSize);\n\n\tsbi = list_entry(log->sb_list.next, struct jfs_sb_info, log_list);\n\n\t/* allocate a log buffer */\n\tbp = lbmAllocate(log, 1);\n\n\tnpages = logSize >> sbi->l2nbperpage;\n\n\t/*\n\t *\tlog space:\n\t *\n\t * page 0 - reserved;\n\t * page 1 - log superblock;\n\t * page 2 - log data page: A SYNC log record is written\n\t *\t    into this page at logform time;\n\t * pages 3-N - log data page: set to empty log data pages;\n\t */\n\t/*\n\t *\tinit log superblock: log page 1\n\t */\n\tlogsuper = (struct logsuper *) bp->l_ldata;\n\n\tlogsuper->magic = cpu_to_le32(LOGMAGIC);\n\tlogsuper->version = cpu_to_le32(LOGVERSION);\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->flag = cpu_to_le32(sbi->mntflag);\t/* ? */\n\tlogsuper->size = cpu_to_le32(npages);\n\tlogsuper->bsize = cpu_to_le32(sbi->bsize);\n\tlogsuper->l2bsize = cpu_to_le32(sbi->l2bsize);\n\tlogsuper->end = cpu_to_le32(2 * LOGPSIZE + LOGPHDRSIZE + LOGRDSIZE);\n\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tbp->l_blkno = logAddress + sbi->nbperpage;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t/*\n\t *\tinit pages 2 to npages-1 as log data pages:\n\t *\n\t * log page sequence number (lpsn) initialization:\n\t *\n\t * pn:   0     1     2     3                 n-1\n\t *       +-----+-----+=====+=====+===.....===+=====+\n\t * lspn:             N-1   0     1           N-2\n\t *                   <--- N page circular file ---->\n\t *\n\t * the N (= npages-2) data pages of the log is maintained as\n\t * a circular file for the log records;\n\t * lpsn grows by 1 monotonically as each log page is written\n\t * to the circular file of the log;\n\t * and setLogpage() will not reset the page number even if\n\t * the eor is equal to LOGPHDRSIZE. In order for binary search\n\t * still work in find log end process, we have to simulate the\n\t * log wrap situation at the log format time.\n\t * The 1st log page written will have the highest lpsn. Then\n\t * the succeeding log pages will have ascending order of\n\t * the lspn starting from 0, ... (N-2)\n\t */\n\tlp = (struct logpage *) bp->l_ldata;\n\t/*\n\t * initialize 1st log page to be written: lpsn = N - 1,\n\t * write a SYNCPT log record is written to this page\n\t */\n\tlp->h.page = lp->t.page = cpu_to_le32(npages - 3);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE + LOGRDSIZE);\n\n\tlrd_ptr = (struct lrd *) &lp->data;\n\tlrd_ptr->logtid = 0;\n\tlrd_ptr->backchain = 0;\n\tlrd_ptr->type = cpu_to_le16(LOG_SYNCPT);\n\tlrd_ptr->length = 0;\n\tlrd_ptr->log.syncpt.sync = 0;\n\n\tbp->l_blkno += sbi->nbperpage;\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t/*\n\t *\tinitialize succeeding log pages: lpsn = 0, 1, ..., (N-2)\n\t */\n\tfor (lspn = 0; lspn < npages - 3; lspn++) {\n\t\tlp->h.page = lp->t.page = cpu_to_le32(lspn);\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\t\tbp->l_blkno += sbi->nbperpage;\n\t\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\t\tlbmStartIO(bp);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto exit;\n\t}\n\n\trc = 0;\nexit:\n\t/*\n\t *\tfinalize log\n\t */\n\t/* release the buffer */\n\tlbmFree(bp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define lbmDIRECT\t0x0100",
      "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lbmFree",
          "args": [
            "bp"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "lbmFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1930-1939",
          "snippet": "static void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmIOWait",
          "args": [
            "bp",
            "0"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "lbmIOWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2172-2192",
          "snippet": "static int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmERROR\t0x0040",
            "#define\tlbmDONE\t\t0x0020",
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmERROR\t0x0040\n#define\tlbmDONE\t\t0x0020\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmStartIO",
          "args": [
            "bp"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "lbmStartIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2138-2166",
          "snippet": "static void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOGPHDRSIZE"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lspn"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_SYNCPT"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOGPHDRSIZE + LOGRDSIZE"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "npages - 3"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "2 * LOGPSIZE + LOGPHDRSIZE + LOGRDSIZE"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->l2bsize"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->bsize"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "npages"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sbi->mntflag"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LOGREDONE"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LOGVERSION"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LOGMAGIC"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmAllocate",
          "args": [
            "log",
            "1"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "lbmAllocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1899-1922",
          "snippet": "static struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "log->sb_list.next",
            "structjfs_sb_info",
            "log_list"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogFormat: logAddress:%Ld logSize:%d\"",
            "(long long)logAddress",
            "logSize"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogFormat(struct jfs_log *log, s64 logAddress, int logSize)\n{\n\tint rc = -EIO;\n\tstruct jfs_sb_info *sbi;\n\tstruct logsuper *logsuper;\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tstruct lrd *lrd_ptr;\n\tint npages = 0;\n\tstruct lbuf *bp;\n\n\tjfs_info(\"lmLogFormat: logAddress:%Ld logSize:%d\",\n\t\t (long long)logAddress, logSize);\n\n\tsbi = list_entry(log->sb_list.next, struct jfs_sb_info, log_list);\n\n\t/* allocate a log buffer */\n\tbp = lbmAllocate(log, 1);\n\n\tnpages = logSize >> sbi->l2nbperpage;\n\n\t/*\n\t *\tlog space:\n\t *\n\t * page 0 - reserved;\n\t * page 1 - log superblock;\n\t * page 2 - log data page: A SYNC log record is written\n\t *\t    into this page at logform time;\n\t * pages 3-N - log data page: set to empty log data pages;\n\t */\n\t/*\n\t *\tinit log superblock: log page 1\n\t */\n\tlogsuper = (struct logsuper *) bp->l_ldata;\n\n\tlogsuper->magic = cpu_to_le32(LOGMAGIC);\n\tlogsuper->version = cpu_to_le32(LOGVERSION);\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->flag = cpu_to_le32(sbi->mntflag);\t/* ? */\n\tlogsuper->size = cpu_to_le32(npages);\n\tlogsuper->bsize = cpu_to_le32(sbi->bsize);\n\tlogsuper->l2bsize = cpu_to_le32(sbi->l2bsize);\n\tlogsuper->end = cpu_to_le32(2 * LOGPSIZE + LOGPHDRSIZE + LOGRDSIZE);\n\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tbp->l_blkno = logAddress + sbi->nbperpage;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t/*\n\t *\tinit pages 2 to npages-1 as log data pages:\n\t *\n\t * log page sequence number (lpsn) initialization:\n\t *\n\t * pn:   0     1     2     3                 n-1\n\t *       +-----+-----+=====+=====+===.....===+=====+\n\t * lspn:             N-1   0     1           N-2\n\t *                   <--- N page circular file ---->\n\t *\n\t * the N (= npages-2) data pages of the log is maintained as\n\t * a circular file for the log records;\n\t * lpsn grows by 1 monotonically as each log page is written\n\t * to the circular file of the log;\n\t * and setLogpage() will not reset the page number even if\n\t * the eor is equal to LOGPHDRSIZE. In order for binary search\n\t * still work in find log end process, we have to simulate the\n\t * log wrap situation at the log format time.\n\t * The 1st log page written will have the highest lpsn. Then\n\t * the succeeding log pages will have ascending order of\n\t * the lspn starting from 0, ... (N-2)\n\t */\n\tlp = (struct logpage *) bp->l_ldata;\n\t/*\n\t * initialize 1st log page to be written: lpsn = N - 1,\n\t * write a SYNCPT log record is written to this page\n\t */\n\tlp->h.page = lp->t.page = cpu_to_le32(npages - 3);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE + LOGRDSIZE);\n\n\tlrd_ptr = (struct lrd *) &lp->data;\n\tlrd_ptr->logtid = 0;\n\tlrd_ptr->backchain = 0;\n\tlrd_ptr->type = cpu_to_le16(LOG_SYNCPT);\n\tlrd_ptr->length = 0;\n\tlrd_ptr->log.syncpt.sync = 0;\n\n\tbp->l_blkno += sbi->nbperpage;\n\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\tlbmStartIO(bp);\n\tif ((rc = lbmIOWait(bp, 0)))\n\t\tgoto exit;\n\n\t/*\n\t *\tinitialize succeeding log pages: lpsn = 0, 1, ..., (N-2)\n\t */\n\tfor (lspn = 0; lspn < npages - 3; lspn++) {\n\t\tlp->h.page = lp->t.page = cpu_to_le32(lspn);\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\t\tbp->l_blkno += sbi->nbperpage;\n\t\tbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\n\t\tlbmStartIO(bp);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto exit;\n\t}\n\n\trc = 0;\nexit:\n\t/*\n\t *\tfinalize log\n\t */\n\t/* release the buffer */\n\tlbmFree(bp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "jfsIOWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2340-2366",
    "snippet": "int jfsIOWait(void *arg)\n{\n\tstruct lbuf *bp;\n\n\tdo {\n\t\tspin_lock_irq(&log_redrive_lock);\n\t\twhile ((bp = log_redrive_list)) {\n\t\t\tlog_redrive_list = bp->l_redrive_next;\n\t\t\tbp->l_redrive_next = NULL;\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\tlbmStartIO(bp);\n\t\t\tspin_lock_irq(&log_redrive_lock);\n\t\t}\n\n\t\tif (freezing(current)) {\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\tschedule();\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tjfs_info(\"jfsIOWait being killed!\");\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lbuf *log_redrive_list;",
      "static DEFINE_SPINLOCK(log_redrive_lock);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfsIOWait being killed!\""
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log_redrive_lock"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log_redrive_lock"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log_redrive_lock"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmStartIO",
          "args": [
            "bp"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "lbmStartIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2138-2166",
          "snippet": "static void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&log_redrive_lock"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&log_redrive_lock"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct lbuf *log_redrive_list;\nstatic DEFINE_SPINLOCK(log_redrive_lock);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint jfsIOWait(void *arg)\n{\n\tstruct lbuf *bp;\n\n\tdo {\n\t\tspin_lock_irq(&log_redrive_lock);\n\t\twhile ((bp = log_redrive_list)) {\n\t\t\tlog_redrive_list = bp->l_redrive_next;\n\t\t\tbp->l_redrive_next = NULL;\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\tlbmStartIO(bp);\n\t\t\tspin_lock_irq(&log_redrive_lock);\n\t\t}\n\n\t\tif (freezing(current)) {\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\ttry_to_freeze();\n\t\t} else {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&log_redrive_lock);\n\t\t\tschedule();\n\t\t}\n\t} while (!kthread_should_stop());\n\n\tjfs_info(\"jfsIOWait being killed!\");\n\treturn 0;\n}"
  },
  {
    "function_name": "lbmIODone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2199-2338",
    "snippet": "static void lbmIODone(struct bio *bio, int error)\n{\n\tstruct lbuf *bp = bio->bi_private;\n\tstruct lbuf *nextbp, *tail;\n\tstruct jfs_log *log;\n\tunsigned long flags;\n\n\t/*\n\t * get back jfs buffer bound to the i/o buffer\n\t */\n\tjfs_info(\"lbmIODone: bp:0x%p flag:0x%x\", bp, bp->l_flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tbp->l_flag |= lbmDONE;\n\n\tif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tbp->l_flag |= lbmERROR;\n\n\t\tjfs_err(\"lbmIODone: I/O error in JFS log\");\n\t}\n\n\tbio_put(bio);\n\n\t/*\n\t *\tpagein completion\n\t */\n\tif (bp->l_flag & lbmREAD) {\n\t\tbp->l_flag &= ~lbmREAD;\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpageout completion\n\t *\n\t * the bp at the head of write queue has completed pageout.\n\t *\n\t * if single-commit/full-page pageout, remove the current buffer\n\t * from head of pageout queue, and redrive pageout with\n\t * the new buffer at head of pageout queue;\n\t * otherwise, the partial-page pageout buffer stays at\n\t * the head of pageout queue to be redriven for pageout\n\t * by lmGroupCommit() until full-page pageout is completed.\n\t */\n\tbp->l_flag &= ~lbmWRITE;\n\tINCREMENT(lmStat.pagedone);\n\n\t/* update committed lsn */\n\tlog = bp->l_log;\n\tlog->clsn = (bp->l_pn << L2LOGPSIZE) + bp->l_ceor;\n\n\tif (bp->l_flag & lbmDIRECT) {\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t\tLCACHE_UNLOCK(flags);\n\t\treturn;\n\t}\n\n\ttail = log->wqueue;\n\n\t/* single element queue */\n\tif (bp == tail) {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tlog->wqueue = NULL;\n\t\t\tbp->l_wqnext = NULL;\n\t\t}\n\t}\n\t/* multi element queue */\n\telse {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tnextbp = tail->l_wqnext = bp->l_wqnext;\n\t\t\tbp->l_wqnext = NULL;\n\n\t\t\t/*\n\t\t\t * redrive pageout of next page at head of write queue:\n\t\t\t * redrive next page without any bound tblk\n\t\t\t * (i.e., page w/o any COMMIT records), or\n\t\t\t * first page of new group commit which has been\n\t\t\t * queued after current page (subsequent pageout\n\t\t\t * is performed synchronously, except page without\n\t\t\t * any COMMITs) by lmGroupCommit() as indicated\n\t\t\t * by lbmWRITE flag;\n\t\t\t */\n\t\t\tif (nextbp->l_flag & lbmWRITE) {\n\t\t\t\t/*\n\t\t\t\t * We can't do the I/O at interrupt time.\n\t\t\t\t * The jfsIO thread can do it\n\t\t\t\t */\n\t\t\t\tlbmRedrive(nextbp);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tsynchronous pageout:\n\t *\n\t * buffer has not necessarily been removed from write queue\n\t * (e.g., synchronous write of partial-page with COMMIT):\n\t * leave buffer for i/o initiator to dispose\n\t */\n\tif (bp->l_flag & lbmSYNC) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t}\n\n\t/*\n\t *\tGroup Commit pageout:\n\t */\n\telse if (bp->l_flag & lbmGC) {\n\t\tLCACHE_UNLOCK(flags);\n\t\tlmPostGC(bp);\n\t}\n\n\t/*\n\t *\tasynchronous pageout:\n\t *\n\t * buffer must have been removed from write queue:\n\t * insert buffer at head of freelist where it can be recycled\n\t */\n\telse {\n\t\tassert(bp->l_flag & lbmRELEASE);\n\t\tassert(bp->l_flag & lbmFREE);\n\t\tlbmfree(bp);\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define lbmDIRECT\t0x0100",
      "#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */",
      "#define\tlbmERROR\t0x0040",
      "#define\tlbmDONE\t\t0x0020",
      "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
      "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
      "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */",
      "#define\tlbmREAD\t\t0x0001"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static bio_end_io_t lbmIODone;",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmfree",
          "args": [
            "bp"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "lbmfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1941-1955",
          "snippet": "static void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t/*\n\t * return the buffer to head of freelist\n\t */\n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t/*\n\t * return the buffer to head of freelist\n\t */\n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bp->l_flag & lbmFREE"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmPostGC",
          "args": [
            "bp"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "lmPostGC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "823-923",
          "snippet": "static void lmPostGC(struct lbuf * bp)\n{\n\tunsigned long flags;\n\tstruct jfs_log *log = bp->l_log;\n\tstruct logpage *lp;\n\tstruct tblock *tblk, *temp;\n\n\t//LOGGC_LOCK(log);\n\tspin_lock_irqsave(&log->gclock, flags);\n\t/*\n\t * current pageout of group commit completed.\n\t *\n\t * remove/wakeup transactions from commit queue who were\n\t * group committed with the current log page\n\t */\n\tlist_for_each_entry_safe(tblk, temp, &log->cqueue, cqueue) {\n\t\tif (!(tblk->flag & tblkGC_COMMIT))\n\t\t\tbreak;\n\t\t/* if transaction was marked GC_COMMIT then\n\t\t * it has been shipped in the current pageout\n\t\t * and made it to disk - it is committed.\n\t\t */\n\n\t\tif (bp->l_flag & lbmERROR)\n\t\t\ttblk->flag |= tblkGC_ERROR;\n\n\t\t/* remove it from the commit queue */\n\t\tlist_del(&tblk->cqueue);\n\t\ttblk->flag &= ~tblkGC_QUEUE;\n\n\t\tif (tblk == log->flush_tblk) {\n\t\t\t/* we can stop flushing the log now */\n\t\t\tclear_bit(log_FLUSH, &log->flag);\n\t\t\tlog->flush_tblk = NULL;\n\t\t}\n\n\t\tjfs_info(\"lmPostGC: tblk = 0x%p, flag = 0x%x\", tblk,\n\t\t\t tblk->flag);\n\n\t\tif (!(tblk->xflag & COMMIT_FORCE))\n\t\t\t/*\n\t\t\t * Hand tblk over to lazy commit thread\n\t\t\t */\n\t\t\ttxLazyUnlock(tblk);\n\t\telse {\n\t\t\t/* state transition: COMMIT -> COMMITTED */\n\t\t\ttblk->flag |= tblkGC_COMMITTED;\n\n\t\t\tif (tblk->flag & tblkGC_READY)\n\t\t\t\tlog->gcrtc--;\n\n\t\t\tLOGGC_WAKEUP(tblk);\n\t\t}\n\n\t\t/* was page full before pageout ?\n\t\t * (and this is the last tblk bound with the page)\n\t\t */\n\t\tif (tblk->flag & tblkGC_FREE)\n\t\t\tlbmFree(bp);\n\t\t/* did page become full after pageout ?\n\t\t * (and this is the last tblk bound with the page)\n\t\t */\n\t\telse if (tblk->flag & tblkGC_EOP) {\n\t\t\t/* finalize the page */\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tbp->l_ceor = bp->l_eor;\n\t\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\t\tjfs_info(\"lmPostGC: calling lbmWrite\");\n\t\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE,\n\t\t\t\t 1);\n\t\t}\n\n\t}\n\n\t/* are there any transactions who have entered lnGroupCommit()\n\t * (whose COMMITs are after that of the last log page written.\n\t * They are waiting for new group commit (above at (SLEEP 1))\n\t * or lazy transactions are on a full (queued) log page,\n\t * select the latest ready transaction as new group leader and\n\t * wake her up to lead her group.\n\t */\n\tif ((!list_empty(&log->cqueue)) &&\n\t    ((log->gcrtc > 0) || (tblk->bp->l_wqnext != NULL) ||\n\t     test_bit(log_FLUSH, &log->flag) || jfs_tlocks_low))\n\t\t/*\n\t\t * Call lmGCwrite with new group leader\n\t\t */\n\t\tlmGCwrite(log, 1);\n\n\t/* no transaction are ready yet (transactions are only just\n\t * queued (GC_QUEUE) and not entered for group commit yet).\n\t * the first transaction entering group commit\n\t * will elect herself as new group leader.\n\t */\n\telse\n\t\tlog->cflag &= ~logGC_PAGEOUT;\n\n\t//LOGGC_UNLOCK(log);\n\tspin_unlock_irqrestore(&log->gclock, flags);\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmERROR\t0x0040",
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmERROR\t0x0040\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lmPostGC(struct lbuf * bp)\n{\n\tunsigned long flags;\n\tstruct jfs_log *log = bp->l_log;\n\tstruct logpage *lp;\n\tstruct tblock *tblk, *temp;\n\n\t//LOGGC_LOCK(log);\n\tspin_lock_irqsave(&log->gclock, flags);\n\t/*\n\t * current pageout of group commit completed.\n\t *\n\t * remove/wakeup transactions from commit queue who were\n\t * group committed with the current log page\n\t */\n\tlist_for_each_entry_safe(tblk, temp, &log->cqueue, cqueue) {\n\t\tif (!(tblk->flag & tblkGC_COMMIT))\n\t\t\tbreak;\n\t\t/* if transaction was marked GC_COMMIT then\n\t\t * it has been shipped in the current pageout\n\t\t * and made it to disk - it is committed.\n\t\t */\n\n\t\tif (bp->l_flag & lbmERROR)\n\t\t\ttblk->flag |= tblkGC_ERROR;\n\n\t\t/* remove it from the commit queue */\n\t\tlist_del(&tblk->cqueue);\n\t\ttblk->flag &= ~tblkGC_QUEUE;\n\n\t\tif (tblk == log->flush_tblk) {\n\t\t\t/* we can stop flushing the log now */\n\t\t\tclear_bit(log_FLUSH, &log->flag);\n\t\t\tlog->flush_tblk = NULL;\n\t\t}\n\n\t\tjfs_info(\"lmPostGC: tblk = 0x%p, flag = 0x%x\", tblk,\n\t\t\t tblk->flag);\n\n\t\tif (!(tblk->xflag & COMMIT_FORCE))\n\t\t\t/*\n\t\t\t * Hand tblk over to lazy commit thread\n\t\t\t */\n\t\t\ttxLazyUnlock(tblk);\n\t\telse {\n\t\t\t/* state transition: COMMIT -> COMMITTED */\n\t\t\ttblk->flag |= tblkGC_COMMITTED;\n\n\t\t\tif (tblk->flag & tblkGC_READY)\n\t\t\t\tlog->gcrtc--;\n\n\t\t\tLOGGC_WAKEUP(tblk);\n\t\t}\n\n\t\t/* was page full before pageout ?\n\t\t * (and this is the last tblk bound with the page)\n\t\t */\n\t\tif (tblk->flag & tblkGC_FREE)\n\t\t\tlbmFree(bp);\n\t\t/* did page become full after pageout ?\n\t\t * (and this is the last tblk bound with the page)\n\t\t */\n\t\telse if (tblk->flag & tblkGC_EOP) {\n\t\t\t/* finalize the page */\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tbp->l_ceor = bp->l_eor;\n\t\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\t\tjfs_info(\"lmPostGC: calling lbmWrite\");\n\t\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE,\n\t\t\t\t 1);\n\t\t}\n\n\t}\n\n\t/* are there any transactions who have entered lnGroupCommit()\n\t * (whose COMMITs are after that of the last log page written.\n\t * They are waiting for new group commit (above at (SLEEP 1))\n\t * or lazy transactions are on a full (queued) log page,\n\t * select the latest ready transaction as new group leader and\n\t * wake her up to lead her group.\n\t */\n\tif ((!list_empty(&log->cqueue)) &&\n\t    ((log->gcrtc > 0) || (tblk->bp->l_wqnext != NULL) ||\n\t     test_bit(log_FLUSH, &log->flag) || jfs_tlocks_low))\n\t\t/*\n\t\t * Call lmGCwrite with new group leader\n\t\t */\n\t\tlmGCwrite(log, 1);\n\n\t/* no transaction are ready yet (transactions are only just\n\t * queued (GC_QUEUE) and not entered for group commit yet).\n\t * the first transaction entering group commit\n\t * will elect herself as new group leader.\n\t */\n\telse\n\t\tlog->cflag &= ~logGC_PAGEOUT;\n\n\t//LOGGC_UNLOCK(log);\n\tspin_unlock_irqrestore(&log->gclock, flags);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_WAKEUP",
          "args": [
            "&bp->l_ioevent"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmRedrive",
          "args": [
            "nextbp"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "lbmRedrive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1969-1979",
          "snippet": "static inline void lbmRedrive(struct lbuf *bp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&log_redrive_lock, flags);\n\tbp->l_redrive_next = log_redrive_list;\n\tlog_redrive_list = bp;\n\tspin_unlock_irqrestore(&log_redrive_lock, flags);\n\n\twake_up_process(jfsIOthread);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lbuf *log_redrive_list;",
            "static DEFINE_SPINLOCK(log_redrive_lock);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct lbuf *log_redrive_list;\nstatic DEFINE_SPINLOCK(log_redrive_lock);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic inline void lbmRedrive(struct lbuf *bp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&log_redrive_lock, flags);\n\tbp->l_redrive_next = log_redrive_list;\n\tlog_redrive_list = bp;\n\tspin_unlock_irqrestore(&log_redrive_lock, flags);\n\n\twake_up_process(jfsIOthread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_WAKEUP",
          "args": [
            "&bp->l_ioevent"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "lmStat.pagedone"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_WAKEUP",
          "args": [
            "&bp->l_ioevent"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"lbmIODone: I/O error in JFS log\""
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LCACHE_LOCK",
          "args": [
            "flags"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmIODone: bp:0x%p flag:0x%x\"",
            "bp",
            "bp->l_flag"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */\n#define\tlbmERROR\t0x0040\n#define\tlbmDONE\t\t0x0020\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n#define\tlbmREAD\t\t0x0001\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmIODone(struct bio *bio, int error)\n{\n\tstruct lbuf *bp = bio->bi_private;\n\tstruct lbuf *nextbp, *tail;\n\tstruct jfs_log *log;\n\tunsigned long flags;\n\n\t/*\n\t * get back jfs buffer bound to the i/o buffer\n\t */\n\tjfs_info(\"lbmIODone: bp:0x%p flag:0x%x\", bp, bp->l_flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tbp->l_flag |= lbmDONE;\n\n\tif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tbp->l_flag |= lbmERROR;\n\n\t\tjfs_err(\"lbmIODone: I/O error in JFS log\");\n\t}\n\n\tbio_put(bio);\n\n\t/*\n\t *\tpagein completion\n\t */\n\tif (bp->l_flag & lbmREAD) {\n\t\tbp->l_flag &= ~lbmREAD;\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpageout completion\n\t *\n\t * the bp at the head of write queue has completed pageout.\n\t *\n\t * if single-commit/full-page pageout, remove the current buffer\n\t * from head of pageout queue, and redrive pageout with\n\t * the new buffer at head of pageout queue;\n\t * otherwise, the partial-page pageout buffer stays at\n\t * the head of pageout queue to be redriven for pageout\n\t * by lmGroupCommit() until full-page pageout is completed.\n\t */\n\tbp->l_flag &= ~lbmWRITE;\n\tINCREMENT(lmStat.pagedone);\n\n\t/* update committed lsn */\n\tlog = bp->l_log;\n\tlog->clsn = (bp->l_pn << L2LOGPSIZE) + bp->l_ceor;\n\n\tif (bp->l_flag & lbmDIRECT) {\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t\tLCACHE_UNLOCK(flags);\n\t\treturn;\n\t}\n\n\ttail = log->wqueue;\n\n\t/* single element queue */\n\tif (bp == tail) {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tlog->wqueue = NULL;\n\t\t\tbp->l_wqnext = NULL;\n\t\t}\n\t}\n\t/* multi element queue */\n\telse {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tnextbp = tail->l_wqnext = bp->l_wqnext;\n\t\t\tbp->l_wqnext = NULL;\n\n\t\t\t/*\n\t\t\t * redrive pageout of next page at head of write queue:\n\t\t\t * redrive next page without any bound tblk\n\t\t\t * (i.e., page w/o any COMMIT records), or\n\t\t\t * first page of new group commit which has been\n\t\t\t * queued after current page (subsequent pageout\n\t\t\t * is performed synchronously, except page without\n\t\t\t * any COMMITs) by lmGroupCommit() as indicated\n\t\t\t * by lbmWRITE flag;\n\t\t\t */\n\t\t\tif (nextbp->l_flag & lbmWRITE) {\n\t\t\t\t/*\n\t\t\t\t * We can't do the I/O at interrupt time.\n\t\t\t\t * The jfsIO thread can do it\n\t\t\t\t */\n\t\t\t\tlbmRedrive(nextbp);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tsynchronous pageout:\n\t *\n\t * buffer has not necessarily been removed from write queue\n\t * (e.g., synchronous write of partial-page with COMMIT):\n\t * leave buffer for i/o initiator to dispose\n\t */\n\tif (bp->l_flag & lbmSYNC) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t}\n\n\t/*\n\t *\tGroup Commit pageout:\n\t */\n\telse if (bp->l_flag & lbmGC) {\n\t\tLCACHE_UNLOCK(flags);\n\t\tlmPostGC(bp);\n\t}\n\n\t/*\n\t *\tasynchronous pageout:\n\t *\n\t * buffer must have been removed from write queue:\n\t * insert buffer at head of freelist where it can be recycled\n\t */\n\telse {\n\t\tassert(bp->l_flag & lbmRELEASE);\n\t\tassert(bp->l_flag & lbmFREE);\n\t\tlbmfree(bp);\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t}\n}"
  },
  {
    "function_name": "lbmIOWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2172-2192",
    "snippet": "static int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define\tlbmERROR\t0x0040",
      "#define\tlbmDONE\t\t0x0020",
      "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\"",
            "bp",
            "bp->l_flag",
            "flag"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmfree",
          "args": [
            "bp"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "lbmfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1941-1955",
          "snippet": "static void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t/*\n\t * return the buffer to head of freelist\n\t */\n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t/*\n\t * return the buffer to head of freelist\n\t */\n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LCACHE_SLEEP_COND",
          "args": [
            "bp->l_ioevent",
            "(bp->l_flag & lbmDONE)",
            "flags"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_LOCK",
          "args": [
            "flags"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\"",
            "bp",
            "bp->l_flag",
            "flag"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmERROR\t0x0040\n#define\tlbmDONE\t\t0x0020\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}"
  },
  {
    "function_name": "lbmStartIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2138-2166",
    "snippet": "static void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static bio_end_io_t lbmIODone;",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "lmStat.submitted"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "WRITE_SYNC",
            "bio"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmIODone",
          "args": [
            "bio",
            "0"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "lbmIODone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2199-2338",
          "snippet": "static void lbmIODone(struct bio *bio, int error)\n{\n\tstruct lbuf *bp = bio->bi_private;\n\tstruct lbuf *nextbp, *tail;\n\tstruct jfs_log *log;\n\tunsigned long flags;\n\n\t/*\n\t * get back jfs buffer bound to the i/o buffer\n\t */\n\tjfs_info(\"lbmIODone: bp:0x%p flag:0x%x\", bp, bp->l_flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tbp->l_flag |= lbmDONE;\n\n\tif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tbp->l_flag |= lbmERROR;\n\n\t\tjfs_err(\"lbmIODone: I/O error in JFS log\");\n\t}\n\n\tbio_put(bio);\n\n\t/*\n\t *\tpagein completion\n\t */\n\tif (bp->l_flag & lbmREAD) {\n\t\tbp->l_flag &= ~lbmREAD;\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpageout completion\n\t *\n\t * the bp at the head of write queue has completed pageout.\n\t *\n\t * if single-commit/full-page pageout, remove the current buffer\n\t * from head of pageout queue, and redrive pageout with\n\t * the new buffer at head of pageout queue;\n\t * otherwise, the partial-page pageout buffer stays at\n\t * the head of pageout queue to be redriven for pageout\n\t * by lmGroupCommit() until full-page pageout is completed.\n\t */\n\tbp->l_flag &= ~lbmWRITE;\n\tINCREMENT(lmStat.pagedone);\n\n\t/* update committed lsn */\n\tlog = bp->l_log;\n\tlog->clsn = (bp->l_pn << L2LOGPSIZE) + bp->l_ceor;\n\n\tif (bp->l_flag & lbmDIRECT) {\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t\tLCACHE_UNLOCK(flags);\n\t\treturn;\n\t}\n\n\ttail = log->wqueue;\n\n\t/* single element queue */\n\tif (bp == tail) {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tlog->wqueue = NULL;\n\t\t\tbp->l_wqnext = NULL;\n\t\t}\n\t}\n\t/* multi element queue */\n\telse {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tnextbp = tail->l_wqnext = bp->l_wqnext;\n\t\t\tbp->l_wqnext = NULL;\n\n\t\t\t/*\n\t\t\t * redrive pageout of next page at head of write queue:\n\t\t\t * redrive next page without any bound tblk\n\t\t\t * (i.e., page w/o any COMMIT records), or\n\t\t\t * first page of new group commit which has been\n\t\t\t * queued after current page (subsequent pageout\n\t\t\t * is performed synchronously, except page without\n\t\t\t * any COMMITs) by lmGroupCommit() as indicated\n\t\t\t * by lbmWRITE flag;\n\t\t\t */\n\t\t\tif (nextbp->l_flag & lbmWRITE) {\n\t\t\t\t/*\n\t\t\t\t * We can't do the I/O at interrupt time.\n\t\t\t\t * The jfsIO thread can do it\n\t\t\t\t */\n\t\t\t\tlbmRedrive(nextbp);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tsynchronous pageout:\n\t *\n\t * buffer has not necessarily been removed from write queue\n\t * (e.g., synchronous write of partial-page with COMMIT):\n\t * leave buffer for i/o initiator to dispose\n\t */\n\tif (bp->l_flag & lbmSYNC) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t}\n\n\t/*\n\t *\tGroup Commit pageout:\n\t */\n\telse if (bp->l_flag & lbmGC) {\n\t\tLCACHE_UNLOCK(flags);\n\t\tlmPostGC(bp);\n\t}\n\n\t/*\n\t *\tasynchronous pageout:\n\t *\n\t * buffer must have been removed from write queue:\n\t * insert buffer at head of freelist where it can be recycled\n\t */\n\telse {\n\t\tassert(bp->l_flag & lbmRELEASE);\n\t\tassert(bp->l_flag & lbmFREE);\n\t\tlbmfree(bp);\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmDIRECT\t0x0100",
            "#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */",
            "#define\tlbmERROR\t0x0040",
            "#define\tlbmDONE\t\t0x0020",
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */",
            "#define\tlbmREAD\t\t0x0001"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */\n#define\tlbmERROR\t0x0040\n#define\tlbmDONE\t\t0x0020\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n#define\tlbmREAD\t\t0x0001\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmIODone(struct bio *bio, int error)\n{\n\tstruct lbuf *bp = bio->bi_private;\n\tstruct lbuf *nextbp, *tail;\n\tstruct jfs_log *log;\n\tunsigned long flags;\n\n\t/*\n\t * get back jfs buffer bound to the i/o buffer\n\t */\n\tjfs_info(\"lbmIODone: bp:0x%p flag:0x%x\", bp, bp->l_flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tbp->l_flag |= lbmDONE;\n\n\tif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tbp->l_flag |= lbmERROR;\n\n\t\tjfs_err(\"lbmIODone: I/O error in JFS log\");\n\t}\n\n\tbio_put(bio);\n\n\t/*\n\t *\tpagein completion\n\t */\n\tif (bp->l_flag & lbmREAD) {\n\t\tbp->l_flag &= ~lbmREAD;\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpageout completion\n\t *\n\t * the bp at the head of write queue has completed pageout.\n\t *\n\t * if single-commit/full-page pageout, remove the current buffer\n\t * from head of pageout queue, and redrive pageout with\n\t * the new buffer at head of pageout queue;\n\t * otherwise, the partial-page pageout buffer stays at\n\t * the head of pageout queue to be redriven for pageout\n\t * by lmGroupCommit() until full-page pageout is completed.\n\t */\n\tbp->l_flag &= ~lbmWRITE;\n\tINCREMENT(lmStat.pagedone);\n\n\t/* update committed lsn */\n\tlog = bp->l_log;\n\tlog->clsn = (bp->l_pn << L2LOGPSIZE) + bp->l_ceor;\n\n\tif (bp->l_flag & lbmDIRECT) {\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t\tLCACHE_UNLOCK(flags);\n\t\treturn;\n\t}\n\n\ttail = log->wqueue;\n\n\t/* single element queue */\n\tif (bp == tail) {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tlog->wqueue = NULL;\n\t\t\tbp->l_wqnext = NULL;\n\t\t}\n\t}\n\t/* multi element queue */\n\telse {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tnextbp = tail->l_wqnext = bp->l_wqnext;\n\t\t\tbp->l_wqnext = NULL;\n\n\t\t\t/*\n\t\t\t * redrive pageout of next page at head of write queue:\n\t\t\t * redrive next page without any bound tblk\n\t\t\t * (i.e., page w/o any COMMIT records), or\n\t\t\t * first page of new group commit which has been\n\t\t\t * queued after current page (subsequent pageout\n\t\t\t * is performed synchronously, except page without\n\t\t\t * any COMMITs) by lmGroupCommit() as indicated\n\t\t\t * by lbmWRITE flag;\n\t\t\t */\n\t\t\tif (nextbp->l_flag & lbmWRITE) {\n\t\t\t\t/*\n\t\t\t\t * We can't do the I/O at interrupt time.\n\t\t\t\t * The jfsIO thread can do it\n\t\t\t\t */\n\t\t\t\tlbmRedrive(nextbp);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tsynchronous pageout:\n\t *\n\t * buffer has not necessarily been removed from write queue\n\t * (e.g., synchronous write of partial-page with COMMIT):\n\t * leave buffer for i/o initiator to dispose\n\t */\n\tif (bp->l_flag & lbmSYNC) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t}\n\n\t/*\n\t *\tGroup Commit pageout:\n\t */\n\telse if (bp->l_flag & lbmGC) {\n\t\tLCACHE_UNLOCK(flags);\n\t\tlmPostGC(bp);\n\t}\n\n\t/*\n\t *\tasynchronous pageout:\n\t *\n\t * buffer must have been removed from write queue:\n\t * insert buffer at head of freelist where it can be recycled\n\t */\n\telse {\n\t\tassert(bp->l_flag & lbmRELEASE);\n\t\tassert(bp->l_flag & lbmFREE);\n\t\tlbmfree(bp);\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmStartIO\\n\""
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}"
  },
  {
    "function_name": "lbmDirectWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2108-2126",
    "snippet": "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag | lbmDIRECT;\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t/*\n\t *\tinitiate pageout of the page\n\t */\n\tlbmStartIO(bp);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define lbmDIRECT\t0x0100"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lbmStartIO",
          "args": [
            "bp"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "lbmStartIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2138-2166",
          "snippet": "static void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\"",
            "bp",
            "flag",
            "bp->l_pn"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag | lbmDIRECT;\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t/*\n\t *\tinitiate pageout of the page\n\t */\n\tlbmStartIO(bp);\n}"
  },
  {
    "function_name": "lbmWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "2040-2099",
    "snippet": "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);",
      "static void lmGCwrite(struct jfs_log * log, int cant_block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGGC_LOCK",
          "args": [
            "log"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmStartIO",
          "args": [
            "bp"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "lbmStartIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2138-2166",
          "snippet": "static void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmStartIO(struct lbuf * bp)\n{\n\tstruct bio *bio;\n\tstruct jfs_log *log = bp->l_log;\n\n\tjfs_info(\"lbmStartIO\\n\");\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\n\t/* check if journaling to disk has been disabled */\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(WRITE_SYNC, bio);\n\t\tINCREMENT(lmStat.submitted);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmRedrive",
          "args": [
            "bp"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "lbmRedrive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1969-1979",
          "snippet": "static inline void lbmRedrive(struct lbuf *bp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&log_redrive_lock, flags);\n\tbp->l_redrive_next = log_redrive_list;\n\tlog_redrive_list = bp;\n\tspin_unlock_irqrestore(&log_redrive_lock, flags);\n\n\twake_up_process(jfsIOthread);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lbuf *log_redrive_list;",
            "static DEFINE_SPINLOCK(log_redrive_lock);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct lbuf *log_redrive_list;\nstatic DEFINE_SPINLOCK(log_redrive_lock);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic inline void lbmRedrive(struct lbuf *bp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&log_redrive_lock, flags);\n\tbp->l_redrive_next = log_redrive_list;\n\tlog_redrive_list = bp;\n\tspin_unlock_irqrestore(&log_redrive_lock, flags);\n\n\twake_up_process(jfsIOthread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_LOCK",
          "args": [
            "flags"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\"",
            "bp",
            "flag",
            "bp->l_pn"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\nstatic void lmGCwrite(struct jfs_log * log, int cant_block);\n\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}"
  },
  {
    "function_name": "lbmRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1985-2022",
    "snippet": "static int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t/*\n\t * allocate a log buffer\n\t */\n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t/*check if journaling to disk has been disabled*/\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(READ_SYNC, bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define\tlbmREAD\t\t0x0001"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);",
      "static bio_end_io_t lbmIODone;",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "bp->l_ioevent",
            "(bp->l_flag != lbmREAD)"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "READ_SYNC",
            "bio"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmIODone",
          "args": [
            "bio",
            "0"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "lbmIODone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2199-2338",
          "snippet": "static void lbmIODone(struct bio *bio, int error)\n{\n\tstruct lbuf *bp = bio->bi_private;\n\tstruct lbuf *nextbp, *tail;\n\tstruct jfs_log *log;\n\tunsigned long flags;\n\n\t/*\n\t * get back jfs buffer bound to the i/o buffer\n\t */\n\tjfs_info(\"lbmIODone: bp:0x%p flag:0x%x\", bp, bp->l_flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tbp->l_flag |= lbmDONE;\n\n\tif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tbp->l_flag |= lbmERROR;\n\n\t\tjfs_err(\"lbmIODone: I/O error in JFS log\");\n\t}\n\n\tbio_put(bio);\n\n\t/*\n\t *\tpagein completion\n\t */\n\tif (bp->l_flag & lbmREAD) {\n\t\tbp->l_flag &= ~lbmREAD;\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpageout completion\n\t *\n\t * the bp at the head of write queue has completed pageout.\n\t *\n\t * if single-commit/full-page pageout, remove the current buffer\n\t * from head of pageout queue, and redrive pageout with\n\t * the new buffer at head of pageout queue;\n\t * otherwise, the partial-page pageout buffer stays at\n\t * the head of pageout queue to be redriven for pageout\n\t * by lmGroupCommit() until full-page pageout is completed.\n\t */\n\tbp->l_flag &= ~lbmWRITE;\n\tINCREMENT(lmStat.pagedone);\n\n\t/* update committed lsn */\n\tlog = bp->l_log;\n\tlog->clsn = (bp->l_pn << L2LOGPSIZE) + bp->l_ceor;\n\n\tif (bp->l_flag & lbmDIRECT) {\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t\tLCACHE_UNLOCK(flags);\n\t\treturn;\n\t}\n\n\ttail = log->wqueue;\n\n\t/* single element queue */\n\tif (bp == tail) {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tlog->wqueue = NULL;\n\t\t\tbp->l_wqnext = NULL;\n\t\t}\n\t}\n\t/* multi element queue */\n\telse {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tnextbp = tail->l_wqnext = bp->l_wqnext;\n\t\t\tbp->l_wqnext = NULL;\n\n\t\t\t/*\n\t\t\t * redrive pageout of next page at head of write queue:\n\t\t\t * redrive next page without any bound tblk\n\t\t\t * (i.e., page w/o any COMMIT records), or\n\t\t\t * first page of new group commit which has been\n\t\t\t * queued after current page (subsequent pageout\n\t\t\t * is performed synchronously, except page without\n\t\t\t * any COMMITs) by lmGroupCommit() as indicated\n\t\t\t * by lbmWRITE flag;\n\t\t\t */\n\t\t\tif (nextbp->l_flag & lbmWRITE) {\n\t\t\t\t/*\n\t\t\t\t * We can't do the I/O at interrupt time.\n\t\t\t\t * The jfsIO thread can do it\n\t\t\t\t */\n\t\t\t\tlbmRedrive(nextbp);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tsynchronous pageout:\n\t *\n\t * buffer has not necessarily been removed from write queue\n\t * (e.g., synchronous write of partial-page with COMMIT):\n\t * leave buffer for i/o initiator to dispose\n\t */\n\tif (bp->l_flag & lbmSYNC) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t}\n\n\t/*\n\t *\tGroup Commit pageout:\n\t */\n\telse if (bp->l_flag & lbmGC) {\n\t\tLCACHE_UNLOCK(flags);\n\t\tlmPostGC(bp);\n\t}\n\n\t/*\n\t *\tasynchronous pageout:\n\t *\n\t * buffer must have been removed from write queue:\n\t * insert buffer at head of freelist where it can be recycled\n\t */\n\telse {\n\t\tassert(bp->l_flag & lbmRELEASE);\n\t\tassert(bp->l_flag & lbmFREE);\n\t\tlbmfree(bp);\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmDIRECT\t0x0100",
            "#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */",
            "#define\tlbmERROR\t0x0040",
            "#define\tlbmDONE\t\t0x0020",
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */",
            "#define\tlbmREAD\t\t0x0001"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */\n#define\tlbmERROR\t0x0040\n#define\tlbmDONE\t\t0x0020\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n#define\tlbmREAD\t\t0x0001\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmIODone(struct bio *bio, int error)\n{\n\tstruct lbuf *bp = bio->bi_private;\n\tstruct lbuf *nextbp, *tail;\n\tstruct jfs_log *log;\n\tunsigned long flags;\n\n\t/*\n\t * get back jfs buffer bound to the i/o buffer\n\t */\n\tjfs_info(\"lbmIODone: bp:0x%p flag:0x%x\", bp, bp->l_flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tbp->l_flag |= lbmDONE;\n\n\tif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tbp->l_flag |= lbmERROR;\n\n\t\tjfs_err(\"lbmIODone: I/O error in JFS log\");\n\t}\n\n\tbio_put(bio);\n\n\t/*\n\t *\tpagein completion\n\t */\n\tif (bp->l_flag & lbmREAD) {\n\t\tbp->l_flag &= ~lbmREAD;\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\n\t\treturn;\n\t}\n\n\t/*\n\t *\tpageout completion\n\t *\n\t * the bp at the head of write queue has completed pageout.\n\t *\n\t * if single-commit/full-page pageout, remove the current buffer\n\t * from head of pageout queue, and redrive pageout with\n\t * the new buffer at head of pageout queue;\n\t * otherwise, the partial-page pageout buffer stays at\n\t * the head of pageout queue to be redriven for pageout\n\t * by lmGroupCommit() until full-page pageout is completed.\n\t */\n\tbp->l_flag &= ~lbmWRITE;\n\tINCREMENT(lmStat.pagedone);\n\n\t/* update committed lsn */\n\tlog = bp->l_log;\n\tlog->clsn = (bp->l_pn << L2LOGPSIZE) + bp->l_ceor;\n\n\tif (bp->l_flag & lbmDIRECT) {\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t\tLCACHE_UNLOCK(flags);\n\t\treturn;\n\t}\n\n\ttail = log->wqueue;\n\n\t/* single element queue */\n\tif (bp == tail) {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tlog->wqueue = NULL;\n\t\t\tbp->l_wqnext = NULL;\n\t\t}\n\t}\n\t/* multi element queue */\n\telse {\n\t\t/* remove head buffer of full-page pageout\n\t\t * from log device write queue\n\t\t */\n\t\tif (bp->l_flag & lbmRELEASE) {\n\t\t\tnextbp = tail->l_wqnext = bp->l_wqnext;\n\t\t\tbp->l_wqnext = NULL;\n\n\t\t\t/*\n\t\t\t * redrive pageout of next page at head of write queue:\n\t\t\t * redrive next page without any bound tblk\n\t\t\t * (i.e., page w/o any COMMIT records), or\n\t\t\t * first page of new group commit which has been\n\t\t\t * queued after current page (subsequent pageout\n\t\t\t * is performed synchronously, except page without\n\t\t\t * any COMMITs) by lmGroupCommit() as indicated\n\t\t\t * by lbmWRITE flag;\n\t\t\t */\n\t\t\tif (nextbp->l_flag & lbmWRITE) {\n\t\t\t\t/*\n\t\t\t\t * We can't do the I/O at interrupt time.\n\t\t\t\t * The jfsIO thread can do it\n\t\t\t\t */\n\t\t\t\tlbmRedrive(nextbp);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tsynchronous pageout:\n\t *\n\t * buffer has not necessarily been removed from write queue\n\t * (e.g., synchronous write of partial-page with COMMIT):\n\t * leave buffer for i/o initiator to dispose\n\t */\n\tif (bp->l_flag & lbmSYNC) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\t\t/* wakeup I/O initiator */\n\t\tLCACHE_WAKEUP(&bp->l_ioevent);\n\t}\n\n\t/*\n\t *\tGroup Commit pageout:\n\t */\n\telse if (bp->l_flag & lbmGC) {\n\t\tLCACHE_UNLOCK(flags);\n\t\tlmPostGC(bp);\n\t}\n\n\t/*\n\t *\tasynchronous pageout:\n\t *\n\t * buffer must have been removed from write queue:\n\t * insert buffer at head of freelist where it can be recycled\n\t */\n\telse {\n\t\tassert(bp->l_flag & lbmRELEASE);\n\t\tassert(bp->l_flag & lbmFREE);\n\t\tlbmfree(bp);\n\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmRead: bp:0x%p pn:0x%x\"",
            "bp",
            "pn"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmAllocate",
          "args": [
            "log",
            "pn"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "lbmAllocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1899-1922",
          "snippet": "static struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmREAD\t\t0x0001\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t/*\n\t * allocate a log buffer\n\t */\n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t/*check if journaling to disk has been disabled*/\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(READ_SYNC, bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lbmRedrive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1969-1979",
    "snippet": "static inline void lbmRedrive(struct lbuf *bp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&log_redrive_lock, flags);\n\tbp->l_redrive_next = log_redrive_list;\n\tlog_redrive_list = bp;\n\tspin_unlock_irqrestore(&log_redrive_lock, flags);\n\n\twake_up_process(jfsIOthread);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lbuf *log_redrive_list;",
      "static DEFINE_SPINLOCK(log_redrive_lock);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "jfsIOthread"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&log_redrive_lock",
            "flags"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&log_redrive_lock",
            "flags"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct lbuf *log_redrive_list;\nstatic DEFINE_SPINLOCK(log_redrive_lock);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic inline void lbmRedrive(struct lbuf *bp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&log_redrive_lock, flags);\n\tbp->l_redrive_next = log_redrive_list;\n\tlog_redrive_list = bp;\n\tspin_unlock_irqrestore(&log_redrive_lock, flags);\n\n\twake_up_process(jfsIOthread);\n}"
  },
  {
    "function_name": "lbmfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1941-1955",
    "snippet": "static void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t/*\n\t * return the buffer to head of freelist\n\t */\n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&log->free_wait"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bp->l_wqnext == NULL"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t/*\n\t * return the buffer to head of freelist\n\t */\n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}"
  },
  {
    "function_name": "lbmFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1930-1939",
    "snippet": "static void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmfree",
          "args": [
            "bp"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "lbmfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1941-1955",
          "snippet": "static void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t/*\n\t * return the buffer to head of freelist\n\t */\n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmfree(struct lbuf * bp)\n{\n\tstruct jfs_log *log = bp->l_log;\n\n\tassert(bp->l_wqnext == NULL);\n\n\t/*\n\t * return the buffer to head of freelist\n\t */\n\tbp->l_freelist = log->lbuf_free;\n\tlog->lbuf_free = bp;\n\n\twake_up(&log->free_wait);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LCACHE_LOCK",
          "args": [
            "flags"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}"
  },
  {
    "function_name": "lbmAllocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1899-1922",
    "snippet": "static struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LCACHE_UNLOCK",
          "args": [
            "flags"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_SLEEP_COND",
          "args": [
            "log->free_wait",
            "(bp = log->lbuf_free)",
            "flags"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LCACHE_LOCK",
          "args": [
            "flags"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}"
  },
  {
    "function_name": "lbmLogShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1878-1891",
    "snippet": "static void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lbuf"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "lbuf->l_page"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmLogShutdown: log:0x%p\"",
            "log"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}"
  },
  {
    "function_name": "lbmLogInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1809-1870",
    "snippet": "static int lbmLogInit(struct jfs_log * log)\n{\t\t\t\t/* log inode */\n\tint i;\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogInit: log:0x%p\", log);\n\n\t/* initialize current buffer cursor */\n\tlog->bp = NULL;\n\n\t/* initialize log device write queue */\n\tlog->wqueue = NULL;\n\n\t/*\n\t * Each log has its own buffer pages allocated to it.  These are\n\t * not managed by the page cache.  This ensures that a transaction\n\t * writing to the log does not block trying to allocate a page from\n\t * the page cache (for the log).  This would be bad, since page\n\t * allocation waits on the kswapd thread that may be committing inodes\n\t * which would cause log activity.  Was that clear?  I'm trying to\n\t * avoid deadlock here.\n\t */\n\tinit_waitqueue_head(&log->free_wait);\n\n\tlog->lbuf_free = NULL;\n\n\tfor (i = 0; i < LOGPAGES;) {\n\t\tchar *buffer;\n\t\tuint offset;\n\t\tstruct page *page;\n\n\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\tif (buffer == NULL)\n\t\t\tgoto error;\n\t\tpage = virt_to_page(buffer);\n\t\tfor (offset = 0; offset < PAGE_SIZE; offset += LOGPSIZE) {\n\t\t\tlbuf = kmalloc(sizeof(struct lbuf), GFP_KERNEL);\n\t\t\tif (lbuf == NULL) {\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tfree_page((unsigned long) buffer);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (offset) /* we already have one reference */\n\t\t\t\tget_page(page);\n\t\t\tlbuf->l_offset = offset;\n\t\t\tlbuf->l_ldata = buffer + offset;\n\t\t\tlbuf->l_page = page;\n\t\t\tlbuf->l_log = log;\n\t\t\tinit_waitqueue_head(&lbuf->l_ioevent);\n\n\t\t\tlbuf->l_freelist = log->lbuf_free;\n\t\t\tlog->lbuf_free = lbuf;\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn (0);\n\n      error:\n\tlbmLogShutdown(log);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lbmLogShutdown",
          "args": [
            "log"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "lbmLogShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1878-1891",
          "snippet": "static void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&lbuf->l_ioevent"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) buffer"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct lbuf)",
            "GFP_KERNEL"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "buffer"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&log->free_wait"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lbmLogInit: log:0x%p\"",
            "log"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmLogInit(struct jfs_log * log)\n{\t\t\t\t/* log inode */\n\tint i;\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogInit: log:0x%p\", log);\n\n\t/* initialize current buffer cursor */\n\tlog->bp = NULL;\n\n\t/* initialize log device write queue */\n\tlog->wqueue = NULL;\n\n\t/*\n\t * Each log has its own buffer pages allocated to it.  These are\n\t * not managed by the page cache.  This ensures that a transaction\n\t * writing to the log does not block trying to allocate a page from\n\t * the page cache (for the log).  This would be bad, since page\n\t * allocation waits on the kswapd thread that may be committing inodes\n\t * which would cause log activity.  Was that clear?  I'm trying to\n\t * avoid deadlock here.\n\t */\n\tinit_waitqueue_head(&log->free_wait);\n\n\tlog->lbuf_free = NULL;\n\n\tfor (i = 0; i < LOGPAGES;) {\n\t\tchar *buffer;\n\t\tuint offset;\n\t\tstruct page *page;\n\n\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\tif (buffer == NULL)\n\t\t\tgoto error;\n\t\tpage = virt_to_page(buffer);\n\t\tfor (offset = 0; offset < PAGE_SIZE; offset += LOGPSIZE) {\n\t\t\tlbuf = kmalloc(sizeof(struct lbuf), GFP_KERNEL);\n\t\t\tif (lbuf == NULL) {\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tfree_page((unsigned long) buffer);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (offset) /* we already have one reference */\n\t\t\t\tget_page(page);\n\t\t\tlbuf->l_offset = offset;\n\t\t\tlbuf->l_ldata = buffer + offset;\n\t\t\tlbuf->l_page = page;\n\t\t\tlbuf->l_log = log;\n\t\t\tinit_waitqueue_head(&lbuf->l_ioevent);\n\n\t\t\tlbuf->l_freelist = log->lbuf_free;\n\t\t\tlog->lbuf_free = lbuf;\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn (0);\n\n      error:\n\tlbmLogShutdown(log);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "lmLogFileSystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1730-1787",
    "snippet": "static int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate)\n{\n\tint rc = 0;\n\tint i;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tchar *uuid = sbi->uuid;\n\n\t/*\n\t * insert/remove file system device to log active file system list.\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\treturn rc;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tif (activate) {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, NULL_UUID, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, uuid, 16);\n\t\t\t\tsbi->aggregate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Too many file systems sharing journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EMFILE;\t/* Is there a better rc? */\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, uuid, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, NULL_UUID, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Somebody stomped on the journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EIO;\n\t\t}\n\n\t}\n\n\t/*\n\t * synchronous write log superblock:\n\t *\n\t * write sidestream bypassing write queue:\n\t * at file system mount, log super block is updated for\n\t * activation of the file system before any log record\n\t * (MOUNT record) of the file system, and at file system\n\t * unmount, all meta data for the file system has been\n\t * flushed before log super block is updated for deactivation\n\t * of the file system.\n\t */\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
      "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
      "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lbmIOWait",
          "args": [
            "bpsuper",
            "lbmFREE"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "lbmIOWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2172-2192",
          "snippet": "static int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmERROR\t0x0040",
            "#define\tlbmDONE\t\t0x0020",
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmERROR\t0x0040\n#define\tlbmDONE\t\t0x0020\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmDirectWrite",
          "args": [
            "log",
            "bpsuper",
            "lbmWRITE | lbmRELEASE | lbmSYNC"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "lbmDirectWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2108-2126",
          "snippet": "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag | lbmDIRECT;\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t/*\n\t *\tinitiate pageout of the page\n\t */\n\tlbmStartIO(bp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmDIRECT\t0x0100"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag | lbmDIRECT;\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t/*\n\t *\tinitiate pageout of the page\n\t */\n\tlbmStartIO(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmFree",
          "args": [
            "bpsuper"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "lbmFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1930-1939",
          "snippet": "static void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"Somebody stomped on the journal!\""
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "logsuper->active[i].uuid",
            "NULL_UUID",
            "16"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "logsuper->active[i].uuid",
            "uuid",
            "16"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"Too many file systems sharing journal!\""
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "logsuper->active[i].uuid",
            "uuid",
            "16"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "logsuper->active[i].uuid",
            "NULL_UUID",
            "16"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmRead",
          "args": [
            "log",
            "1",
            "&bpsuper"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "lbmRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1985-2022",
          "snippet": "static int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t/*\n\t * allocate a log buffer\n\t */\n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t/*check if journaling to disk has been disabled*/\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(READ_SYNC, bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmREAD\t\t0x0001"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmREAD\t\t0x0001\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t/*\n\t * allocate a log buffer\n\t */\n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t/*check if journaling to disk has been disabled*/\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(READ_SYNC, bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate)\n{\n\tint rc = 0;\n\tint i;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tchar *uuid = sbi->uuid;\n\n\t/*\n\t * insert/remove file system device to log active file system list.\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\treturn rc;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tif (activate) {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, NULL_UUID, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, uuid, 16);\n\t\t\t\tsbi->aggregate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Too many file systems sharing journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EMFILE;\t/* Is there a better rc? */\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, uuid, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, NULL_UUID, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Somebody stomped on the journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EIO;\n\t\t}\n\n\t}\n\n\t/*\n\t * synchronous write log superblock:\n\t *\n\t * write sidestream bypassing write queue:\n\t * at file system mount, log super block is updated for\n\t * activation of the file system before any log record\n\t * (MOUNT record) of the file system, and at file system\n\t * unmount, all meta data for the file system has been\n\t * flushed before log super block is updated for deactivation\n\t * of the file system.\n\t */\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "lmLogShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1654-1713",
    "snippet": "int lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * write the last SYNCPT record with syncpoint = 0\n\t * (i.e., log redo up to HERE !)\n\t */\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t/*\n\t * synchronous update log superblock\n\t * mark log state as shutdown cleanly\n\t * (i.e., Log does not need to be replayed).\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t/*\n\t * shutdown per log i/o\n\t */\n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
      "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
      "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"lmLogShutdown: exit(%d)\"",
            "rc"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmLogShutdown",
          "args": [
            "log"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "lbmLogShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1878-1891",
          "snippet": "static void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogShutdown: lsn:0x%x page:%d eor:%d\"",
            "lsn",
            "log->page",
            "log->eor"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmIOWait",
          "args": [
            "bpsuper",
            "lbmFREE"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "lbmIOWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2172-2192",
          "snippet": "static int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmERROR\t0x0040",
            "#define\tlbmDONE\t\t0x0020",
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmERROR\t0x0040\n#define\tlbmDONE\t\t0x0020\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmDirectWrite",
          "args": [
            "log",
            "bpsuper",
            "lbmWRITE | lbmRELEASE | lbmSYNC"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "lbmDirectWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2108-2126",
          "snippet": "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag | lbmDIRECT;\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t/*\n\t *\tinitiate pageout of the page\n\t */\n\tlbmStartIO(bp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmDIRECT\t0x0100"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag | lbmDIRECT;\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t/*\n\t *\tinitiate pageout of the page\n\t */\n\tlbmStartIO(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lsn"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LOGREDONE"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmRead",
          "args": [
            "log",
            "1",
            "&bpsuper"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "lbmRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1985-2022",
          "snippet": "static int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t/*\n\t * allocate a log buffer\n\t */\n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t/*check if journaling to disk has been disabled*/\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(READ_SYNC, bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmREAD\t\t0x0001"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmREAD\t\t0x0001\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t/*\n\t * allocate a log buffer\n\t */\n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t/*check if journaling to disk has been disabled*/\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(READ_SYNC, bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmWrite",
          "args": [
            "log",
            "log->bp",
            "lbmWRITE | lbmRELEASE | lbmSYNC",
            "0"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "lbmWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2040-2099",
          "snippet": "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);",
            "static void lmGCwrite(struct jfs_log * log, int cant_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\nstatic void lmGCwrite(struct jfs_log * log, int cant_block);\n\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bp->l_eor"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmWriteRecord",
          "args": [
            "log",
            "NULL",
            "&lrd",
            "NULL"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "lmWriteRecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "356-559",
          "snippet": "static int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_SYNCPT"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_flush_journal",
          "args": [
            "log",
            "2"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_flush_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1532-1638",
          "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogShutdown: log:0x%p\"",
            "log"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * write the last SYNCPT record with syncpoint = 0\n\t * (i.e., log redo up to HERE !)\n\t */\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t/*\n\t * synchronous update log superblock\n\t * mark log state as shutdown cleanly\n\t * (i.e., Log does not need to be replayed).\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t/*\n\t * shutdown per log i/o\n\t */\n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_flush_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1532-1638",
    "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "log_FLUSH",
            "&log->flag"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&log->synclist)"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->synclist"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"tblock:\"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "lp",
            "sizeof(struct tblock)",
            "0"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"page: \"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "sizeof(long)",
            "mp->page",
            "sizeof(struct page)",
            "0"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"metapage: \"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "mp",
            "sizeof(struct metapage)",
            "0"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lp",
            "&log->synclist",
            "synclist"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"jfs_flush_journal: synclist not empty\\n\""
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "list_empty(&log->cqueue)"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_special_inodes",
          "args": [
            "log",
            "filemap_fdatawrite"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "write_special_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "214-224",
          "snippet": "static void write_special_inodes(struct jfs_log *log,\n\t\t\t\t int (*writer)(struct address_space *))\n{\n\tstruct jfs_sb_info *sbi;\n\n\tlist_for_each_entry(sbi, &log->sb_list, log_list) {\n\t\twriter(sbi->ipbmap->i_mapping);\n\t\twriter(sbi->ipimap->i_mapping);\n\t\twriter(sbi->direct_inode->i_mapping);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic void write_special_inodes(struct jfs_log *log,\n\t\t\t\t int (*writer)(struct address_space *))\n{\n\tstruct jfs_sb_info *sbi;\n\n\tlist_for_each_entry(sbi, &log->sb_list, log_list) {\n\t\twriter(sbi->ipbmap->i_mapping);\n\t\twriter(sbi->ipimap->i_mapping);\n\t\twriter(sbi->direct_inode->i_mapping);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "250"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&target->gcwait",
            "&__wait"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_LOCK",
          "args": [
            "log"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&target->gcwait",
            "&__wait"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "__wait",
            "current"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "log_FLUSH",
            "&log->flag"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_SYNCBARRIER",
            "&log->flag"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmGCwrite",
          "args": [
            "log",
            "0"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "lmGCwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "758-809",
          "snippet": "static void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "log->cqueue.prev",
            "structtblock",
            "cqueue"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_LOCK",
          "args": [
            "log"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_flush_journal: log:0x%p wait=%d\"",
            "log",
            "wait"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
  },
  {
    "function_name": "lmLogClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1458-1519",
    "snippet": "int lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t/*\n\t * We need to make sure all of the \"written\" metapages\n\t * actually make it to disk\n\t */\n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t/*\n\t\t *\tin-line log in host file system\n\t\t */\n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t/*\n\t * TODO: ensure that the dummy_log is in a state to allow\n\t * lbmLogShutdown to deallocate all the buffers and call\n\t * kfree against dummy_log.  For now, leave dummy_log & its\n\t * buffers in memory, and resuse if another no-integrity mount\n\t * is requested.\n\t */\n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t/*\n\t *\texternal log as separate logical volume\n\t */\n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct jfs_log *dummy_log;",
      "static DEFINE_MUTEX(jfs_log_mutex);",
      "static int lmNextPage(struct jfs_log * log);",
      "static int open_inline_log(struct super_block *sb);",
      "static int open_dummy_log(struct super_block *sb);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogClose: exit(%d)\"",
            "rc"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLogShutdown",
          "args": [
            "log"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1654-1713",
          "snippet": "int lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * write the last SYNCPT record with syncpoint = 0\n\t * (i.e., log redo up to HERE !)\n\t */\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t/*\n\t * synchronous update log superblock\n\t * mark log state as shutdown cleanly\n\t * (i.e., Log does not need to be replayed).\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t/*\n\t * shutdown per log i/o\n\t */\n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogShutdown(struct jfs_log * log)\n{\n\tint rc;\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\n\tjfs_info(\"lmLogShutdown: log:0x%p\", log);\n\n\tjfs_flush_journal(log, 2);\n\n\t/*\n\t * write the last SYNCPT record with syncpoint = 0\n\t * (i.e., log redo up to HERE !)\n\t */\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\tlrd.length = 0;\n\tlrd.log.syncpt.sync = 0;\n\n\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\tlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\n\tlbmIOWait(log->bp, lbmFREE);\n\tlog->bp = NULL;\n\n\t/*\n\t * synchronous update log superblock\n\t * mark log state as shutdown cleanly\n\t * (i.e., Log does not need to be replayed).\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\tgoto out;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tlogsuper->state = cpu_to_le32(LOGREDONE);\n\tlogsuper->end = cpu_to_le32(lsn);\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\tjfs_info(\"lmLogShutdown: lsn:0x%x page:%d eor:%d\",\n\t\t lsn, log->page, log->eor);\n\n      out:\n\t/*\n\t * shutdown per log i/o\n\t */\n\tlbmLogShutdown(log);\n\n\tif (rc) {\n\t\tjfs_warn(\"lmLogShutdown: exit(%d)\", rc);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&log->journal_list"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->sb_list"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLogFileSystem",
          "args": [
            "log",
            "sbi",
            "0"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogFileSystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1730-1787",
          "snippet": "static int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate)\n{\n\tint rc = 0;\n\tint i;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tchar *uuid = sbi->uuid;\n\n\t/*\n\t * insert/remove file system device to log active file system list.\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\treturn rc;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tif (activate) {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, NULL_UUID, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, uuid, 16);\n\t\t\t\tsbi->aggregate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Too many file systems sharing journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EMFILE;\t/* Is there a better rc? */\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, uuid, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, NULL_UUID, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Somebody stomped on the journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EIO;\n\t\t}\n\n\t}\n\n\t/*\n\t * synchronous write log superblock:\n\t *\n\t * write sidestream bypassing write queue:\n\t * at file system mount, log super block is updated for\n\t * activation of the file system before any log record\n\t * (MOUNT record) of the file system, and at file system\n\t * unmount, all meta data for the file system has been\n\t * flushed before log super block is updated for deactivation\n\t * of the file system.\n\t */\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate)\n{\n\tint rc = 0;\n\tint i;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tchar *uuid = sbi->uuid;\n\n\t/*\n\t * insert/remove file system device to log active file system list.\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\treturn rc;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tif (activate) {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, NULL_UUID, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, uuid, 16);\n\t\t\t\tsbi->aggregate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Too many file systems sharing journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EMFILE;\t/* Is there a better rc? */\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, uuid, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, NULL_UUID, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Somebody stomped on the journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EIO;\n\t\t}\n\n\t}\n\n\t/*\n\t * synchronous write log superblock:\n\t *\n\t * write sidestream bypassing write queue:\n\t * at file system mount, log super block is updated for\n\t * activation of the file system before any log record\n\t * (MOUNT record) of the file system, and at file system\n\t * unmount, all meta data for the file system has been\n\t * flushed before log super block is updated for deactivation\n\t * of the file system.\n\t */\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_INLINELOG",
            "&log->flag"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOG_UNLOCK",
          "args": [
            "log"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG_LOCK",
          "args": [
            "log"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogClose: log:0x%p\"",
            "log"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct jfs_log *dummy_log;\nstatic DEFINE_MUTEX(jfs_log_mutex);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nint lmLogClose(struct super_block *sb)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_log *log = sbi->log;\n\tstruct block_device *bdev;\n\tint rc = 0;\n\n\tjfs_info(\"lmLogClose: log:0x%p\", log);\n\n\tmutex_lock(&jfs_log_mutex);\n\tLOG_LOCK(log);\n\tlist_del(&sbi->log_list);\n\tLOG_UNLOCK(log);\n\tsbi->log = NULL;\n\n\t/*\n\t * We need to make sure all of the \"written\" metapages\n\t * actually make it to disk\n\t */\n\tsync_blockdev(sb->s_bdev);\n\n\tif (test_bit(log_INLINELOG, &log->flag)) {\n\t\t/*\n\t\t *\tin-line log in host file system\n\t\t */\n\t\trc = lmLogShutdown(log);\n\t\tkfree(log);\n\t\tgoto out;\n\t}\n\n\tif (!log->no_integrity)\n\t\tlmLogFileSystem(log, sbi, 0);\n\n\tif (!list_empty(&log->sb_list))\n\t\tgoto out;\n\n\t/*\n\t * TODO: ensure that the dummy_log is in a state to allow\n\t * lbmLogShutdown to deallocate all the buffers and call\n\t * kfree against dummy_log.  For now, leave dummy_log & its\n\t * buffers in memory, and resuse if another no-integrity mount\n\t * is requested.\n\t */\n\tif (log->no_integrity)\n\t\tgoto out;\n\n\t/*\n\t *\texternal log as separate logical volume\n\t */\n\tlist_del(&log->journal_list);\n\tbdev = log->bdev;\n\trc = lmLogShutdown(log);\n\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n\tkfree(log);\n\n      out:\n\tmutex_unlock(&jfs_log_mutex);\n\tjfs_info(\"lmLogClose: exit(%d)\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "lmLogInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1262-1443",
    "snippet": "int lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
      "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
      "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"lmLogInit: exit(%d)\"",
            "rc"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmLogShutdown",
          "args": [
            "log"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "lbmLogShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1878-1891",
          "snippet": "static void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmFree",
          "args": [
            "bpsuper"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "lbmFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1930-1939",
          "snippet": "static void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\"",
            "log->lsn",
            "log->syncpt",
            "log->sync"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGSYNC_DELTA",
          "args": [
            "log->logsize"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmIOWait",
          "args": [
            "bpsuper",
            "lbmFREE"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "lbmIOWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2172-2192",
          "snippet": "static int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmERROR\t0x0040",
            "#define\tlbmDONE\t\t0x0020",
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmERROR\t0x0040\n#define\tlbmDONE\t\t0x0020\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmIOWait(struct lbuf * bp, int flag)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tjfs_info(\"lbmIOWait1: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\tLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\n\n\trc = (bp->l_flag & lbmERROR) ? -EIO : 0;\n\n\tif (flag & lbmFREE)\n\t\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tjfs_info(\"lbmIOWait2: bp:0x%p flag:0x%x:0x%x\", bp, bp->l_flag, flag);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmDirectWrite",
          "args": [
            "log",
            "bpsuper",
            "lbmWRITE | lbmRELEASE | lbmSYNC"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "lbmDirectWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2108-2126",
          "snippet": "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag | lbmDIRECT;\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t/*\n\t *\tinitiate pageout of the page\n\t */\n\tlbmStartIO(bp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmDIRECT\t0x0100"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmDIRECT\t0x0100\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\n{\n\tjfs_info(\"lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x\",\n\t\t bp, flag, bp->l_pn);\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag | lbmDIRECT;\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\t/*\n\t *\tinitiate pageout of the page\n\t */\n\tlbmStartIO(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "log->serial"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "logsuper->serial"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LOGMOUNT"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmWrite",
          "args": [
            "log",
            "bp",
            "lbmWRITE | lbmSYNC",
            "0"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "lbmWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2040-2099",
          "snippet": "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);",
            "static void lmGCwrite(struct jfs_log * log, int cant_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\nstatic void lmGCwrite(struct jfs_log * log, int cant_block);\n\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bp->l_eor"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmWriteRecord",
          "args": [
            "log",
            "NULL",
            "&lrd",
            "NULL"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "lmWriteRecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "356-559",
          "snippet": "static int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_SYNCPT"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmNextPage",
          "args": [
            "log"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "lmNextPage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "573-661",
          "snippet": "static int lmNextPage(struct jfs_log * log)\n{\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tint pn;\t\t\t/* current page number */\n\tstruct lbuf *bp;\n\tstruct lbuf *nextbp;\n\tstruct tblock *tblk;\n\n\t/* get current log page number and log sequence page number */\n\tpn = log->page;\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlspn = le32_to_cpu(lp->h.page);\n\n\tLOGGC_LOCK(log);\n\n\t/*\n\t *\twrite or queue the full page at the tail of write queue\n\t */\n\t/* get the tail tblk on commit queue */\n\tif (list_empty(&log->cqueue))\n\t\ttblk = NULL;\n\telse\n\t\ttblk = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t/* every tblk who has COMMIT record on the current page,\n\t * and has not been committed, must be on commit queue\n\t * since tblk is queued at commit queueu at the time\n\t * of writing its COMMIT record on the page before\n\t * page becomes full (even though the tblk thread\n\t * who wrote COMMIT record may have been suspended\n\t * currently);\n\t */\n\n\t/* is page bound with outstanding tail tblk ? */\n\tif (tblk && tblk->pn == pn) {\n\t\t/* mark tblk for end-of-page */\n\t\ttblk->flag |= tblkGC_EOP;\n\n\t\tif (log->cflag & logGC_PAGEOUT) {\n\t\t\t/* if page is not already on write queue,\n\t\t\t * just enqueue (no lbmWRITE to prevent redrive)\n\t\t\t * buffer to wqueue to ensure correct serial order\n\t\t\t * of the pages since log pages will be added\n\t\t\t * continuously\n\t\t\t */\n\t\t\tif (bp->l_wqnext == NULL)\n\t\t\t\tlbmWrite(log, bp, 0, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No current GC leader, initiate group commit\n\t\t\t */\n\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\tlmGCwrite(log, 0);\n\t\t}\n\t}\n\t/* page is not bound with outstanding tblk:\n\t * init write or mark it to be redriven (lbmWRITE)\n\t */\n\telse {\n\t\t/* finalize the page */\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE, 0);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\t/*\n\t *\tallocate/initialize next page\n\t */\n\t/* if log wraps, the first data page of log is 2\n\t * (0 never used, 1 is superblock).\n\t */\n\tlog->page = (pn == log->size - 1) ? 2 : pn + 1;\n\tlog->eor = LOGPHDRSIZE;\t/* ? valid page empty/full at logRedo() */\n\n\t/* allocate/initialize next log page buffer */\n\tnextbp = lbmAllocate(log, log->page);\n\tnextbp->l_eor = log->eor;\n\tlog->bp = nextbp;\n\n\t/* initialize next log page */\n\tlp = (struct logpage *) nextbp->l_ldata;\n\tlp->h.page = lp->t.page = cpu_to_le32(lspn + 1);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lmNextPage(struct jfs_log * log)\n{\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tint pn;\t\t\t/* current page number */\n\tstruct lbuf *bp;\n\tstruct lbuf *nextbp;\n\tstruct tblock *tblk;\n\n\t/* get current log page number and log sequence page number */\n\tpn = log->page;\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlspn = le32_to_cpu(lp->h.page);\n\n\tLOGGC_LOCK(log);\n\n\t/*\n\t *\twrite or queue the full page at the tail of write queue\n\t */\n\t/* get the tail tblk on commit queue */\n\tif (list_empty(&log->cqueue))\n\t\ttblk = NULL;\n\telse\n\t\ttblk = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t/* every tblk who has COMMIT record on the current page,\n\t * and has not been committed, must be on commit queue\n\t * since tblk is queued at commit queueu at the time\n\t * of writing its COMMIT record on the page before\n\t * page becomes full (even though the tblk thread\n\t * who wrote COMMIT record may have been suspended\n\t * currently);\n\t */\n\n\t/* is page bound with outstanding tail tblk ? */\n\tif (tblk && tblk->pn == pn) {\n\t\t/* mark tblk for end-of-page */\n\t\ttblk->flag |= tblkGC_EOP;\n\n\t\tif (log->cflag & logGC_PAGEOUT) {\n\t\t\t/* if page is not already on write queue,\n\t\t\t * just enqueue (no lbmWRITE to prevent redrive)\n\t\t\t * buffer to wqueue to ensure correct serial order\n\t\t\t * of the pages since log pages will be added\n\t\t\t * continuously\n\t\t\t */\n\t\t\tif (bp->l_wqnext == NULL)\n\t\t\t\tlbmWrite(log, bp, 0, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No current GC leader, initiate group commit\n\t\t\t */\n\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\tlmGCwrite(log, 0);\n\t\t}\n\t}\n\t/* page is not bound with outstanding tblk:\n\t * init write or mark it to be redriven (lbmWRITE)\n\t */\n\telse {\n\t\t/* finalize the page */\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE, 0);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\t/*\n\t *\tallocate/initialize next page\n\t */\n\t/* if log wraps, the first data page of log is 2\n\t * (0 never used, 1 is superblock).\n\t */\n\tlog->page = (pn == log->size - 1) ? 2 : pn + 1;\n\tlog->eor = LOGPHDRSIZE;\t/* ? valid page empty/full at logRedo() */\n\n\t/* allocate/initialize next log page buffer */\n\tnextbp = lbmAllocate(log, log->page);\n\tnextbp->l_eor = log->eor;\n\tlog->bp = nextbp;\n\n\t/* initialize next log page */\n\tlp = (struct logpage *) nextbp->l_ldata;\n\tlp->h.page = lp->t.page = cpu_to_le32(lspn + 1);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\"",
            "le32_to_cpu(logsuper->end)",
            "log->page",
            "log->eor",
            "le16_to_cpu(lp->h.eor)"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "lp->h.eor"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmRead",
          "args": [
            "log",
            "log->page",
            "&bp"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "lbmRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1985-2022",
          "snippet": "static int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t/*\n\t * allocate a log buffer\n\t */\n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t/*check if journaling to disk has been disabled*/\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(READ_SYNC, bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmREAD\t\t0x0001"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);",
            "static bio_end_io_t lbmIODone;",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmREAD\t\t0x0001\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp);\nstatic bio_end_io_t lbmIODone;\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\n{\n\tstruct bio *bio;\n\tstruct lbuf *bp;\n\n\t/*\n\t * allocate a log buffer\n\t */\n\t*bpp = bp = lbmAllocate(log, pn);\n\tjfs_info(\"lbmRead: bp:0x%p pn:0x%x\", bp, pn);\n\n\tbp->l_flag |= lbmREAD;\n\n\tbio = bio_alloc(GFP_NOFS, 1);\n\n\tbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\n\tbio->bi_bdev = log->bdev;\n\tbio->bi_io_vec[0].bv_page = bp->l_page;\n\tbio->bi_io_vec[0].bv_len = LOGPSIZE;\n\tbio->bi_io_vec[0].bv_offset = bp->l_offset;\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = LOGPSIZE;\n\n\tbio->bi_end_io = lbmIODone;\n\tbio->bi_private = bp;\n\t/*check if journaling to disk has been disabled*/\n\tif (log->no_integrity) {\n\t\tbio->bi_iter.bi_size = 0;\n\t\tlbmIODone(bio, 0);\n\t} else {\n\t\tsubmit_bio(READ_SYNC, bio);\n\t}\n\n\twait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\"",
            "log",
            "(unsigned long long) log->base",
            "log->size"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"wrong uuid on JFS log device\""
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "logsuper->uuid",
            "log->uuid",
            "16"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\"",
            "log",
            "(unsigned long long) log->base",
            "log->size"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_INLINELOG",
            "&log->flag"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"*** Log Is Dirty ! ***\""
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LOGREDONE"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"*** Log Format Error ! ***\""
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LOGMAGIC"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmAllocate",
          "args": [
            "log",
            "0"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "lbmAllocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1899-1922",
          "snippet": "static struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmLogInit",
          "args": [
            "log"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "lbmLogInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1809-1870",
          "snippet": "static int lbmLogInit(struct jfs_log * log)\n{\t\t\t\t/* log inode */\n\tint i;\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogInit: log:0x%p\", log);\n\n\t/* initialize current buffer cursor */\n\tlog->bp = NULL;\n\n\t/* initialize log device write queue */\n\tlog->wqueue = NULL;\n\n\t/*\n\t * Each log has its own buffer pages allocated to it.  These are\n\t * not managed by the page cache.  This ensures that a transaction\n\t * writing to the log does not block trying to allocate a page from\n\t * the page cache (for the log).  This would be bad, since page\n\t * allocation waits on the kswapd thread that may be committing inodes\n\t * which would cause log activity.  Was that clear?  I'm trying to\n\t * avoid deadlock here.\n\t */\n\tinit_waitqueue_head(&log->free_wait);\n\n\tlog->lbuf_free = NULL;\n\n\tfor (i = 0; i < LOGPAGES;) {\n\t\tchar *buffer;\n\t\tuint offset;\n\t\tstruct page *page;\n\n\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\tif (buffer == NULL)\n\t\t\tgoto error;\n\t\tpage = virt_to_page(buffer);\n\t\tfor (offset = 0; offset < PAGE_SIZE; offset += LOGPSIZE) {\n\t\t\tlbuf = kmalloc(sizeof(struct lbuf), GFP_KERNEL);\n\t\t\tif (lbuf == NULL) {\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tfree_page((unsigned long) buffer);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (offset) /* we already have one reference */\n\t\t\t\tget_page(page);\n\t\t\tlbuf->l_offset = offset;\n\t\t\tlbuf->l_ldata = buffer + offset;\n\t\t\tlbuf->l_page = page;\n\t\t\tlbuf->l_log = log;\n\t\t\tinit_waitqueue_head(&lbuf->l_ioevent);\n\n\t\t\tlbuf->l_freelist = log->lbuf_free;\n\t\t\tlog->lbuf_free = lbuf;\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn (0);\n\n      error:\n\tlbmLogShutdown(log);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lbmLogInit(struct jfs_log * log)\n{\t\t\t\t/* log inode */\n\tint i;\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogInit: log:0x%p\", log);\n\n\t/* initialize current buffer cursor */\n\tlog->bp = NULL;\n\n\t/* initialize log device write queue */\n\tlog->wqueue = NULL;\n\n\t/*\n\t * Each log has its own buffer pages allocated to it.  These are\n\t * not managed by the page cache.  This ensures that a transaction\n\t * writing to the log does not block trying to allocate a page from\n\t * the page cache (for the log).  This would be bad, since page\n\t * allocation waits on the kswapd thread that may be committing inodes\n\t * which would cause log activity.  Was that clear?  I'm trying to\n\t * avoid deadlock here.\n\t */\n\tinit_waitqueue_head(&log->free_wait);\n\n\tlog->lbuf_free = NULL;\n\n\tfor (i = 0; i < LOGPAGES;) {\n\t\tchar *buffer;\n\t\tuint offset;\n\t\tstruct page *page;\n\n\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\tif (buffer == NULL)\n\t\t\tgoto error;\n\t\tpage = virt_to_page(buffer);\n\t\tfor (offset = 0; offset < PAGE_SIZE; offset += LOGPSIZE) {\n\t\t\tlbuf = kmalloc(sizeof(struct lbuf), GFP_KERNEL);\n\t\t\tif (lbuf == NULL) {\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tfree_page((unsigned long) buffer);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (offset) /* we already have one reference */\n\t\t\t\tget_page(page);\n\t\t\tlbuf->l_offset = offset;\n\t\t\tlbuf->l_ldata = buffer + offset;\n\t\t\tlbuf->l_page = page;\n\t\t\tlbuf->l_log = log;\n\t\t\tinit_waitqueue_head(&lbuf->l_ioevent);\n\n\t\t\tlbuf->l_freelist = log->lbuf_free;\n\t\t\tlog->lbuf_free = lbuf;\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn (0);\n\n      error:\n\tlbmLogShutdown(log);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&log->cqueue"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&log->synclist"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGSYNC_LOCK_INIT",
          "args": [
            "log"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG_LOCK_INIT",
          "args": [
            "log"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_LOCK_INIT",
          "args": [
            "log"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLogInit: log:0x%p\"",
            "log"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "open_dummy_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1209-1242",
    "snippet": "static int open_dummy_log(struct super_block *sb)\n{\n\tint rc;\n\n\tmutex_lock(&jfs_log_mutex);\n\tif (!dummy_log) {\n\t\tdummy_log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL);\n\t\tif (!dummy_log) {\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(&dummy_log->sb_list);\n\t\tinit_waitqueue_head(&dummy_log->syncwait);\n\t\tdummy_log->no_integrity = 1;\n\t\t/* Make up some stuff */\n\t\tdummy_log->base = 0;\n\t\tdummy_log->size = 1024;\n\t\trc = lmLogInit(dummy_log);\n\t\tif (rc) {\n\t\t\tkfree(dummy_log);\n\t\t\tdummy_log = NULL;\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tLOG_LOCK(dummy_log);\n\tlist_add(&JFS_SBI(sb)->log_list, &dummy_log->sb_list);\n\tJFS_SBI(sb)->log = dummy_log;\n\tLOG_UNLOCK(dummy_log);\n\tmutex_unlock(&jfs_log_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct jfs_log *dummy_log;",
      "static DEFINE_MUTEX(jfs_log_mutex);",
      "static int lmNextPage(struct jfs_log * log);",
      "static int open_inline_log(struct super_block *sb);",
      "static int open_dummy_log(struct super_block *sb);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG_UNLOCK",
          "args": [
            "dummy_log"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&JFS_SBI(sb)->log_list",
            "&dummy_log->sb_list"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOG_LOCK",
          "args": [
            "dummy_log"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dummy_log"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLogInit",
          "args": [
            "dummy_log"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1262-1443",
          "snippet": "int lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&dummy_log->syncwait"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dummy_log->sb_list"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct jfs_log)",
            "GFP_KERNEL"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct jfs_log *dummy_log;\nstatic DEFINE_MUTEX(jfs_log_mutex);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic int open_dummy_log(struct super_block *sb)\n{\n\tint rc;\n\n\tmutex_lock(&jfs_log_mutex);\n\tif (!dummy_log) {\n\t\tdummy_log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL);\n\t\tif (!dummy_log) {\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(&dummy_log->sb_list);\n\t\tinit_waitqueue_head(&dummy_log->syncwait);\n\t\tdummy_log->no_integrity = 1;\n\t\t/* Make up some stuff */\n\t\tdummy_log->base = 0;\n\t\tdummy_log->size = 1024;\n\t\trc = lmLogInit(dummy_log);\n\t\tif (rc) {\n\t\t\tkfree(dummy_log);\n\t\t\tdummy_log = NULL;\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tLOG_LOCK(dummy_log);\n\tlist_add(&JFS_SBI(sb)->log_list, &dummy_log->sb_list);\n\tJFS_SBI(sb)->log = dummy_log;\n\tLOG_UNLOCK(dummy_log);\n\tmutex_unlock(&jfs_log_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "open_inline_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1176-1207",
    "snippet": "static int open_inline_log(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\tint rc;\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\tset_bit(log_INLINELOG, &log->flag);\n\tlog->bdev = sb->s_bdev;\n\tlog->base = addressPXD(&JFS_SBI(sb)->logpxd);\n\tlog->size = lengthPXD(&JFS_SBI(sb)->logpxd) >>\n\t    (L2LOGPSIZE - sb->s_blocksize_bits);\n\tlog->l2bsize = sb->s_blocksize_bits;\n\tASSERT(L2LOGPSIZE >= sb->s_blocksize_bits);\n\n\t/*\n\t * initialize log.\n\t */\n\tif ((rc = lmLogInit(log))) {\n\t\tkfree(log);\n\t\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\t\treturn rc;\n\t}\n\n\tlist_add(&JFS_SBI(sb)->log_list, &log->sb_list);\n\tJFS_SBI(sb)->log = log;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int open_inline_log(struct super_block *sb);",
      "static int open_dummy_log(struct super_block *sb);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&JFS_SBI(sb)->log_list",
            "&log->sb_list"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"lmLogOpen: exit(%d)\"",
            "rc"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLogInit",
          "args": [
            "log"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1262-1443",
          "snippet": "int lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "L2LOGPSIZE >= sb->s_blocksize_bits"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&JFS_SBI(sb)->logpxd"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&JFS_SBI(sb)->logpxd"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "log_INLINELOG",
            "&log->flag"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&log->syncwait"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&log->sb_list"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct jfs_log)",
            "GFP_KERNEL"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nstatic int open_inline_log(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\tint rc;\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\tset_bit(log_INLINELOG, &log->flag);\n\tlog->bdev = sb->s_bdev;\n\tlog->base = addressPXD(&JFS_SBI(sb)->logpxd);\n\tlog->size = lengthPXD(&JFS_SBI(sb)->logpxd) >>\n\t    (L2LOGPSIZE - sb->s_blocksize_bits);\n\tlog->l2bsize = sb->s_blocksize_bits;\n\tASSERT(L2LOGPSIZE >= sb->s_blocksize_bits);\n\n\t/*\n\t * initialize log.\n\t */\n\tif ((rc = lmLogInit(log))) {\n\t\tkfree(log);\n\t\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\t\treturn rc;\n\t}\n\n\tlist_add(&JFS_SBI(sb)->log_list, &log->sb_list);\n\tJFS_SBI(sb)->log = log;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "lmLogOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1079-1174",
    "snippet": "int lmLogOpen(struct super_block *sb)\n{\n\tint rc;\n\tstruct block_device *bdev;\n\tstruct jfs_log *log;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sbi->flag & JFS_NOINTEGRITY)\n\t\treturn open_dummy_log(sb);\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\treturn open_inline_log(sb);\n\n\tmutex_lock(&jfs_log_mutex);\n\tlist_for_each_entry(log, &jfs_external_logs, journal_list) {\n\t\tif (log->bdev->bd_dev == sbi->logdev) {\n\t\t\tif (memcmp(log->uuid, sbi->loguuid,\n\t\t\t\t   sizeof(log->uuid))) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS journal\\n\");\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * add file system to log active file system list\n\t\t\t */\n\t\t\tif ((rc = lmLogFileSystem(log, sbi, 1))) {\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto journal_found;\n\t\t}\n\t}\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL))) {\n\t\tmutex_unlock(&jfs_log_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\t/*\n\t *\texternal log as separate logical volume\n\t *\n\t * file systems to log may have n-to-1 relationship;\n\t */\n\n\tbdev = blkdev_get_by_dev(sbi->logdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t log);\n\tif (IS_ERR(bdev)) {\n\t\trc = PTR_ERR(bdev);\n\t\tgoto free;\n\t}\n\n\tlog->bdev = bdev;\n\tmemcpy(log->uuid, sbi->loguuid, sizeof(log->uuid));\n\n\t/*\n\t * initialize log:\n\t */\n\tif ((rc = lmLogInit(log)))\n\t\tgoto close;\n\n\tlist_add(&log->journal_list, &jfs_external_logs);\n\n\t/*\n\t * add file system to log active file system list\n\t */\n\tif ((rc = lmLogFileSystem(log, sbi, 1)))\n\t\tgoto shutdown;\n\njournal_found:\n\tLOG_LOCK(log);\n\tlist_add(&sbi->log_list, &log->sb_list);\n\tsbi->log = log;\n\tLOG_UNLOCK(log);\n\n\tmutex_unlock(&jfs_log_mutex);\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      shutdown:\t\t/* unwind lbmLogInit() */\n\tlist_del(&log->journal_list);\n\tlbmLogShutdown(log);\n\n      close:\t\t/* close external log device */\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n      free:\t\t/* free log descriptor */\n\tmutex_unlock(&jfs_log_mutex);\n\tkfree(log);\n\n\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(jfs_external_logs);",
      "static DEFINE_MUTEX(jfs_log_mutex);",
      "static int lmNextPage(struct jfs_log * log);",
      "static int open_inline_log(struct super_block *sb);",
      "static int open_dummy_log(struct super_block *sb);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"lmLogOpen: exit(%d)\"",
            "rc"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmLogShutdown",
          "args": [
            "log"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "lbmLogShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1878-1891",
          "snippet": "static void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic void lbmLogShutdown(struct jfs_log * log)\n{\n\tstruct lbuf *lbuf;\n\n\tjfs_info(\"lbmLogShutdown: log:0x%p\", log);\n\n\tlbuf = log->lbuf_free;\n\twhile (lbuf) {\n\t\tstruct lbuf *next = lbuf->l_freelist;\n\t\t__free_page(lbuf->l_page);\n\t\tkfree(lbuf);\n\t\tlbuf = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&log->journal_list"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG_UNLOCK",
          "args": [
            "log"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sbi->log_list",
            "&log->sb_list"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOG_LOCK",
          "args": [
            "log"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLogFileSystem",
          "args": [
            "log",
            "sbi",
            "1"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogFileSystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1730-1787",
          "snippet": "static int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate)\n{\n\tint rc = 0;\n\tint i;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tchar *uuid = sbi->uuid;\n\n\t/*\n\t * insert/remove file system device to log active file system list.\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\treturn rc;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tif (activate) {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, NULL_UUID, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, uuid, 16);\n\t\t\t\tsbi->aggregate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Too many file systems sharing journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EMFILE;\t/* Is there a better rc? */\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, uuid, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, NULL_UUID, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Somebody stomped on the journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EIO;\n\t\t}\n\n\t}\n\n\t/*\n\t * synchronous write log superblock:\n\t *\n\t * write sidestream bypassing write queue:\n\t * at file system mount, log super block is updated for\n\t * activation of the file system before any log record\n\t * (MOUNT record) of the file system, and at file system\n\t * unmount, all meta data for the file system has been\n\t * flushed before log super block is updated for deactivation\n\t * of the file system.\n\t */\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\n\t\t\t   int activate)\n{\n\tint rc = 0;\n\tint i;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tchar *uuid = sbi->uuid;\n\n\t/*\n\t * insert/remove file system device to log active file system list.\n\t */\n\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\treturn rc;\n\n\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\tif (activate) {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, NULL_UUID, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, uuid, 16);\n\t\t\t\tsbi->aggregate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Too many file systems sharing journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EMFILE;\t/* Is there a better rc? */\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < MAX_ACTIVE; i++)\n\t\t\tif (!memcmp(logsuper->active[i].uuid, uuid, 16)) {\n\t\t\t\tmemcpy(logsuper->active[i].uuid, NULL_UUID, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (i == MAX_ACTIVE) {\n\t\t\tjfs_warn(\"Somebody stomped on the journal!\");\n\t\t\tlbmFree(bpsuper);\n\t\t\treturn -EIO;\n\t\t}\n\n\t}\n\n\t/*\n\t * synchronous write log superblock:\n\t *\n\t * write sidestream bypassing write queue:\n\t * at file system mount, log super block is updated for\n\t * activation of the file system before any log record\n\t * (MOUNT record) of the file system, and at file system\n\t * unmount, all meta data for the file system has been\n\t * flushed before log super block is updated for deactivation\n\t * of the file system.\n\t */\n\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\trc = lbmIOWait(bpsuper, lbmFREE);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmLogInit",
          "args": [
            "log"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1262-1443",
          "snippet": "int lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nint lmLogInit(struct jfs_log * log)\n{\n\tint rc = 0;\n\tstruct lrd lrd;\n\tstruct logsuper *logsuper;\n\tstruct lbuf *bpsuper;\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint lsn = 0;\n\n\tjfs_info(\"lmLogInit: log:0x%p\", log);\n\n\t/* initialize the group commit serialization lock */\n\tLOGGC_LOCK_INIT(log);\n\n\t/* allocate/initialize the log write serialization lock */\n\tLOG_LOCK_INIT(log);\n\n\tLOGSYNC_LOCK_INIT(log);\n\n\tINIT_LIST_HEAD(&log->synclist);\n\n\tINIT_LIST_HEAD(&log->cqueue);\n\tlog->flush_tblk = NULL;\n\n\tlog->count = 0;\n\n\t/*\n\t * initialize log i/o\n\t */\n\tif ((rc = lbmLogInit(log)))\n\t\treturn rc;\n\n\tif (!test_bit(log_INLINELOG, &log->flag))\n\t\tlog->l2bsize = L2LOGPSIZE;\n\n\t/* check for disabled journaling to disk */\n\tif (log->no_integrity) {\n\t\t/*\n\t\t * Journal pages will still be filled.  When the time comes\n\t\t * to actually do the I/O, the write is not done, and the\n\t\t * endio routine is called directly.\n\t\t */\n\t\tbp = lbmAllocate(log , 0);\n\t\tlog->bp = bp;\n\t\tbp->l_pn = bp->l_eor = 0;\n\t} else {\n\t\t/*\n\t\t * validate log superblock\n\t\t */\n\t\tif ((rc = lbmRead(log, 1, &bpsuper)))\n\t\t\tgoto errout10;\n\n\t\tlogsuper = (struct logsuper *) bpsuper->l_ldata;\n\n\t\tif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\n\t\t\tjfs_warn(\"*** Log Format Error ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* logredo() should have been run successfully. */\n\t\tif (logsuper->state != cpu_to_le32(LOGREDONE)) {\n\t\t\tjfs_warn(\"*** Log Is Dirty ! ***\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto errout20;\n\t\t}\n\n\t\t/* initialize log from log superblock */\n\t\tif (test_bit(log_INLINELOG,&log->flag)) {\n\t\t\tif (log->size != le32_to_cpu(logsuper->size)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tjfs_info(\"lmLogInit: inline log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t} else {\n\t\t\tif (memcmp(logsuper->uuid, log->uuid, 16)) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS log device\");\n\t\t\t\tgoto errout20;\n\t\t\t}\n\t\t\tlog->size = le32_to_cpu(logsuper->size);\n\t\t\tlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\n\t\t\tjfs_info(\"lmLogInit: external log:0x%p base:0x%Lx \"\n\t\t\t\t \"size:0x%x\", log,\n\t\t\t\t (unsigned long long) log->base, log->size);\n\t\t}\n\n\t\tlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\n\t\tlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\n\n\t\t/*\n\t\t * initialize for log append write mode\n\t\t */\n\t\t/* establish current/end-of-log page/buffer */\n\t\tif ((rc = lbmRead(log, log->page, &bp)))\n\t\t\tgoto errout20;\n\n\t\tlp = (struct logpage *) bp->l_ldata;\n\n\t\tjfs_info(\"lmLogInit: lsn:0x%x page:%d eor:%d:%d\",\n\t\t\t le32_to_cpu(logsuper->end), log->page, log->eor,\n\t\t\t le16_to_cpu(lp->h.eor));\n\n\t\tlog->bp = bp;\n\t\tbp->l_pn = log->page;\n\t\tbp->l_eor = log->eor;\n\n\t\t/* if current page is full, move on to next page */\n\t\tif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\n\t\t\tlmNextPage(log);\n\n\t\t/*\n\t\t * initialize log syncpoint\n\t\t */\n\t\t/*\n\t\t * write the first SYNCPT record with syncpoint = 0\n\t\t * (i.e., log redo up to HERE !);\n\t\t * remove current page from lbm write queue at end of pageout\n\t\t * (to write log superblock update), but do not release to\n\t\t * freelist;\n\t\t */\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = 0;\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\t\tbp = log->bp;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\n\t\tif ((rc = lbmIOWait(bp, 0)))\n\t\t\tgoto errout30;\n\n\t\t/*\n\t\t * update/write superblock\n\t\t */\n\t\tlogsuper->state = cpu_to_le32(LOGMOUNT);\n\t\tlog->serial = le32_to_cpu(logsuper->serial) + 1;\n\t\tlogsuper->serial = cpu_to_le32(log->serial);\n\t\tlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\n\t\tif ((rc = lbmIOWait(bpsuper, lbmFREE)))\n\t\t\tgoto errout30;\n\t}\n\n\t/* initialize logsync parameters */\n\tlog->logsize = (log->size - 2) << L2LOGPSIZE;\n\tlog->lsn = lsn;\n\tlog->syncpt = lsn;\n\tlog->sync = log->syncpt;\n\tlog->nextsync = LOGSYNC_DELTA(log->logsize);\n\n\tjfs_info(\"lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x\",\n\t\t log->lsn, log->syncpt, log->sync);\n\n\t/*\n\t * initialize for lazy/group commit\n\t */\n\tlog->clsn = lsn;\n\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      errout30:\t\t/* release log page */\n\tlog->wqueue = NULL;\n\tbp->l_wqnext = NULL;\n\tlbmFree(bp);\n\n      errout20:\t\t/* release log superblock */\n\tlbmFree(bpsuper);\n\n      errout10:\t\t/* unwind lbmLogInit() */\n\tlbmLogShutdown(log);\n\n\tjfs_warn(\"lmLogInit: exit(%d)\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "log->uuid",
            "sbi->loguuid",
            "sizeof(log->uuid)"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bdev"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_dev",
          "args": [
            "sbi->logdev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL",
            "log"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1432-1446",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&log->syncwait"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&log->sb_list"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct jfs_log)",
            "GFP_KERNEL"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"wrong uuid on JFS journal\\n\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "log->uuid",
            "sbi->loguuid",
            "sizeof(log->uuid)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "log",
            "&jfs_external_logs",
            "journal_list"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&jfs_log_mutex"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_inline_log",
          "args": [
            "sb"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "open_inline_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1176-1207",
          "snippet": "static int open_inline_log(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\tint rc;\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\tset_bit(log_INLINELOG, &log->flag);\n\tlog->bdev = sb->s_bdev;\n\tlog->base = addressPXD(&JFS_SBI(sb)->logpxd);\n\tlog->size = lengthPXD(&JFS_SBI(sb)->logpxd) >>\n\t    (L2LOGPSIZE - sb->s_blocksize_bits);\n\tlog->l2bsize = sb->s_blocksize_bits;\n\tASSERT(L2LOGPSIZE >= sb->s_blocksize_bits);\n\n\t/*\n\t * initialize log.\n\t */\n\tif ((rc = lmLogInit(log))) {\n\t\tkfree(log);\n\t\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\t\treturn rc;\n\t}\n\n\tlist_add(&JFS_SBI(sb)->log_list, &log->sb_list);\n\tJFS_SBI(sb)->log = log;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int open_inline_log(struct super_block *sb);",
            "static int open_dummy_log(struct super_block *sb);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nstatic int open_inline_log(struct super_block *sb)\n{\n\tstruct jfs_log *log;\n\tint rc;\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\tset_bit(log_INLINELOG, &log->flag);\n\tlog->bdev = sb->s_bdev;\n\tlog->base = addressPXD(&JFS_SBI(sb)->logpxd);\n\tlog->size = lengthPXD(&JFS_SBI(sb)->logpxd) >>\n\t    (L2LOGPSIZE - sb->s_blocksize_bits);\n\tlog->l2bsize = sb->s_blocksize_bits;\n\tASSERT(L2LOGPSIZE >= sb->s_blocksize_bits);\n\n\t/*\n\t * initialize log.\n\t */\n\tif ((rc = lmLogInit(log))) {\n\t\tkfree(log);\n\t\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\t\treturn rc;\n\t}\n\n\tlist_add(&JFS_SBI(sb)->log_list, &log->sb_list);\n\tJFS_SBI(sb)->log = log;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_dummy_log",
          "args": [
            "sb"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "open_dummy_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1209-1242",
          "snippet": "static int open_dummy_log(struct super_block *sb)\n{\n\tint rc;\n\n\tmutex_lock(&jfs_log_mutex);\n\tif (!dummy_log) {\n\t\tdummy_log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL);\n\t\tif (!dummy_log) {\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(&dummy_log->sb_list);\n\t\tinit_waitqueue_head(&dummy_log->syncwait);\n\t\tdummy_log->no_integrity = 1;\n\t\t/* Make up some stuff */\n\t\tdummy_log->base = 0;\n\t\tdummy_log->size = 1024;\n\t\trc = lmLogInit(dummy_log);\n\t\tif (rc) {\n\t\t\tkfree(dummy_log);\n\t\t\tdummy_log = NULL;\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tLOG_LOCK(dummy_log);\n\tlist_add(&JFS_SBI(sb)->log_list, &dummy_log->sb_list);\n\tJFS_SBI(sb)->log = dummy_log;\n\tLOG_UNLOCK(dummy_log);\n\tmutex_unlock(&jfs_log_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct jfs_log *dummy_log;",
            "static DEFINE_MUTEX(jfs_log_mutex);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int open_inline_log(struct super_block *sb);",
            "static int open_dummy_log(struct super_block *sb);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct jfs_log *dummy_log;\nstatic DEFINE_MUTEX(jfs_log_mutex);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic int open_dummy_log(struct super_block *sb)\n{\n\tint rc;\n\n\tmutex_lock(&jfs_log_mutex);\n\tif (!dummy_log) {\n\t\tdummy_log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL);\n\t\tif (!dummy_log) {\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(&dummy_log->sb_list);\n\t\tinit_waitqueue_head(&dummy_log->syncwait);\n\t\tdummy_log->no_integrity = 1;\n\t\t/* Make up some stuff */\n\t\tdummy_log->base = 0;\n\t\tdummy_log->size = 1024;\n\t\trc = lmLogInit(dummy_log);\n\t\tif (rc) {\n\t\t\tkfree(dummy_log);\n\t\t\tdummy_log = NULL;\n\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tLOG_LOCK(dummy_log);\n\tlist_add(&JFS_SBI(sb)->log_list, &dummy_log->sb_list);\n\tJFS_SBI(sb)->log = dummy_log;\n\tLOG_UNLOCK(dummy_log);\n\tmutex_unlock(&jfs_log_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic LIST_HEAD(jfs_external_logs);\nstatic DEFINE_MUTEX(jfs_log_mutex);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int open_inline_log(struct super_block *sb);\nstatic int open_dummy_log(struct super_block *sb);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nint lmLogOpen(struct super_block *sb)\n{\n\tint rc;\n\tstruct block_device *bdev;\n\tstruct jfs_log *log;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\n\tif (sbi->flag & JFS_NOINTEGRITY)\n\t\treturn open_dummy_log(sb);\n\n\tif (sbi->mntflag & JFS_INLINELOG)\n\t\treturn open_inline_log(sb);\n\n\tmutex_lock(&jfs_log_mutex);\n\tlist_for_each_entry(log, &jfs_external_logs, journal_list) {\n\t\tif (log->bdev->bd_dev == sbi->logdev) {\n\t\t\tif (memcmp(log->uuid, sbi->loguuid,\n\t\t\t\t   sizeof(log->uuid))) {\n\t\t\t\tjfs_warn(\"wrong uuid on JFS journal\\n\");\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * add file system to log active file system list\n\t\t\t */\n\t\t\tif ((rc = lmLogFileSystem(log, sbi, 1))) {\n\t\t\t\tmutex_unlock(&jfs_log_mutex);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto journal_found;\n\t\t}\n\t}\n\n\tif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL))) {\n\t\tmutex_unlock(&jfs_log_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&log->sb_list);\n\tinit_waitqueue_head(&log->syncwait);\n\n\t/*\n\t *\texternal log as separate logical volume\n\t *\n\t * file systems to log may have n-to-1 relationship;\n\t */\n\n\tbdev = blkdev_get_by_dev(sbi->logdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t log);\n\tif (IS_ERR(bdev)) {\n\t\trc = PTR_ERR(bdev);\n\t\tgoto free;\n\t}\n\n\tlog->bdev = bdev;\n\tmemcpy(log->uuid, sbi->loguuid, sizeof(log->uuid));\n\n\t/*\n\t * initialize log:\n\t */\n\tif ((rc = lmLogInit(log)))\n\t\tgoto close;\n\n\tlist_add(&log->journal_list, &jfs_external_logs);\n\n\t/*\n\t * add file system to log active file system list\n\t */\n\tif ((rc = lmLogFileSystem(log, sbi, 1)))\n\t\tgoto shutdown;\n\njournal_found:\n\tLOG_LOCK(log);\n\tlist_add(&sbi->log_list, &log->sb_list);\n\tsbi->log = log;\n\tLOG_UNLOCK(log);\n\n\tmutex_unlock(&jfs_log_mutex);\n\treturn 0;\n\n\t/*\n\t *\tunwind on error\n\t */\n      shutdown:\t\t/* unwind lbmLogInit() */\n\tlist_del(&log->journal_list);\n\tlbmLogShutdown(log);\n\n      close:\t\t/* close external log device */\n\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\n      free:\t\t/* free log descriptor */\n\tmutex_unlock(&jfs_log_mutex);\n\tkfree(log);\n\n\tjfs_warn(\"lmLogOpen: exit(%d)\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_syncpt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "1059-1064",
    "snippet": "void jfs_syncpt(struct jfs_log *log, int hard_sync)\n{\tLOG_LOCK(log);\n\tif (!test_bit(log_QUIESCE, &log->flag))\n\t\tlmLogSync(log, hard_sync);\n\tLOG_UNLOCK(log);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static int lmLogSync(struct jfs_log * log, int hard_sync);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOG_UNLOCK",
          "args": [
            "log"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLogSync",
          "args": [
            "log",
            "hard_sync"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "942-1049",
          "snippet": "static int lmLogSync(struct jfs_log * log, int hard_sync)\n{\n\tint logsize;\n\tint written;\t\t/* written since last syncpt */\n\tint free;\t\t/* free space left available */\n\tint delta;\t\t/* additional delta to write normally */\n\tint more;\t\t/* additional write granted */\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsyncblk *lp;\n\tunsigned long flags;\n\n\t/* push dirty metapages out to disk */\n\tif (hard_sync)\n\t\twrite_special_inodes(log, filemap_fdatawrite);\n\telse\n\t\twrite_special_inodes(log, filemap_flush);\n\n\t/*\n\t *\tforward syncpt\n\t */\n\t/* if last sync is same as last syncpt,\n\t * invoke sync point forward processing to update sync.\n\t */\n\n\tif (log->sync == log->syncpt) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (list_empty(&log->synclist))\n\t\t\tlog->sync = log->lsn;\n\t\telse {\n\t\t\tlp = list_entry(log->synclist.next,\n\t\t\t\t\tstruct logsyncblk, synclist);\n\t\t\tlog->sync = lp->lsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t}\n\n\t/* if sync is different from last syncpt,\n\t * write a SYNCPT record with syncpt = sync.\n\t * reset syncpt = sync\n\t */\n\tif (log->sync != log->syncpt) {\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = cpu_to_le32(log->sync);\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\n\t\tlog->syncpt = log->sync;\n\t} else\n\t\tlsn = log->lsn;\n\n\t/*\n\t *\tsetup next syncpt trigger (SWAG)\n\t */\n\tlogsize = log->logsize;\n\n\tlogdiff(written, lsn, log);\n\tfree = logsize - written;\n\tdelta = LOGSYNC_DELTA(logsize);\n\tmore = min(free / 2, delta);\n\tif (more < 2 * LOGPSIZE) {\n\t\tjfs_warn(\"\\n ... Log Wrap ... Log Wrap ... Log Wrap ...\\n\");\n\t\t/*\n\t\t *\tlog wrapping\n\t\t *\n\t\t * option 1 - panic ? No.!\n\t\t * option 2 - shutdown file systems\n\t\t *\t      associated with log ?\n\t\t * option 3 - extend log ?\n\t\t * option 4 - second chance\n\t\t *\n\t\t * mark log wrapped, and continue.\n\t\t * when all active transactions are completed,\n\t\t * mark log valid for recovery.\n\t\t * if crashed during invalid state, log state\n\t\t * implies invalid log, forcing fsck().\n\t\t */\n\t\t/* mark log state log wrap in log superblock */\n\t\t/* log->state = LOGWRAP; */\n\n\t\t/* reset sync point computation */\n\t\tlog->syncpt = log->sync = lsn;\n\t\tlog->nextsync = delta;\n\t} else\n\t\t/* next syncpt trigger = written + more */\n\t\tlog->nextsync = written + more;\n\n\t/* if number of bytes written from last sync point is more\n\t * than 1/4 of the log size, stop new transactions from\n\t * starting until all current transactions are completed\n\t * by setting syncbarrier flag.\n\t */\n\tif (!test_bit(log_SYNCBARRIER, &log->flag) &&\n\t    (written > LOGSYNC_BARRIER(logsize)) && log->active) {\n\t\tset_bit(log_SYNCBARRIER, &log->flag);\n\t\tjfs_info(\"log barrier on: lsn=0x%x syncpt=0x%x\", lsn,\n\t\t\t log->syncpt);\n\t\t/*\n\t\t * We may have to initiate group commit\n\t\t */\n\t\tjfs_flush_journal(log, 0);\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static int lmLogSync(struct jfs_log * log, int hard_sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic int lmLogSync(struct jfs_log * log, int hard_sync);\n\nstatic int lmLogSync(struct jfs_log * log, int hard_sync)\n{\n\tint logsize;\n\tint written;\t\t/* written since last syncpt */\n\tint free;\t\t/* free space left available */\n\tint delta;\t\t/* additional delta to write normally */\n\tint more;\t\t/* additional write granted */\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsyncblk *lp;\n\tunsigned long flags;\n\n\t/* push dirty metapages out to disk */\n\tif (hard_sync)\n\t\twrite_special_inodes(log, filemap_fdatawrite);\n\telse\n\t\twrite_special_inodes(log, filemap_flush);\n\n\t/*\n\t *\tforward syncpt\n\t */\n\t/* if last sync is same as last syncpt,\n\t * invoke sync point forward processing to update sync.\n\t */\n\n\tif (log->sync == log->syncpt) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (list_empty(&log->synclist))\n\t\t\tlog->sync = log->lsn;\n\t\telse {\n\t\t\tlp = list_entry(log->synclist.next,\n\t\t\t\t\tstruct logsyncblk, synclist);\n\t\t\tlog->sync = lp->lsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t}\n\n\t/* if sync is different from last syncpt,\n\t * write a SYNCPT record with syncpt = sync.\n\t * reset syncpt = sync\n\t */\n\tif (log->sync != log->syncpt) {\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = cpu_to_le32(log->sync);\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\n\t\tlog->syncpt = log->sync;\n\t} else\n\t\tlsn = log->lsn;\n\n\t/*\n\t *\tsetup next syncpt trigger (SWAG)\n\t */\n\tlogsize = log->logsize;\n\n\tlogdiff(written, lsn, log);\n\tfree = logsize - written;\n\tdelta = LOGSYNC_DELTA(logsize);\n\tmore = min(free / 2, delta);\n\tif (more < 2 * LOGPSIZE) {\n\t\tjfs_warn(\"\\n ... Log Wrap ... Log Wrap ... Log Wrap ...\\n\");\n\t\t/*\n\t\t *\tlog wrapping\n\t\t *\n\t\t * option 1 - panic ? No.!\n\t\t * option 2 - shutdown file systems\n\t\t *\t      associated with log ?\n\t\t * option 3 - extend log ?\n\t\t * option 4 - second chance\n\t\t *\n\t\t * mark log wrapped, and continue.\n\t\t * when all active transactions are completed,\n\t\t * mark log valid for recovery.\n\t\t * if crashed during invalid state, log state\n\t\t * implies invalid log, forcing fsck().\n\t\t */\n\t\t/* mark log state log wrap in log superblock */\n\t\t/* log->state = LOGWRAP; */\n\n\t\t/* reset sync point computation */\n\t\tlog->syncpt = log->sync = lsn;\n\t\tlog->nextsync = delta;\n\t} else\n\t\t/* next syncpt trigger = written + more */\n\t\tlog->nextsync = written + more;\n\n\t/* if number of bytes written from last sync point is more\n\t * than 1/4 of the log size, stop new transactions from\n\t * starting until all current transactions are completed\n\t * by setting syncbarrier flag.\n\t */\n\tif (!test_bit(log_SYNCBARRIER, &log->flag) &&\n\t    (written > LOGSYNC_BARRIER(logsize)) && log->active) {\n\t\tset_bit(log_SYNCBARRIER, &log->flag);\n\t\tjfs_info(\"log barrier on: lsn=0x%x syncpt=0x%x\", lsn,\n\t\t\t log->syncpt);\n\t\t/*\n\t\t * We may have to initiate group commit\n\t\t */\n\t\tjfs_flush_journal(log, 0);\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_QUIESCE",
            "&log->flag"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOG_LOCK",
          "args": [
            "log"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic int lmLogSync(struct jfs_log * log, int hard_sync);\n\nvoid jfs_syncpt(struct jfs_log *log, int hard_sync)\n{\tLOG_LOCK(log);\n\tif (!test_bit(log_QUIESCE, &log->flag))\n\t\tlmLogSync(log, hard_sync);\n\tLOG_UNLOCK(log);\n}"
  },
  {
    "function_name": "lmLogSync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "942-1049",
    "snippet": "static int lmLogSync(struct jfs_log * log, int hard_sync)\n{\n\tint logsize;\n\tint written;\t\t/* written since last syncpt */\n\tint free;\t\t/* free space left available */\n\tint delta;\t\t/* additional delta to write normally */\n\tint more;\t\t/* additional write granted */\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsyncblk *lp;\n\tunsigned long flags;\n\n\t/* push dirty metapages out to disk */\n\tif (hard_sync)\n\t\twrite_special_inodes(log, filemap_fdatawrite);\n\telse\n\t\twrite_special_inodes(log, filemap_flush);\n\n\t/*\n\t *\tforward syncpt\n\t */\n\t/* if last sync is same as last syncpt,\n\t * invoke sync point forward processing to update sync.\n\t */\n\n\tif (log->sync == log->syncpt) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (list_empty(&log->synclist))\n\t\t\tlog->sync = log->lsn;\n\t\telse {\n\t\t\tlp = list_entry(log->synclist.next,\n\t\t\t\t\tstruct logsyncblk, synclist);\n\t\t\tlog->sync = lp->lsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t}\n\n\t/* if sync is different from last syncpt,\n\t * write a SYNCPT record with syncpt = sync.\n\t * reset syncpt = sync\n\t */\n\tif (log->sync != log->syncpt) {\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = cpu_to_le32(log->sync);\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\n\t\tlog->syncpt = log->sync;\n\t} else\n\t\tlsn = log->lsn;\n\n\t/*\n\t *\tsetup next syncpt trigger (SWAG)\n\t */\n\tlogsize = log->logsize;\n\n\tlogdiff(written, lsn, log);\n\tfree = logsize - written;\n\tdelta = LOGSYNC_DELTA(logsize);\n\tmore = min(free / 2, delta);\n\tif (more < 2 * LOGPSIZE) {\n\t\tjfs_warn(\"\\n ... Log Wrap ... Log Wrap ... Log Wrap ...\\n\");\n\t\t/*\n\t\t *\tlog wrapping\n\t\t *\n\t\t * option 1 - panic ? No.!\n\t\t * option 2 - shutdown file systems\n\t\t *\t      associated with log ?\n\t\t * option 3 - extend log ?\n\t\t * option 4 - second chance\n\t\t *\n\t\t * mark log wrapped, and continue.\n\t\t * when all active transactions are completed,\n\t\t * mark log valid for recovery.\n\t\t * if crashed during invalid state, log state\n\t\t * implies invalid log, forcing fsck().\n\t\t */\n\t\t/* mark log state log wrap in log superblock */\n\t\t/* log->state = LOGWRAP; */\n\n\t\t/* reset sync point computation */\n\t\tlog->syncpt = log->sync = lsn;\n\t\tlog->nextsync = delta;\n\t} else\n\t\t/* next syncpt trigger = written + more */\n\t\tlog->nextsync = written + more;\n\n\t/* if number of bytes written from last sync point is more\n\t * than 1/4 of the log size, stop new transactions from\n\t * starting until all current transactions are completed\n\t * by setting syncbarrier flag.\n\t */\n\tif (!test_bit(log_SYNCBARRIER, &log->flag) &&\n\t    (written > LOGSYNC_BARRIER(logsize)) && log->active) {\n\t\tset_bit(log_SYNCBARRIER, &log->flag);\n\t\tjfs_info(\"log barrier on: lsn=0x%x syncpt=0x%x\", lsn,\n\t\t\t log->syncpt);\n\t\t/*\n\t\t * We may have to initiate group commit\n\t\t */\n\t\tjfs_flush_journal(log, 0);\n\t}\n\n\treturn lsn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static int lmLogSync(struct jfs_log * log, int hard_sync);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_flush_journal",
          "args": [
            "log",
            "0"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_flush_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1532-1638",
          "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"log barrier on: lsn=0x%x syncpt=0x%x\"",
            "lsn",
            "log->syncpt"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "log_SYNCBARRIER",
            "&log->flag"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_BARRIER",
          "args": [
            "logsize"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_SYNCBARRIER",
            "&log->flag"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"\\n ... Log Wrap ... Log Wrap ... Log Wrap ...\\n\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "free / 2",
            "delta"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_DELTA",
          "args": [
            "logsize"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "written",
            "lsn",
            "log"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmWriteRecord",
          "args": [
            "log",
            "NULL",
            "&lrd",
            "NULL"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "lmWriteRecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "356-559",
          "snippet": "static int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "log->sync"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_SYNCPT"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGSYNC_UNLOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "log->synclist.next",
            "structlogsyncblk",
            "synclist"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->synclist"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_LOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_special_inodes",
          "args": [
            "log",
            "filemap_flush"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "write_special_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "214-224",
          "snippet": "static void write_special_inodes(struct jfs_log *log,\n\t\t\t\t int (*writer)(struct address_space *))\n{\n\tstruct jfs_sb_info *sbi;\n\n\tlist_for_each_entry(sbi, &log->sb_list, log_list) {\n\t\twriter(sbi->ipbmap->i_mapping);\n\t\twriter(sbi->ipimap->i_mapping);\n\t\twriter(sbi->direct_inode->i_mapping);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic void write_special_inodes(struct jfs_log *log,\n\t\t\t\t int (*writer)(struct address_space *))\n{\n\tstruct jfs_sb_info *sbi;\n\n\tlist_for_each_entry(sbi, &log->sb_list, log_list) {\n\t\twriter(sbi->ipbmap->i_mapping);\n\t\twriter(sbi->ipimap->i_mapping);\n\t\twriter(sbi->direct_inode->i_mapping);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic int lmLogSync(struct jfs_log * log, int hard_sync);\n\nstatic int lmLogSync(struct jfs_log * log, int hard_sync)\n{\n\tint logsize;\n\tint written;\t\t/* written since last syncpt */\n\tint free;\t\t/* free space left available */\n\tint delta;\t\t/* additional delta to write normally */\n\tint more;\t\t/* additional write granted */\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsyncblk *lp;\n\tunsigned long flags;\n\n\t/* push dirty metapages out to disk */\n\tif (hard_sync)\n\t\twrite_special_inodes(log, filemap_fdatawrite);\n\telse\n\t\twrite_special_inodes(log, filemap_flush);\n\n\t/*\n\t *\tforward syncpt\n\t */\n\t/* if last sync is same as last syncpt,\n\t * invoke sync point forward processing to update sync.\n\t */\n\n\tif (log->sync == log->syncpt) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (list_empty(&log->synclist))\n\t\t\tlog->sync = log->lsn;\n\t\telse {\n\t\t\tlp = list_entry(log->synclist.next,\n\t\t\t\t\tstruct logsyncblk, synclist);\n\t\t\tlog->sync = lp->lsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t}\n\n\t/* if sync is different from last syncpt,\n\t * write a SYNCPT record with syncpt = sync.\n\t * reset syncpt = sync\n\t */\n\tif (log->sync != log->syncpt) {\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = cpu_to_le32(log->sync);\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\n\t\tlog->syncpt = log->sync;\n\t} else\n\t\tlsn = log->lsn;\n\n\t/*\n\t *\tsetup next syncpt trigger (SWAG)\n\t */\n\tlogsize = log->logsize;\n\n\tlogdiff(written, lsn, log);\n\tfree = logsize - written;\n\tdelta = LOGSYNC_DELTA(logsize);\n\tmore = min(free / 2, delta);\n\tif (more < 2 * LOGPSIZE) {\n\t\tjfs_warn(\"\\n ... Log Wrap ... Log Wrap ... Log Wrap ...\\n\");\n\t\t/*\n\t\t *\tlog wrapping\n\t\t *\n\t\t * option 1 - panic ? No.!\n\t\t * option 2 - shutdown file systems\n\t\t *\t      associated with log ?\n\t\t * option 3 - extend log ?\n\t\t * option 4 - second chance\n\t\t *\n\t\t * mark log wrapped, and continue.\n\t\t * when all active transactions are completed,\n\t\t * mark log valid for recovery.\n\t\t * if crashed during invalid state, log state\n\t\t * implies invalid log, forcing fsck().\n\t\t */\n\t\t/* mark log state log wrap in log superblock */\n\t\t/* log->state = LOGWRAP; */\n\n\t\t/* reset sync point computation */\n\t\tlog->syncpt = log->sync = lsn;\n\t\tlog->nextsync = delta;\n\t} else\n\t\t/* next syncpt trigger = written + more */\n\t\tlog->nextsync = written + more;\n\n\t/* if number of bytes written from last sync point is more\n\t * than 1/4 of the log size, stop new transactions from\n\t * starting until all current transactions are completed\n\t * by setting syncbarrier flag.\n\t */\n\tif (!test_bit(log_SYNCBARRIER, &log->flag) &&\n\t    (written > LOGSYNC_BARRIER(logsize)) && log->active) {\n\t\tset_bit(log_SYNCBARRIER, &log->flag);\n\t\tjfs_info(\"log barrier on: lsn=0x%x syncpt=0x%x\", lsn,\n\t\t\t log->syncpt);\n\t\t/*\n\t\t * We may have to initiate group commit\n\t\t */\n\t\tjfs_flush_journal(log, 0);\n\t}\n\n\treturn lsn;\n}"
  },
  {
    "function_name": "lmPostGC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "823-923",
    "snippet": "static void lmPostGC(struct lbuf * bp)\n{\n\tunsigned long flags;\n\tstruct jfs_log *log = bp->l_log;\n\tstruct logpage *lp;\n\tstruct tblock *tblk, *temp;\n\n\t//LOGGC_LOCK(log);\n\tspin_lock_irqsave(&log->gclock, flags);\n\t/*\n\t * current pageout of group commit completed.\n\t *\n\t * remove/wakeup transactions from commit queue who were\n\t * group committed with the current log page\n\t */\n\tlist_for_each_entry_safe(tblk, temp, &log->cqueue, cqueue) {\n\t\tif (!(tblk->flag & tblkGC_COMMIT))\n\t\t\tbreak;\n\t\t/* if transaction was marked GC_COMMIT then\n\t\t * it has been shipped in the current pageout\n\t\t * and made it to disk - it is committed.\n\t\t */\n\n\t\tif (bp->l_flag & lbmERROR)\n\t\t\ttblk->flag |= tblkGC_ERROR;\n\n\t\t/* remove it from the commit queue */\n\t\tlist_del(&tblk->cqueue);\n\t\ttblk->flag &= ~tblkGC_QUEUE;\n\n\t\tif (tblk == log->flush_tblk) {\n\t\t\t/* we can stop flushing the log now */\n\t\t\tclear_bit(log_FLUSH, &log->flag);\n\t\t\tlog->flush_tblk = NULL;\n\t\t}\n\n\t\tjfs_info(\"lmPostGC: tblk = 0x%p, flag = 0x%x\", tblk,\n\t\t\t tblk->flag);\n\n\t\tif (!(tblk->xflag & COMMIT_FORCE))\n\t\t\t/*\n\t\t\t * Hand tblk over to lazy commit thread\n\t\t\t */\n\t\t\ttxLazyUnlock(tblk);\n\t\telse {\n\t\t\t/* state transition: COMMIT -> COMMITTED */\n\t\t\ttblk->flag |= tblkGC_COMMITTED;\n\n\t\t\tif (tblk->flag & tblkGC_READY)\n\t\t\t\tlog->gcrtc--;\n\n\t\t\tLOGGC_WAKEUP(tblk);\n\t\t}\n\n\t\t/* was page full before pageout ?\n\t\t * (and this is the last tblk bound with the page)\n\t\t */\n\t\tif (tblk->flag & tblkGC_FREE)\n\t\t\tlbmFree(bp);\n\t\t/* did page become full after pageout ?\n\t\t * (and this is the last tblk bound with the page)\n\t\t */\n\t\telse if (tblk->flag & tblkGC_EOP) {\n\t\t\t/* finalize the page */\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tbp->l_ceor = bp->l_eor;\n\t\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\t\tjfs_info(\"lmPostGC: calling lbmWrite\");\n\t\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE,\n\t\t\t\t 1);\n\t\t}\n\n\t}\n\n\t/* are there any transactions who have entered lnGroupCommit()\n\t * (whose COMMITs are after that of the last log page written.\n\t * They are waiting for new group commit (above at (SLEEP 1))\n\t * or lazy transactions are on a full (queued) log page,\n\t * select the latest ready transaction as new group leader and\n\t * wake her up to lead her group.\n\t */\n\tif ((!list_empty(&log->cqueue)) &&\n\t    ((log->gcrtc > 0) || (tblk->bp->l_wqnext != NULL) ||\n\t     test_bit(log_FLUSH, &log->flag) || jfs_tlocks_low))\n\t\t/*\n\t\t * Call lmGCwrite with new group leader\n\t\t */\n\t\tlmGCwrite(log, 1);\n\n\t/* no transaction are ready yet (transactions are only just\n\t * queued (GC_QUEUE) and not entered for group commit yet).\n\t * the first transaction entering group commit\n\t * will elect herself as new group leader.\n\t */\n\telse\n\t\tlog->cflag &= ~logGC_PAGEOUT;\n\n\t//LOGGC_UNLOCK(log);\n\tspin_unlock_irqrestore(&log->gclock, flags);\n\treturn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define\tlbmERROR\t0x0040",
      "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
      "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&log->gclock",
            "flags"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmGCwrite",
          "args": [
            "log",
            "1"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "lmGCwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "758-809",
          "snippet": "static void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_FLUSH",
            "&log->flag"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->cqueue"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lbmWrite",
          "args": [
            "log",
            "bp",
            "lbmWRITE | lbmRELEASE | lbmFREE",
            "1"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "lbmWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2040-2099",
          "snippet": "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);",
            "static void lmGCwrite(struct jfs_log * log, int cant_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\nstatic void lmGCwrite(struct jfs_log * log, int cant_block);\n\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmPostGC: calling lbmWrite\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bp->l_eor"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmFree",
          "args": [
            "bp"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "lbmFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1930-1939",
          "snippet": "static void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lbmFree(struct lbuf * bp)\n{\n\tunsigned long flags;\n\n\tLCACHE_LOCK(flags);\n\n\tlbmfree(bp);\n\n\tLCACHE_UNLOCK(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGGC_WAKEUP",
          "args": [
            "tblk"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLazyUnlock",
          "args": [
            "tblk"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "txLazyUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2821-2838",
          "snippet": "void txLazyUnlock(struct tblock * tblk)\n{\n\tunsigned long flags;\n\n\tLAZY_LOCK(flags);\n\n\tlist_add_tail(&tblk->cqueue, &TxAnchor.unlock_queue);\n\t/*\n\t * Don't wake up a commit thread if there is already one servicing\n\t * this superblock, or if the last one we woke up hasn't started yet.\n\t */\n\tif (!(JFS_SBI(tblk->sb)->commit_state & IN_LAZYCOMMIT) &&\n\t    !jfs_commit_thread_waking) {\n\t\tjfs_commit_thread_waking = 1;\n\t\twake_up(&jfs_commit_thread_wait);\n\t}\n\tLAZY_UNLOCK(flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static DECLARE_WAIT_QUEUE_HEAD(jfs_commit_thread_wait);",
            "static int jfs_commit_thread_waking;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic DECLARE_WAIT_QUEUE_HEAD(jfs_commit_thread_wait);\nstatic int jfs_commit_thread_waking;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txLazyUnlock(struct tblock * tblk)\n{\n\tunsigned long flags;\n\n\tLAZY_LOCK(flags);\n\n\tlist_add_tail(&tblk->cqueue, &TxAnchor.unlock_queue);\n\t/*\n\t * Don't wake up a commit thread if there is already one servicing\n\t * this superblock, or if the last one we woke up hasn't started yet.\n\t */\n\tif (!(JFS_SBI(tblk->sb)->commit_state & IN_LAZYCOMMIT) &&\n\t    !jfs_commit_thread_waking) {\n\t\tjfs_commit_thread_waking = 1;\n\t\twake_up(&jfs_commit_thread_wait);\n\t}\n\tLAZY_UNLOCK(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmPostGC: tblk = 0x%p, flag = 0x%x\"",
            "tblk",
            "tblk->flag"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "log_FLUSH",
            "&log->flag"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tblk->cqueue"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "tblk",
            "temp",
            "&log->cqueue",
            "cqueue"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&log->gclock",
            "flags"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmERROR\t0x0040\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lmPostGC(struct lbuf * bp)\n{\n\tunsigned long flags;\n\tstruct jfs_log *log = bp->l_log;\n\tstruct logpage *lp;\n\tstruct tblock *tblk, *temp;\n\n\t//LOGGC_LOCK(log);\n\tspin_lock_irqsave(&log->gclock, flags);\n\t/*\n\t * current pageout of group commit completed.\n\t *\n\t * remove/wakeup transactions from commit queue who were\n\t * group committed with the current log page\n\t */\n\tlist_for_each_entry_safe(tblk, temp, &log->cqueue, cqueue) {\n\t\tif (!(tblk->flag & tblkGC_COMMIT))\n\t\t\tbreak;\n\t\t/* if transaction was marked GC_COMMIT then\n\t\t * it has been shipped in the current pageout\n\t\t * and made it to disk - it is committed.\n\t\t */\n\n\t\tif (bp->l_flag & lbmERROR)\n\t\t\ttblk->flag |= tblkGC_ERROR;\n\n\t\t/* remove it from the commit queue */\n\t\tlist_del(&tblk->cqueue);\n\t\ttblk->flag &= ~tblkGC_QUEUE;\n\n\t\tif (tblk == log->flush_tblk) {\n\t\t\t/* we can stop flushing the log now */\n\t\t\tclear_bit(log_FLUSH, &log->flag);\n\t\t\tlog->flush_tblk = NULL;\n\t\t}\n\n\t\tjfs_info(\"lmPostGC: tblk = 0x%p, flag = 0x%x\", tblk,\n\t\t\t tblk->flag);\n\n\t\tif (!(tblk->xflag & COMMIT_FORCE))\n\t\t\t/*\n\t\t\t * Hand tblk over to lazy commit thread\n\t\t\t */\n\t\t\ttxLazyUnlock(tblk);\n\t\telse {\n\t\t\t/* state transition: COMMIT -> COMMITTED */\n\t\t\ttblk->flag |= tblkGC_COMMITTED;\n\n\t\t\tif (tblk->flag & tblkGC_READY)\n\t\t\t\tlog->gcrtc--;\n\n\t\t\tLOGGC_WAKEUP(tblk);\n\t\t}\n\n\t\t/* was page full before pageout ?\n\t\t * (and this is the last tblk bound with the page)\n\t\t */\n\t\tif (tblk->flag & tblkGC_FREE)\n\t\t\tlbmFree(bp);\n\t\t/* did page become full after pageout ?\n\t\t * (and this is the last tblk bound with the page)\n\t\t */\n\t\telse if (tblk->flag & tblkGC_EOP) {\n\t\t\t/* finalize the page */\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tbp->l_ceor = bp->l_eor;\n\t\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\n\t\t\tjfs_info(\"lmPostGC: calling lbmWrite\");\n\t\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE,\n\t\t\t\t 1);\n\t\t}\n\n\t}\n\n\t/* are there any transactions who have entered lnGroupCommit()\n\t * (whose COMMITs are after that of the last log page written.\n\t * They are waiting for new group commit (above at (SLEEP 1))\n\t * or lazy transactions are on a full (queued) log page,\n\t * select the latest ready transaction as new group leader and\n\t * wake her up to lead her group.\n\t */\n\tif ((!list_empty(&log->cqueue)) &&\n\t    ((log->gcrtc > 0) || (tblk->bp->l_wqnext != NULL) ||\n\t     test_bit(log_FLUSH, &log->flag) || jfs_tlocks_low))\n\t\t/*\n\t\t * Call lmGCwrite with new group leader\n\t\t */\n\t\tlmGCwrite(log, 1);\n\n\t/* no transaction are ready yet (transactions are only just\n\t * queued (GC_QUEUE) and not entered for group commit yet).\n\t * the first transaction entering group commit\n\t * will elect herself as new group leader.\n\t */\n\telse\n\t\tlog->cflag &= ~logGC_PAGEOUT;\n\n\t//LOGGC_UNLOCK(log);\n\tspin_unlock_irqrestore(&log->gclock, flags);\n\treturn;\n}"
  },
  {
    "function_name": "lmGCwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "758-809",
    "snippet": "static void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */",
      "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "lmStat.partial_page"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmWrite",
          "args": [
            "log",
            "bp",
            "lbmWRITE | lbmGC",
            "cant_write"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "lbmWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2040-2099",
          "snippet": "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);",
            "static void lmGCwrite(struct jfs_log * log, int cant_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\nstatic void lmGCwrite(struct jfs_log * log, int cant_block);\n\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bp->l_ceor"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "lmStat.full_page"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bp->l_ceor"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tblk",
            "&log->cqueue",
            "cqueue"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "log->cqueue.next",
            "structtblock",
            "cqueue"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}"
  },
  {
    "function_name": "lmGroupCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "679-743",
    "snippet": "int lmGroupCommit(struct jfs_log * log, struct tblock * tblk)\n{\n\tint rc = 0;\n\n\tLOGGC_LOCK(log);\n\n\t/* group committed already ? */\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\tjfs_info(\"lmGroup Commit: tblk = 0x%p, gcrtc = %d\", tblk, log->gcrtc);\n\n\tif (tblk->xflag & COMMIT_LAZY)\n\t\ttblk->flag |= tblkGC_LAZY;\n\n\tif ((!(log->cflag & logGC_PAGEOUT)) && (!list_empty(&log->cqueue)) &&\n\t    (!(tblk->xflag & COMMIT_LAZY) || test_bit(log_FLUSH, &log->flag)\n\t     || jfs_tlocks_low)) {\n\t\t/*\n\t\t * No pageout in progress\n\t\t *\n\t\t * start group commit as its group leader.\n\t\t */\n\t\tlog->cflag |= logGC_PAGEOUT;\n\n\t\tlmGCwrite(log, 0);\n\t}\n\n\tif (tblk->xflag & COMMIT_LAZY) {\n\t\t/*\n\t\t * Lazy transactions can leave now\n\t\t */\n\t\tLOGGC_UNLOCK(log);\n\t\treturn 0;\n\t}\n\n\t/* lmGCwrite gives up LOGGC_LOCK, check again */\n\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\n\t/* upcount transaction waiting for completion\n\t */\n\tlog->gcrtc++;\n\ttblk->flag |= tblkGC_READY;\n\n\t__SLEEP_COND(tblk->gcwait, (tblk->flag & tblkGC_COMMITTED),\n\t\t     LOGGC_LOCK(log), LOGGC_UNLOCK(log));\n\n\t/* removed from commit queue */\n\tif (tblk->flag & tblkGC_ERROR)\n\t\trc = -EIO;\n\n\tLOGGC_UNLOCK(log);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SLEEP_COND",
          "args": [
            "tblk->gcwait",
            "(tblk->flag & tblkGC_COMMITTED)",
            "LOGGC_LOCK(log)",
            "LOGGC_UNLOCK(log)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_LOCK",
          "args": [
            "log"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmGCwrite",
          "args": [
            "log",
            "0"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "lmGCwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "758-809",
          "snippet": "static void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "log_FLUSH",
            "&log->flag"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->cqueue"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmGroup Commit: tblk = 0x%p, gcrtc = %d\"",
            "tblk",
            "log->gcrtc"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_LOCK",
          "args": [
            "log"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nint lmGroupCommit(struct jfs_log * log, struct tblock * tblk)\n{\n\tint rc = 0;\n\n\tLOGGC_LOCK(log);\n\n\t/* group committed already ? */\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\tjfs_info(\"lmGroup Commit: tblk = 0x%p, gcrtc = %d\", tblk, log->gcrtc);\n\n\tif (tblk->xflag & COMMIT_LAZY)\n\t\ttblk->flag |= tblkGC_LAZY;\n\n\tif ((!(log->cflag & logGC_PAGEOUT)) && (!list_empty(&log->cqueue)) &&\n\t    (!(tblk->xflag & COMMIT_LAZY) || test_bit(log_FLUSH, &log->flag)\n\t     || jfs_tlocks_low)) {\n\t\t/*\n\t\t * No pageout in progress\n\t\t *\n\t\t * start group commit as its group leader.\n\t\t */\n\t\tlog->cflag |= logGC_PAGEOUT;\n\n\t\tlmGCwrite(log, 0);\n\t}\n\n\tif (tblk->xflag & COMMIT_LAZY) {\n\t\t/*\n\t\t * Lazy transactions can leave now\n\t\t */\n\t\tLOGGC_UNLOCK(log);\n\t\treturn 0;\n\t}\n\n\t/* lmGCwrite gives up LOGGC_LOCK, check again */\n\n\tif (tblk->flag & tblkGC_COMMITTED) {\n\t\tif (tblk->flag & tblkGC_ERROR)\n\t\t\trc = -EIO;\n\n\t\tLOGGC_UNLOCK(log);\n\t\treturn rc;\n\t}\n\n\t/* upcount transaction waiting for completion\n\t */\n\tlog->gcrtc++;\n\ttblk->flag |= tblkGC_READY;\n\n\t__SLEEP_COND(tblk->gcwait, (tblk->flag & tblkGC_COMMITTED),\n\t\t     LOGGC_LOCK(log), LOGGC_UNLOCK(log));\n\n\t/* removed from commit queue */\n\tif (tblk->flag & tblkGC_ERROR)\n\t\trc = -EIO;\n\n\tLOGGC_UNLOCK(log);\n\treturn rc;\n}"
  },
  {
    "function_name": "lmNextPage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "573-661",
    "snippet": "static int lmNextPage(struct jfs_log * log)\n{\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tint pn;\t\t\t/* current page number */\n\tstruct lbuf *bp;\n\tstruct lbuf *nextbp;\n\tstruct tblock *tblk;\n\n\t/* get current log page number and log sequence page number */\n\tpn = log->page;\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlspn = le32_to_cpu(lp->h.page);\n\n\tLOGGC_LOCK(log);\n\n\t/*\n\t *\twrite or queue the full page at the tail of write queue\n\t */\n\t/* get the tail tblk on commit queue */\n\tif (list_empty(&log->cqueue))\n\t\ttblk = NULL;\n\telse\n\t\ttblk = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t/* every tblk who has COMMIT record on the current page,\n\t * and has not been committed, must be on commit queue\n\t * since tblk is queued at commit queueu at the time\n\t * of writing its COMMIT record on the page before\n\t * page becomes full (even though the tblk thread\n\t * who wrote COMMIT record may have been suspended\n\t * currently);\n\t */\n\n\t/* is page bound with outstanding tail tblk ? */\n\tif (tblk && tblk->pn == pn) {\n\t\t/* mark tblk for end-of-page */\n\t\ttblk->flag |= tblkGC_EOP;\n\n\t\tif (log->cflag & logGC_PAGEOUT) {\n\t\t\t/* if page is not already on write queue,\n\t\t\t * just enqueue (no lbmWRITE to prevent redrive)\n\t\t\t * buffer to wqueue to ensure correct serial order\n\t\t\t * of the pages since log pages will be added\n\t\t\t * continuously\n\t\t\t */\n\t\t\tif (bp->l_wqnext == NULL)\n\t\t\t\tlbmWrite(log, bp, 0, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No current GC leader, initiate group commit\n\t\t\t */\n\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\tlmGCwrite(log, 0);\n\t\t}\n\t}\n\t/* page is not bound with outstanding tblk:\n\t * init write or mark it to be redriven (lbmWRITE)\n\t */\n\telse {\n\t\t/* finalize the page */\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE, 0);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\t/*\n\t *\tallocate/initialize next page\n\t */\n\t/* if log wraps, the first data page of log is 2\n\t * (0 never used, 1 is superblock).\n\t */\n\tlog->page = (pn == log->size - 1) ? 2 : pn + 1;\n\tlog->eor = LOGPHDRSIZE;\t/* ? valid page empty/full at logRedo() */\n\n\t/* allocate/initialize next log page buffer */\n\tnextbp = lbmAllocate(log, log->page);\n\tnextbp->l_eor = log->eor;\n\tlog->bp = nextbp;\n\n\t/* initialize next log page */\n\tlp = (struct logpage *) nextbp->l_ldata;\n\tlp->h.page = lp->t.page = cpu_to_le32(lspn + 1);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
      "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
      "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
    ],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOGPHDRSIZE"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lspn + 1"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmAllocate",
          "args": [
            "log",
            "log->page"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "lbmAllocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1899-1922",
          "snippet": "static struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\n{\n\tstruct lbuf *bp;\n\tunsigned long flags;\n\n\t/*\n\t * recycle from log buffer freelist if any\n\t */\n\tLCACHE_LOCK(flags);\n\tLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\n\tlog->lbuf_free = bp->l_freelist;\n\tLCACHE_UNLOCK(flags);\n\n\tbp->l_flag = 0;\n\n\tbp->l_wqnext = NULL;\n\tbp->l_freelist = NULL;\n\n\tbp->l_pn = pn;\n\tbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\n\tbp->l_ceor = 0;\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lbmWrite",
          "args": [
            "log",
            "bp",
            "lbmWRITE | lbmRELEASE | lbmFREE",
            "0"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "lbmWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "2040-2099",
          "snippet": "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);",
            "static void lmGCwrite(struct jfs_log * log, int cant_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define\tlbmSYNC\t\t0x0008\t/* do not return to freelist\n\t\t\t\t * when removed from write queue;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag, int cant_block);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\nstatic void lmGCwrite(struct jfs_log * log, int cant_block);\n\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\n\t\t     int cant_block)\n{\n\tstruct lbuf *tail;\n\tunsigned long flags;\n\n\tjfs_info(\"lbmWrite: bp:0x%p flag:0x%x pn:0x%x\", bp, flag, bp->l_pn);\n\n\t/* map the logical block address to physical block address */\n\tbp->l_blkno =\n\t    log->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\n\n\tLCACHE_LOCK(flags);\t\t/* disable+lock */\n\n\t/*\n\t * initialize buffer for device driver\n\t */\n\tbp->l_flag = flag;\n\n\t/*\n\t *\tinsert bp at tail of write queue associated with log\n\t *\n\t * (request is either for bp already/currently at head of queue\n\t * or new bp to be inserted at tail)\n\t */\n\ttail = log->wqueue;\n\n\t/* is buffer not already on write queue ? */\n\tif (bp->l_wqnext == NULL) {\n\t\t/* insert at tail of wqueue */\n\t\tif (tail == NULL) {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = bp;\n\t\t} else {\n\t\t\tlog->wqueue = bp;\n\t\t\tbp->l_wqnext = tail->l_wqnext;\n\t\t\ttail->l_wqnext = bp;\n\t\t}\n\n\t\ttail = bp;\n\t}\n\n\t/* is buffer at head of wqueue and for write ? */\n\tif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\n\t\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\t\treturn;\n\t}\n\n\tLCACHE_UNLOCK(flags);\t/* unlock+enable */\n\n\tif (cant_block)\n\t\tlbmRedrive(bp);\n\telse if (flag & lbmSYNC)\n\t\tlbmStartIO(bp);\n\telse {\n\t\tLOGGC_UNLOCK(log);\n\t\tlbmStartIO(bp);\n\t\tLOGGC_LOCK(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bp->l_ceor"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmGCwrite",
          "args": [
            "log",
            "0"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "lmGCwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "758-809",
          "snippet": "static void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmGC\t\t0x0080\t/* lbmIODone to perform post-GC processing\n\t\t\t\t * of log page\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic void lmGCwrite(struct jfs_log * log, int cant_write)\n{\n\tstruct lbuf *bp;\n\tstruct logpage *lp;\n\tint gcpn;\t\t/* group commit page number */\n\tstruct tblock *tblk;\n\tstruct tblock *xtblk = NULL;\n\n\t/*\n\t * build the commit group of a log page\n\t *\n\t * scan commit queue and make a commit group of all\n\t * transactions with COMMIT records on the same log page.\n\t */\n\t/* get the head tblk on the commit queue */\n\tgcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\n\n\tlist_for_each_entry(tblk, &log->cqueue, cqueue) {\n\t\tif (tblk->pn != gcpn)\n\t\t\tbreak;\n\n\t\txtblk = tblk;\n\n\t\t/* state transition: (QUEUE, READY) -> COMMIT */\n\t\ttblk->flag |= tblkGC_COMMIT;\n\t}\n\ttblk = xtblk;\t\t/* last tblk of the page */\n\n\t/*\n\t * pageout to commit transactions on the log page.\n\t */\n\tbp = (struct lbuf *) tblk->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\t/* is page already full ? */\n\tif (tblk->flag & tblkGC_EOP) {\n\t\t/* mark page to free at end of group commit of the page */\n\t\ttblk->flag &= ~tblkGC_EOP;\n\t\ttblk->flag |= tblkGC_FREE;\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\n\t\t\t cant_write);\n\t\tINCREMENT(lmStat.full_page);\n\t}\n\t/* page is not yet full */\n\telse {\n\t\tbp->l_ceor = tblk->eor;\t/* ? bp->l_ceor = bp->l_eor; */\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\n\t\tINCREMENT(lmStat.partial_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "log->cqueue.prev",
            "structtblock",
            "cqueue"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->cqueue"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGGC_LOCK",
          "args": [
            "log"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lp->h.page"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lmNextPage(struct jfs_log * log)\n{\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tint pn;\t\t\t/* current page number */\n\tstruct lbuf *bp;\n\tstruct lbuf *nextbp;\n\tstruct tblock *tblk;\n\n\t/* get current log page number and log sequence page number */\n\tpn = log->page;\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlspn = le32_to_cpu(lp->h.page);\n\n\tLOGGC_LOCK(log);\n\n\t/*\n\t *\twrite or queue the full page at the tail of write queue\n\t */\n\t/* get the tail tblk on commit queue */\n\tif (list_empty(&log->cqueue))\n\t\ttblk = NULL;\n\telse\n\t\ttblk = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t/* every tblk who has COMMIT record on the current page,\n\t * and has not been committed, must be on commit queue\n\t * since tblk is queued at commit queueu at the time\n\t * of writing its COMMIT record on the page before\n\t * page becomes full (even though the tblk thread\n\t * who wrote COMMIT record may have been suspended\n\t * currently);\n\t */\n\n\t/* is page bound with outstanding tail tblk ? */\n\tif (tblk && tblk->pn == pn) {\n\t\t/* mark tblk for end-of-page */\n\t\ttblk->flag |= tblkGC_EOP;\n\n\t\tif (log->cflag & logGC_PAGEOUT) {\n\t\t\t/* if page is not already on write queue,\n\t\t\t * just enqueue (no lbmWRITE to prevent redrive)\n\t\t\t * buffer to wqueue to ensure correct serial order\n\t\t\t * of the pages since log pages will be added\n\t\t\t * continuously\n\t\t\t */\n\t\t\tif (bp->l_wqnext == NULL)\n\t\t\t\tlbmWrite(log, bp, 0, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No current GC leader, initiate group commit\n\t\t\t */\n\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\tlmGCwrite(log, 0);\n\t\t}\n\t}\n\t/* page is not bound with outstanding tblk:\n\t * init write or mark it to be redriven (lbmWRITE)\n\t */\n\telse {\n\t\t/* finalize the page */\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE, 0);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\t/*\n\t *\tallocate/initialize next page\n\t */\n\t/* if log wraps, the first data page of log is 2\n\t * (0 never used, 1 is superblock).\n\t */\n\tlog->page = (pn == log->size - 1) ? 2 : pn + 1;\n\tlog->eor = LOGPHDRSIZE;\t/* ? valid page empty/full at logRedo() */\n\n\t/* allocate/initialize next log page buffer */\n\tnextbp = lbmAllocate(log, log->page);\n\tnextbp->l_eor = log->eor;\n\tlog->bp = nextbp;\n\n\t/* initialize next log page */\n\tlp = (struct logpage *) nextbp->l_ldata;\n\tlp->h.page = lp->t.page = cpu_to_le32(lspn + 1);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lmWriteRecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "356-559",
    "snippet": "static int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
      "static void lbmFree(struct lbuf * bp);",
      "static void lbmfree(struct lbuf * bp);",
      "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
      "static int lbmIOWait(struct lbuf * bp, int flag);",
      "static void lbmStartIO(struct lbuf * bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmNextPage",
          "args": [
            "log"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "lmNextPage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "573-661",
          "snippet": "static int lmNextPage(struct jfs_log * log)\n{\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tint pn;\t\t\t/* current page number */\n\tstruct lbuf *bp;\n\tstruct lbuf *nextbp;\n\tstruct tblock *tblk;\n\n\t/* get current log page number and log sequence page number */\n\tpn = log->page;\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlspn = le32_to_cpu(lp->h.page);\n\n\tLOGGC_LOCK(log);\n\n\t/*\n\t *\twrite or queue the full page at the tail of write queue\n\t */\n\t/* get the tail tblk on commit queue */\n\tif (list_empty(&log->cqueue))\n\t\ttblk = NULL;\n\telse\n\t\ttblk = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t/* every tblk who has COMMIT record on the current page,\n\t * and has not been committed, must be on commit queue\n\t * since tblk is queued at commit queueu at the time\n\t * of writing its COMMIT record on the page before\n\t * page becomes full (even though the tblk thread\n\t * who wrote COMMIT record may have been suspended\n\t * currently);\n\t */\n\n\t/* is page bound with outstanding tail tblk ? */\n\tif (tblk && tblk->pn == pn) {\n\t\t/* mark tblk for end-of-page */\n\t\ttblk->flag |= tblkGC_EOP;\n\n\t\tif (log->cflag & logGC_PAGEOUT) {\n\t\t\t/* if page is not already on write queue,\n\t\t\t * just enqueue (no lbmWRITE to prevent redrive)\n\t\t\t * buffer to wqueue to ensure correct serial order\n\t\t\t * of the pages since log pages will be added\n\t\t\t * continuously\n\t\t\t */\n\t\t\tif (bp->l_wqnext == NULL)\n\t\t\t\tlbmWrite(log, bp, 0, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No current GC leader, initiate group commit\n\t\t\t */\n\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\tlmGCwrite(log, 0);\n\t\t}\n\t}\n\t/* page is not bound with outstanding tblk:\n\t * init write or mark it to be redriven (lbmWRITE)\n\t */\n\telse {\n\t\t/* finalize the page */\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE, 0);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\t/*\n\t *\tallocate/initialize next page\n\t */\n\t/* if log wraps, the first data page of log is 2\n\t * (0 never used, 1 is superblock).\n\t */\n\tlog->page = (pn == log->size - 1) ? 2 : pn + 1;\n\tlog->eor = LOGPHDRSIZE;\t/* ? valid page empty/full at logRedo() */\n\n\t/* allocate/initialize next log page buffer */\n\tnextbp = lbmAllocate(log, log->page);\n\tnextbp->l_eor = log->eor;\n\tlog->bp = nextbp;\n\n\t/* initialize next log page */\n\tlp = (struct logpage *) nextbp->l_ldata;\n\tlp->h.page = lp->t.page = cpu_to_le32(lspn + 1);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */",
            "#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */",
            "#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */"
          ],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\n#define lbmFREE\t\t0x0010\t/* return to freelist\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * the buffer may be recycled;\n\t\t\t\t */\n#define\tlbmRELEASE\t0x0004\t/* remove from write queue\n\t\t\t\t * at completion of pageout;\n\t\t\t\t * do not free/recycle it yet:\n\t\t\t\t * caller will free it;\n\t\t\t\t */\n#define\tlbmWRITE\t0x0002\t/* enqueue at tail of write queue;\n\t\t\t\t * init pageout if at head of queue;\n\t\t\t\t */\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int lmNextPage(struct jfs_log * log)\n{\n\tstruct logpage *lp;\n\tint lspn;\t\t/* log sequence page number */\n\tint pn;\t\t\t/* current page number */\n\tstruct lbuf *bp;\n\tstruct lbuf *nextbp;\n\tstruct tblock *tblk;\n\n\t/* get current log page number and log sequence page number */\n\tpn = log->page;\n\tbp = log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tlspn = le32_to_cpu(lp->h.page);\n\n\tLOGGC_LOCK(log);\n\n\t/*\n\t *\twrite or queue the full page at the tail of write queue\n\t */\n\t/* get the tail tblk on commit queue */\n\tif (list_empty(&log->cqueue))\n\t\ttblk = NULL;\n\telse\n\t\ttblk = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t/* every tblk who has COMMIT record on the current page,\n\t * and has not been committed, must be on commit queue\n\t * since tblk is queued at commit queueu at the time\n\t * of writing its COMMIT record on the page before\n\t * page becomes full (even though the tblk thread\n\t * who wrote COMMIT record may have been suspended\n\t * currently);\n\t */\n\n\t/* is page bound with outstanding tail tblk ? */\n\tif (tblk && tblk->pn == pn) {\n\t\t/* mark tblk for end-of-page */\n\t\ttblk->flag |= tblkGC_EOP;\n\n\t\tif (log->cflag & logGC_PAGEOUT) {\n\t\t\t/* if page is not already on write queue,\n\t\t\t * just enqueue (no lbmWRITE to prevent redrive)\n\t\t\t * buffer to wqueue to ensure correct serial order\n\t\t\t * of the pages since log pages will be added\n\t\t\t * continuously\n\t\t\t */\n\t\t\tif (bp->l_wqnext == NULL)\n\t\t\t\tlbmWrite(log, bp, 0, 0);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No current GC leader, initiate group commit\n\t\t\t */\n\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\tlmGCwrite(log, 0);\n\t\t}\n\t}\n\t/* page is not bound with outstanding tblk:\n\t * init write or mark it to be redriven (lbmWRITE)\n\t */\n\telse {\n\t\t/* finalize the page */\n\t\tbp->l_ceor = bp->l_eor;\n\t\tlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\n\t\tlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE, 0);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\t/*\n\t *\tallocate/initialize next page\n\t */\n\t/* if log wraps, the first data page of log is 2\n\t * (0 never used, 1 is superblock).\n\t */\n\tlog->page = (pn == log->size - 1) ? 2 : pn + 1;\n\tlog->eor = LOGPHDRSIZE;\t/* ? valid page empty/full at logRedo() */\n\n\t/* allocate/initialize next log page buffer */\n\tnextbp = lbmAllocate(log, log->page);\n\tnextbp->l_eor = log->eor;\n\tlog->bp = nextbp;\n\n\t/* initialize next log page */\n\tlp = (struct logpage *) nextbp->l_ldata;\n\tlp->h.page = lp->t.page = cpu_to_le32(lspn + 1);\n\tlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\"",
            "le16_to_cpu(lrd->type)",
            "log->bp",
            "log->page",
            "dstoffset"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "lrd->type"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGGC_UNLOCK",
          "args": [
            "log"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tblk->cqueue",
            "&log->cqueue"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGGC_LOCK",
          "args": [
            "log"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "lmStat.commit"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"wr: tclsn:0x%x, beor:0x%x\"",
            "tblk->clsn",
            "bp->l_eor"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "LOG_COMMIT"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "nbytes"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "freespace",
            "srclen"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lid_to_tlock",
          "args": [
            "i"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmWriteRecord: lv offset:%d length:%d\"",
            "lv->offset",
            "lv->length"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "lv->length"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "lv->offset"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "nbytes"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "linelock->index <= linelock->maxcnt"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"lmWriteRecord: UFO tlck:0x%p\"",
            "tlck"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "tlck->ip"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tlck->mp->data"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}"
  },
  {
    "function_name": "lmLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "238-343",
    "snippet": "int lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOG_UNLOCK",
          "args": [
            "log"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmLogSync",
          "args": [
            "log",
            "0"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "lmLogSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "942-1049",
          "snippet": "static int lmLogSync(struct jfs_log * log, int hard_sync)\n{\n\tint logsize;\n\tint written;\t\t/* written since last syncpt */\n\tint free;\t\t/* free space left available */\n\tint delta;\t\t/* additional delta to write normally */\n\tint more;\t\t/* additional write granted */\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsyncblk *lp;\n\tunsigned long flags;\n\n\t/* push dirty metapages out to disk */\n\tif (hard_sync)\n\t\twrite_special_inodes(log, filemap_fdatawrite);\n\telse\n\t\twrite_special_inodes(log, filemap_flush);\n\n\t/*\n\t *\tforward syncpt\n\t */\n\t/* if last sync is same as last syncpt,\n\t * invoke sync point forward processing to update sync.\n\t */\n\n\tif (log->sync == log->syncpt) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (list_empty(&log->synclist))\n\t\t\tlog->sync = log->lsn;\n\t\telse {\n\t\t\tlp = list_entry(log->synclist.next,\n\t\t\t\t\tstruct logsyncblk, synclist);\n\t\t\tlog->sync = lp->lsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t}\n\n\t/* if sync is different from last syncpt,\n\t * write a SYNCPT record with syncpt = sync.\n\t * reset syncpt = sync\n\t */\n\tif (log->sync != log->syncpt) {\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = cpu_to_le32(log->sync);\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\n\t\tlog->syncpt = log->sync;\n\t} else\n\t\tlsn = log->lsn;\n\n\t/*\n\t *\tsetup next syncpt trigger (SWAG)\n\t */\n\tlogsize = log->logsize;\n\n\tlogdiff(written, lsn, log);\n\tfree = logsize - written;\n\tdelta = LOGSYNC_DELTA(logsize);\n\tmore = min(free / 2, delta);\n\tif (more < 2 * LOGPSIZE) {\n\t\tjfs_warn(\"\\n ... Log Wrap ... Log Wrap ... Log Wrap ...\\n\");\n\t\t/*\n\t\t *\tlog wrapping\n\t\t *\n\t\t * option 1 - panic ? No.!\n\t\t * option 2 - shutdown file systems\n\t\t *\t      associated with log ?\n\t\t * option 3 - extend log ?\n\t\t * option 4 - second chance\n\t\t *\n\t\t * mark log wrapped, and continue.\n\t\t * when all active transactions are completed,\n\t\t * mark log valid for recovery.\n\t\t * if crashed during invalid state, log state\n\t\t * implies invalid log, forcing fsck().\n\t\t */\n\t\t/* mark log state log wrap in log superblock */\n\t\t/* log->state = LOGWRAP; */\n\n\t\t/* reset sync point computation */\n\t\tlog->syncpt = log->sync = lsn;\n\t\tlog->nextsync = delta;\n\t} else\n\t\t/* next syncpt trigger = written + more */\n\t\tlog->nextsync = written + more;\n\n\t/* if number of bytes written from last sync point is more\n\t * than 1/4 of the log size, stop new transactions from\n\t * starting until all current transactions are completed\n\t * by setting syncbarrier flag.\n\t */\n\tif (!test_bit(log_SYNCBARRIER, &log->flag) &&\n\t    (written > LOGSYNC_BARRIER(logsize)) && log->active) {\n\t\tset_bit(log_SYNCBARRIER, &log->flag);\n\t\tjfs_info(\"log barrier on: lsn=0x%x syncpt=0x%x\", lsn,\n\t\t\t log->syncpt);\n\t\t/*\n\t\t * We may have to initiate group commit\n\t\t */\n\t\tjfs_flush_journal(log, 0);\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static int lmLogSync(struct jfs_log * log, int hard_sync);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic int lmLogSync(struct jfs_log * log, int hard_sync);\n\nstatic int lmLogSync(struct jfs_log * log, int hard_sync)\n{\n\tint logsize;\n\tint written;\t\t/* written since last syncpt */\n\tint free;\t\t/* free space left available */\n\tint delta;\t\t/* additional delta to write normally */\n\tint more;\t\t/* additional write granted */\n\tstruct lrd lrd;\n\tint lsn;\n\tstruct logsyncblk *lp;\n\tunsigned long flags;\n\n\t/* push dirty metapages out to disk */\n\tif (hard_sync)\n\t\twrite_special_inodes(log, filemap_fdatawrite);\n\telse\n\t\twrite_special_inodes(log, filemap_flush);\n\n\t/*\n\t *\tforward syncpt\n\t */\n\t/* if last sync is same as last syncpt,\n\t * invoke sync point forward processing to update sync.\n\t */\n\n\tif (log->sync == log->syncpt) {\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (list_empty(&log->synclist))\n\t\t\tlog->sync = log->lsn;\n\t\telse {\n\t\t\tlp = list_entry(log->synclist.next,\n\t\t\t\t\tstruct logsyncblk, synclist);\n\t\t\tlog->sync = lp->lsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\n\t}\n\n\t/* if sync is different from last syncpt,\n\t * write a SYNCPT record with syncpt = sync.\n\t * reset syncpt = sync\n\t */\n\tif (log->sync != log->syncpt) {\n\t\tlrd.logtid = 0;\n\t\tlrd.backchain = 0;\n\t\tlrd.type = cpu_to_le16(LOG_SYNCPT);\n\t\tlrd.length = 0;\n\t\tlrd.log.syncpt.sync = cpu_to_le32(log->sync);\n\t\tlsn = lmWriteRecord(log, NULL, &lrd, NULL);\n\n\t\tlog->syncpt = log->sync;\n\t} else\n\t\tlsn = log->lsn;\n\n\t/*\n\t *\tsetup next syncpt trigger (SWAG)\n\t */\n\tlogsize = log->logsize;\n\n\tlogdiff(written, lsn, log);\n\tfree = logsize - written;\n\tdelta = LOGSYNC_DELTA(logsize);\n\tmore = min(free / 2, delta);\n\tif (more < 2 * LOGPSIZE) {\n\t\tjfs_warn(\"\\n ... Log Wrap ... Log Wrap ... Log Wrap ...\\n\");\n\t\t/*\n\t\t *\tlog wrapping\n\t\t *\n\t\t * option 1 - panic ? No.!\n\t\t * option 2 - shutdown file systems\n\t\t *\t      associated with log ?\n\t\t * option 3 - extend log ?\n\t\t * option 4 - second chance\n\t\t *\n\t\t * mark log wrapped, and continue.\n\t\t * when all active transactions are completed,\n\t\t * mark log valid for recovery.\n\t\t * if crashed during invalid state, log state\n\t\t * implies invalid log, forcing fsck().\n\t\t */\n\t\t/* mark log state log wrap in log superblock */\n\t\t/* log->state = LOGWRAP; */\n\n\t\t/* reset sync point computation */\n\t\tlog->syncpt = log->sync = lsn;\n\t\tlog->nextsync = delta;\n\t} else\n\t\t/* next syncpt trigger = written + more */\n\t\tlog->nextsync = written + more;\n\n\t/* if number of bytes written from last sync point is more\n\t * than 1/4 of the log size, stop new transactions from\n\t * starting until all current transactions are completed\n\t * by setting syncbarrier flag.\n\t */\n\tif (!test_bit(log_SYNCBARRIER, &log->flag) &&\n\t    (written > LOGSYNC_BARRIER(logsize)) && log->active) {\n\t\tset_bit(log_SYNCBARRIER, &log->flag);\n\t\tjfs_info(\"log barrier on: lsn=0x%x syncpt=0x%x\", lsn,\n\t\t\t log->syncpt);\n\t\t/*\n\t\t * We may have to initiate group commit\n\t\t */\n\t\tjfs_flush_journal(log, 0);\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "diffp",
            "lsn",
            "log"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmWriteRecord",
          "args": [
            "log",
            "tblk",
            "lrd",
            "tlck"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "lmWriteRecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "356-559",
          "snippet": "static int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);",
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmFree(struct lbuf * bp);",
            "static void lbmfree(struct lbuf * bp);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);",
            "static void lbmStartIO(struct lbuf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmFree(struct lbuf * bp);\nstatic void lbmfree(struct lbuf * bp);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\nstatic void lbmStartIO(struct lbuf * bp);\n\nstatic int\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t      struct tlock * tlck)\n{\n\tint lsn = 0;\t\t/* end-of-log address */\n\tstruct lbuf *bp;\t/* dst log page buffer */\n\tstruct logpage *lp;\t/* dst log page */\n\tcaddr_t dst;\t\t/* destination address in log page */\n\tint dstoffset;\t\t/* end-of-log offset in log page */\n\tint freespace;\t\t/* free space in log page */\n\tcaddr_t p;\t\t/* src meta-data page */\n\tcaddr_t src;\n\tint srclen;\n\tint nbytes;\t\t/* number of bytes to move */\n\tint i;\n\tint len;\n\tstruct linelock *linelock;\n\tstruct lv *lv;\n\tstruct lvd *lvd;\n\tint l2linesize;\n\n\tlen = 0;\n\n\t/* retrieve destination log page to write */\n\tbp = (struct lbuf *) log->bp;\n\tlp = (struct logpage *) bp->l_ldata;\n\tdstoffset = log->eor;\n\n\t/* any log data to write ? */\n\tif (tlck == NULL)\n\t\tgoto moveLrd;\n\n\t/*\n\t *\tmove log record data\n\t */\n\t/* retrieve source meta-data page to log */\n\tif (tlck->flag & tlckPAGELOCK) {\n\t\tp = (caddr_t) (tlck->mp->data);\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n\t/* retrieve source in-memory inode to log */\n\telse if (tlck->flag & tlckINODELOCK) {\n\t\tif (tlck->type & tlckDTREE)\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\n\t\telse\n\t\t\tp = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\n\t\tlinelock = (struct linelock *) & tlck->lock;\n\t}\n#ifdef\t_JFS_WIP\n\telse if (tlck->flag & tlckINLINELOCK) {\n\n\t\tinlinelock = (struct inlinelock *) & tlck;\n\t\tp = (caddr_t) & inlinelock->pxd;\n\t\tlinelock = (struct linelock *) & tlck;\n\t}\n#endif\t\t\t\t/* _JFS_WIP */\n\telse {\n\t\tjfs_err(\"lmWriteRecord: UFO tlck:0x%p\", tlck);\n\t\treturn 0;\t/* Probably should trap */\n\t}\n\tl2linesize = linelock->l2linesize;\n\n      moveData:\n\tASSERT(linelock->index <= linelock->maxcnt);\n\n\tlv = linelock->lv;\n\tfor (i = 0; i < linelock->index; i++, lv++) {\n\t\tif (lv->length == 0)\n\t\t\tcontinue;\n\n\t\t/* is page full ? */\n\t\tif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\t\t}\n\n\t\t/*\n\t\t * move log vector data\n\t\t */\n\t\tsrc = (u8 *) p + (lv->offset << l2linesize);\n\t\tsrclen = lv->length << l2linesize;\n\t\tlen += srclen;\n\t\twhile (srclen > 0) {\n\t\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\t\tnbytes = min(freespace, srclen);\n\t\t\tdst = (caddr_t) lp + dstoffset;\n\t\t\tmemcpy(dst, src, nbytes);\n\t\t\tdstoffset += nbytes;\n\n\t\t\t/* is page not full ? */\n\t\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\t\tbreak;\n\n\t\t\t/* page become full: move on to next page */\n\t\t\tlmNextPage(log);\n\n\t\t\tbp = (struct lbuf *) log->bp;\n\t\t\tlp = (struct logpage *) bp->l_ldata;\n\t\t\tdstoffset = LOGPHDRSIZE;\n\n\t\t\tsrclen -= nbytes;\n\t\t\tsrc += nbytes;\n\t\t}\n\n\t\t/*\n\t\t * move log vector descriptor\n\t\t */\n\t\tlen += 4;\n\t\tlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\n\t\tlvd->offset = cpu_to_le16(lv->offset);\n\t\tlvd->length = cpu_to_le16(lv->length);\n\t\tdstoffset += 4;\n\t\tjfs_info(\"lmWriteRecord: lv offset:%d length:%d\",\n\t\t\t lv->offset, lv->length);\n\t}\n\n\tif ((i = linelock->next)) {\n\t\tlinelock = (struct linelock *) lid_to_tlock(i);\n\t\tgoto moveData;\n\t}\n\n\t/*\n\t *\tmove log record descriptor\n\t */\n      moveLrd:\n\tlrd->length = cpu_to_le16(len);\n\n\tsrc = (caddr_t) lrd;\n\tsrclen = LOGRDSIZE;\n\n\twhile (srclen > 0) {\n\t\tfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\n\t\tnbytes = min(freespace, srclen);\n\t\tdst = (caddr_t) lp + dstoffset;\n\t\tmemcpy(dst, src, nbytes);\n\n\t\tdstoffset += nbytes;\n\t\tsrclen -= nbytes;\n\n\t\t/* are there more to move than freespace of page ? */\n\t\tif (srclen)\n\t\t\tgoto pageFull;\n\n\t\t/*\n\t\t * end of log record descriptor\n\t\t */\n\n\t\t/* update last log record eor */\n\t\tlog->eor = dstoffset;\n\t\tbp->l_eor = dstoffset;\n\t\tlsn = (log->page << L2LOGPSIZE) + dstoffset;\n\n\t\tif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\n\t\t\ttblk->clsn = lsn;\n\t\t\tjfs_info(\"wr: tclsn:0x%x, beor:0x%x\", tblk->clsn,\n\t\t\t\t bp->l_eor);\n\n\t\t\tINCREMENT(lmStat.commit);\t/* # of commit */\n\n\t\t\t/*\n\t\t\t * enqueue tblock for group commit:\n\t\t\t *\n\t\t\t * enqueue tblock of non-trivial/synchronous COMMIT\n\t\t\t * at tail of group commit queue\n\t\t\t * (trivial/asynchronous COMMITs are ignored by\n\t\t\t * group commit.)\n\t\t\t */\n\t\t\tLOGGC_LOCK(log);\n\n\t\t\t/* init tblock gc state */\n\t\t\ttblk->flag = tblkGC_QUEUE;\n\t\t\ttblk->bp = log->bp;\n\t\t\ttblk->pn = log->page;\n\t\t\ttblk->eor = log->eor;\n\n\t\t\t/* enqueue transaction to commit queue */\n\t\t\tlist_add_tail(&tblk->cqueue, &log->cqueue);\n\n\t\t\tLOGGC_UNLOCK(log);\n\t\t}\n\n\t\tjfs_info(\"lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x\",\n\t\t\tle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\n\n\t\t/* page not full ? */\n\t\tif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\n\t\t\treturn lsn;\n\n\t      pageFull:\n\t\t/* page become full: move on to next page */\n\t\tlmNextPage(log);\n\n\t\tbp = (struct lbuf *) log->bp;\n\t\tlp = (struct logpage *) bp->l_ldata;\n\t\tdstoffset = LOGPHDRSIZE;\n\t\tsrc += nbytes;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_UNLOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&tblk->synclist",
            "&mp->synclist"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "difft",
            "tblk->lsn",
            "log"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logdiff",
          "args": [
            "diffp",
            "mp->lsn",
            "log"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tblk->synclist",
            "&mp->synclist"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mp->synclist",
            "&log->synclist"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGSYNC_LOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG_LOCK",
          "args": [
            "log"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\"",
            "log",
            "tblk",
            "lrd",
            "tlck"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmWriteRecord(struct jfs_log * log, struct tblock * tblk,\n\t\t\t struct lrd * lrd, struct tlock * tlck);\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t  struct tlock * tlck)\n{\n\tint lsn;\n\tint diffp, difft;\n\tstruct metapage *mp = NULL;\n\tunsigned long flags;\n\n\tjfs_info(\"lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p\",\n\t\t log, tblk, lrd, tlck);\n\n\tLOG_LOCK(log);\n\n\t/* log by (out-of-transaction) JFS ? */\n\tif (tblk == NULL)\n\t\tgoto writeRecord;\n\n\t/* log from page ? */\n\tif (tlck == NULL ||\n\t    tlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\n\t\tgoto writeRecord;\n\n\t/*\n\t *\tinitialize/update page/transaction recovery lsn\n\t */\n\tlsn = log->lsn;\n\n\tLOGSYNC_LOCK(log, flags);\n\n\t/*\n\t * initialize page lsn if first log write of the page\n\t */\n\tif (mp->lsn == 0) {\n\t\tmp->log = log;\n\t\tmp->lsn = lsn;\n\t\tlog->count++;\n\n\t\t/* insert page at tail of logsynclist */\n\t\tlist_add_tail(&mp->synclist, &log->synclist);\n\t}\n\n\t/*\n\t *\tinitialize/update lsn of tblock of the page\n\t *\n\t * transaction inherits oldest lsn of pages associated\n\t * with allocation/deallocation of resources (their\n\t * log records are used to reconstruct allocation map\n\t * at recovery time: inode for inode allocation map,\n\t * B+-tree index of extent descriptors for block\n\t * allocation map);\n\t * allocation map pages inherit transaction lsn at\n\t * commit time to allow forwarding log syncpt past log\n\t * records associated with allocation/deallocation of\n\t * resources only after persistent map of these map pages\n\t * have been updated and propagated to home.\n\t */\n\t/*\n\t * initialize transaction lsn:\n\t */\n\tif (tblk->lsn == 0) {\n\t\t/* inherit lsn of its first page logged */\n\t\ttblk->lsn = mp->lsn;\n\t\tlog->count++;\n\n\t\t/* insert tblock after the page on logsynclist */\n\t\tlist_add(&tblk->synclist, &mp->synclist);\n\t}\n\t/*\n\t * update transaction lsn:\n\t */\n\telse {\n\t\t/* inherit oldest/smallest lsn of page */\n\t\tlogdiff(diffp, mp->lsn, log);\n\t\tlogdiff(difft, tblk->lsn, log);\n\t\tif (diffp < difft) {\n\t\t\t/* update tblock lsn with page lsn */\n\t\t\ttblk->lsn = mp->lsn;\n\n\t\t\t/* move tblock after page on logsynclist */\n\t\t\tlist_move(&tblk->synclist, &mp->synclist);\n\t\t}\n\t}\n\n\tLOGSYNC_UNLOCK(log, flags);\n\n\t/*\n\t *\twrite the log record\n\t */\n      writeRecord:\n\tlsn = lmWriteRecord(log, tblk, lrd, tlck);\n\n\t/*\n\t * forward log syncpt if log reached next syncpt trigger\n\t */\n\tlogdiff(diffp, lsn, log);\n\tif (diffp >= log->nextsync)\n\t\tlsn = lmLogSync(log, 0);\n\n\t/* update end-of-log lsn */\n\tlog->lsn = lsn;\n\n\tLOG_UNLOCK(log);\n\n\t/* return end-of-log address */\n\treturn lsn;\n}"
  },
  {
    "function_name": "write_special_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
    "lines": "214-224",
    "snippet": "static void write_special_inodes(struct jfs_log *log,\n\t\t\t\t int (*writer)(struct address_space *))\n{\n\tstruct jfs_sb_info *sbi;\n\n\tlist_for_each_entry(sbi, &log->sb_list, log_list) {\n\t\twriter(sbi->ipbmap->i_mapping);\n\t\twriter(sbi->ipimap->i_mapping);\n\t\twriter(sbi->direct_inode->i_mapping);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mutex.h>",
      "#include <linux/delay.h>",
      "#include <linux/export.h>",
      "#include <linux/freezer.h>",
      "#include <linux/bio.h>",
      "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
      "#include <linux/kthread.h>",
      "#include <linux/completion.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int lmNextPage(struct jfs_log * log);",
      "static int lbmLogInit(struct jfs_log * log);",
      "static void lbmLogShutdown(struct jfs_log * log);",
      "static struct lbuf *lbmAllocate(struct jfs_log * log, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "writer",
          "args": [
            "sbi->direct_inode->i_mapping"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "721-727",
          "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sbi",
            "&log->sb_list",
            "log_list"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\n\nstatic void write_special_inodes(struct jfs_log *log,\n\t\t\t\t int (*writer)(struct address_space *))\n{\n\tstruct jfs_sb_info *sbi;\n\n\tlist_for_each_entry(sbi, &log->sb_list, log_list) {\n\t\twriter(sbi->ipbmap->i_mapping);\n\t\twriter(sbi->ipimap->i_mapping);\n\t\twriter(sbi->direct_inode->i_mapping);\n\t}\n}"
  }
]