[
  {
    "function_name": "fsnotify_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
    "lines": "287-298",
    "snippet": "static __init int fsnotify_init(void)\n{\n\tint ret;\n\n\tBUG_ON(hweight32(ALL_FSNOTIFY_EVENTS) != 23);\n\n\tret = init_srcu_struct(&fsnotify_mark_srcu);\n\tif (ret)\n\t\tpanic(\"initializing fsnotify_mark_srcu\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../mount.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/srcu.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"initializing fsnotify_mark_srcu\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_srcu_struct",
          "args": [
            "&fsnotify_mark_srcu"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "hweight32(ALL_FSNOTIFY_EVENTS) != 23"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "ALL_FSNOTIFY_EVENTS"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nstatic __init int fsnotify_init(void)\n{\n\tint ret;\n\n\tBUG_ON(hweight32(ALL_FSNOTIFY_EVENTS) != 23);\n\n\tret = init_srcu_struct(&fsnotify_mark_srcu);\n\tif (ret)\n\t\tpanic(\"initializing fsnotify_mark_srcu\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fsnotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
    "lines": "191-284",
    "snippet": "int fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\n\t     const unsigned char *file_name, u32 cookie)\n{\n\tstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\n\tstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\n\tstruct fsnotify_group *inode_group, *vfsmount_group;\n\tstruct mount *mnt;\n\tint idx, ret = 0;\n\t/* global tests shouldn't care about events on child only the specific event */\n\t__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\n\tif (data_is == FSNOTIFY_EVENT_PATH)\n\t\tmnt = real_mount(((struct path *)data)->mnt);\n\telse\n\t\tmnt = NULL;\n\n\t/*\n\t * if this is a modify event we may need to clear the ignored masks\n\t * otherwise return if neither the inode nor the vfsmount care about\n\t * this type of event.\n\t */\n\tif (!(mask & FS_MODIFY) &&\n\t    !(test_mask & to_tell->i_fsnotify_mask) &&\n\t    !(mnt && test_mask & mnt->mnt_fsnotify_mask))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\tif ((mask & FS_MODIFY) ||\n\t    (test_mask & to_tell->i_fsnotify_mask))\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\n\tif (mnt && ((mask & FS_MODIFY) ||\n\t\t    (test_mask & mnt->mnt_fsnotify_mask))) {\n\t\tvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\n\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\t}\n\n\t/*\n\t * We need to merge inode & vfsmount mark lists so that inode mark\n\t * ignore masks are properly reflected for mount mark notifications.\n\t * That's why this traversal is so complicated...\n\t */\n\twhile (inode_node || vfsmount_node) {\n\t\tinode_group = NULL;\n\t\tinode_mark = NULL;\n\t\tvfsmount_group = NULL;\n\t\tvfsmount_mark = NULL;\n\n\t\tif (inode_node) {\n\t\t\tinode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t struct fsnotify_mark, obj_list);\n\t\t\tinode_group = inode_mark->group;\n\t\t}\n\n\t\tif (vfsmount_node) {\n\t\t\tvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t    struct fsnotify_mark, obj_list);\n\t\t\tvfsmount_group = vfsmount_mark->group;\n\t\t}\n\n\t\tif (inode_group && vfsmount_group) {\n\t\t\tint cmp = fsnotify_compare_groups(inode_group,\n\t\t\t\t\t\t\t  vfsmount_group);\n\t\t\tif (cmp > 0) {\n\t\t\t\tinode_group = NULL;\n\t\t\t\tinode_mark = NULL;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tvfsmount_group = NULL;\n\t\t\t\tvfsmount_mark = NULL;\n\t\t\t}\n\t\t}\n\t\tret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\n\t\t\t\t    data, data_is, cookie, file_name);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tif (inode_group)\n\t\t\tinode_node = srcu_dereference(inode_node->next,\n\t\t\t\t\t\t      &fsnotify_mark_srcu);\n\t\tif (vfsmount_group)\n\t\t\tvfsmount_node = srcu_dereference(vfsmount_node->next,\n\t\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"../mount.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/srcu.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fsnotify_mark_srcu",
            "idx"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "vfsmount_node->next",
            "&fsnotify_mark_srcu"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "inode_node->next",
            "&fsnotify_mark_srcu"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_to_group",
          "args": [
            "to_tell",
            "inode_mark",
            "vfsmount_mark",
            "mask",
            "data",
            "data_is",
            "cookie",
            "file_name"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "send_to_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "126-183",
          "snippet": "static int send_to_group(struct inode *to_tell,\n\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t struct fsnotify_mark *vfsmount_mark,\n\t\t\t __u32 mask, void *data,\n\t\t\t int data_is, u32 cookie,\n\t\t\t const unsigned char *file_name)\n{\n\tstruct fsnotify_group *group = NULL;\n\t__u32 inode_test_mask = 0;\n\t__u32 vfsmount_test_mask = 0;\n\n\tif (unlikely(!inode_mark && !vfsmount_mark)) {\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\t/* clear ignored on inode modification */\n\tif (mask & FS_MODIFY) {\n\t\tif (inode_mark &&\n\t\t    !(inode_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\tinode_mark->ignored_mask = 0;\n\t\tif (vfsmount_mark &&\n\t\t    !(vfsmount_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\tvfsmount_mark->ignored_mask = 0;\n\t}\n\n\t/* does the inode mark tell us to do something? */\n\tif (inode_mark) {\n\t\tgroup = inode_mark->group;\n\t\tinode_test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\t\tinode_test_mask &= inode_mark->mask;\n\t\tinode_test_mask &= ~inode_mark->ignored_mask;\n\t}\n\n\t/* does the vfsmount_mark tell us to do something? */\n\tif (vfsmount_mark) {\n\t\tvfsmount_test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\t\tgroup = vfsmount_mark->group;\n\t\tvfsmount_test_mask &= vfsmount_mark->mask;\n\t\tvfsmount_test_mask &= ~vfsmount_mark->ignored_mask;\n\t\tif (inode_mark)\n\t\t\tvfsmount_test_mask &= ~inode_mark->ignored_mask;\n\t}\n\n\tpr_debug(\"%s: group=%p to_tell=%p mask=%x inode_mark=%p\"\n\t\t \" inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x\"\n\t\t \" data=%p data_is=%d cookie=%d\\n\",\n\t\t __func__, group, to_tell, mask, inode_mark,\n\t\t inode_test_mask, vfsmount_mark, vfsmount_test_mask, data,\n\t\t data_is, cookie);\n\n\tif (!inode_test_mask && !vfsmount_test_mask)\n\t\treturn 0;\n\n\treturn group->ops->handle_event(group, to_tell, inode_mark,\n\t\t\t\t\tvfsmount_mark, mask, data, data_is,\n\t\t\t\t\tfile_name, cookie);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nstatic int send_to_group(struct inode *to_tell,\n\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t struct fsnotify_mark *vfsmount_mark,\n\t\t\t __u32 mask, void *data,\n\t\t\t int data_is, u32 cookie,\n\t\t\t const unsigned char *file_name)\n{\n\tstruct fsnotify_group *group = NULL;\n\t__u32 inode_test_mask = 0;\n\t__u32 vfsmount_test_mask = 0;\n\n\tif (unlikely(!inode_mark && !vfsmount_mark)) {\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\t/* clear ignored on inode modification */\n\tif (mask & FS_MODIFY) {\n\t\tif (inode_mark &&\n\t\t    !(inode_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\tinode_mark->ignored_mask = 0;\n\t\tif (vfsmount_mark &&\n\t\t    !(vfsmount_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\tvfsmount_mark->ignored_mask = 0;\n\t}\n\n\t/* does the inode mark tell us to do something? */\n\tif (inode_mark) {\n\t\tgroup = inode_mark->group;\n\t\tinode_test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\t\tinode_test_mask &= inode_mark->mask;\n\t\tinode_test_mask &= ~inode_mark->ignored_mask;\n\t}\n\n\t/* does the vfsmount_mark tell us to do something? */\n\tif (vfsmount_mark) {\n\t\tvfsmount_test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\t\tgroup = vfsmount_mark->group;\n\t\tvfsmount_test_mask &= vfsmount_mark->mask;\n\t\tvfsmount_test_mask &= ~vfsmount_mark->ignored_mask;\n\t\tif (inode_mark)\n\t\t\tvfsmount_test_mask &= ~inode_mark->ignored_mask;\n\t}\n\n\tpr_debug(\"%s: group=%p to_tell=%p mask=%x inode_mark=%p\"\n\t\t \" inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x\"\n\t\t \" data=%p data_is=%d cookie=%d\\n\",\n\t\t __func__, group, to_tell, mask, inode_mark,\n\t\t inode_test_mask, vfsmount_mark, vfsmount_test_mask, data,\n\t\t data_is, cookie);\n\n\tif (!inode_test_mask && !vfsmount_test_mask)\n\t\treturn 0;\n\n\treturn group->ops->handle_event(group, to_tell, inode_mark,\n\t\t\t\t\tvfsmount_mark, mask, data, data_is,\n\t\t\t\t\tfile_name, cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_compare_groups",
          "args": [
            "inode_group",
            "vfsmount_group"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_compare_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "263-278",
          "snippet": "int fsnotify_compare_groups(struct fsnotify_group *a, struct fsnotify_group *b)\n{\n\tif (a == b)\n\t\treturn 0;\n\tif (!a)\n\t\treturn 1;\n\tif (!b)\n\t\treturn -1;\n\tif (a->priority < b->priority)\n\t\treturn 1;\n\tif (a->priority > b->priority)\n\t\treturn -1;\n\tif (a < b)\n\t\treturn 1;\n\treturn -1;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_compare_groups(struct fsnotify_group *a, struct fsnotify_group *b)\n{\n\tif (a == b)\n\t\treturn 0;\n\tif (!a)\n\t\treturn 1;\n\tif (!b)\n\t\treturn -1;\n\tif (a->priority < b->priority)\n\t\treturn 1;\n\tif (a->priority > b->priority)\n\t\treturn -1;\n\tif (a < b)\n\t\treturn 1;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "srcu_dereference(vfsmount_node, &fsnotify_mark_srcu)",
            "structfsnotify_mark",
            "obj_list"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "vfsmount_node",
            "&fsnotify_mark_srcu"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "srcu_dereference(inode_node, &fsnotify_mark_srcu)",
            "structfsnotify_mark",
            "obj_list"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "inode_node",
            "&fsnotify_mark_srcu"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "to_tell->i_fsnotify_marks.first",
            "&fsnotify_mark_srcu"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "mnt->mnt_fsnotify_marks.first",
            "&fsnotify_mark_srcu"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "to_tell->i_fsnotify_marks.first",
            "&fsnotify_mark_srcu"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&fsnotify_mark_srcu"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "((struct path *)data)->mnt"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nint fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\n\t     const unsigned char *file_name, u32 cookie)\n{\n\tstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\n\tstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\n\tstruct fsnotify_group *inode_group, *vfsmount_group;\n\tstruct mount *mnt;\n\tint idx, ret = 0;\n\t/* global tests shouldn't care about events on child only the specific event */\n\t__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\n\tif (data_is == FSNOTIFY_EVENT_PATH)\n\t\tmnt = real_mount(((struct path *)data)->mnt);\n\telse\n\t\tmnt = NULL;\n\n\t/*\n\t * if this is a modify event we may need to clear the ignored masks\n\t * otherwise return if neither the inode nor the vfsmount care about\n\t * this type of event.\n\t */\n\tif (!(mask & FS_MODIFY) &&\n\t    !(test_mask & to_tell->i_fsnotify_mask) &&\n\t    !(mnt && test_mask & mnt->mnt_fsnotify_mask))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\tif ((mask & FS_MODIFY) ||\n\t    (test_mask & to_tell->i_fsnotify_mask))\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\n\tif (mnt && ((mask & FS_MODIFY) ||\n\t\t    (test_mask & mnt->mnt_fsnotify_mask))) {\n\t\tvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\n\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\t}\n\n\t/*\n\t * We need to merge inode & vfsmount mark lists so that inode mark\n\t * ignore masks are properly reflected for mount mark notifications.\n\t * That's why this traversal is so complicated...\n\t */\n\twhile (inode_node || vfsmount_node) {\n\t\tinode_group = NULL;\n\t\tinode_mark = NULL;\n\t\tvfsmount_group = NULL;\n\t\tvfsmount_mark = NULL;\n\n\t\tif (inode_node) {\n\t\t\tinode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t struct fsnotify_mark, obj_list);\n\t\t\tinode_group = inode_mark->group;\n\t\t}\n\n\t\tif (vfsmount_node) {\n\t\t\tvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t    struct fsnotify_mark, obj_list);\n\t\t\tvfsmount_group = vfsmount_mark->group;\n\t\t}\n\n\t\tif (inode_group && vfsmount_group) {\n\t\t\tint cmp = fsnotify_compare_groups(inode_group,\n\t\t\t\t\t\t\t  vfsmount_group);\n\t\t\tif (cmp > 0) {\n\t\t\t\tinode_group = NULL;\n\t\t\t\tinode_mark = NULL;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tvfsmount_group = NULL;\n\t\t\t\tvfsmount_mark = NULL;\n\t\t\t}\n\t\t}\n\t\tret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\n\t\t\t\t    data, data_is, cookie, file_name);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tif (inode_group)\n\t\t\tinode_node = srcu_dereference(inode_node->next,\n\t\t\t\t\t\t      &fsnotify_mark_srcu);\n\t\tif (vfsmount_group)\n\t\t\tvfsmount_node = srcu_dereference(vfsmount_node->next,\n\t\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "send_to_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
    "lines": "126-183",
    "snippet": "static int send_to_group(struct inode *to_tell,\n\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t struct fsnotify_mark *vfsmount_mark,\n\t\t\t __u32 mask, void *data,\n\t\t\t int data_is, u32 cookie,\n\t\t\t const unsigned char *file_name)\n{\n\tstruct fsnotify_group *group = NULL;\n\t__u32 inode_test_mask = 0;\n\t__u32 vfsmount_test_mask = 0;\n\n\tif (unlikely(!inode_mark && !vfsmount_mark)) {\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\t/* clear ignored on inode modification */\n\tif (mask & FS_MODIFY) {\n\t\tif (inode_mark &&\n\t\t    !(inode_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\tinode_mark->ignored_mask = 0;\n\t\tif (vfsmount_mark &&\n\t\t    !(vfsmount_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\tvfsmount_mark->ignored_mask = 0;\n\t}\n\n\t/* does the inode mark tell us to do something? */\n\tif (inode_mark) {\n\t\tgroup = inode_mark->group;\n\t\tinode_test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\t\tinode_test_mask &= inode_mark->mask;\n\t\tinode_test_mask &= ~inode_mark->ignored_mask;\n\t}\n\n\t/* does the vfsmount_mark tell us to do something? */\n\tif (vfsmount_mark) {\n\t\tvfsmount_test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\t\tgroup = vfsmount_mark->group;\n\t\tvfsmount_test_mask &= vfsmount_mark->mask;\n\t\tvfsmount_test_mask &= ~vfsmount_mark->ignored_mask;\n\t\tif (inode_mark)\n\t\t\tvfsmount_test_mask &= ~inode_mark->ignored_mask;\n\t}\n\n\tpr_debug(\"%s: group=%p to_tell=%p mask=%x inode_mark=%p\"\n\t\t \" inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x\"\n\t\t \" data=%p data_is=%d cookie=%d\\n\",\n\t\t __func__, group, to_tell, mask, inode_mark,\n\t\t inode_test_mask, vfsmount_mark, vfsmount_test_mask, data,\n\t\t data_is, cookie);\n\n\tif (!inode_test_mask && !vfsmount_test_mask)\n\t\treturn 0;\n\n\treturn group->ops->handle_event(group, to_tell, inode_mark,\n\t\t\t\t\tvfsmount_mark, mask, data, data_is,\n\t\t\t\t\tfile_name, cookie);\n}",
    "includes": [
      "#include \"../mount.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/srcu.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "group->ops->handle_event",
          "args": [
            "group",
            "to_tell",
            "inode_mark",
            "vfsmount_mark",
            "mask",
            "data",
            "data_is",
            "file_name",
            "cookie"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p to_tell=%p mask=%x inode_mark=%p\"\n\t\t \" inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x\"\n\t\t \" data=%p data_is=%d cookie=%d\\n\"",
            "__func__",
            "group",
            "to_tell",
            "mask",
            "inode_mark",
            "inode_test_mask",
            "vfsmount_mark",
            "vfsmount_test_mask",
            "data",
            "data_is",
            "cookie"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode_mark && !vfsmount_mark"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nstatic int send_to_group(struct inode *to_tell,\n\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t struct fsnotify_mark *vfsmount_mark,\n\t\t\t __u32 mask, void *data,\n\t\t\t int data_is, u32 cookie,\n\t\t\t const unsigned char *file_name)\n{\n\tstruct fsnotify_group *group = NULL;\n\t__u32 inode_test_mask = 0;\n\t__u32 vfsmount_test_mask = 0;\n\n\tif (unlikely(!inode_mark && !vfsmount_mark)) {\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\t/* clear ignored on inode modification */\n\tif (mask & FS_MODIFY) {\n\t\tif (inode_mark &&\n\t\t    !(inode_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\tinode_mark->ignored_mask = 0;\n\t\tif (vfsmount_mark &&\n\t\t    !(vfsmount_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\n\t\t\tvfsmount_mark->ignored_mask = 0;\n\t}\n\n\t/* does the inode mark tell us to do something? */\n\tif (inode_mark) {\n\t\tgroup = inode_mark->group;\n\t\tinode_test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\t\tinode_test_mask &= inode_mark->mask;\n\t\tinode_test_mask &= ~inode_mark->ignored_mask;\n\t}\n\n\t/* does the vfsmount_mark tell us to do something? */\n\tif (vfsmount_mark) {\n\t\tvfsmount_test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\t\tgroup = vfsmount_mark->group;\n\t\tvfsmount_test_mask &= vfsmount_mark->mask;\n\t\tvfsmount_test_mask &= ~vfsmount_mark->ignored_mask;\n\t\tif (inode_mark)\n\t\t\tvfsmount_test_mask &= ~inode_mark->ignored_mask;\n\t}\n\n\tpr_debug(\"%s: group=%p to_tell=%p mask=%x inode_mark=%p\"\n\t\t \" inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x\"\n\t\t \" data=%p data_is=%d cookie=%d\\n\",\n\t\t __func__, group, to_tell, mask, inode_mark,\n\t\t inode_test_mask, vfsmount_mark, vfsmount_test_mask, data,\n\t\t data_is, cookie);\n\n\tif (!inode_test_mask && !vfsmount_test_mask)\n\t\treturn 0;\n\n\treturn group->ops->handle_event(group, to_tell, inode_mark,\n\t\t\t\t\tvfsmount_mark, mask, data, data_is,\n\t\t\t\t\tfile_name, cookie);\n}"
  },
  {
    "function_name": "__fsnotify_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
    "lines": "90-123",
    "snippet": "int __fsnotify_parent(struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\t/* we are notifying a parent so come up with the new mask which\n\t\t * specifies these are events which came from a child. */\n\t\tmask |= FS_EVENT_ON_CHILD;\n\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\n\tdput(parent);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"../mount.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/srcu.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify",
          "args": [
            "p_inode",
            "mask",
            "dentry->d_inode",
            "FSNOTIFY_EVENT_INODE",
            "dentry->d_name.name",
            "0"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "191-284",
          "snippet": "int fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\n\t     const unsigned char *file_name, u32 cookie)\n{\n\tstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\n\tstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\n\tstruct fsnotify_group *inode_group, *vfsmount_group;\n\tstruct mount *mnt;\n\tint idx, ret = 0;\n\t/* global tests shouldn't care about events on child only the specific event */\n\t__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\n\tif (data_is == FSNOTIFY_EVENT_PATH)\n\t\tmnt = real_mount(((struct path *)data)->mnt);\n\telse\n\t\tmnt = NULL;\n\n\t/*\n\t * if this is a modify event we may need to clear the ignored masks\n\t * otherwise return if neither the inode nor the vfsmount care about\n\t * this type of event.\n\t */\n\tif (!(mask & FS_MODIFY) &&\n\t    !(test_mask & to_tell->i_fsnotify_mask) &&\n\t    !(mnt && test_mask & mnt->mnt_fsnotify_mask))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\tif ((mask & FS_MODIFY) ||\n\t    (test_mask & to_tell->i_fsnotify_mask))\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\n\tif (mnt && ((mask & FS_MODIFY) ||\n\t\t    (test_mask & mnt->mnt_fsnotify_mask))) {\n\t\tvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\n\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\t}\n\n\t/*\n\t * We need to merge inode & vfsmount mark lists so that inode mark\n\t * ignore masks are properly reflected for mount mark notifications.\n\t * That's why this traversal is so complicated...\n\t */\n\twhile (inode_node || vfsmount_node) {\n\t\tinode_group = NULL;\n\t\tinode_mark = NULL;\n\t\tvfsmount_group = NULL;\n\t\tvfsmount_mark = NULL;\n\n\t\tif (inode_node) {\n\t\t\tinode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t struct fsnotify_mark, obj_list);\n\t\t\tinode_group = inode_mark->group;\n\t\t}\n\n\t\tif (vfsmount_node) {\n\t\t\tvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t    struct fsnotify_mark, obj_list);\n\t\t\tvfsmount_group = vfsmount_mark->group;\n\t\t}\n\n\t\tif (inode_group && vfsmount_group) {\n\t\t\tint cmp = fsnotify_compare_groups(inode_group,\n\t\t\t\t\t\t\t  vfsmount_group);\n\t\t\tif (cmp > 0) {\n\t\t\t\tinode_group = NULL;\n\t\t\t\tinode_mark = NULL;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tvfsmount_group = NULL;\n\t\t\t\tvfsmount_mark = NULL;\n\t\t\t}\n\t\t}\n\t\tret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\n\t\t\t\t    data, data_is, cookie, file_name);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tif (inode_group)\n\t\t\tinode_node = srcu_dereference(inode_node->next,\n\t\t\t\t\t\t      &fsnotify_mark_srcu);\n\t\tif (vfsmount_group)\n\t\t\tvfsmount_node = srcu_dereference(vfsmount_node->next,\n\t\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nint fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\n\t     const unsigned char *file_name, u32 cookie)\n{\n\tstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\n\tstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\n\tstruct fsnotify_group *inode_group, *vfsmount_group;\n\tstruct mount *mnt;\n\tint idx, ret = 0;\n\t/* global tests shouldn't care about events on child only the specific event */\n\t__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\n\tif (data_is == FSNOTIFY_EVENT_PATH)\n\t\tmnt = real_mount(((struct path *)data)->mnt);\n\telse\n\t\tmnt = NULL;\n\n\t/*\n\t * if this is a modify event we may need to clear the ignored masks\n\t * otherwise return if neither the inode nor the vfsmount care about\n\t * this type of event.\n\t */\n\tif (!(mask & FS_MODIFY) &&\n\t    !(test_mask & to_tell->i_fsnotify_mask) &&\n\t    !(mnt && test_mask & mnt->mnt_fsnotify_mask))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\tif ((mask & FS_MODIFY) ||\n\t    (test_mask & to_tell->i_fsnotify_mask))\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\n\tif (mnt && ((mask & FS_MODIFY) ||\n\t\t    (test_mask & mnt->mnt_fsnotify_mask))) {\n\t\tvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\n\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\t}\n\n\t/*\n\t * We need to merge inode & vfsmount mark lists so that inode mark\n\t * ignore masks are properly reflected for mount mark notifications.\n\t * That's why this traversal is so complicated...\n\t */\n\twhile (inode_node || vfsmount_node) {\n\t\tinode_group = NULL;\n\t\tinode_mark = NULL;\n\t\tvfsmount_group = NULL;\n\t\tvfsmount_mark = NULL;\n\n\t\tif (inode_node) {\n\t\t\tinode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t struct fsnotify_mark, obj_list);\n\t\t\tinode_group = inode_mark->group;\n\t\t}\n\n\t\tif (vfsmount_node) {\n\t\t\tvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t    struct fsnotify_mark, obj_list);\n\t\t\tvfsmount_group = vfsmount_mark->group;\n\t\t}\n\n\t\tif (inode_group && vfsmount_group) {\n\t\t\tint cmp = fsnotify_compare_groups(inode_group,\n\t\t\t\t\t\t\t  vfsmount_group);\n\t\t\tif (cmp > 0) {\n\t\t\t\tinode_group = NULL;\n\t\t\t\tinode_mark = NULL;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tvfsmount_group = NULL;\n\t\t\t\tvfsmount_mark = NULL;\n\t\t\t}\n\t\t}\n\t\tret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\n\t\t\t\t    data, data_is, cookie, file_name);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tif (inode_group)\n\t\t\tinode_node = srcu_dereference(inode_node->next,\n\t\t\t\t\t\t      &fsnotify_mark_srcu);\n\t\tif (vfsmount_group)\n\t\t\tvfsmount_node = srcu_dereference(vfsmount_node->next,\n\t\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fsnotify_update_child_dentry_flags",
          "args": [
            "p_inode"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_update_child_dentry_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "52-87",
          "snippet": "void __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fsnotify_inode_watches_children(p_inode)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_inode_watches_children",
          "args": [
            "p_inode"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nint __fsnotify_parent(struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\t/* we are notifying a parent so come up with the new mask which\n\t\t * specifies these are events which came from a child. */\n\t\tmask |= FS_EVENT_ON_CHILD;\n\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\n\tdput(parent);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__fsnotify_update_child_dentry_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
    "lines": "52-87",
    "snippet": "void __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"../mount.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/srcu.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&child->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&alias->d_subdirs",
            "d_child"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&alias->d_lock"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "alias",
            "&inode->i_dentry",
            "d_u.d_alias"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_inode_watches_children",
          "args": [
            "inode"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "__fsnotify_vfsmount_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
    "lines": "40-43",
    "snippet": "void __fsnotify_vfsmount_delete(struct vfsmount *mnt)\n{\n\tfsnotify_clear_marks_by_mount(mnt);\n}",
    "includes": [
      "#include \"../mount.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/srcu.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_clear_marks_by_mount",
          "args": [
            "mnt"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_clear_marks_by_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/vfsmount_mark.c",
          "lines": "33-49",
          "snippet": "void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct hlist_node *n;\n\tstruct mount *m = real_mount(mnt);\n\tLIST_HEAD(free_list);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\thlist_for_each_entry_safe(mark, n, &m->mnt_fsnotify_marks, obj_list) {\n\t\tlist_add(&mark->free_list, &free_list);\n\t\thlist_del_init_rcu(&mark->obj_list);\n\t\tfsnotify_get_mark(mark);\n\t}\n\tspin_unlock(&mnt->mnt_root->d_lock);\n\n\tfsnotify_destroy_marks(&free_list);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_clear_marks_by_mount(struct vfsmount *mnt)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct hlist_node *n;\n\tstruct mount *m = real_mount(mnt);\n\tLIST_HEAD(free_list);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\thlist_for_each_entry_safe(mark, n, &m->mnt_fsnotify_marks, obj_list) {\n\t\tlist_add(&mark->free_list, &free_list);\n\t\thlist_del_init_rcu(&mark->obj_list);\n\t\tfsnotify_get_mark(mark);\n\t}\n\tspin_unlock(&mnt->mnt_root->d_lock);\n\n\tfsnotify_destroy_marks(&free_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_vfsmount_delete(struct vfsmount *mnt)\n{\n\tfsnotify_clear_marks_by_mount(mnt);\n}"
  },
  {
    "function_name": "__fsnotify_inode_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
    "lines": "34-37",
    "snippet": "void __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}",
    "includes": [
      "#include \"../mount.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/srcu.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_clear_marks_by_inode",
          "args": [
            "inode"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_clear_marks_by_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "70-85",
          "snippet": "void fsnotify_clear_marks_by_inode(struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct hlist_node *n;\n\tLIST_HEAD(free_list);\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry_safe(mark, n, &inode->i_fsnotify_marks, obj_list) {\n\t\tlist_add(&mark->free_list, &free_list);\n\t\thlist_del_init_rcu(&mark->obj_list);\n\t\tfsnotify_get_mark(mark);\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tfsnotify_destroy_marks(&free_list);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_clear_marks_by_inode(struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct hlist_node *n;\n\tLIST_HEAD(free_list);\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry_safe(mark, n, &inode->i_fsnotify_marks, obj_list) {\n\t\tlist_add(&mark->free_list, &free_list);\n\t\thlist_del_init_rcu(&mark->obj_list);\n\t\tfsnotify_get_mark(mark);\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tfsnotify_destroy_marks(&free_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}"
  }
]