[
  {
    "function_name": "fs2_ubivol_cleanup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1351-1353",
    "snippet": "id jffs2_ubivol_cleanup(struct jffs2_sb_info *c) {\n\tkfree(c->wbuf);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf);"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid jffs2_ubivol_cleanup(struct jffs2_sb_info *c) {\n\tkfree(c->wbuf);\n}"
  },
  {
    "function_name": "fs2_ubivol_setup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1329-1349",
    "snippet": "t jffs2_ubivol_setup(struct jffs2_sb_info *c) {\n\tc->cleanmarker_size = 0;\n\n\tif (c->mtd->writesize == 1)\n\t\t/* We do not need write-buffer */\n\t\treturn 0;\n\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\n\tc->wbuf_pagesize =  c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"write-buffering enabled buffer (%d) erasesize (%d)\\n\",\n\t\tc->wbuf_pagesize, c->sector_size);\n\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_info(\"",
          "args": [
            "rite-buffering enabled buffer (%d) erasesize (%d)\\n\",",
            ">wbuf_pagesize,",
            ">sector_size);"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(c",
          "args": [
            ">wbuf_pagesize,",
            "P_KERNEL);"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_DELAYED_WORK(&",
          "args": [
            "->wbuf_dwork,",
            "layed_wbuf_sync);"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_rwsem(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_ubivol_setup(struct jffs2_sb_info *c) {\n\tc->cleanmarker_size = 0;\n\n\tif (c->mtd->writesize == 1)\n\t\t/* We do not need write-buffer */\n\t\treturn 0;\n\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\n\tc->wbuf_pagesize =  c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"write-buffering enabled buffer (%d) erasesize (%d)\\n\",\n\t\tc->wbuf_pagesize, c->sector_size);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_nor_wbuf_flash_cleanup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1322-1327",
    "snippet": "id jffs2_nor_wbuf_flash_cleanup(struct jffs2_sb_info *c) {\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf);"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf_verify);"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid jffs2_nor_wbuf_flash_cleanup(struct jffs2_sb_info *c) {\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n}"
  },
  {
    "function_name": "fs2_nor_wbuf_flash_setup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1296-1320",
    "snippet": "t jffs2_nor_wbuf_flash_setup(struct jffs2_sb_info *c) {\n\t/* Cleanmarker currently occupies whole programming regions,\n\t * either one or 2 for 8Byte STMicro flashes. */\n\tc->cleanmarker_size = max(16u, c->mtd->writesize);\n\n\t/* Initialize write buffer */\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\n\tc->wbuf_pagesize = c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf);"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(c",
          "args": [
            ">wbuf_pagesize,",
            "P_KERNEL);"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(c",
          "args": [
            ">wbuf_pagesize,",
            "P_KERNEL);"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_DELAYED_WORK(&",
          "args": [
            "->wbuf_dwork,",
            "layed_wbuf_sync);"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_rwsem(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x(1",
          "args": [
            "u,",
            ">mtd->writesize);"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_nor_wbuf_flash_setup(struct jffs2_sb_info *c) {\n\t/* Cleanmarker currently occupies whole programming regions,\n\t * either one or 2 for 8Byte STMicro flashes. */\n\tc->cleanmarker_size = max(16u, c->mtd->writesize);\n\n\t/* Initialize write buffer */\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\n\tc->wbuf_pagesize = c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_dataflash_cleanup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1289-1294",
    "snippet": "id jffs2_dataflash_cleanup(struct jffs2_sb_info *c) {\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf);"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf_verify);"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid jffs2_dataflash_cleanup(struct jffs2_sb_info *c) {\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n}"
  },
  {
    "function_name": "fs2_dataflash_setup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1239-1287",
    "snippet": "t jffs2_dataflash_setup(struct jffs2_sb_info *c) {\n\tc->cleanmarker_size = 0;\t\t/* No cleanmarkers needed */\n\n\t/* Initialize write buffer */\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\tc->wbuf_pagesize =  c->mtd->erasesize;\n\n\t/* Find a suitable c->sector_size\n\t * - Not too much sectors\n\t * - Sectors have to be at least 4 K + some bytes\n\t * - All known dataflashes have erase sizes of 528 or 1056\n\t * - we take at least 8 eraseblocks and want to have at least 8K size\n\t * - The concatenation should be a power of 2\n\t*/\n\n\tc->sector_size = 8 * c->mtd->erasesize;\n\n\twhile (c->sector_size < 8192) {\n\t\tc->sector_size *= 2;\n\t}\n\n\t/* It may be necessary to adjust the flash size */\n\tc->flash_size = c->mtd->size;\n\n\tif ((c->flash_size % c->sector_size) != 0) {\n\t\tc->flash_size = (c->flash_size / c->sector_size) * c->sector_size;\n\t\tpr_warn(\"flash size adjusted to %dKiB\\n\", c->flash_size);\n\t};\n\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->oobbuf);\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tpr_info(\"write-buffering enabled buffer (%d) erasesize (%d)\\n\",\n\t\tc->wbuf_pagesize, c->sector_size);\n\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_info(\"",
          "args": [
            "rite-buffering enabled buffer (%d) erasesize (%d)\\n\",",
            ">wbuf_pagesize,",
            ">sector_size);"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf);"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">oobbuf);"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(c",
          "args": [
            ">wbuf_pagesize,",
            "P_KERNEL);"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(c",
          "args": [
            ">wbuf_pagesize,",
            "P_KERNEL);"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "lash size adjusted to %dKiB\\n\",",
            ">flash_size);"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_DELAYED_WORK(&",
          "args": [
            "->wbuf_dwork,",
            "layed_wbuf_sync);"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_rwsem(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_dataflash_setup(struct jffs2_sb_info *c) {\n\tc->cleanmarker_size = 0;\t\t/* No cleanmarkers needed */\n\n\t/* Initialize write buffer */\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\tc->wbuf_pagesize =  c->mtd->erasesize;\n\n\t/* Find a suitable c->sector_size\n\t * - Not too much sectors\n\t * - Sectors have to be at least 4 K + some bytes\n\t * - All known dataflashes have erase sizes of 528 or 1056\n\t * - we take at least 8 eraseblocks and want to have at least 8K size\n\t * - The concatenation should be a power of 2\n\t*/\n\n\tc->sector_size = 8 * c->mtd->erasesize;\n\n\twhile (c->sector_size < 8192) {\n\t\tc->sector_size *= 2;\n\t}\n\n\t/* It may be necessary to adjust the flash size */\n\tc->flash_size = c->mtd->size;\n\n\tif ((c->flash_size % c->sector_size) != 0) {\n\t\tc->flash_size = (c->flash_size / c->sector_size) * c->sector_size;\n\t\tpr_warn(\"flash size adjusted to %dKiB\\n\", c->flash_size);\n\t};\n\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->oobbuf);\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tpr_info(\"write-buffering enabled buffer (%d) erasesize (%d)\\n\",\n\t\tc->wbuf_pagesize, c->sector_size);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_nand_flash_cleanup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1230-1237",
    "snippet": "id jffs2_nand_flash_cleanup(struct jffs2_sb_info *c)\n{\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n\tkfree(c->oobbuf);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">oobbuf);"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf);"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf_verify);"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid jffs2_nand_flash_cleanup(struct jffs2_sb_info *c)\n{\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tkfree(c->wbuf_verify);\n#endif\n\tkfree(c->wbuf);\n\tkfree(c->oobbuf);\n}"
  },
  {
    "function_name": "fs2_nand_flash_setup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1184-1228",
    "snippet": "t jffs2_nand_flash_setup(struct jffs2_sb_info *c)\n{\n\tstruct nand_ecclayout *oinfo = c->mtd->ecclayout;\n\n\tif (!c->mtd->oobsize)\n\t\treturn 0;\n\n\t/* Cleanmarker is out-of-band, so inline size zero */\n\tc->cleanmarker_size = 0;\n\n\tif (!oinfo || oinfo->oobavail == 0) {\n\t\tpr_err(\"inconsistent device description\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjffs2_dbg(1, \"using OOB on NAND\\n\");\n\n\tc->oobavail = oinfo->oobavail;\n\n\t/* Initialise write buffer */\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\tc->wbuf_pagesize = c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n\tc->oobbuf = kmalloc(NR_OOB_SCAN_PAGES * c->oobavail, GFP_KERNEL);\n\tif (!c->oobbuf) {\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->oobbuf);\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf);"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">oobbuf);"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(c",
          "args": [
            ">wbuf_pagesize,",
            "P_KERNEL);"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">wbuf);"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(N",
          "args": [
            "_OOB_SCAN_PAGES * c->oobavail,",
            "P_KERNEL);"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(c",
          "args": [
            ">wbuf_pagesize,",
            "P_KERNEL);"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IT_DELAYED_WORK(&",
          "args": [
            "->wbuf_dwork,",
            "layed_wbuf_sync);"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_rwsem(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "sing OOB on NAND\\n\");"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_err(\"",
          "args": [
            "nconsistent device description\\n\");"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_nand_flash_setup(struct jffs2_sb_info *c)\n{\n\tstruct nand_ecclayout *oinfo = c->mtd->ecclayout;\n\n\tif (!c->mtd->oobsize)\n\t\treturn 0;\n\n\t/* Cleanmarker is out-of-band, so inline size zero */\n\tc->cleanmarker_size = 0;\n\n\tif (!oinfo || oinfo->oobavail == 0) {\n\t\tpr_err(\"inconsistent device description\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjffs2_dbg(1, \"using OOB on NAND\\n\");\n\n\tc->oobavail = oinfo->oobavail;\n\n\t/* Initialise write buffer */\n\tinit_rwsem(&c->wbuf_sem);\n\tINIT_DELAYED_WORK(&c->wbuf_dwork, delayed_wbuf_sync);\n\tc->wbuf_pagesize = c->mtd->writesize;\n\tc->wbuf_ofs = 0xFFFFFFFF;\n\n\tc->wbuf = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf)\n\t\treturn -ENOMEM;\n\n\tc->oobbuf = kmalloc(NR_OOB_SCAN_PAGES * c->oobavail, GFP_KERNEL);\n\tif (!c->oobbuf) {\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n\n#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY\n\tc->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);\n\tif (!c->wbuf_verify) {\n\t\tkfree(c->oobbuf);\n\t\tkfree(c->wbuf);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_dirty_trigger(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1171-1182",
    "snippet": "id jffs2_dirty_trigger(struct jffs2_sb_info *c)\n{\n\tstruct super_block *sb = OFNI_BS_2SFFJ(c);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (queue_delayed_work(system_long_wq, &c->wbuf_dwork, delay))\n\t\tjffs2_dbg(1, \"%s()\\n\", __func__);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s()\\n\",",
            "func__);"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eue_delayed_work(s",
          "args": [
            "stem_long_wq,",
            "->wbuf_dwork,",
            "lay))"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecs_to_jiffies(d",
          "args": [
            "rty_writeback_interval * 10);"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NI_BS_2SFFJ(c",
          "args": [
            ";"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid jffs2_dirty_trigger(struct jffs2_sb_info *c)\n{\n\tstruct super_block *sb = OFNI_BS_2SFFJ(c);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (queue_delayed_work(system_long_wq, &c->wbuf_dwork, delay))\n\t\tjffs2_dbg(1, \"%s()\\n\", __func__);\n}"
  },
  {
    "function_name": "layed_wbuf_sync(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1160-1169",
    "snippet": "atic void delayed_wbuf_sync(struct work_struct *work)\n{\n\tstruct jffs2_sb_info *c = work_to_sb(work);\n\tstruct super_block *sb = OFNI_BS_2SFFJ(c);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tjffs2_dbg(1, \"%s()\\n\", __func__);\n\t\tjffs2_flush_wbuf_gc(c, 0);\n\t}\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_flush_wbuf_gc(c",
          "args": [
            ";"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s()\\n\",",
            "func__);"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NI_BS_2SFFJ(c",
          "args": [
            ";"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rk_to_sb(w",
          "args": [
            "rk);"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void delayed_wbuf_sync(struct work_struct *work)\n{\n\tstruct jffs2_sb_info *c = work_to_sb(work);\n\tstruct super_block *sb = OFNI_BS_2SFFJ(c);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tjffs2_dbg(1, \"%s()\\n\", __func__);\n\t\tjffs2_flush_wbuf_gc(c, 0);\n\t}\n}"
  },
  {
    "function_name": "rk_to_sb(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1152-1158",
    "snippet": "atic struct jffs2_sb_info *work_to_sb(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\n\tdwork = container_of(work, struct delayed_work, work);\n\treturn container_of(dwork, struct jffs2_sb_info, wbuf_dwork);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntainer_of(d",
          "args": [
            "ork,",
            "ruct jfs2_sb_info,",
            "uf_dwork);"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntainer_of(w",
          "args": [
            "rk,",
            "ruct dlayed_work,",
            "rk);"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic struct jffs2_sb_info *work_to_sb(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\n\tdwork = container_of(work, struct delayed_work, work);\n\treturn container_of(dwork, struct jffs2_sb_info, wbuf_dwork);\n}"
  },
  {
    "function_name": "fs2_write_nand_badblock(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1133-1150",
    "snippet": "t jffs2_write_nand_badblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)\n{\n\tint \tret;\n\n\t/* if the count is < max, we try to write the counter to the 2nd page oob area */\n\tif( ++jeb->bad_count < MAX_ERASE_FAILURES)\n\t\treturn 0;\n\n\tpr_warn(\"marking eraseblock at %08x as bad\\n\", bad_offset);\n\tret = mtd_block_markbad(c->mtd, bad_offset);\n\n\tif (ret) {\n\t\tjffs2_dbg(1, \"%s(): Write failed for block at %08x: error %d\\n\",\n\t\t\t  __func__, jeb->offset, ret);\n\t\treturn ret;\n\t}\n\treturn 1;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): Write failed for block at %08x: error %d\\n\",",
            "func__,",
            "b->offset,",
            "t);"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_block_markbad(c",
          "args": [
            ">mtd,",
            "d_offset);"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "arking eraseblock at %08x as bad\\n\",",
            "d_offset);"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_write_nand_badblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)\n{\n\tint \tret;\n\n\t/* if the count is < max, we try to write the counter to the 2nd page oob area */\n\tif( ++jeb->bad_count < MAX_ERASE_FAILURES)\n\t\treturn 0;\n\n\tpr_warn(\"marking eraseblock at %08x as bad\\n\", bad_offset);\n\tret = mtd_block_markbad(c->mtd, bad_offset);\n\n\tif (ret) {\n\t\tjffs2_dbg(1, \"%s(): Write failed for block at %08x: error %d\\n\",\n\t\t\t  __func__, jeb->offset, ret);\n\t\treturn ret;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "fs2_write_nand_cleanmarker(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1100-1123",
    "snippet": "t jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\tstruct mtd_oob_ops ops;\n\tint cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = cmlen;\n\tops.oobbuf = (uint8_t *)&oob_cleanmarker;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_write_oob(c->mtd, jeb->offset, &ops);\n\tif (ret || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot write OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic const struct jffs2_unknown_node oob_cleanmarker =\n{\n\t.magic = constant_cpu_to_je16(JFFS2_MAGIC_BITMASK),\n\t.nodetype = constant_cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\n\t.totlen = constant_cpu_to_je32(8)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_err(\"",
          "args": [
            "annot write OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",",
            "b->offset,",
            "s.ooblen,",
            "s.oobretlen,",
            "t);"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_write_oob(c",
          "args": [
            ">mtd,",
            "b->offset,",
            "ps);"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_t(i",
          "args": [
            "t,",
            ">oobavail,",
            "B_CM_SIZE);"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic const struct jffs2_unknown_node oob_cleanmarker =\n{\n\t.magic = constant_cpu_to_je16(JFFS2_MAGIC_BITMASK),\n\t.nodetype = constant_cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\n\t.totlen = constant_cpu_to_je32(8)\n};\n\nt jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\tstruct mtd_oob_ops ops;\n\tint cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = cmlen;\n\tops.oobbuf = (uint8_t *)&oob_cleanmarker;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_write_oob(c->mtd, jeb->offset, &ops);\n\tif (ret || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot write OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_check_nand_cleanmarker(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1076-1098",
    "snippet": "t jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb)\n{\n\tstruct mtd_oob_ops ops;\n\tint ret, cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = cmlen;\n\tops.oobbuf = c->oobbuf;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_read_oob(c->mtd, jeb->offset, &ops);\n\tif ((ret && !mtd_is_bitflip(ret)) || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret || mtd_is_bitflip(ret))\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\treturn !!memcmp(&oob_cleanmarker, c->oobbuf, cmlen);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic const struct jffs2_unknown_node oob_cleanmarker =\n{\n\t.magic = constant_cpu_to_je16(JFFS2_MAGIC_BITMASK),\n\t.nodetype = constant_cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\n\t.totlen = constant_cpu_to_je32(8)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcmp(&",
          "args": [
            "ob_cleanmarker,",
            ">oobbuf,",
            "len);"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_bitflip(r",
          "args": [
            "t))"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_err(\"",
          "args": [
            "annot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",",
            "b->offset,",
            "s.ooblen,",
            "s.oobretlen,",
            "t);"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_bitflip(r",
          "args": [
            "t))"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_read_oob(c",
          "args": [
            ">mtd,",
            "b->offset,",
            "ps);"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_t(i",
          "args": [
            "t,",
            ">oobavail,",
            "B_CM_SIZE);"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic const struct jffs2_unknown_node oob_cleanmarker =\n{\n\t.magic = constant_cpu_to_je16(JFFS2_MAGIC_BITMASK),\n\t.nodetype = constant_cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\n\t.totlen = constant_cpu_to_je32(8)\n};\n\nt jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb)\n{\n\tstruct mtd_oob_ops ops;\n\tint ret, cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = cmlen;\n\tops.oobbuf = c->oobbuf;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_read_oob(c->mtd, jeb->offset, &ops);\n\tif ((ret && !mtd_is_bitflip(ret)) || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret || mtd_is_bitflip(ret))\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\treturn !!memcmp(&oob_cleanmarker, c->oobbuf, cmlen);\n}"
  },
  {
    "function_name": "fs2_check_oob_empty(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "1033-1068",
    "snippet": "t jffs2_check_oob_empty(struct jffs2_sb_info *c,\n\t\t\t  struct jffs2_eraseblock *jeb, int mode)\n{\n\tint i, ret;\n\tint cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\tstruct mtd_oob_ops ops;\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = NR_OOB_SCAN_PAGES * c->oobavail;\n\tops.oobbuf = c->oobbuf;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_read_oob(c->mtd, jeb->offset, &ops);\n\tif ((ret && !mtd_is_bitflip(ret)) || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret || mtd_is_bitflip(ret))\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\tfor(i = 0; i < ops.ooblen; i++) {\n\t\tif (mode && i < cmlen)\n\t\t\t/* Yeah, we know about the cleanmarker */\n\t\t\tcontinue;\n\n\t\tif (ops.oobbuf[i] != 0xFF) {\n\t\t\tjffs2_dbg(2, \"Found %02x at %x in OOB for \"\n\t\t\t\t  \"%08x\\n\", ops.oobbuf[i], i, jeb->offset);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_dbg(2",
          "args": [
            "ound %02x at %x in OOB for \"\n\t\t\t\t  \"%08x\\n\",",
            "s.oobbuf[i],",
            "b->offset);"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_bitflip(r",
          "args": [
            "t))"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_err(\"",
          "args": [
            "annot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",",
            "b->offset,",
            "s.ooblen,",
            "s.oobretlen,",
            "t);"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_bitflip(r",
          "args": [
            "t))"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_read_oob(c",
          "args": [
            ">mtd,",
            "b->offset,",
            "ps);"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_t(i",
          "args": [
            "t,",
            ">oobavail,",
            "B_CM_SIZE);"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_check_oob_empty(struct jffs2_sb_info *c,\n\t\t\t  struct jffs2_eraseblock *jeb, int mode)\n{\n\tint i, ret;\n\tint cmlen = min_t(int, c->oobavail, OOB_CM_SIZE);\n\tstruct mtd_oob_ops ops;\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.ooblen = NR_OOB_SCAN_PAGES * c->oobavail;\n\tops.oobbuf = c->oobbuf;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\tops.datbuf = NULL;\n\n\tret = mtd_read_oob(c->mtd, jeb->offset, &ops);\n\tif ((ret && !mtd_is_bitflip(ret)) || ops.oobretlen != ops.ooblen) {\n\t\tpr_err(\"cannot read OOB for EB at %08x, requested %zd bytes, read %zd bytes, error %d\\n\",\n\t\t       jeb->offset, ops.ooblen, ops.oobretlen, ret);\n\t\tif (!ret || mtd_is_bitflip(ret))\n\t\t\tret = -EIO;\n\t\treturn ret;\n\t}\n\n\tfor(i = 0; i < ops.ooblen; i++) {\n\t\tif (mode && i < cmlen)\n\t\t\t/* Yeah, we know about the cleanmarker */\n\t\t\tcontinue;\n\n\t\tif (ops.oobbuf[i] != 0xFF) {\n\t\t\tjffs2_dbg(2, \"Found %02x at %x in OOB for \"\n\t\t\t\t  \"%08x\\n\", ops.oobbuf[i], i, jeb->offset);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_flash_read(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "957-1015",
    "snippet": "t jffs2_flash_read(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, u_char *buf)\n{\n\tloff_t\torbf = 0, owbf = 0, lwbf = 0;\n\tint\tret;\n\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn mtd_read(c->mtd, ofs, len, retlen, buf);\n\n\t/* Read flash */\n\tdown_read(&c->wbuf_sem);\n\tret = mtd_read(c->mtd, ofs, len, retlen, buf);\n\n\tif ( (ret == -EBADMSG || ret == -EUCLEAN) && (*retlen == len) ) {\n\t\tif (ret == -EBADMSG)\n\t\t\tpr_warn(\"mtd->read(0x%zx bytes from 0x%llx) returned ECC error\\n\",\n\t\t\t\tlen, ofs);\n\t\t/*\n\t\t * We have the raw data without ECC correction in the buffer,\n\t\t * maybe we are lucky and all data or parts are correct. We\n\t\t * check the node.  If data are corrupted node check will sort\n\t\t * it out.  We keep this block, it will fail on write or erase\n\t\t * and the we mark it bad. Or should we do that now? But we\n\t\t * should give him a chance.  Maybe we had a system crash or\n\t\t * power loss before the ecc write or a erase was completed.\n\t\t * So we return success. :)\n\t\t */\n\t\tret = 0;\n\t}\n\n\t/* if no writebuffer available or write buffer empty, return */\n\tif (!c->wbuf_pagesize || !c->wbuf_len)\n\t\tgoto exit;\n\n\t/* if we read in a different block, return */\n\tif (SECTOR_ADDR(ofs) != SECTOR_ADDR(c->wbuf_ofs))\n\t\tgoto exit;\n\n\tif (ofs >= c->wbuf_ofs) {\n\t\towbf = (ofs - c->wbuf_ofs);\t/* offset in write buffer */\n\t\tif (owbf > c->wbuf_len)\t\t/* is read beyond write buffer ? */\n\t\t\tgoto exit;\n\t\tlwbf = c->wbuf_len - owbf;\t/* number of bytes to copy */\n\t\tif (lwbf > len)\n\t\t\tlwbf = len;\n\t} else {\n\t\torbf = (c->wbuf_ofs - ofs);\t/* offset in read buffer */\n\t\tif (orbf > len)\t\t\t/* is write beyond write buffer ? */\n\t\t\tgoto exit;\n\t\tlwbf = len - orbf;\t\t/* number of bytes to copy */\n\t\tif (lwbf > c->wbuf_len)\n\t\t\tlwbf = c->wbuf_len;\n\t}\n\tif (lwbf > 0)\n\t\tmemcpy(buf+orbf,c->wbuf+owbf,lwbf);\n\nexit:\n\tup_read(&c->wbuf_sem);\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_read(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcpy(b",
          "args": [
            "f+orbf,c",
            ">wbuf+owbf,l",
            "bf);"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTOR_ADDR(c",
          "args": [
            ">wbuf_ofs))"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTOR_ADDR(o",
          "args": [
            "s)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "td->read(0x%zx bytes from 0x%llx) returned ECC error\\n\",",
            "n,",
            "s);"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_read(c",
          "args": [
            ">mtd,",
            "s,",
            "n,",
            "tlen,",
            "f);"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wn_read(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_read(c",
          "args": [
            ">mtd,",
            "s,",
            "n,",
            "tlen,",
            "f);"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_is_writebuffered(c",
          "args": [
            ")"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_flash_read(struct jffs2_sb_info *c, loff_t ofs, size_t len, size_t *retlen, u_char *buf)\n{\n\tloff_t\torbf = 0, owbf = 0, lwbf = 0;\n\tint\tret;\n\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn mtd_read(c->mtd, ofs, len, retlen, buf);\n\n\t/* Read flash */\n\tdown_read(&c->wbuf_sem);\n\tret = mtd_read(c->mtd, ofs, len, retlen, buf);\n\n\tif ( (ret == -EBADMSG || ret == -EUCLEAN) && (*retlen == len) ) {\n\t\tif (ret == -EBADMSG)\n\t\t\tpr_warn(\"mtd->read(0x%zx bytes from 0x%llx) returned ECC error\\n\",\n\t\t\t\tlen, ofs);\n\t\t/*\n\t\t * We have the raw data without ECC correction in the buffer,\n\t\t * maybe we are lucky and all data or parts are correct. We\n\t\t * check the node.  If data are corrupted node check will sort\n\t\t * it out.  We keep this block, it will fail on write or erase\n\t\t * and the we mark it bad. Or should we do that now? But we\n\t\t * should give him a chance.  Maybe we had a system crash or\n\t\t * power loss before the ecc write or a erase was completed.\n\t\t * So we return success. :)\n\t\t */\n\t\tret = 0;\n\t}\n\n\t/* if no writebuffer available or write buffer empty, return */\n\tif (!c->wbuf_pagesize || !c->wbuf_len)\n\t\tgoto exit;\n\n\t/* if we read in a different block, return */\n\tif (SECTOR_ADDR(ofs) != SECTOR_ADDR(c->wbuf_ofs))\n\t\tgoto exit;\n\n\tif (ofs >= c->wbuf_ofs) {\n\t\towbf = (ofs - c->wbuf_ofs);\t/* offset in write buffer */\n\t\tif (owbf > c->wbuf_len)\t\t/* is read beyond write buffer ? */\n\t\t\tgoto exit;\n\t\tlwbf = c->wbuf_len - owbf;\t/* number of bytes to copy */\n\t\tif (lwbf > len)\n\t\t\tlwbf = len;\n\t} else {\n\t\torbf = (c->wbuf_ofs - ofs);\t/* offset in read buffer */\n\t\tif (orbf > len)\t\t\t/* is write beyond write buffer ? */\n\t\t\tgoto exit;\n\t\tlwbf = len - orbf;\t\t/* number of bytes to copy */\n\t\tif (lwbf > c->wbuf_len)\n\t\t\tlwbf = c->wbuf_len;\n\t}\n\tif (lwbf > 0)\n\t\tmemcpy(buf+orbf,c->wbuf+owbf,lwbf);\n\nexit:\n\tup_read(&c->wbuf_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_flash_write(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "941-952",
    "snippet": "t jffs2_flash_write(struct jffs2_sb_info *c, loff_t ofs, size_t len,\n\t\t      size_t *retlen, const u_char *buf)\n{\n\tstruct kvec vecs[1];\n\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn jffs2_flash_direct_write(c, ofs, len, retlen, buf);\n\n\tvecs[0].iov_base = (unsigned char *) buf;\n\tvecs[0].iov_len = len;\n\treturn jffs2_flash_writev(c, vecs, 1, ofs, retlen, 0);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_flash_writev(c",
          "args": [
            "cs,",
            "s,",
            "tlen,",
            ";"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_direct_write(c",
          "args": [
            "s,",
            "n,",
            "tlen,",
            "f);"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_is_writebuffered(c",
          "args": [
            ")"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_flash_write(struct jffs2_sb_info *c, loff_t ofs, size_t len,\n\t\t      size_t *retlen, const u_char *buf)\n{\n\tstruct kvec vecs[1];\n\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn jffs2_flash_direct_write(c, ofs, len, retlen, buf);\n\n\tvecs[0].iov_base = (unsigned char *) buf;\n\tvecs[0].iov_len = len;\n\treturn jffs2_flash_writev(c, vecs, 1, ofs, retlen, 0);\n}"
  },
  {
    "function_name": "fs2_flash_writev(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "794-935",
    "snippet": "t jffs2_flash_writev(struct jffs2_sb_info *c, const struct kvec *invecs,\n\t\t       unsigned long count, loff_t to, size_t *retlen,\n\t\t       uint32_t ino)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tsize_t wbuf_retlen, donelen = 0;\n\tuint32_t outvec_to = to;\n\tint ret, invec;\n\n\t/* If not writebuffered flash, don't bother */\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn jffs2_flash_direct_writev(c, invecs, count, to, retlen);\n\n\tdown_write(&c->wbuf_sem);\n\n\t/* If wbuf_ofs is not initialized, set it to target address */\n\tif (c->wbuf_ofs == 0xFFFFFFFF) {\n\t\tc->wbuf_ofs = PAGE_DIV(to);\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t\tmemset(c->wbuf,0xff,c->wbuf_pagesize);\n\t}\n\n\t/*\n\t * Sanity checks on target address.  It's permitted to write\n\t * at PAD(c->wbuf_len+c->wbuf_ofs), and it's permitted to\n\t * write at the beginning of a new erase block. Anything else,\n\t * and you die.  New block starts at xxx000c (0-b = block\n\t * header)\n\t */\n\tif (SECTOR_ADDR(to) != SECTOR_ADDR(c->wbuf_ofs)) {\n\t\t/* It's a write to a new block */\n\t\tif (c->wbuf_len) {\n\t\t\tjffs2_dbg(1, \"%s(): to 0x%lx causes flush of wbuf at 0x%08x\\n\",\n\t\t\t\t  __func__, (unsigned long)to, c->wbuf_ofs);\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t\t/* set pointer to new block */\n\t\tc->wbuf_ofs = PAGE_DIV(to);\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t}\n\n\tif (to != PAD(c->wbuf_ofs + c->wbuf_len)) {\n\t\t/* We're not writing immediately after the writebuffer. Bad. */\n\t\tpr_crit(\"%s(): Non-contiguous write to %08lx\\n\",\n\t\t\t__func__, (unsigned long)to);\n\t\tif (c->wbuf_len)\n\t\t\tpr_crit(\"wbuf was previously %08x-%08x\\n\",\n\t\t\t\tc->wbuf_ofs, c->wbuf_ofs + c->wbuf_len);\n\t\tBUG();\n\t}\n\n\t/* adjust alignment offset */\n\tif (c->wbuf_len != PAGE_MOD(to)) {\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t\t/* take care of alignment to next page */\n\t\tif (!c->wbuf_len) {\n\t\t\tc->wbuf_len = c->wbuf_pagesize;\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t}\n\n\tfor (invec = 0; invec < count; invec++) {\n\t\tint vlen = invecs[invec].iov_len;\n\t\tuint8_t *v = invecs[invec].iov_base;\n\n\t\twbuf_retlen = jffs2_fill_wbuf(c, v, vlen);\n\n\t\tif (c->wbuf_len == c->wbuf_pagesize) {\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t\tvlen -= wbuf_retlen;\n\t\toutvec_to += wbuf_retlen;\n\t\tdonelen += wbuf_retlen;\n\t\tv += wbuf_retlen;\n\n\t\tif (vlen >= c->wbuf_pagesize) {\n\t\t\tret = mtd_write(c->mtd, outvec_to, PAGE_DIV(vlen),\n\t\t\t\t\t&wbuf_retlen, v);\n\t\t\tif (ret < 0 || wbuf_retlen != PAGE_DIV(vlen))\n\t\t\t\tgoto outfile;\n\n\t\t\tvlen -= wbuf_retlen;\n\t\t\toutvec_to += wbuf_retlen;\n\t\t\tc->wbuf_ofs = outvec_to;\n\t\t\tdonelen += wbuf_retlen;\n\t\t\tv += wbuf_retlen;\n\t\t}\n\n\t\twbuf_retlen = jffs2_fill_wbuf(c, v, vlen);\n\t\tif (c->wbuf_len == c->wbuf_pagesize) {\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\n\t\toutvec_to += wbuf_retlen;\n\t\tdonelen += wbuf_retlen;\n\t}\n\n\t/*\n\t * If there's a remainder in the wbuf and it's a non-GC write,\n\t * remember that the wbuf affects this ino\n\t */\n\t*retlen = donelen;\n\n\tif (jffs2_sum_active()) {\n\t\tint res = jffs2_sum_add_kvec(c, invecs, count, (uint32_t) to);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (c->wbuf_len && ino)\n\t\tjffs2_wbuf_dirties_inode(c, ino);\n\n\tret = 0;\n\tup_write(&c->wbuf_sem);\n\treturn ret;\n\noutfile:\n\t/*\n\t * At this point we have no problem, c->wbuf is empty. However\n\t * refile nextblock to avoid writing again to same address.\n\t */\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tjeb = &c->blocks[outvec_to / c->sector_size];\n\tjffs2_block_refile(c, jeb, REFILE_ANYWAY);\n\n\tspin_unlock(&c->erase_completion_lock);\n\nouterr:\n\t*retlen = 0;\n\tup_write(&c->wbuf_sem);\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_block_refile(c",
          "args": [
            "b,",
            "FILE_ANYWAY);"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_wbuf_dirties_inode(c",
          "args": [
            "o);"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_sum_add_kvec(c",
          "args": [
            "vecs,",
            "unt,",
            "int32_t) to);"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_sum_active()",
          "args": [],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "PAD);"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_fill_wbuf(c",
          "args": [
            "en);"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GE_DIV(v",
          "args": [
            "en))"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_write(c",
          "args": [
            ">mtd,",
            "tvec_to,",
            "GE_DIV(vlen),",
            "buf_retlen,",
            ";"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GE_DIV(v",
          "args": [
            "en),"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "PAD);"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_fill_wbuf(c",
          "args": [
            "en);"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "PAD);"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GE_MOD(t",
          "args": [
            ");"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GE_MOD(t",
          "args": [
            "))"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "buf was previously %08x-%08x\\n\",",
            ">wbuf_ofs,",
            ">wbuf_ofs + c->wbuf_len);"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "s(): Non-contiguous write to %08lx\\n\",",
            "func__,",
            "nsigned long)to);"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(c",
          "args": [
            ">wbuf_ofs + c->wbuf_len))"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GE_MOD(t",
          "args": [
            ");"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GE_DIV(t",
          "args": [
            ");"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "D_NOACCOUNT);"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): to 0x%lx causes flush of wbuf at 0x%08x\\n\",",
            "func__,",
            "nsigned long)to,",
            ">wbuf_ofs);"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTOR_ADDR(c",
          "args": [
            ">wbuf_ofs))"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTOR_ADDR(t",
          "args": [
            ")"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mset(c",
          "args": [
            ">wbuf,0",
            "ff,c",
            ">wbuf_pagesize);"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GE_MOD(t",
          "args": [
            ");"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GE_DIV(t",
          "args": [
            ");"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wn_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_direct_writev(c",
          "args": [
            "vecs,",
            "unt,",
            ",",
            "tlen);"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_is_writebuffered(c",
          "args": [
            ")"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_flash_writev(struct jffs2_sb_info *c, const struct kvec *invecs,\n\t\t       unsigned long count, loff_t to, size_t *retlen,\n\t\t       uint32_t ino)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tsize_t wbuf_retlen, donelen = 0;\n\tuint32_t outvec_to = to;\n\tint ret, invec;\n\n\t/* If not writebuffered flash, don't bother */\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn jffs2_flash_direct_writev(c, invecs, count, to, retlen);\n\n\tdown_write(&c->wbuf_sem);\n\n\t/* If wbuf_ofs is not initialized, set it to target address */\n\tif (c->wbuf_ofs == 0xFFFFFFFF) {\n\t\tc->wbuf_ofs = PAGE_DIV(to);\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t\tmemset(c->wbuf,0xff,c->wbuf_pagesize);\n\t}\n\n\t/*\n\t * Sanity checks on target address.  It's permitted to write\n\t * at PAD(c->wbuf_len+c->wbuf_ofs), and it's permitted to\n\t * write at the beginning of a new erase block. Anything else,\n\t * and you die.  New block starts at xxx000c (0-b = block\n\t * header)\n\t */\n\tif (SECTOR_ADDR(to) != SECTOR_ADDR(c->wbuf_ofs)) {\n\t\t/* It's a write to a new block */\n\t\tif (c->wbuf_len) {\n\t\t\tjffs2_dbg(1, \"%s(): to 0x%lx causes flush of wbuf at 0x%08x\\n\",\n\t\t\t\t  __func__, (unsigned long)to, c->wbuf_ofs);\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t\t/* set pointer to new block */\n\t\tc->wbuf_ofs = PAGE_DIV(to);\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t}\n\n\tif (to != PAD(c->wbuf_ofs + c->wbuf_len)) {\n\t\t/* We're not writing immediately after the writebuffer. Bad. */\n\t\tpr_crit(\"%s(): Non-contiguous write to %08lx\\n\",\n\t\t\t__func__, (unsigned long)to);\n\t\tif (c->wbuf_len)\n\t\t\tpr_crit(\"wbuf was previously %08x-%08x\\n\",\n\t\t\t\tc->wbuf_ofs, c->wbuf_ofs + c->wbuf_len);\n\t\tBUG();\n\t}\n\n\t/* adjust alignment offset */\n\tif (c->wbuf_len != PAGE_MOD(to)) {\n\t\tc->wbuf_len = PAGE_MOD(to);\n\t\t/* take care of alignment to next page */\n\t\tif (!c->wbuf_len) {\n\t\t\tc->wbuf_len = c->wbuf_pagesize;\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t}\n\n\tfor (invec = 0; invec < count; invec++) {\n\t\tint vlen = invecs[invec].iov_len;\n\t\tuint8_t *v = invecs[invec].iov_base;\n\n\t\twbuf_retlen = jffs2_fill_wbuf(c, v, vlen);\n\n\t\tif (c->wbuf_len == c->wbuf_pagesize) {\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\t\tvlen -= wbuf_retlen;\n\t\toutvec_to += wbuf_retlen;\n\t\tdonelen += wbuf_retlen;\n\t\tv += wbuf_retlen;\n\n\t\tif (vlen >= c->wbuf_pagesize) {\n\t\t\tret = mtd_write(c->mtd, outvec_to, PAGE_DIV(vlen),\n\t\t\t\t\t&wbuf_retlen, v);\n\t\t\tif (ret < 0 || wbuf_retlen != PAGE_DIV(vlen))\n\t\t\t\tgoto outfile;\n\n\t\t\tvlen -= wbuf_retlen;\n\t\t\toutvec_to += wbuf_retlen;\n\t\t\tc->wbuf_ofs = outvec_to;\n\t\t\tdonelen += wbuf_retlen;\n\t\t\tv += wbuf_retlen;\n\t\t}\n\n\t\twbuf_retlen = jffs2_fill_wbuf(c, v, vlen);\n\t\tif (c->wbuf_len == c->wbuf_pagesize) {\n\t\t\tret = __jffs2_flush_wbuf(c, NOPAD);\n\t\t\tif (ret)\n\t\t\t\tgoto outerr;\n\t\t}\n\n\t\toutvec_to += wbuf_retlen;\n\t\tdonelen += wbuf_retlen;\n\t}\n\n\t/*\n\t * If there's a remainder in the wbuf and it's a non-GC write,\n\t * remember that the wbuf affects this ino\n\t */\n\t*retlen = donelen;\n\n\tif (jffs2_sum_active()) {\n\t\tint res = jffs2_sum_add_kvec(c, invecs, count, (uint32_t) to);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (c->wbuf_len && ino)\n\t\tjffs2_wbuf_dirties_inode(c, ino);\n\n\tret = 0;\n\tup_write(&c->wbuf_sem);\n\treturn ret;\n\noutfile:\n\t/*\n\t * At this point we have no problem, c->wbuf is empty. However\n\t * refile nextblock to avoid writing again to same address.\n\t */\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tjeb = &c->blocks[outvec_to / c->sector_size];\n\tjffs2_block_refile(c, jeb, REFILE_ANYWAY);\n\n\tspin_unlock(&c->erase_completion_lock);\n\nouterr:\n\t*retlen = 0;\n\tup_write(&c->wbuf_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_fill_wbuf(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "781-792",
    "snippet": "atic size_t jffs2_fill_wbuf(struct jffs2_sb_info *c, const uint8_t *buf,\n\t\t\t      size_t len)\n{\n\tif (len && !c->wbuf_len && (len >= c->wbuf_pagesize))\n\t\treturn 0;\n\n\tif (len > (c->wbuf_pagesize - c->wbuf_len))\n\t\tlen = c->wbuf_pagesize - c->wbuf_len;\n\tmemcpy(c->wbuf + c->wbuf_len, buf, len);\n\tc->wbuf_len += (uint32_t) len;\n\treturn len;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcpy(c",
          "args": [
            ">wbuf + c->wbuf_len,",
            "f,",
            "n);"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic size_t jffs2_fill_wbuf(struct jffs2_sb_info *c, const uint8_t *buf,\n\t\t\t      size_t len)\n{\n\tif (len && !c->wbuf_len && (len >= c->wbuf_pagesize))\n\t\treturn 0;\n\n\tif (len > (c->wbuf_pagesize - c->wbuf_len))\n\t\tlen = c->wbuf_pagesize - c->wbuf_len;\n\tmemcpy(c->wbuf + c->wbuf_len, buf, len);\n\tc->wbuf_len += (uint32_t) len;\n\treturn len;\n}"
  },
  {
    "function_name": "fs2_flush_wbuf_pad(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "764-779",
    "snippet": "t jffs2_flush_wbuf_pad(struct jffs2_sb_info *c)\n{\n\tint ret;\n\n\tif (!c->wbuf)\n\t\treturn 0;\n\n\tdown_write(&c->wbuf_sem);\n\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\t/* retry - maybe wbuf recover left some data in wbuf. */\n\tif (ret)\n\t\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\tup_write(&c->wbuf_sem);\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "D_NOACCOUNT);"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "D_NOACCOUNT);"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wn_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_flush_wbuf_pad(struct jffs2_sb_info *c)\n{\n\tint ret;\n\n\tif (!c->wbuf)\n\t\treturn 0;\n\n\tdown_write(&c->wbuf_sem);\n\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\t/* retry - maybe wbuf recover left some data in wbuf. */\n\tif (ret)\n\t\tret = __jffs2_flush_wbuf(c, PAD_NOACCOUNT);\n\tup_write(&c->wbuf_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_flush_wbuf_gc(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "702-761",
    "snippet": "t jffs2_flush_wbuf_gc(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tuint32_t old_wbuf_ofs;\n\tuint32_t old_wbuf_len;\n\tint ret = 0;\n\n\tjffs2_dbg(1, \"jffs2_flush_wbuf_gc() called for ino #%u...\\n\", ino);\n\n\tif (!c->wbuf)\n\t\treturn 0;\n\n\tmutex_lock(&c->alloc_sem);\n\tif (!jffs2_wbuf_pending_for_ino(c, ino)) {\n\t\tjffs2_dbg(1, \"Ino #%d not pending in wbuf. Returning\\n\", ino);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn 0;\n\t}\n\n\told_wbuf_ofs = c->wbuf_ofs;\n\told_wbuf_len = c->wbuf_len;\n\n\tif (c->unchecked_size) {\n\t\t/* GC won't make any progress for a while */\n\t\tjffs2_dbg(1, \"%s(): padding. Not finished checking\\n\",\n\t\t\t  __func__);\n\t\tdown_write(&c->wbuf_sem);\n\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t/* retry flushing wbuf in case jffs2_wbuf_recover\n\t\t   left some data in the wbuf */\n\t\tif (ret)\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\tup_write(&c->wbuf_sem);\n\t} else while (old_wbuf_len &&\n\t\t      old_wbuf_ofs == c->wbuf_ofs) {\n\n\t\tmutex_unlock(&c->alloc_sem);\n\n\t\tjffs2_dbg(1, \"%s(): calls gc pass\\n\", __func__);\n\n\t\tret = jffs2_garbage_collect_pass(c);\n\t\tif (ret) {\n\t\t\t/* GC failed. Flush it with padding instead */\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tdown_write(&c->wbuf_sem);\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t\t/* retry flushing wbuf in case jffs2_wbuf_recover\n\t\t\t   left some data in the wbuf */\n\t\t\tif (ret)\n\t\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t\tup_write(&c->wbuf_sem);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_lock(&c->alloc_sem);\n\t}\n\n\tjffs2_dbg(1, \"%s(): ends...\\n\", __func__);\n\n\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): ends...\\n\",",
            "func__);"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "D_ACCOUNTING);"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "D_ACCOUNTING);"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wn_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_pass(c",
          "args": [
            ";"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): calls gc pass\\n\",",
            "func__);"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "D_ACCOUNTING);"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jffs2_flush_wbuf(c",
          "args": [
            "D_ACCOUNTING);"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wn_write(&",
          "args": [
            "->wbuf_sem);"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): padding. Not finished checking\\n\",",
            "func__);"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "no #%d not pending in wbuf. Returning\\n\",",
            "o);"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_wbuf_pending_for_ino(c",
          "args": [
            "o))"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ffs2_flush_wbuf_gc() called for ino #%u...\\n\",",
            "o);"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nt jffs2_flush_wbuf_gc(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tuint32_t old_wbuf_ofs;\n\tuint32_t old_wbuf_len;\n\tint ret = 0;\n\n\tjffs2_dbg(1, \"jffs2_flush_wbuf_gc() called for ino #%u...\\n\", ino);\n\n\tif (!c->wbuf)\n\t\treturn 0;\n\n\tmutex_lock(&c->alloc_sem);\n\tif (!jffs2_wbuf_pending_for_ino(c, ino)) {\n\t\tjffs2_dbg(1, \"Ino #%d not pending in wbuf. Returning\\n\", ino);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn 0;\n\t}\n\n\told_wbuf_ofs = c->wbuf_ofs;\n\told_wbuf_len = c->wbuf_len;\n\n\tif (c->unchecked_size) {\n\t\t/* GC won't make any progress for a while */\n\t\tjffs2_dbg(1, \"%s(): padding. Not finished checking\\n\",\n\t\t\t  __func__);\n\t\tdown_write(&c->wbuf_sem);\n\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t/* retry flushing wbuf in case jffs2_wbuf_recover\n\t\t   left some data in the wbuf */\n\t\tif (ret)\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\tup_write(&c->wbuf_sem);\n\t} else while (old_wbuf_len &&\n\t\t      old_wbuf_ofs == c->wbuf_ofs) {\n\n\t\tmutex_unlock(&c->alloc_sem);\n\n\t\tjffs2_dbg(1, \"%s(): calls gc pass\\n\", __func__);\n\n\t\tret = jffs2_garbage_collect_pass(c);\n\t\tif (ret) {\n\t\t\t/* GC failed. Flush it with padding instead */\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tdown_write(&c->wbuf_sem);\n\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t\t/* retry flushing wbuf in case jffs2_wbuf_recover\n\t\t\t   left some data in the wbuf */\n\t\t\tif (ret)\n\t\t\t\tret = __jffs2_flush_wbuf(c, PAD_ACCOUNTING);\n\t\t\tup_write(&c->wbuf_sem);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_lock(&c->alloc_sem);\n\t}\n\n\tjffs2_dbg(1, \"%s(): ends...\\n\", __func__);\n\n\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "jffs2_flush_wbuf(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "580-696",
    "snippet": "atic int __jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)\n{\n\tstruct jffs2_eraseblock *wbuf_jeb;\n\tint ret;\n\tsize_t retlen;\n\n\t/* Nothing to do if not write-buffering the flash. In particular, we shouldn't\n\t   del_timer() the timer we never initialised. */\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn 0;\n\n\tif (!mutex_is_locked(&c->alloc_sem)) {\n\t\tpr_crit(\"jffs2_flush_wbuf() called with alloc_sem not locked!\\n\");\n\t\tBUG();\n\t}\n\n\tif (!c->wbuf_len)\t/* already checked c->wbuf above */\n\t\treturn 0;\n\n\twbuf_jeb = &c->blocks[c->wbuf_ofs / c->sector_size];\n\tif (jffs2_prealloc_raw_node_refs(c, wbuf_jeb, c->nextblock->allocated_refs + 1))\n\t\treturn -ENOMEM;\n\n\t/* claim remaining space on the page\n\t   this happens, if we have a change to a new block,\n\t   or if fsync forces us to flush the writebuffer.\n\t   if we have a switch to next page, we will not have\n\t   enough remaining space for this.\n\t*/\n\tif (pad ) {\n\t\tc->wbuf_len = PAD(c->wbuf_len);\n\n\t\t/* Pad with JFFS2_DIRTY_BITMASK initially.  this helps out ECC'd NOR\n\t\t   with 8 byte page size */\n\t\tmemset(c->wbuf + c->wbuf_len, 0, c->wbuf_pagesize - c->wbuf_len);\n\n\t\tif ( c->wbuf_len + sizeof(struct jffs2_unknown_node) < c->wbuf_pagesize) {\n\t\t\tstruct jffs2_unknown_node *padnode = (void *)(c->wbuf + c->wbuf_len);\n\t\t\tpadnode->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\t\tpadnode->nodetype = cpu_to_je16(JFFS2_NODETYPE_PADDING);\n\t\t\tpadnode->totlen = cpu_to_je32(c->wbuf_pagesize - c->wbuf_len);\n\t\t\tpadnode->hdr_crc = cpu_to_je32(crc32(0, padnode, sizeof(*padnode)-4));\n\t\t}\n\t}\n\t/* else jffs2_flash_writev has actually filled in the rest of the\n\t   buffer for us, and will deal with the node refs etc. later. */\n\n#ifdef BREAKME\n\tstatic int breakme;\n\tif (breakme++ == 20) {\n\t\tpr_notice(\"Faking write error at 0x%08x\\n\", c->wbuf_ofs);\n\t\tbreakme = 0;\n\t\tmtd_write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize, &retlen,\n\t\t\t  brokenbuf);\n\t\tret = -EIO;\n\t} else\n#endif\n\n\t\tret = mtd_write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize,\n\t\t\t\t&retlen, c->wbuf);\n\n\tif (ret) {\n\t\tpr_warn(\"jffs2_flush_wbuf(): Write failed with %d\\n\", ret);\n\t\tgoto wfail;\n\t} else if (retlen != c->wbuf_pagesize) {\n\t\tpr_warn(\"jffs2_flush_wbuf(): Write was short: %zd instead of %d\\n\",\n\t\t\tretlen, c->wbuf_pagesize);\n\t\tret = -EIO;\n\t\tgoto wfail;\n\t} else if ((ret = jffs2_verify_write(c, c->wbuf, c->wbuf_ofs))) {\n\twfail:\n\t\tjffs2_wbuf_recover(c);\n\n\t\treturn ret;\n\t}\n\n\t/* Adjust free size of the block if we padded. */\n\tif (pad) {\n\t\tuint32_t waste = c->wbuf_pagesize - c->wbuf_len;\n\n\t\tjffs2_dbg(1, \"jffs2_flush_wbuf() adjusting free_size of %sblock at %08x\\n\",\n\t\t\t  (wbuf_jeb == c->nextblock) ? \"next\" : \"\",\n\t\t\t  wbuf_jeb->offset);\n\n\t\t/* wbuf_pagesize - wbuf_len is the amount of space that's to be\n\t\t   padded. If there is less free space in the block than that,\n\t\t   something screwed up */\n\t\tif (wbuf_jeb->free_size < waste) {\n\t\t\tpr_crit(\"jffs2_flush_wbuf(): Accounting error. wbuf at 0x%08x has 0x%03x bytes, 0x%03x left.\\n\",\n\t\t\t\tc->wbuf_ofs, c->wbuf_len, waste);\n\t\t\tpr_crit(\"jffs2_flush_wbuf(): But free_size for block at 0x%08x is only 0x%08x\\n\",\n\t\t\t\twbuf_jeb->offset, wbuf_jeb->free_size);\n\t\t\tBUG();\n\t\t}\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tjffs2_link_node_ref(c, wbuf_jeb, (c->wbuf_ofs + c->wbuf_len) | REF_OBSOLETE, waste, NULL);\n\t\t/* FIXME: that made it count as dirty. Convert to wasted */\n\t\twbuf_jeb->dirty_size -= waste;\n\t\tc->dirty_size -= waste;\n\t\twbuf_jeb->wasted_size += waste;\n\t\tc->wasted_size += waste;\n\t} else\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t/* Stick any now-obsoleted blocks on the erase_pending_list */\n\tjffs2_refile_wbuf_blocks(c);\n\tjffs2_clear_wbuf_ino_list(c);\n\tspin_unlock(&c->erase_completion_lock);\n\n\tmemset(c->wbuf,0xff,c->wbuf_pagesize);\n\t/* adjust write buffer offset, else we get a non contiguous write bug */\n\tc->wbuf_ofs += c->wbuf_pagesize;\n\tc->wbuf_len = 0;\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mset(c",
          "args": [
            ">wbuf,0",
            "ff,c",
            ">wbuf_pagesize);"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_clear_wbuf_ino_list(c",
          "args": [
            ";"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_refile_wbuf_blocks(c",
          "args": [
            ";"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_link_node_ref(c",
          "args": [
            "uf_jeb,",
            "->wbuf_ofs + c->wbuf_len) | REF_OBSOLETE,",
            "ste,",
            "LL);"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "ffs2_flush_wbuf(): But free_size for block at 0x%08x is only 0x%08x\\n\",",
            "uf_jeb->offset,",
            "uf_jeb->free_size);"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "ffs2_flush_wbuf(): Accounting error. wbuf at 0x%08x has 0x%03x bytes, 0x%03x left.\\n\",",
            ">wbuf_ofs,",
            ">wbuf_len,",
            "ste);"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ffs2_flush_wbuf() adjusting free_size of %sblock at %08x\\n\",",
            "buf_jeb == c->nextblock) ? \"next\" : \"\",",
            "uf_jeb->offset);"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_wbuf_recover(c",
          "args": [
            ";"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_verify_write(c",
          "args": [
            ">wbuf,",
            ">wbuf_ofs))"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ffs2_flush_wbuf(): Write was short: %zd instead of %d\\n\",",
            "tlen,",
            ">wbuf_pagesize);"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ffs2_flush_wbuf(): Write failed with %d\\n\",",
            "t);"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_write(c",
          "args": [
            ">mtd,",
            ">wbuf_ofs,",
            ">wbuf_pagesize,",
            "etlen,",
            ">wbuf);"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_write(c",
          "args": [
            ">mtd,",
            ">wbuf_ofs,",
            ">wbuf_pagesize,",
            "etlen,",
            "okenbuf);"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "aking write error at 0x%08x\\n\",",
            ">wbuf_ofs);"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, padnode, sizeof(*padnode)-4));"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "dnode,",
            "zeof(*padnode)-4))"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            ">wbuf_pagesize - c->wbuf_len);"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_NODETYPE_PADDING);"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_MAGIC_BITMASK);"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mset(c",
          "args": [
            ">wbuf + c->wbuf_len,",
            ">wbuf_pagesize - c->wbuf_len);"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(c",
          "args": [
            ">wbuf_len);"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_prealloc_raw_node_refs(c",
          "args": [
            "uf_jeb,",
            ">nextblock->allocated_refs + 1))"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "ffs2_flush_wbuf() called with alloc_sem not locked!\\n\");"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_is_locked(&",
          "args": [
            "->alloc_sem))"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_is_writebuffered(c",
          "args": [
            ")"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int __jffs2_flush_wbuf(struct jffs2_sb_info *c, int pad)\n{\n\tstruct jffs2_eraseblock *wbuf_jeb;\n\tint ret;\n\tsize_t retlen;\n\n\t/* Nothing to do if not write-buffering the flash. In particular, we shouldn't\n\t   del_timer() the timer we never initialised. */\n\tif (!jffs2_is_writebuffered(c))\n\t\treturn 0;\n\n\tif (!mutex_is_locked(&c->alloc_sem)) {\n\t\tpr_crit(\"jffs2_flush_wbuf() called with alloc_sem not locked!\\n\");\n\t\tBUG();\n\t}\n\n\tif (!c->wbuf_len)\t/* already checked c->wbuf above */\n\t\treturn 0;\n\n\twbuf_jeb = &c->blocks[c->wbuf_ofs / c->sector_size];\n\tif (jffs2_prealloc_raw_node_refs(c, wbuf_jeb, c->nextblock->allocated_refs + 1))\n\t\treturn -ENOMEM;\n\n\t/* claim remaining space on the page\n\t   this happens, if we have a change to a new block,\n\t   or if fsync forces us to flush the writebuffer.\n\t   if we have a switch to next page, we will not have\n\t   enough remaining space for this.\n\t*/\n\tif (pad ) {\n\t\tc->wbuf_len = PAD(c->wbuf_len);\n\n\t\t/* Pad with JFFS2_DIRTY_BITMASK initially.  this helps out ECC'd NOR\n\t\t   with 8 byte page size */\n\t\tmemset(c->wbuf + c->wbuf_len, 0, c->wbuf_pagesize - c->wbuf_len);\n\n\t\tif ( c->wbuf_len + sizeof(struct jffs2_unknown_node) < c->wbuf_pagesize) {\n\t\t\tstruct jffs2_unknown_node *padnode = (void *)(c->wbuf + c->wbuf_len);\n\t\t\tpadnode->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\t\tpadnode->nodetype = cpu_to_je16(JFFS2_NODETYPE_PADDING);\n\t\t\tpadnode->totlen = cpu_to_je32(c->wbuf_pagesize - c->wbuf_len);\n\t\t\tpadnode->hdr_crc = cpu_to_je32(crc32(0, padnode, sizeof(*padnode)-4));\n\t\t}\n\t}\n\t/* else jffs2_flash_writev has actually filled in the rest of the\n\t   buffer for us, and will deal with the node refs etc. later. */\n\n#ifdef BREAKME\n\tstatic int breakme;\n\tif (breakme++ == 20) {\n\t\tpr_notice(\"Faking write error at 0x%08x\\n\", c->wbuf_ofs);\n\t\tbreakme = 0;\n\t\tmtd_write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize, &retlen,\n\t\t\t  brokenbuf);\n\t\tret = -EIO;\n\t} else\n#endif\n\n\t\tret = mtd_write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize,\n\t\t\t\t&retlen, c->wbuf);\n\n\tif (ret) {\n\t\tpr_warn(\"jffs2_flush_wbuf(): Write failed with %d\\n\", ret);\n\t\tgoto wfail;\n\t} else if (retlen != c->wbuf_pagesize) {\n\t\tpr_warn(\"jffs2_flush_wbuf(): Write was short: %zd instead of %d\\n\",\n\t\t\tretlen, c->wbuf_pagesize);\n\t\tret = -EIO;\n\t\tgoto wfail;\n\t} else if ((ret = jffs2_verify_write(c, c->wbuf, c->wbuf_ofs))) {\n\twfail:\n\t\tjffs2_wbuf_recover(c);\n\n\t\treturn ret;\n\t}\n\n\t/* Adjust free size of the block if we padded. */\n\tif (pad) {\n\t\tuint32_t waste = c->wbuf_pagesize - c->wbuf_len;\n\n\t\tjffs2_dbg(1, \"jffs2_flush_wbuf() adjusting free_size of %sblock at %08x\\n\",\n\t\t\t  (wbuf_jeb == c->nextblock) ? \"next\" : \"\",\n\t\t\t  wbuf_jeb->offset);\n\n\t\t/* wbuf_pagesize - wbuf_len is the amount of space that's to be\n\t\t   padded. If there is less free space in the block than that,\n\t\t   something screwed up */\n\t\tif (wbuf_jeb->free_size < waste) {\n\t\t\tpr_crit(\"jffs2_flush_wbuf(): Accounting error. wbuf at 0x%08x has 0x%03x bytes, 0x%03x left.\\n\",\n\t\t\t\tc->wbuf_ofs, c->wbuf_len, waste);\n\t\t\tpr_crit(\"jffs2_flush_wbuf(): But free_size for block at 0x%08x is only 0x%08x\\n\",\n\t\t\t\twbuf_jeb->offset, wbuf_jeb->free_size);\n\t\t\tBUG();\n\t\t}\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tjffs2_link_node_ref(c, wbuf_jeb, (c->wbuf_ofs + c->wbuf_len) | REF_OBSOLETE, waste, NULL);\n\t\t/* FIXME: that made it count as dirty. Convert to wasted */\n\t\twbuf_jeb->dirty_size -= waste;\n\t\tc->dirty_size -= waste;\n\t\twbuf_jeb->wasted_size += waste;\n\t\tc->wasted_size += waste;\n\t} else\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t/* Stick any now-obsoleted blocks on the erase_pending_list */\n\tjffs2_refile_wbuf_blocks(c);\n\tjffs2_clear_wbuf_ino_list(c);\n\tspin_unlock(&c->erase_completion_lock);\n\n\tmemset(c->wbuf,0xff,c->wbuf_pagesize);\n\t/* adjust write buffer offset, else we get a non contiguous write bug */\n\tc->wbuf_ofs += c->wbuf_pagesize;\n\tc->wbuf_len = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_wbuf_recover(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "275-569",
    "snippet": "atic void jffs2_wbuf_recover(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_eraseblock *jeb, *new_jeb;\n\tstruct jffs2_raw_node_ref *raw, *next, *first_raw = NULL;\n\tsize_t retlen;\n\tint ret;\n\tint nr_refile = 0;\n\tunsigned char *buf;\n\tuint32_t start, end, ofs, len;\n\n\tjeb = &c->blocks[c->wbuf_ofs / c->sector_size];\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (c->wbuf_ofs % c->mtd->erasesize)\n\t\tjffs2_block_refile(c, jeb, REFILE_NOTEMPTY);\n\telse\n\t\tjffs2_block_refile(c, jeb, REFILE_ANYWAY);\n\tspin_unlock(&c->erase_completion_lock);\n\n\tBUG_ON(!ref_obsolete(jeb->last_node));\n\n\t/* Find the first node to be recovered, by skipping over every\n\t   node which ends before the wbuf starts, or which is obsolete. */\n\tfor (next = raw = jeb->first_node; next; raw = next) {\n\t\tnext = ref_next(raw);\n\n\t\tif (ref_obsolete(raw) || \n\t\t    (next && ref_offset(next) <= c->wbuf_ofs)) {\n\t\t\tdbg_noderef(\"Skipping node at 0x%08x(%d)-0x%08x which is either before 0x%08x or obsolete\\n\",\n\t\t\t\t    ref_offset(raw), ref_flags(raw),\n\t\t\t\t    (ref_offset(raw) + ref_totlen(c, jeb, raw)),\n\t\t\t\t    c->wbuf_ofs);\n\t\t\tcontinue;\n\t\t}\n\t\tdbg_noderef(\"First node to be recovered is at 0x%08x(%d)-0x%08x\\n\",\n\t\t\t    ref_offset(raw), ref_flags(raw),\n\t\t\t    (ref_offset(raw) + ref_totlen(c, jeb, raw)));\n\n\t\tfirst_raw = raw;\n\t\tbreak;\n\t}\n\n\tif (!first_raw) {\n\t\t/* All nodes were obsolete. Nothing to recover. */\n\t\tjffs2_dbg(1, \"No non-obsolete nodes to be recovered. Just filing block bad\\n\");\n\t\tc->wbuf_len = 0;\n\t\treturn;\n\t}\n\n\tstart = ref_offset(first_raw);\n\tend = ref_offset(jeb->last_node);\n\tnr_refile = 1;\n\n\t/* Count the number of refs which need to be copied */\n\twhile ((raw = ref_next(raw)) != jeb->last_node)\n\t\tnr_refile++;\n\n\tdbg_noderef(\"wbuf recover %08x-%08x (%d bytes in %d nodes)\\n\",\n\t\t    start, end, end - start, nr_refile);\n\n\tbuf = NULL;\n\tif (start < c->wbuf_ofs) {\n\t\t/* First affected node was already partially written.\n\t\t * Attempt to reread the old data into our buffer. */\n\n\t\tbuf = kmalloc(end - start, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_crit(\"Malloc failure in wbuf recovery. Data loss ensues.\\n\");\n\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t/* Do the read... */\n\t\tret = mtd_read(c->mtd, start, c->wbuf_ofs - start, &retlen,\n\t\t\t       buf);\n\n\t\t/* ECC recovered ? */\n\t\tif ((ret == -EUCLEAN || ret == -EBADMSG) &&\n\t\t    (retlen == c->wbuf_ofs - start))\n\t\t\tret = 0;\n\n\t\tif (ret || retlen != c->wbuf_ofs - start) {\n\t\t\tpr_crit(\"Old data are already lost in wbuf recovery. Data loss ensues.\\n\");\n\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\tread_failed:\n\t\t\tfirst_raw = ref_next(first_raw);\n\t\t\tnr_refile--;\n\t\t\twhile (first_raw && ref_obsolete(first_raw)) {\n\t\t\t\tfirst_raw = ref_next(first_raw);\n\t\t\t\tnr_refile--;\n\t\t\t}\n\n\t\t\t/* If this was the only node to be recovered, give up */\n\t\t\tif (!first_raw) {\n\t\t\t\tc->wbuf_len = 0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* It wasn't. Go on and try to recover nodes complete in the wbuf */\n\t\t\tstart = ref_offset(first_raw);\n\t\t\tdbg_noderef(\"wbuf now recover %08x-%08x (%d bytes in %d nodes)\\n\",\n\t\t\t\t    start, end, end - start, nr_refile);\n\n\t\t} else {\n\t\t\t/* Read succeeded. Copy the remaining data from the wbuf */\n\t\t\tmemcpy(buf + (c->wbuf_ofs - start), c->wbuf, end - c->wbuf_ofs);\n\t\t}\n\t}\n\t/* OK... we're to rewrite (end-start) bytes of data from first_raw onwards.\n\t   Either 'buf' contains the data, or we find it in the wbuf */\n\n\t/* ... and get an allocation of space from a shiny new block instead */\n\tret = jffs2_reserve_space_gc(c, end-start, &len, JFFS2_SUMMARY_NOSUM_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate space for wbuf recovery. Data loss ensues.\\n\");\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\t/* The summary is not recovered, so it must be disabled for this erase block */\n\tjffs2_sum_disable_collecting(c->summary);\n\n\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, nr_refile);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate node refs for wbuf recovery. Data loss ensues.\\n\");\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tofs = write_ofs(c);\n\n\tif (end-start >= c->wbuf_pagesize) {\n\t\t/* Need to do another write immediately, but it's possible\n\t\t   that this is just because the wbuf itself is completely\n\t\t   full, and there's nothing earlier read back from the\n\t\t   flash. Hence 'buf' isn't necessarily what we're writing\n\t\t   from. */\n\t\tunsigned char *rewrite_buf = buf?:c->wbuf;\n\t\tuint32_t towrite = (end-start) - ((end-start)%c->wbuf_pagesize);\n\n\t\tjffs2_dbg(1, \"Write 0x%x bytes at 0x%08x in wbuf recover\\n\",\n\t\t\t  towrite, ofs);\n\n#ifdef BREAKMEHEADER\n\t\tstatic int breakme;\n\t\tif (breakme++ == 20) {\n\t\t\tpr_notice(\"Faking write error at 0x%08x\\n\", ofs);\n\t\t\tbreakme = 0;\n\t\t\tmtd_write(c->mtd, ofs, towrite, &retlen, brokenbuf);\n\t\t\tret = -EIO;\n\t\t} else\n#endif\n\t\t\tret = mtd_write(c->mtd, ofs, towrite, &retlen,\n\t\t\t\t\trewrite_buf);\n\n\t\tif (ret || retlen != towrite || jffs2_verify_write(c, rewrite_buf, ofs)) {\n\t\t\t/* Argh. We tried. Really we did. */\n\t\t\tpr_crit(\"Recovery of wbuf failed due to a second write error\\n\");\n\t\t\tkfree(buf);\n\n\t\t\tif (retlen)\n\t\t\t\tjffs2_add_physical_node_ref(c, ofs | REF_OBSOLETE, ref_totlen(c, jeb, first_raw), NULL);\n\n\t\t\treturn;\n\t\t}\n\t\tpr_notice(\"Recovery of wbuf succeeded to %08x\\n\", ofs);\n\n\t\tc->wbuf_len = (end - start) - towrite;\n\t\tc->wbuf_ofs = ofs + towrite;\n\t\tmemmove(c->wbuf, rewrite_buf + towrite, c->wbuf_len);\n\t\t/* Don't muck about with c->wbuf_inodes. False positives are harmless. */\n\t} else {\n\t\t/* OK, now we're left with the dregs in whichever buffer we're using */\n\t\tif (buf) {\n\t\t\tmemcpy(c->wbuf, buf, end-start);\n\t\t} else {\n\t\t\tmemmove(c->wbuf, c->wbuf + (start - c->wbuf_ofs), end - start);\n\t\t}\n\t\tc->wbuf_ofs = ofs;\n\t\tc->wbuf_len = end - start;\n\t}\n\n\t/* Now sort out the jffs2_raw_node_refs, moving them from the old to the next block */\n\tnew_jeb = &c->blocks[ofs / c->sector_size];\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw = first_raw; raw != jeb->last_node; raw = ref_next(raw)) {\n\t\tuint32_t rawlen = ref_totlen(c, jeb, raw);\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref *new_ref;\n\t\tstruct jffs2_raw_node_ref **adjust_ref = NULL;\n\t\tstruct jffs2_inode_info *f = NULL;\n\n\t\tjffs2_dbg(1, \"Refiling block of %08x at %08x(%d) to %08x\\n\",\n\t\t\t  rawlen, ref_offset(raw), ref_flags(raw), ofs);\n\n\t\tic = jffs2_raw_ref_to_ic(raw);\n\n\t\t/* Ick. This XATTR mess should be fixed shortly... */\n\t\tif (ic && ic->class == RAWNODE_CLASS_XATTR_DATUM) {\n\t\t\tstruct jffs2_xattr_datum *xd = (void *)ic;\n\t\t\tBUG_ON(xd->node != raw);\n\t\t\tadjust_ref = &xd->node;\n\t\t\traw->next_in_ino = NULL;\n\t\t\tic = NULL;\n\t\t} else if (ic && ic->class == RAWNODE_CLASS_XATTR_REF) {\n\t\t\tstruct jffs2_xattr_datum *xr = (void *)ic;\n\t\t\tBUG_ON(xr->node != raw);\n\t\t\tadjust_ref = &xr->node;\n\t\t\traw->next_in_ino = NULL;\n\t\t\tic = NULL;\n\t\t} else if (ic && ic->class == RAWNODE_CLASS_INODE_CACHE) {\n\t\t\tstruct jffs2_raw_node_ref **p = &ic->nodes;\n\n\t\t\t/* Remove the old node from the per-inode list */\n\t\t\twhile (*p && *p != (void *)ic) {\n\t\t\t\tif (*p == raw) {\n\t\t\t\t\t(*p) = (raw->next_in_ino);\n\t\t\t\t\traw->next_in_ino = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = &((*p)->next_in_ino);\n\t\t\t}\n\n\t\t\tif (ic->state == INO_STATE_PRESENT && !ref_obsolete(raw)) {\n\t\t\t\t/* If it's an in-core inode, then we have to adjust any\n\t\t\t\t   full_dirent or full_dnode structure to point to the\n\t\t\t\t   new version instead of the old */\n\t\t\t\tf = jffs2_gc_fetch_inode(c, ic->ino, !ic->pino_nlink);\n\t\t\t\tif (IS_ERR(f)) {\n\t\t\t\t\t/* Should never happen; it _must_ be present */\n\t\t\t\t\tJFFS2_ERROR(\"Failed to iget() ino #%u, err %ld\\n\",\n\t\t\t\t\t\t    ic->ino, PTR_ERR(f));\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\t/* We don't lock f->sem. There's a number of ways we could\n\t\t\t\t   end up in here with it already being locked, and nobody's\n\t\t\t\t   going to modify it on us anyway because we hold the\n\t\t\t\t   alloc_sem. We're only changing one ->raw pointer too,\n\t\t\t\t   which we can get away with without upsetting readers. */\n\t\t\t\tadjust_ref = jffs2_incore_replace_raw(c, f, raw,\n\t\t\t\t\t\t\t\t      (void *)(buf?:c->wbuf) + (ref_offset(raw) - start));\n\t\t\t} else if (unlikely(ic->state != INO_STATE_PRESENT &&\n\t\t\t\t\t    ic->state != INO_STATE_CHECKEDABSENT &&\n\t\t\t\t\t    ic->state != INO_STATE_GC)) {\n\t\t\t\tJFFS2_ERROR(\"Inode #%u is in strange state %d!\\n\", ic->ino, ic->state);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\tnew_ref = jffs2_link_node_ref(c, new_jeb, ofs | ref_flags(raw), rawlen, ic);\n\n\t\tif (adjust_ref) {\n\t\t\tBUG_ON(*adjust_ref != raw);\n\t\t\t*adjust_ref = new_ref;\n\t\t}\n\t\tif (f)\n\t\t\tjffs2_gc_release_inode(c, f);\n\n\t\tif (!ref_obsolete(raw)) {\n\t\t\tjeb->dirty_size += rawlen;\n\t\t\tjeb->used_size  -= rawlen;\n\t\t\tc->dirty_size += rawlen;\n\t\t\tc->used_size -= rawlen;\n\t\t\traw->flash_offset = ref_offset(raw) | REF_OBSOLETE;\n\t\t\tBUG_ON(raw->next_in_ino);\n\t\t}\n\t\tofs += rawlen;\n\t}\n\n\tkfree(buf);\n\n\t/* Fix up the original jeb now it's on the bad_list */\n\tif (first_raw == jeb->first_node) {\n\t\tjffs2_dbg(1, \"Failing block at %08x is now empty. Moving to erase_pending_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, new_jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, new_jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjffs2_dbg(1, \"wbuf recovery completed OK. wbuf_ofs 0x%08x, len 0x%x\\n\",\n\t\t  c->wbuf_ofs, c->wbuf_len);\n\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "buf recovery completed OK. wbuf_ofs 0x%08x, len 0x%x\\n\",",
            ">wbuf_ofs,",
            ">wbuf_len);"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_paranoia_check_nolock(c",
          "args": [
            "w_jeb);"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_sanity_check_nolock(c",
          "args": [
            "w_jeb);"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_paranoia_check_nolock(c",
          "args": [
            "b);"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_sanity_check_nolock(c",
          "args": [
            "b);"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_trigger(c",
          "args": [
            ";"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move(&",
          "args": [
            "eb->list,",
            "->erase_pending_list);"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ailing block at %08x is now empty. Moving to erase_pending_list\\n\",",
            "b->offset);"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(b",
          "args": [
            "f);"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(r",
          "args": [
            "w->next_in_ino);"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(r",
          "args": [
            "w))"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_gc_release_inode(c",
          "args": [
            ";"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(*",
          "args": [
            "djust_ref != raw);"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_link_node_ref(c",
          "args": [
            "w_jeb,",
            "s | ref_flags(raw),",
            "wlen,",
            ");"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(r",
          "args": [
            "w),"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_ERROR(\"",
          "args": [
            "node #%u is in strange state %d!\\n\",",
            "->ino,",
            "->state);"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(i",
          "args": [
            "->state != INO_STATE_PRESENT &&\n\t\t\t\t\t    ic->state != INO_STATE_CHECKEDABSENT &&\n\t\t\t\t\t    ic->state != INO_STATE_GC))"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_incore_replace_raw(c",
          "args": [
            "w,",
            "oid *)(buf?:c->wbuf) + (ref_offset(raw) - start));"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_ERROR(\"",
          "args": [
            "ailed to iget() ino #%u, err %ld\\n\",",
            "->ino,",
            "R_ERR(f));"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(f",
          "args": [
            ")"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(f",
          "args": [
            ")"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_gc_fetch_inode(c",
          "args": [
            "->ino,",
            "c->pino_nlink);"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(r",
          "args": [
            "w))"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(x",
          "args": [
            "->node != raw);"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(x",
          "args": [
            "->node != raw);"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_raw_ref_to_ic(r",
          "args": [
            "w);"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "efiling block of %08x at %08x(%d) to %08x\\n\",",
            "wlen,",
            "f_offset(raw),",
            "f_flags(raw),",
            "s);"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(r",
          "args": [
            "w),"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_totlen(c",
          "args": [
            "b,",
            "w);"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_next(r",
          "args": [
            "w))"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmove(c",
          "args": [
            ">wbuf,",
            ">wbuf + (start - c->wbuf_ofs),",
            "d - start);"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcpy(c",
          "args": [
            ">wbuf,",
            "f,",
            "d-start);"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmove(c",
          "args": [
            ">wbuf,",
            "write_buf + towrite,",
            ">wbuf_len);"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "ecovery of wbuf succeeded to %08x\\n\",",
            "s);"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_add_physical_node_ref(c",
          "args": [
            "s | REF_OBSOLETE,",
            "f_totlen(c, jeb, first_raw),",
            "LL);"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_totlen(c",
          "args": [
            "b,",
            "rst_raw),"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(b",
          "args": [
            "f);"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "ecovery of wbuf failed due to a second write error\\n\");"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_verify_write(c",
          "args": [
            "write_buf,",
            "s))"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_write(c",
          "args": [
            ">mtd,",
            "s,",
            "write,",
            "etlen,",
            "write_buf);"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_write(c",
          "args": [
            ">mtd,",
            "s,",
            "write,",
            "etlen,",
            "okenbuf);"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "aking write error at 0x%08x\\n\",",
            "s);"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "rite 0x%x bytes at 0x%08x in wbuf recover\\n\",",
            "write,",
            "s);"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ite_ofs(c",
          "args": [
            ";"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(b",
          "args": [
            "f);"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ailed to allocate node refs for wbuf recovery. Data loss ensues.\\n\");"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_prealloc_raw_node_refs(c",
          "args": [
            ">nextblock,",
            "_refile);"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_sum_disable_collecting(c",
          "args": [
            ">summary);"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(b",
          "args": [
            "f);"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ailed to allocate space for wbuf recovery. Data loss ensues.\\n\");"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_reserve_space_gc(c",
          "args": [
            "d-start,",
            "en,",
            "FS2_SUMMARY_NOSUM_SIZE);"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcpy(b",
          "args": [
            "f + (c->wbuf_ofs - start),",
            ">wbuf,",
            "d - c->wbuf_ofs);"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "buf now recover %08x-%08x (%d bytes in %d nodes)\\n\",",
            "art,",
            "d,",
            "d - start,",
            "_refile);"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(f",
          "args": [
            "rst_raw);"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_next(f",
          "args": [
            "rst_raw);"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(f",
          "args": [
            "rst_raw))"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_next(f",
          "args": [
            "rst_raw);"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(b",
          "args": [
            "f);"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "ld data are already lost in wbuf recovery. Data loss ensues.\\n\");"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_read(c",
          "args": [
            ">mtd,",
            "art,",
            ">wbuf_ofs - start,",
            "etlen,",
            "f);"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "alloc failure in wbuf recovery. Data loss ensues.\\n\");"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(e",
          "args": [
            "d - start,",
            "P_KERNEL);"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "buf recover %08x-%08x (%d bytes in %d nodes)\\n\",",
            "art,",
            "d,",
            "d - start,",
            "_refile);"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_next(r",
          "args": [
            "w))"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(j",
          "args": [
            "b->last_node);"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(f",
          "args": [
            "rst_raw);"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "o non-obsolete nodes to be recovered. Just filing block bad\\n\");"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "irst node to be recovered is at 0x%08x(%d)-0x%08x\\n\",",
            "f_offset(raw),",
            "f_flags(raw),",
            "ef_offset(raw) + ref_totlen(c, jeb, raw)));"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_totlen(c",
          "args": [
            "b,",
            "w))"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(r",
          "args": [
            "w),"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "kipping node at 0x%08x(%d)-0x%08x which is either before 0x%08x or obsolete\\n\",",
            "f_offset(raw),",
            "f_flags(raw),",
            "ef_offset(raw) + ref_totlen(c, jeb, raw)),",
            ">wbuf_ofs);"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_totlen(c",
          "args": [
            "b,",
            "w))"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(r",
          "args": [
            "w),"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(n",
          "args": [
            "xt)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(r",
          "args": [
            "w)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_next(r",
          "args": [
            "w);"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(!",
          "args": [
            "ef_obsolete(jeb->last_node));"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(j",
          "args": [
            "b->last_node))"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_block_refile(c",
          "args": [
            "b,",
            "FILE_ANYWAY);"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_block_refile(c",
          "args": [
            "b,",
            "FILE_NOTEMPTY);"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_wbuf_recover(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_eraseblock *jeb, *new_jeb;\n\tstruct jffs2_raw_node_ref *raw, *next, *first_raw = NULL;\n\tsize_t retlen;\n\tint ret;\n\tint nr_refile = 0;\n\tunsigned char *buf;\n\tuint32_t start, end, ofs, len;\n\n\tjeb = &c->blocks[c->wbuf_ofs / c->sector_size];\n\n\tspin_lock(&c->erase_completion_lock);\n\tif (c->wbuf_ofs % c->mtd->erasesize)\n\t\tjffs2_block_refile(c, jeb, REFILE_NOTEMPTY);\n\telse\n\t\tjffs2_block_refile(c, jeb, REFILE_ANYWAY);\n\tspin_unlock(&c->erase_completion_lock);\n\n\tBUG_ON(!ref_obsolete(jeb->last_node));\n\n\t/* Find the first node to be recovered, by skipping over every\n\t   node which ends before the wbuf starts, or which is obsolete. */\n\tfor (next = raw = jeb->first_node; next; raw = next) {\n\t\tnext = ref_next(raw);\n\n\t\tif (ref_obsolete(raw) || \n\t\t    (next && ref_offset(next) <= c->wbuf_ofs)) {\n\t\t\tdbg_noderef(\"Skipping node at 0x%08x(%d)-0x%08x which is either before 0x%08x or obsolete\\n\",\n\t\t\t\t    ref_offset(raw), ref_flags(raw),\n\t\t\t\t    (ref_offset(raw) + ref_totlen(c, jeb, raw)),\n\t\t\t\t    c->wbuf_ofs);\n\t\t\tcontinue;\n\t\t}\n\t\tdbg_noderef(\"First node to be recovered is at 0x%08x(%d)-0x%08x\\n\",\n\t\t\t    ref_offset(raw), ref_flags(raw),\n\t\t\t    (ref_offset(raw) + ref_totlen(c, jeb, raw)));\n\n\t\tfirst_raw = raw;\n\t\tbreak;\n\t}\n\n\tif (!first_raw) {\n\t\t/* All nodes were obsolete. Nothing to recover. */\n\t\tjffs2_dbg(1, \"No non-obsolete nodes to be recovered. Just filing block bad\\n\");\n\t\tc->wbuf_len = 0;\n\t\treturn;\n\t}\n\n\tstart = ref_offset(first_raw);\n\tend = ref_offset(jeb->last_node);\n\tnr_refile = 1;\n\n\t/* Count the number of refs which need to be copied */\n\twhile ((raw = ref_next(raw)) != jeb->last_node)\n\t\tnr_refile++;\n\n\tdbg_noderef(\"wbuf recover %08x-%08x (%d bytes in %d nodes)\\n\",\n\t\t    start, end, end - start, nr_refile);\n\n\tbuf = NULL;\n\tif (start < c->wbuf_ofs) {\n\t\t/* First affected node was already partially written.\n\t\t * Attempt to reread the old data into our buffer. */\n\n\t\tbuf = kmalloc(end - start, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_crit(\"Malloc failure in wbuf recovery. Data loss ensues.\\n\");\n\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t/* Do the read... */\n\t\tret = mtd_read(c->mtd, start, c->wbuf_ofs - start, &retlen,\n\t\t\t       buf);\n\n\t\t/* ECC recovered ? */\n\t\tif ((ret == -EUCLEAN || ret == -EBADMSG) &&\n\t\t    (retlen == c->wbuf_ofs - start))\n\t\t\tret = 0;\n\n\t\tif (ret || retlen != c->wbuf_ofs - start) {\n\t\t\tpr_crit(\"Old data are already lost in wbuf recovery. Data loss ensues.\\n\");\n\n\t\t\tkfree(buf);\n\t\t\tbuf = NULL;\n\t\tread_failed:\n\t\t\tfirst_raw = ref_next(first_raw);\n\t\t\tnr_refile--;\n\t\t\twhile (first_raw && ref_obsolete(first_raw)) {\n\t\t\t\tfirst_raw = ref_next(first_raw);\n\t\t\t\tnr_refile--;\n\t\t\t}\n\n\t\t\t/* If this was the only node to be recovered, give up */\n\t\t\tif (!first_raw) {\n\t\t\t\tc->wbuf_len = 0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* It wasn't. Go on and try to recover nodes complete in the wbuf */\n\t\t\tstart = ref_offset(first_raw);\n\t\t\tdbg_noderef(\"wbuf now recover %08x-%08x (%d bytes in %d nodes)\\n\",\n\t\t\t\t    start, end, end - start, nr_refile);\n\n\t\t} else {\n\t\t\t/* Read succeeded. Copy the remaining data from the wbuf */\n\t\t\tmemcpy(buf + (c->wbuf_ofs - start), c->wbuf, end - c->wbuf_ofs);\n\t\t}\n\t}\n\t/* OK... we're to rewrite (end-start) bytes of data from first_raw onwards.\n\t   Either 'buf' contains the data, or we find it in the wbuf */\n\n\t/* ... and get an allocation of space from a shiny new block instead */\n\tret = jffs2_reserve_space_gc(c, end-start, &len, JFFS2_SUMMARY_NOSUM_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate space for wbuf recovery. Data loss ensues.\\n\");\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\t/* The summary is not recovered, so it must be disabled for this erase block */\n\tjffs2_sum_disable_collecting(c->summary);\n\n\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, nr_refile);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate node refs for wbuf recovery. Data loss ensues.\\n\");\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tofs = write_ofs(c);\n\n\tif (end-start >= c->wbuf_pagesize) {\n\t\t/* Need to do another write immediately, but it's possible\n\t\t   that this is just because the wbuf itself is completely\n\t\t   full, and there's nothing earlier read back from the\n\t\t   flash. Hence 'buf' isn't necessarily what we're writing\n\t\t   from. */\n\t\tunsigned char *rewrite_buf = buf?:c->wbuf;\n\t\tuint32_t towrite = (end-start) - ((end-start)%c->wbuf_pagesize);\n\n\t\tjffs2_dbg(1, \"Write 0x%x bytes at 0x%08x in wbuf recover\\n\",\n\t\t\t  towrite, ofs);\n\n#ifdef BREAKMEHEADER\n\t\tstatic int breakme;\n\t\tif (breakme++ == 20) {\n\t\t\tpr_notice(\"Faking write error at 0x%08x\\n\", ofs);\n\t\t\tbreakme = 0;\n\t\t\tmtd_write(c->mtd, ofs, towrite, &retlen, brokenbuf);\n\t\t\tret = -EIO;\n\t\t} else\n#endif\n\t\t\tret = mtd_write(c->mtd, ofs, towrite, &retlen,\n\t\t\t\t\trewrite_buf);\n\n\t\tif (ret || retlen != towrite || jffs2_verify_write(c, rewrite_buf, ofs)) {\n\t\t\t/* Argh. We tried. Really we did. */\n\t\t\tpr_crit(\"Recovery of wbuf failed due to a second write error\\n\");\n\t\t\tkfree(buf);\n\n\t\t\tif (retlen)\n\t\t\t\tjffs2_add_physical_node_ref(c, ofs | REF_OBSOLETE, ref_totlen(c, jeb, first_raw), NULL);\n\n\t\t\treturn;\n\t\t}\n\t\tpr_notice(\"Recovery of wbuf succeeded to %08x\\n\", ofs);\n\n\t\tc->wbuf_len = (end - start) - towrite;\n\t\tc->wbuf_ofs = ofs + towrite;\n\t\tmemmove(c->wbuf, rewrite_buf + towrite, c->wbuf_len);\n\t\t/* Don't muck about with c->wbuf_inodes. False positives are harmless. */\n\t} else {\n\t\t/* OK, now we're left with the dregs in whichever buffer we're using */\n\t\tif (buf) {\n\t\t\tmemcpy(c->wbuf, buf, end-start);\n\t\t} else {\n\t\t\tmemmove(c->wbuf, c->wbuf + (start - c->wbuf_ofs), end - start);\n\t\t}\n\t\tc->wbuf_ofs = ofs;\n\t\tc->wbuf_len = end - start;\n\t}\n\n\t/* Now sort out the jffs2_raw_node_refs, moving them from the old to the next block */\n\tnew_jeb = &c->blocks[ofs / c->sector_size];\n\n\tspin_lock(&c->erase_completion_lock);\n\tfor (raw = first_raw; raw != jeb->last_node; raw = ref_next(raw)) {\n\t\tuint32_t rawlen = ref_totlen(c, jeb, raw);\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref *new_ref;\n\t\tstruct jffs2_raw_node_ref **adjust_ref = NULL;\n\t\tstruct jffs2_inode_info *f = NULL;\n\n\t\tjffs2_dbg(1, \"Refiling block of %08x at %08x(%d) to %08x\\n\",\n\t\t\t  rawlen, ref_offset(raw), ref_flags(raw), ofs);\n\n\t\tic = jffs2_raw_ref_to_ic(raw);\n\n\t\t/* Ick. This XATTR mess should be fixed shortly... */\n\t\tif (ic && ic->class == RAWNODE_CLASS_XATTR_DATUM) {\n\t\t\tstruct jffs2_xattr_datum *xd = (void *)ic;\n\t\t\tBUG_ON(xd->node != raw);\n\t\t\tadjust_ref = &xd->node;\n\t\t\traw->next_in_ino = NULL;\n\t\t\tic = NULL;\n\t\t} else if (ic && ic->class == RAWNODE_CLASS_XATTR_REF) {\n\t\t\tstruct jffs2_xattr_datum *xr = (void *)ic;\n\t\t\tBUG_ON(xr->node != raw);\n\t\t\tadjust_ref = &xr->node;\n\t\t\traw->next_in_ino = NULL;\n\t\t\tic = NULL;\n\t\t} else if (ic && ic->class == RAWNODE_CLASS_INODE_CACHE) {\n\t\t\tstruct jffs2_raw_node_ref **p = &ic->nodes;\n\n\t\t\t/* Remove the old node from the per-inode list */\n\t\t\twhile (*p && *p != (void *)ic) {\n\t\t\t\tif (*p == raw) {\n\t\t\t\t\t(*p) = (raw->next_in_ino);\n\t\t\t\t\traw->next_in_ino = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = &((*p)->next_in_ino);\n\t\t\t}\n\n\t\t\tif (ic->state == INO_STATE_PRESENT && !ref_obsolete(raw)) {\n\t\t\t\t/* If it's an in-core inode, then we have to adjust any\n\t\t\t\t   full_dirent or full_dnode structure to point to the\n\t\t\t\t   new version instead of the old */\n\t\t\t\tf = jffs2_gc_fetch_inode(c, ic->ino, !ic->pino_nlink);\n\t\t\t\tif (IS_ERR(f)) {\n\t\t\t\t\t/* Should never happen; it _must_ be present */\n\t\t\t\t\tJFFS2_ERROR(\"Failed to iget() ino #%u, err %ld\\n\",\n\t\t\t\t\t\t    ic->ino, PTR_ERR(f));\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\t/* We don't lock f->sem. There's a number of ways we could\n\t\t\t\t   end up in here with it already being locked, and nobody's\n\t\t\t\t   going to modify it on us anyway because we hold the\n\t\t\t\t   alloc_sem. We're only changing one ->raw pointer too,\n\t\t\t\t   which we can get away with without upsetting readers. */\n\t\t\t\tadjust_ref = jffs2_incore_replace_raw(c, f, raw,\n\t\t\t\t\t\t\t\t      (void *)(buf?:c->wbuf) + (ref_offset(raw) - start));\n\t\t\t} else if (unlikely(ic->state != INO_STATE_PRESENT &&\n\t\t\t\t\t    ic->state != INO_STATE_CHECKEDABSENT &&\n\t\t\t\t\t    ic->state != INO_STATE_GC)) {\n\t\t\t\tJFFS2_ERROR(\"Inode #%u is in strange state %d!\\n\", ic->ino, ic->state);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\tnew_ref = jffs2_link_node_ref(c, new_jeb, ofs | ref_flags(raw), rawlen, ic);\n\n\t\tif (adjust_ref) {\n\t\t\tBUG_ON(*adjust_ref != raw);\n\t\t\t*adjust_ref = new_ref;\n\t\t}\n\t\tif (f)\n\t\t\tjffs2_gc_release_inode(c, f);\n\n\t\tif (!ref_obsolete(raw)) {\n\t\t\tjeb->dirty_size += rawlen;\n\t\t\tjeb->used_size  -= rawlen;\n\t\t\tc->dirty_size += rawlen;\n\t\t\tc->used_size -= rawlen;\n\t\t\traw->flash_offset = ref_offset(raw) | REF_OBSOLETE;\n\t\t\tBUG_ON(raw->next_in_ino);\n\t\t}\n\t\tofs += rawlen;\n\t}\n\n\tkfree(buf);\n\n\t/* Fix up the original jeb now it's on the bad_list */\n\tif (first_raw == jeb->first_node) {\n\t\tjffs2_dbg(1, \"Failing block at %08x is now empty. Moving to erase_pending_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, new_jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, new_jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjffs2_dbg(1, \"wbuf recovery completed OK. wbuf_ofs 0x%08x, len 0x%x\\n\",\n\t\t  c->wbuf_ofs, c->wbuf_len);\n\n}"
  },
  {
    "function_name": "fs2_verify_write(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "230-267",
    "snippet": "atic int jffs2_verify_write(struct jffs2_sb_info *c, unsigned char *buf,\n\t\t\t      uint32_t ofs)\n{\n\tint ret;\n\tsize_t retlen;\n\tchar *eccstr;\n\n\tret = mtd_read(c->mtd, ofs, c->wbuf_pagesize, &retlen, c->wbuf_verify);\n\tif (ret && ret != -EUCLEAN && ret != -EBADMSG) {\n\t\tpr_warn(\"%s(): Read back of page at %08x failed: %d\\n\",\n\t\t\t__func__, c->wbuf_ofs, ret);\n\t\treturn ret;\n\t} else if (retlen != c->wbuf_pagesize) {\n\t\tpr_warn(\"%s(): Read back of page at %08x gave short read: %zd not %d\\n\",\n\t\t\t__func__, ofs, retlen, c->wbuf_pagesize);\n\t\treturn -EIO;\n\t}\n\tif (!memcmp(buf, c->wbuf_verify, c->wbuf_pagesize))\n\t\treturn 0;\n\n\tif (ret == -EUCLEAN)\n\t\teccstr = \"corrected\";\n\telse if (ret == -EBADMSG)\n\t\teccstr = \"correction failed\";\n\telse\n\t\teccstr = \"OK or unused\";\n\n\tpr_warn(\"Write verify error (ECC %s) at %08x. Wrote:\\n\",\n\t\teccstr, c->wbuf_ofs);\n\tprint_hex_dump(KERN_WARNING, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       c->wbuf, c->wbuf_pagesize, 0);\n\n\tpr_warn(\"Read back:\\n\");\n\tprint_hex_dump(KERN_WARNING, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       c->wbuf_verify, c->wbuf_pagesize, 0);\n\n\treturn -EIO;\n}\n#",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "int_hex_dump(K",
          "args": [
            "RN_WARNING,",
            ",",
            "MP_PREFIX_OFFSET,",
            ",",
            ">wbuf_verify,",
            ">wbuf_pagesize,",
            ";"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ead back:\\n\");"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_hex_dump(K",
          "args": [
            "RN_WARNING,",
            ",",
            "MP_PREFIX_OFFSET,",
            ",",
            ">wbuf,",
            ">wbuf_pagesize,",
            ";"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rite verify error (ECC %s) at %08x. Wrote:\\n\",",
            "cstr,",
            ">wbuf_ofs);"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcmp(b",
          "args": [
            "f,",
            ">wbuf_verify,",
            ">wbuf_pagesize))"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Read back of page at %08x gave short read: %zd not %d\\n\",",
            "func__,",
            "s,",
            "tlen,",
            ">wbuf_pagesize);"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Read back of page at %08x failed: %d\\n\",",
            "func__,",
            ">wbuf_ofs,",
            "t);"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_read(c",
          "args": [
            ">mtd,",
            "s,",
            ">wbuf_pagesize,",
            "etlen,",
            ">wbuf_verify);"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_verify_write(struct jffs2_sb_info *c, unsigned char *buf,\n\t\t\t      uint32_t ofs)\n{\n\tint ret;\n\tsize_t retlen;\n\tchar *eccstr;\n\n\tret = mtd_read(c->mtd, ofs, c->wbuf_pagesize, &retlen, c->wbuf_verify);\n\tif (ret && ret != -EUCLEAN && ret != -EBADMSG) {\n\t\tpr_warn(\"%s(): Read back of page at %08x failed: %d\\n\",\n\t\t\t__func__, c->wbuf_ofs, ret);\n\t\treturn ret;\n\t} else if (retlen != c->wbuf_pagesize) {\n\t\tpr_warn(\"%s(): Read back of page at %08x gave short read: %zd not %d\\n\",\n\t\t\t__func__, ofs, retlen, c->wbuf_pagesize);\n\t\treturn -EIO;\n\t}\n\tif (!memcmp(buf, c->wbuf_verify, c->wbuf_pagesize))\n\t\treturn 0;\n\n\tif (ret == -EUCLEAN)\n\t\teccstr = \"corrected\";\n\telse if (ret == -EBADMSG)\n\t\teccstr = \"correction failed\";\n\telse\n\t\teccstr = \"OK or unused\";\n\n\tpr_warn(\"Write verify error (ECC %s) at %08x. Wrote:\\n\",\n\t\teccstr, c->wbuf_ofs);\n\tprint_hex_dump(KERN_WARNING, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       c->wbuf, c->wbuf_pagesize, 0);\n\n\tpr_warn(\"Read back:\\n\");\n\tprint_hex_dump(KERN_WARNING, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       c->wbuf_verify, c->wbuf_pagesize, 0);\n\n\treturn -EIO;\n}\n#"
  },
  {
    "function_name": "fs2_incore_replace_raw(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "182-227",
    "snippet": "atic struct jffs2_raw_node_ref **jffs2_incore_replace_raw(struct jffs2_sb_info *c,\n\t\t\t\t\t\t\t    struct jffs2_inode_info *f,\n\t\t\t\t\t\t\t    struct jffs2_raw_node_ref *raw,\n\t\t\t\t\t\t\t    union jffs2_node_union *node)\n{\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_noderef(\"incore_replace_raw: node at %p is {%04x,%04x}\\n\",\n\t\t    node, je16_to_cpu(node->u.magic), je16_to_cpu(node->u.nodetype));\n\n\tBUG_ON(je16_to_cpu(node->u.magic) != 0x1985 &&\n\t       je16_to_cpu(node->u.magic) != 0);\n\n\tswitch (je16_to_cpu(node->u.nodetype)) {\n\tcase JFFS2_NODETYPE_INODE:\n\t\tif (f->metadata && f->metadata->raw == raw) {\n\t\t\tdbg_noderef(\"Will replace ->raw in f->metadata at %p\\n\", f->metadata);\n\t\t\treturn &f->metadata->raw;\n\t\t}\n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, je32_to_cpu(node->i.offset));\n\t\tBUG_ON(!frag);\n\t\t/* Find a frag which refers to the full_dnode we want to modify */\n\t\twhile (!frag->node || frag->node->raw != raw) {\n\t\t\tfrag = frag_next(frag);\n\t\t\tBUG_ON(!frag);\n\t\t}\n\t\tdbg_noderef(\"Will replace ->raw in full_dnode at %p\\n\", frag->node);\n\t\treturn &frag->node->raw;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\t\tfor (fd = f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->raw == raw) {\n\t\t\t\tdbg_noderef(\"Will replace ->raw in full_dirent at %p\\n\", fd);\n\t\t\t\treturn &fd->raw;\n\t\t\t}\n\t\t}\n\t\tBUG();\n\n\tdefault:\n\t\tdbg_noderef(\"Don't care about replacing raw for nodetype %x\\n\",\n\t\t\t    je16_to_cpu(node->u.nodetype));\n\t\tbreak;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "on't care about replacing raw for nodetype %x\\n\",",
            "16_to_cpu(node->u.nodetype));"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(n",
          "args": [
            "de->u.nodetype))"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "ill replace ->raw in full_dirent at %p\\n\",",
            ");"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "ill replace ->raw in full_dnode at %p\\n\",",
            "ag->node);"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(!",
          "args": [
            "rag);"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_next(f",
          "args": [
            "ag);"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(!",
          "args": [
            "rag);"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_lookup_node_frag(&",
          "args": [
            "->fragtree,",
            "32_to_cpu(node->i.offset));"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->i.offset))"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "ill replace ->raw in f->metadata at %p\\n\",",
            ">metadata);"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(n",
          "args": [
            "de->u.nodetype))"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(j",
          "args": [
            "16_to_cpu(node->u.magic) != 0x1985 &&\n\t       je16_to_cpu(node->u.magic) != 0);"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(n",
          "args": [
            "de->u.magic)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(n",
          "args": [
            "de->u.magic)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_noderef(\"",
          "args": [
            "ncore_replace_raw: node at %p is {%04x,%04x}\\n\",",
            "de,",
            "16_to_cpu(node->u.magic),",
            "16_to_cpu(node->u.nodetype));"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(n",
          "args": [
            "de->u.nodetype))"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(n",
          "args": [
            "de->u.magic),"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic struct jffs2_raw_node_ref **jffs2_incore_replace_raw(struct jffs2_sb_info *c,\n\t\t\t\t\t\t\t    struct jffs2_inode_info *f,\n\t\t\t\t\t\t\t    struct jffs2_raw_node_ref *raw,\n\t\t\t\t\t\t\t    union jffs2_node_union *node)\n{\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dirent *fd;\n\n\tdbg_noderef(\"incore_replace_raw: node at %p is {%04x,%04x}\\n\",\n\t\t    node, je16_to_cpu(node->u.magic), je16_to_cpu(node->u.nodetype));\n\n\tBUG_ON(je16_to_cpu(node->u.magic) != 0x1985 &&\n\t       je16_to_cpu(node->u.magic) != 0);\n\n\tswitch (je16_to_cpu(node->u.nodetype)) {\n\tcase JFFS2_NODETYPE_INODE:\n\t\tif (f->metadata && f->metadata->raw == raw) {\n\t\t\tdbg_noderef(\"Will replace ->raw in f->metadata at %p\\n\", f->metadata);\n\t\t\treturn &f->metadata->raw;\n\t\t}\n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, je32_to_cpu(node->i.offset));\n\t\tBUG_ON(!frag);\n\t\t/* Find a frag which refers to the full_dnode we want to modify */\n\t\twhile (!frag->node || frag->node->raw != raw) {\n\t\t\tfrag = frag_next(frag);\n\t\t\tBUG_ON(!frag);\n\t\t}\n\t\tdbg_noderef(\"Will replace ->raw in full_dnode at %p\\n\", frag->node);\n\t\treturn &frag->node->raw;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\t\tfor (fd = f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->raw == raw) {\n\t\t\t\tdbg_noderef(\"Will replace ->raw in full_dirent at %p\\n\", fd);\n\t\t\t\treturn &fd->raw;\n\t\t\t}\n\t\t}\n\t\tBUG();\n\n\tdefault:\n\t\tdbg_noderef(\"Don't care about replacing raw for nodetype %x\\n\",\n\t\t\t    je16_to_cpu(node->u.nodetype));\n\t\tbreak;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "fs2_block_refile(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "141-180",
    "snippet": "atic void jffs2_block_refile(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, int allow_empty)\n{\n\tjffs2_dbg(1, \"About to refile bad block at %08x\\n\", jeb->offset);\n\n\t/* File the existing block on the bad_used_list.... */\n\tif (c->nextblock == jeb)\n\t\tc->nextblock = NULL;\n\telse /* Not sure this should ever happen... need more coffee */\n\t\tlist_del(&jeb->list);\n\tif (jeb->first_node) {\n\t\tjffs2_dbg(1, \"Refiling block at %08x to bad_used_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_add(&jeb->list, &c->bad_used_list);\n\t} else {\n\t\tBUG_ON(allow_empty == REFILE_NOTEMPTY);\n\t\t/* It has to have had some nodes or we couldn't be here */\n\t\tjffs2_dbg(1, \"Refiling block at %08x to erase_pending_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\n\tif (!jffs2_prealloc_raw_node_refs(c, jeb, 1)) {\n\t\tuint32_t oldfree = jeb->free_size;\n\n\t\tjffs2_link_node_ref(c, jeb, \n\t\t\t\t    (jeb->offset+c->sector_size-oldfree) | REF_OBSOLETE,\n\t\t\t\t    oldfree, NULL);\n\t\t/* convert to wasted */\n\t\tc->wasted_size += oldfree;\n\t\tjeb->wasted_size += oldfree;\n\t\tc->dirty_size -= oldfree;\n\t\tjeb->dirty_size -= oldfree;\n\t}\n\n\tjffs2_dbg_dump_block_lists_nolock(c);\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_dbg_acct_paranoia_check_nolock(c",
          "args": [
            "b);"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_sanity_check_nolock(c",
          "args": [
            "j",
            "b);"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_dump_block_lists_nolock(c",
          "args": [
            ";"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_link_node_ref(c",
          "args": [
            "b,",
            "eb->offset+c->sector_size-oldfree) | REF_OBSOLETE,",
            "dfree,",
            "LL);"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_prealloc_raw_node_refs(c",
          "args": [
            "b,",
            ")"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_trigger(c",
          "args": [
            ";"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_add(&",
          "args": [
            "eb->list,",
            "->erase_pending_list);"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "efiling block at %08x to erase_pending_list\\n\",",
            "b->offset);"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(a",
          "args": [
            "low_empty == REFILE_NOTEMPTY);"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_add(&",
          "args": [
            "eb->list,",
            "->bad_used_list);"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "efiling block at %08x to bad_used_list\\n\",",
            "b->offset);"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_del(&",
          "args": [
            "eb->list);"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "bout to refile bad block at %08x\\n\",",
            "b->offset);"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_block_refile(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, int allow_empty)\n{\n\tjffs2_dbg(1, \"About to refile bad block at %08x\\n\", jeb->offset);\n\n\t/* File the existing block on the bad_used_list.... */\n\tif (c->nextblock == jeb)\n\t\tc->nextblock = NULL;\n\telse /* Not sure this should ever happen... need more coffee */\n\t\tlist_del(&jeb->list);\n\tif (jeb->first_node) {\n\t\tjffs2_dbg(1, \"Refiling block at %08x to bad_used_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_add(&jeb->list, &c->bad_used_list);\n\t} else {\n\t\tBUG_ON(allow_empty == REFILE_NOTEMPTY);\n\t\t/* It has to have had some nodes or we couldn't be here */\n\t\tjffs2_dbg(1, \"Refiling block at %08x to erase_pending_list\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\n\tif (!jffs2_prealloc_raw_node_refs(c, jeb, 1)) {\n\t\tuint32_t oldfree = jeb->free_size;\n\n\t\tjffs2_link_node_ref(c, jeb, \n\t\t\t\t    (jeb->offset+c->sector_size-oldfree) | REF_OBSOLETE,\n\t\t\t\t    oldfree, NULL);\n\t\t/* convert to wasted */\n\t\tc->wasted_size += oldfree;\n\t\tjeb->wasted_size += oldfree;\n\t\tc->dirty_size -= oldfree;\n\t\tjeb->dirty_size -= oldfree;\n\t}\n\n\tjffs2_dbg_dump_block_lists_nolock(c);\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n}"
  },
  {
    "function_name": "fs2_refile_wbuf_blocks(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "108-136",
    "snippet": "atic inline void jffs2_refile_wbuf_blocks(struct jffs2_sb_info *c)\n{\n\tstruct list_head *this, *next;\n\tstatic int n;\n\n\tif (list_empty(&c->erasable_pending_wbuf_list))\n\t\treturn;\n\n\tlist_for_each_safe(this, next, &c->erasable_pending_wbuf_list) {\n\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\tjffs2_dbg(1, \"Removing eraseblock at 0x%08x from erasable_pending_wbuf_list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(this);\n\t\tif ((jiffies + (n++)) & 127) {\n\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t} else {\n\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t}\n\t}\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "st_add_tail(&",
          "args": [
            "eb->list,",
            "->erasable_list);"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "..and adding to erasable_list\\n\");"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_trigger(c",
          "args": [
            ";"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_add_tail(&",
          "args": [
            "eb->list,",
            "->erase_pending_list);"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "..and adding to erase_pending_list\\n\");"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_del(t",
          "args": [
            "is);"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "emoving eraseblock at 0x%08x from erasable_pending_wbuf_list...\\n\",",
            "b->offset);"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_entry(t",
          "args": [
            "is,",
            "ruct jfs2_eraseblock,",
            "st);"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_for_each_safe(t",
          "args": [
            "is,",
            "xt,",
            "->erasable_pending_wbuf_list)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erasable_pending_wbuf_list))"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic inline void jffs2_refile_wbuf_blocks(struct jffs2_sb_info *c)\n{\n\tstruct list_head *this, *next;\n\tstatic int n;\n\n\tif (list_empty(&c->erasable_pending_wbuf_list))\n\t\treturn;\n\n\tlist_for_each_safe(this, next, &c->erasable_pending_wbuf_list) {\n\t\tstruct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);\n\n\t\tjffs2_dbg(1, \"Removing eraseblock at 0x%08x from erasable_pending_wbuf_list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(this);\n\t\tif ((jiffies + (n++)) & 127) {\n\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t} else {\n\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "fs2_wbuf_dirties_inode(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "85-106",
    "snippet": "atic void jffs2_wbuf_dirties_inode(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inodirty *new;\n\n\t/* Schedule delayed write-buffer write-out */\n\tjffs2_dirty_trigger(c);\n\n\tif (jffs2_wbuf_pending_for_ino(c, ino))\n\t\treturn;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new) {\n\t\tjffs2_dbg(1, \"No memory to allocate inodirty. Fallback to all considered dirty\\n\");\n\t\tjffs2_clear_wbuf_ino_list(c);\n\t\tc->wbuf_inodes = &inodirty_nomem;\n\t\treturn;\n\t}\n\tnew->ino = ino;\n\tnew->next = c->wbuf_inodes;\n\tc->wbuf_inodes = new;\n\treturn;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic struct jffs2_inodirty inodirty_nomem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_clear_wbuf_ino_list(c",
          "args": [
            ";"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "o memory to allocate inodirty. Fallback to all considered dirty\\n\");"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(s",
          "args": [
            "zeof(*new),",
            "P_KERNEL);"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_wbuf_pending_for_ino(c",
          "args": [
            "o))"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dirty_trigger(c",
          "args": [
            ";"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic struct jffs2_inodirty inodirty_nomem;\n\natic void jffs2_wbuf_dirties_inode(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inodirty *new;\n\n\t/* Schedule delayed write-buffer write-out */\n\tjffs2_dirty_trigger(c);\n\n\tif (jffs2_wbuf_pending_for_ino(c, ino))\n\t\treturn;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new) {\n\t\tjffs2_dbg(1, \"No memory to allocate inodirty. Fallback to all considered dirty\\n\");\n\t\tjffs2_clear_wbuf_ino_list(c);\n\t\tc->wbuf_inodes = &inodirty_nomem;\n\t\treturn;\n\t}\n\tnew->ino = ino;\n\tnew->next = c->wbuf_inodes;\n\tc->wbuf_inodes = new;\n\treturn;\n}"
  },
  {
    "function_name": "fs2_clear_wbuf_ino_list(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "69-83",
    "snippet": "atic void jffs2_clear_wbuf_ino_list(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_inodirty *this;\n\n\tthis = c->wbuf_inodes;\n\n\tif (this != &inodirty_nomem) {\n\t\twhile (this) {\n\t\t\tstruct jffs2_inodirty *next = this->next;\n\t\t\tkfree(this);\n\t\t\tthis = next;\n\t\t}\n\t}\n\tc->wbuf_inodes = NULL;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic struct jffs2_inodirty inodirty_nomem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(t",
          "args": [
            "is);"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic struct jffs2_inodirty inodirty_nomem;\n\natic void jffs2_clear_wbuf_ino_list(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_inodirty *this;\n\n\tthis = c->wbuf_inodes;\n\n\tif (this != &inodirty_nomem) {\n\t\twhile (this) {\n\t\t\tstruct jffs2_inodirty *next = this->next;\n\t\t\tkfree(this);\n\t\t\tthis = next;\n\t\t}\n\t}\n\tc->wbuf_inodes = NULL;\n}"
  },
  {
    "function_name": "fs2_wbuf_pending_for_ino(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/wbuf.c",
    "lines": "48-67",
    "snippet": "atic int jffs2_wbuf_pending_for_ino(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inodirty *this = c->wbuf_inodes;\n\n\t/* If a malloc failed, consider _everything_ dirty */\n\tif (this == &inodirty_nomem)\n\t\treturn 1;\n\n\t/* If ino == 0, _any_ non-GC writes mean 'yes' */\n\tif (this && !ino)\n\t\treturn 1;\n\n\t/* Look to see if the inode in question is pending in the wbuf */\n\twhile (this) {\n\t\tif (this->ino == ino)\n\t\t\treturn 1;\n\t\tthis = this->next;\n\t}\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\n/",
      "nclude <linux/writeback.h>\n\n#",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/jiffies.h>\n#i",
      "nclude <linux/mtd/nand.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic struct jffs2_inodirty inodirty_nomem;"
    ],
    "called_functions": [],
    "contextual_snippet": "nclude \"nodelist.h\"\n\n/\nnclude <linux/writeback.h>\n\n#\nnclude <linux/sched.h>\n#i\nnclude <linux/jiffies.h>\n#i\nnclude <linux/mtd/nand.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic struct jffs2_inodirty inodirty_nomem;\n\natic int jffs2_wbuf_pending_for_ino(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inodirty *this = c->wbuf_inodes;\n\n\t/* If a malloc failed, consider _everything_ dirty */\n\tif (this == &inodirty_nomem)\n\t\treturn 1;\n\n\t/* If ino == 0, _any_ non-GC writes mean 'yes' */\n\tif (this && !ino)\n\t\treturn 1;\n\n\t/* Look to see if the inode in question is pending in the wbuf */\n\twhile (this) {\n\t\tif (this->ino == ino)\n\t\t\treturn 1;\n\t\tthis = this->next;\n\t}\n\treturn 0;\n}"
  }
]