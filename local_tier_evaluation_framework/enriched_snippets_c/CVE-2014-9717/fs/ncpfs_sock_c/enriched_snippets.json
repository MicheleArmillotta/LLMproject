[
  {
    "function_name": "ncp_unlock_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "873-881",
    "snippet": "void ncp_unlock_server(struct ncp_server *server)\n{\n\tif (!server->lock) {\n\t\tpr_warn(\"%s: was not locked!\\n\", __func__);\n\t\treturn;\n\t}\n\tserver->lock = 0;\n\tmutex_unlock(&server->mutex);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->mutex"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: was not locked!\\n\"",
            "__func__"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_unlock_server(struct ncp_server *server)\n{\n\tif (!server->lock) {\n\t\tpr_warn(\"%s: was not locked!\\n\", __func__);\n\t\treturn;\n\t}\n\tserver->lock = 0;\n\tmutex_unlock(&server->mutex);\n}"
  },
  {
    "function_name": "ncp_lock_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "865-871",
    "snippet": "void ncp_lock_server(struct ncp_server *server)\n{\n\tmutex_lock(&server->mutex);\n\tif (server->lock)\n\t\tpr_warn(\"%s: was locked!\\n\", __func__);\n\tserver->lock = 1;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: was locked!\\n\"",
            "__func__"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->mutex"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_lock_server(struct ncp_server *server)\n{\n\tmutex_lock(&server->mutex);\n\tif (server->lock)\n\t\tpr_warn(\"%s: was locked!\\n\", __func__);\n\tserver->lock = 1;\n}"
  },
  {
    "function_name": "ncp_disconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "853-863",
    "snippet": "int ncp_disconnect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_DEALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\treturn ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_do_request",
          "args": [
            "server",
            "sizeof(*h)",
            "server->packet",
            "server->packet_size"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "740-788",
          "snippet": "static int ncp_do_request(struct ncp_server *server, int size,\n\t\tvoid* reply, int max_reply_size)\n{\n\tint result;\n\n\tif (server->lock == 0) {\n\t\tpr_err(\"Server not locked!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ncp_conn_valid(server)) {\n\t\treturn -EIO;\n\t}\n\t{\n\t\tsigset_t old_set;\n\t\tunsigned long mask, flags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\told_set = current->blocked;\n\t\tif (current->flags & PF_EXITING)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = sigmask(SIGKILL);\n\t\tif (server->m.flags & NCP_MOUNT_INTR) {\n\t\t\t/* FIXME: This doesn't seem right at all.  So, like,\n\t\t\t   we can't handle SIGINT and get whatever to stop?\n\t\t\t   What if we've blocked it ourselves?  What about\n\t\t\t   alarms?  Why, in fact, are we mucking with the\n\t\t\t   sigmask at all? -- r~ */\n\t\t\tif (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGINT);\n\t\t\tif (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGQUIT);\n\t\t}\n\t\tsiginitsetinv(&current->blocked, mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t\t\n\t\tresult = do_ncp_rpc_call(server, size, reply, max_reply_size);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tcurrent->blocked = old_set;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\tncp_dbg(2, \"do_ncp_rpc_call returned %d\\n\", result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_do_request(struct ncp_server *server, int size,\n\t\tvoid* reply, int max_reply_size)\n{\n\tint result;\n\n\tif (server->lock == 0) {\n\t\tpr_err(\"Server not locked!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ncp_conn_valid(server)) {\n\t\treturn -EIO;\n\t}\n\t{\n\t\tsigset_t old_set;\n\t\tunsigned long mask, flags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\told_set = current->blocked;\n\t\tif (current->flags & PF_EXITING)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = sigmask(SIGKILL);\n\t\tif (server->m.flags & NCP_MOUNT_INTR) {\n\t\t\t/* FIXME: This doesn't seem right at all.  So, like,\n\t\t\t   we can't handle SIGINT and get whatever to stop?\n\t\t\t   What if we've blocked it ourselves?  What about\n\t\t\t   alarms?  Why, in fact, are we mucking with the\n\t\t\t   sigmask at all? -- r~ */\n\t\t\tif (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGINT);\n\t\t\tif (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGQUIT);\n\t\t}\n\t\tsiginitsetinv(&current->blocked, mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t\t\n\t\tresult = do_ncp_rpc_call(server, size, reply, max_reply_size);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tcurrent->blocked = old_set;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\tncp_dbg(2, \"do_ncp_rpc_call returned %d\\n\", result);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nint ncp_disconnect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_DEALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\treturn ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n}"
  },
  {
    "function_name": "ncp_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "831-851",
    "snippet": "int ncp_connect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\tint result;\n\n\tserver->connection = 0xFFFF;\n\tserver->sequence = 255;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_ALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\tresult = ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n\tif (result < 0)\n\t\tgoto out;\n\tserver->connection = h->conn_low + (h->conn_high * 256);\n\tresult = 0;\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_do_request",
          "args": [
            "server",
            "sizeof(*h)",
            "server->packet",
            "server->packet_size"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "740-788",
          "snippet": "static int ncp_do_request(struct ncp_server *server, int size,\n\t\tvoid* reply, int max_reply_size)\n{\n\tint result;\n\n\tif (server->lock == 0) {\n\t\tpr_err(\"Server not locked!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ncp_conn_valid(server)) {\n\t\treturn -EIO;\n\t}\n\t{\n\t\tsigset_t old_set;\n\t\tunsigned long mask, flags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\told_set = current->blocked;\n\t\tif (current->flags & PF_EXITING)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = sigmask(SIGKILL);\n\t\tif (server->m.flags & NCP_MOUNT_INTR) {\n\t\t\t/* FIXME: This doesn't seem right at all.  So, like,\n\t\t\t   we can't handle SIGINT and get whatever to stop?\n\t\t\t   What if we've blocked it ourselves?  What about\n\t\t\t   alarms?  Why, in fact, are we mucking with the\n\t\t\t   sigmask at all? -- r~ */\n\t\t\tif (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGINT);\n\t\t\tif (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGQUIT);\n\t\t}\n\t\tsiginitsetinv(&current->blocked, mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t\t\n\t\tresult = do_ncp_rpc_call(server, size, reply, max_reply_size);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tcurrent->blocked = old_set;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\tncp_dbg(2, \"do_ncp_rpc_call returned %d\\n\", result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_do_request(struct ncp_server *server, int size,\n\t\tvoid* reply, int max_reply_size)\n{\n\tint result;\n\n\tif (server->lock == 0) {\n\t\tpr_err(\"Server not locked!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ncp_conn_valid(server)) {\n\t\treturn -EIO;\n\t}\n\t{\n\t\tsigset_t old_set;\n\t\tunsigned long mask, flags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\told_set = current->blocked;\n\t\tif (current->flags & PF_EXITING)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = sigmask(SIGKILL);\n\t\tif (server->m.flags & NCP_MOUNT_INTR) {\n\t\t\t/* FIXME: This doesn't seem right at all.  So, like,\n\t\t\t   we can't handle SIGINT and get whatever to stop?\n\t\t\t   What if we've blocked it ourselves?  What about\n\t\t\t   alarms?  Why, in fact, are we mucking with the\n\t\t\t   sigmask at all? -- r~ */\n\t\t\tif (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGINT);\n\t\t\tif (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGQUIT);\n\t\t}\n\t\tsiginitsetinv(&current->blocked, mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t\t\n\t\tresult = do_ncp_rpc_call(server, size, reply, max_reply_size);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tcurrent->blocked = old_set;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\tncp_dbg(2, \"do_ncp_rpc_call returned %d\\n\", result);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nint ncp_connect(struct ncp_server *server)\n{\n\tstruct ncp_request_header *h;\n\tint result;\n\n\tserver->connection = 0xFFFF;\n\tserver->sequence = 255;\n\n\th = (struct ncp_request_header *) (server->packet);\n\th->type = NCP_ALLOC_SLOT_REQUEST;\n\th->task\t\t= 2; /* see above */\n\th->function\t= 0;\n\n\tresult = ncp_do_request(server, sizeof(*h), server->packet, server->packet_size);\n\tif (result < 0)\n\t\tgoto out;\n\tserver->connection = h->conn_low + (h->conn_high * 256);\n\tresult = 0;\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "ncp_request2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "794-829",
    "snippet": "int ncp_request2(struct ncp_server *server, int function, \n\t\tvoid* rpl, int size)\n{\n\tstruct ncp_request_header *h;\n\tstruct ncp_reply_header* reply = rpl;\n\tint result;\n\n\th = (struct ncp_request_header *) (server->packet);\n\tif (server->has_subfunction != 0) {\n\t\t*(__u16 *) & (h->data[0]) = htons(server->current_size - sizeof(*h) - 2);\n\t}\n\th->type = NCP_REQUEST;\n\t/*\n\t * The server shouldn't know or care what task is making a\n\t * request, so we always use the same task number.\n\t */\n\th->task = 2; /* (current->pid) & 0xff; */\n\th->function = function;\n\n\tresult = ncp_do_request(server, server->current_size, reply, size);\n\tif (result < 0) {\n\t\tncp_dbg(1, \"ncp_request_error: %d\\n\", result);\n\t\tgoto out;\n\t}\n\tserver->completion = reply->completion_code;\n\tserver->conn_status = reply->connection_state;\n\tserver->reply_size = result;\n\tserver->ncp_reply_size = result - sizeof(struct ncp_reply_header);\n\n\tresult = reply->completion_code;\n\n\tif (result != 0)\n\t\tncp_vdbg(\"completion code=%x\\n\", result);\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"completion code=%x\\n\"",
            "result"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"ncp_request_error: %d\\n\"",
            "result"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_do_request",
          "args": [
            "server",
            "server->current_size",
            "reply",
            "size"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "740-788",
          "snippet": "static int ncp_do_request(struct ncp_server *server, int size,\n\t\tvoid* reply, int max_reply_size)\n{\n\tint result;\n\n\tif (server->lock == 0) {\n\t\tpr_err(\"Server not locked!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ncp_conn_valid(server)) {\n\t\treturn -EIO;\n\t}\n\t{\n\t\tsigset_t old_set;\n\t\tunsigned long mask, flags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\told_set = current->blocked;\n\t\tif (current->flags & PF_EXITING)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = sigmask(SIGKILL);\n\t\tif (server->m.flags & NCP_MOUNT_INTR) {\n\t\t\t/* FIXME: This doesn't seem right at all.  So, like,\n\t\t\t   we can't handle SIGINT and get whatever to stop?\n\t\t\t   What if we've blocked it ourselves?  What about\n\t\t\t   alarms?  Why, in fact, are we mucking with the\n\t\t\t   sigmask at all? -- r~ */\n\t\t\tif (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGINT);\n\t\t\tif (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGQUIT);\n\t\t}\n\t\tsiginitsetinv(&current->blocked, mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t\t\n\t\tresult = do_ncp_rpc_call(server, size, reply, max_reply_size);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tcurrent->blocked = old_set;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\tncp_dbg(2, \"do_ncp_rpc_call returned %d\\n\", result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_do_request(struct ncp_server *server, int size,\n\t\tvoid* reply, int max_reply_size)\n{\n\tint result;\n\n\tif (server->lock == 0) {\n\t\tpr_err(\"Server not locked!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ncp_conn_valid(server)) {\n\t\treturn -EIO;\n\t}\n\t{\n\t\tsigset_t old_set;\n\t\tunsigned long mask, flags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\told_set = current->blocked;\n\t\tif (current->flags & PF_EXITING)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = sigmask(SIGKILL);\n\t\tif (server->m.flags & NCP_MOUNT_INTR) {\n\t\t\t/* FIXME: This doesn't seem right at all.  So, like,\n\t\t\t   we can't handle SIGINT and get whatever to stop?\n\t\t\t   What if we've blocked it ourselves?  What about\n\t\t\t   alarms?  Why, in fact, are we mucking with the\n\t\t\t   sigmask at all? -- r~ */\n\t\t\tif (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGINT);\n\t\t\tif (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGQUIT);\n\t\t}\n\t\tsiginitsetinv(&current->blocked, mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t\t\n\t\tresult = do_ncp_rpc_call(server, size, reply, max_reply_size);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tcurrent->blocked = old_set;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\tncp_dbg(2, \"do_ncp_rpc_call returned %d\\n\", result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "server->current_size - sizeof(*h) - 2"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nint ncp_request2(struct ncp_server *server, int function, \n\t\tvoid* rpl, int size)\n{\n\tstruct ncp_request_header *h;\n\tstruct ncp_reply_header* reply = rpl;\n\tint result;\n\n\th = (struct ncp_request_header *) (server->packet);\n\tif (server->has_subfunction != 0) {\n\t\t*(__u16 *) & (h->data[0]) = htons(server->current_size - sizeof(*h) - 2);\n\t}\n\th->type = NCP_REQUEST;\n\t/*\n\t * The server shouldn't know or care what task is making a\n\t * request, so we always use the same task number.\n\t */\n\th->task = 2; /* (current->pid) & 0xff; */\n\th->function = function;\n\n\tresult = ncp_do_request(server, server->current_size, reply, size);\n\tif (result < 0) {\n\t\tncp_dbg(1, \"ncp_request_error: %d\\n\", result);\n\t\tgoto out;\n\t}\n\tserver->completion = reply->completion_code;\n\tserver->conn_status = reply->connection_state;\n\tserver->reply_size = result;\n\tserver->ncp_reply_size = result - sizeof(struct ncp_reply_header);\n\n\tresult = reply->completion_code;\n\n\tif (result != 0)\n\t\tncp_vdbg(\"completion code=%x\\n\", result);\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "ncp_do_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "740-788",
    "snippet": "static int ncp_do_request(struct ncp_server *server, int size,\n\t\tvoid* reply, int max_reply_size)\n{\n\tint result;\n\n\tif (server->lock == 0) {\n\t\tpr_err(\"Server not locked!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ncp_conn_valid(server)) {\n\t\treturn -EIO;\n\t}\n\t{\n\t\tsigset_t old_set;\n\t\tunsigned long mask, flags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\told_set = current->blocked;\n\t\tif (current->flags & PF_EXITING)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = sigmask(SIGKILL);\n\t\tif (server->m.flags & NCP_MOUNT_INTR) {\n\t\t\t/* FIXME: This doesn't seem right at all.  So, like,\n\t\t\t   we can't handle SIGINT and get whatever to stop?\n\t\t\t   What if we've blocked it ourselves?  What about\n\t\t\t   alarms?  Why, in fact, are we mucking with the\n\t\t\t   sigmask at all? -- r~ */\n\t\t\tif (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGINT);\n\t\t\tif (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGQUIT);\n\t\t}\n\t\tsiginitsetinv(&current->blocked, mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t\t\n\t\tresult = do_ncp_rpc_call(server, size, reply, max_reply_size);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tcurrent->blocked = old_set;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\tncp_dbg(2, \"do_ncp_rpc_call returned %d\\n\", result);\n\n\treturn result;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "2",
            "\"do_ncp_rpc_call returned %d\\n\"",
            "result"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&current->sighand->siglock",
            "flags"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&current->sighand->siglock",
            "flags"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_ncp_rpc_call",
          "args": [
            "server",
            "size",
            "reply",
            "max_reply_size"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "do_ncp_rpc_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "700-734",
          "snippet": "static int do_ncp_rpc_call(struct ncp_server *server, int size,\n\t\tunsigned char* reply_buf, int max_reply_size)\n{\n\tint result;\n\tstruct ncp_request_reply *req;\n\n\treq = ncp_alloc_req();\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->reply_buf = reply_buf;\n\treq->datalen = max_reply_size;\n\treq->tx_iov[1].iov_base = server->packet;\n\treq->tx_iov[1].iov_len = size;\n\treq->tx_iovlen = 1;\n\treq->tx_totallen = size;\n\treq->tx_type = *(u_int16_t*)server->packet;\n\n\tresult = ncp_add_request(server, req);\n\tif (result < 0)\n\t\tgoto out;\n\n\tif (wait_event_interruptible(req->wq, req->status == RQ_DONE)) {\n\t\tncp_abort_request(server, req, -EINTR);\n\t\tresult = -EINTR;\n\t\tgoto out;\n\t}\n\n\tresult = req->result;\n\nout:\n\tncp_req_put(req);\n\n\treturn result;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int do_ncp_rpc_call(struct ncp_server *server, int size,\n\t\tunsigned char* reply_buf, int max_reply_size)\n{\n\tint result;\n\tstruct ncp_request_reply *req;\n\n\treq = ncp_alloc_req();\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->reply_buf = reply_buf;\n\treq->datalen = max_reply_size;\n\treq->tx_iov[1].iov_base = server->packet;\n\treq->tx_iov[1].iov_len = size;\n\treq->tx_iovlen = 1;\n\treq->tx_totallen = size;\n\treq->tx_type = *(u_int16_t*)server->packet;\n\n\tresult = ncp_add_request(server, req);\n\tif (result < 0)\n\t\tgoto out;\n\n\tif (wait_event_interruptible(req->wq, req->status == RQ_DONE)) {\n\t\tncp_abort_request(server, req, -EINTR);\n\t\tresult = -EINTR;\n\t\tgoto out;\n\t}\n\n\tresult = req->result;\n\nout:\n\tncp_req_put(req);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&current->sighand->siglock",
            "flags"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginitsetinv",
          "args": [
            "&current->blocked",
            "mask"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGQUIT"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGINT"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&current->sighand->siglock",
            "flags"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_conn_valid",
          "args": [
            "server"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_conn_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs_sb.h",
          "lines": "164-167",
          "snippet": "static inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/net.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/ncp_mount.h>\n#include <linux/types.h>\n\nstatic inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Server not locked!\\n\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_do_request(struct ncp_server *server, int size,\n\t\tvoid* reply, int max_reply_size)\n{\n\tint result;\n\n\tif (server->lock == 0) {\n\t\tpr_err(\"Server not locked!\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ncp_conn_valid(server)) {\n\t\treturn -EIO;\n\t}\n\t{\n\t\tsigset_t old_set;\n\t\tunsigned long mask, flags;\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\told_set = current->blocked;\n\t\tif (current->flags & PF_EXITING)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = sigmask(SIGKILL);\n\t\tif (server->m.flags & NCP_MOUNT_INTR) {\n\t\t\t/* FIXME: This doesn't seem right at all.  So, like,\n\t\t\t   we can't handle SIGINT and get whatever to stop?\n\t\t\t   What if we've blocked it ourselves?  What about\n\t\t\t   alarms?  Why, in fact, are we mucking with the\n\t\t\t   sigmask at all? -- r~ */\n\t\t\tif (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGINT);\n\t\t\tif (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)\n\t\t\t\tmask |= sigmask(SIGQUIT);\n\t\t}\n\t\tsiginitsetinv(&current->blocked, mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t\t\n\t\tresult = do_ncp_rpc_call(server, size, reply, max_reply_size);\n\n\t\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\t\tcurrent->blocked = old_set;\n\t\trecalc_sigpending();\n\t\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\t}\n\n\tncp_dbg(2, \"do_ncp_rpc_call returned %d\\n\", result);\n\n\treturn result;\n}"
  },
  {
    "function_name": "do_ncp_rpc_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "700-734",
    "snippet": "static int do_ncp_rpc_call(struct ncp_server *server, int size,\n\t\tunsigned char* reply_buf, int max_reply_size)\n{\n\tint result;\n\tstruct ncp_request_reply *req;\n\n\treq = ncp_alloc_req();\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->reply_buf = reply_buf;\n\treq->datalen = max_reply_size;\n\treq->tx_iov[1].iov_base = server->packet;\n\treq->tx_iov[1].iov_len = size;\n\treq->tx_iovlen = 1;\n\treq->tx_totallen = size;\n\treq->tx_type = *(u_int16_t*)server->packet;\n\n\tresult = ncp_add_request(server, req);\n\tif (result < 0)\n\t\tgoto out;\n\n\tif (wait_event_interruptible(req->wq, req->status == RQ_DONE)) {\n\t\tncp_abort_request(server, req, -EINTR);\n\t\tresult = -EINTR;\n\t\tgoto out;\n\t}\n\n\tresult = req->result;\n\nout:\n\tncp_req_put(req);\n\n\treturn result;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_req_put",
          "args": [
            "req"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_req_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "94-98",
          "snippet": "static void ncp_req_put(struct ncp_request_reply *req)\n{\n\tif (atomic_dec_and_test(&req->refs))\n\t\tkfree(req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_req_put(struct ncp_request_reply *req)\n{\n\tif (atomic_dec_and_test(&req->refs))\n\t\tkfree(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_abort_request",
          "args": [
            "server",
            "req",
            "-EINTR"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_abort_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "194-199",
          "snippet": "static inline void ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncp_abort_request(server, req, err);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncp_abort_request(server, req, err);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "req->wq",
            "req->status == RQ_DONE"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_add_request",
          "args": [
            "server",
            "req"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_add_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "331-349",
          "snippet": "static int ncp_add_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tmutex_lock(&server->rcv.creq_mutex);\n\tif (!ncp_conn_valid(server)) {\n\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\tpr_err(\"tcp: Server died\\n\");\n\t\treturn -EIO;\n\t}\n\tncp_req_get(req);\n\tif (server->tx.creq || server->rcv.creq) {\n\t\treq->status = RQ_QUEUED;\n\t\tlist_add_tail(&req->req, &server->tx.requests);\n\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\treturn 0;\n\t}\n\t__ncp_start_request(server, req);\n\tmutex_unlock(&server->rcv.creq_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_add_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tmutex_lock(&server->rcv.creq_mutex);\n\tif (!ncp_conn_valid(server)) {\n\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\tpr_err(\"tcp: Server died\\n\");\n\t\treturn -EIO;\n\t}\n\tncp_req_get(req);\n\tif (server->tx.creq || server->rcv.creq) {\n\t\treq->status = RQ_QUEUED;\n\t\tlist_add_tail(&req->req, &server->tx.requests);\n\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\treturn 0;\n\t}\n\t__ncp_start_request(server, req);\n\tmutex_unlock(&server->rcv.creq_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_alloc_req",
          "args": [],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_alloc_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "74-87",
          "snippet": "static inline struct ncp_request_reply* ncp_alloc_req(void)\n{\n\tstruct ncp_request_reply *req;\n\n\treq = kmalloc(sizeof(struct ncp_request_reply), GFP_KERNEL);\n\tif (!req)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&req->wq);\n\tatomic_set(&req->refs, (1));\n\treq->status = RQ_IDLE;\n\n\treturn req;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline struct ncp_request_reply* ncp_alloc_req(void)\n{\n\tstruct ncp_request_reply *req;\n\n\treq = kmalloc(sizeof(struct ncp_request_reply), GFP_KERNEL);\n\tif (!req)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&req->wq);\n\tatomic_set(&req->refs, (1));\n\treq->status = RQ_IDLE;\n\n\treturn req;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int do_ncp_rpc_call(struct ncp_server *server, int size,\n\t\tunsigned char* reply_buf, int max_reply_size)\n{\n\tint result;\n\tstruct ncp_request_reply *req;\n\n\treq = ncp_alloc_req();\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->reply_buf = reply_buf;\n\treq->datalen = max_reply_size;\n\treq->tx_iov[1].iov_base = server->packet;\n\treq->tx_iov[1].iov_len = size;\n\treq->tx_iovlen = 1;\n\treq->tx_totallen = size;\n\treq->tx_type = *(u_int16_t*)server->packet;\n\n\tresult = ncp_add_request(server, req);\n\tif (result < 0)\n\t\tgoto out;\n\n\tif (wait_event_interruptible(req->wq, req->status == RQ_DONE)) {\n\t\tncp_abort_request(server, req, -EINTR);\n\t\tresult = -EINTR;\n\t\tgoto out;\n\t}\n\n\tresult = req->result;\n\nout:\n\tncp_req_put(req);\n\n\treturn result;\n}"
  },
  {
    "function_name": "ncp_tcp_tx_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "690-698",
    "snippet": "void ncp_tcp_tx_proc(struct work_struct *work)\n{\n\tstruct ncp_server *server =\n\t\tcontainer_of(work, struct ncp_server, tx.tq);\n\t\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncptcp_try_send(server);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ncptcp_try_send",
          "args": [
            "server"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__ncptcp_try_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "215-254",
          "snippet": "static void __ncptcp_try_send(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *rq;\n\tstruct kvec *iov;\n\tstruct kvec iovc[3];\n\tint result;\n\n\trq = server->tx.creq;\n\tif (!rq)\n\t\treturn;\n\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(iovc, rq->tx_ciov, rq->tx_iovlen * sizeof(iov[0]));\n\tresult = do_send(server->ncp_sock, iovc, rq->tx_iovlen,\n\t\t\t rq->tx_totallen, MSG_NOSIGNAL | MSG_DONTWAIT);\n\n\tif (result == -EAGAIN)\n\t\treturn;\n\n\tif (result < 0) {\n\t\tpr_err(\"tcp: Send failed: %d\\n\", result);\n\t\t__ncp_abort_request(server, rq, result);\n\t\treturn;\n\t}\n\tif (result >= rq->tx_totallen) {\n\t\tserver->rcv.creq = rq;\n\t\tserver->tx.creq = NULL;\n\t\treturn;\n\t}\n\trq->tx_totallen -= result;\n\tiov = rq->tx_ciov;\n\twhile (iov->iov_len <= result) {\n\t\tresult -= iov->iov_len;\n\t\tiov++;\n\t\trq->tx_iovlen--;\n\t}\n\tiov->iov_base += result;\n\tiov->iov_len -= result;\n\trq->tx_ciov = iov;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __ncptcp_try_send(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *rq;\n\tstruct kvec *iov;\n\tstruct kvec iovc[3];\n\tint result;\n\n\trq = server->tx.creq;\n\tif (!rq)\n\t\treturn;\n\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(iovc, rq->tx_ciov, rq->tx_iovlen * sizeof(iov[0]));\n\tresult = do_send(server->ncp_sock, iovc, rq->tx_iovlen,\n\t\t\t rq->tx_totallen, MSG_NOSIGNAL | MSG_DONTWAIT);\n\n\tif (result == -EAGAIN)\n\t\treturn;\n\n\tif (result < 0) {\n\t\tpr_err(\"tcp: Send failed: %d\\n\", result);\n\t\t__ncp_abort_request(server, rq, result);\n\t\treturn;\n\t}\n\tif (result >= rq->tx_totallen) {\n\t\tserver->rcv.creq = rq;\n\t\tserver->tx.creq = NULL;\n\t\treturn;\n\t}\n\trq->tx_totallen -= result;\n\tiov = rq->tx_ciov;\n\twhile (iov->iov_len <= result) {\n\t\tresult -= iov->iov_len;\n\t\tiov++;\n\t\trq->tx_iovlen--;\n\t}\n\tiov->iov_base += result;\n\tiov->iov_len -= result;\n\trq->tx_ciov = iov;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structncp_server",
            "tx.tq"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_tcp_tx_proc(struct work_struct *work)\n{\n\tstruct ncp_server *server =\n\t\tcontainer_of(work, struct ncp_server, tx.tq);\n\t\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncptcp_try_send(server);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}"
  },
  {
    "function_name": "ncp_tcp_rcv_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "680-688",
    "snippet": "void ncp_tcp_rcv_proc(struct work_struct *work)\n{\n\tstruct ncp_server *server =\n\t\tcontainer_of(work, struct ncp_server, rcv.tq);\n\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncptcp_rcv_proc(server);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ncptcp_rcv_proc",
          "args": [
            "server"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "__ncptcp_rcv_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "534-678",
          "snippet": "static int __ncptcp_rcv_proc(struct ncp_server *server)\n{\n\t/* We have to check the result, so store the complete header */\n\twhile (1) {\n\t\tint result;\n\t\tstruct ncp_request_reply *req;\n\t\tint datalen;\n\t\tint type;\n\n\t\twhile (server->rcv.len) {\n\t\t\tresult = do_tcp_rcv(server, server->rcv.ptr, server->rcv.len);\n\t\t\tif (result == -EAGAIN) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (result <= 0) {\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (req) {\n\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t}\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tpr_err(\"tcp: error in recvmsg: %d\\n\", result);\n\t\t\t\t} else {\n\t\t\t\t\tncp_dbg(1, \"tcp: EOF\\n\");\n\t\t\t\t}\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (server->rcv.ptr) {\n\t\t\t\tserver->rcv.ptr += result;\n\t\t\t}\n\t\t\tserver->rcv.len -= result;\n\t\t}\n\t\tswitch (server->rcv.state) {\n\t\t\tcase 0:\n\t\t\t\tif (server->rcv.buf.magic != htonl(NCP_TCP_RCVD_MAGIC)) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply type %08X\\n\", ntohl(server->rcv.buf.magic));\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tdatalen = ntohl(server->rcv.buf.len) & 0x0FFFFFFF;\n\t\t\t\tif (datalen < 10) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d\\n\", datalen);\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\t\tif (server->sign_active) {\n\t\t\t\t\tif (datalen < 18) {\n\t\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d\\n\", datalen);\n\t\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tserver->rcv.buf.len = datalen - 8;\n\t\t\t\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf.p1;\n\t\t\t\t\tserver->rcv.len = 8;\n\t\t\t\t\tserver->rcv.state = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\t\t\t\t\n\t\t\t\ttype = ntohs(server->rcv.buf.type);\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\ncont:;\t\t\t\t\n#endif\n\t\t\t\tif (type != NCP_REPLY) {\n\t\t\t\t\tif (datalen - 8 <= sizeof(server->unexpected_packet.data)) {\n\t\t\t\t\t\t*(__u16*)(server->unexpected_packet.data) = htons(type);\n\t\t\t\t\t\tserver->unexpected_packet.len = datalen - 8;\n\n\t\t\t\t\t\tserver->rcv.state = 5;\n\t\t\t\t\t\tserver->rcv.ptr = server->unexpected_packet.data + 2;\n\t\t\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\tncp_dbg(1, \"tcp: Unexpected NCP type %02X\\n\", type);\nskipdata2:;\n\t\t\t\t\tserver->rcv.state = 2;\nskipdata:;\n\t\t\t\t\tserver->rcv.ptr = NULL;\n\t\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (!req) {\n\t\t\t\t\tncp_dbg(1, \"Reply without appropriate request\\n\");\n\t\t\t\t\tgoto skipdata2;\n\t\t\t\t}\n\t\t\t\tif (datalen > req->datalen + 8) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d (expected at most %Zd)\\n\", datalen, req->datalen + 8);\n\t\t\t\t\tserver->rcv.state = 3;\n\t\t\t\t\tgoto skipdata;\n\t\t\t\t}\n\t\t\t\treq->datalen = datalen - 8;\n\t\t\t\t((struct ncp_reply_header*)server->rxbuf)->type = NCP_REPLY;\n\t\t\t\tserver->rcv.ptr = server->rxbuf + 2;\n\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\tserver->rcv.state = 1;\n\t\t\t\tbreak;\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\tcase 4:\n\t\t\t\tdatalen = server->rcv.buf.len;\n\t\t\t\ttype = ntohs(server->rcv.buf.type2);\n\t\t\t\tgoto cont;\n#endif\n\t\t\tcase 1:\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (req->tx_type != NCP_ALLOC_SLOT_REQUEST) {\n\t\t\t\t\tif (((struct ncp_reply_header*)server->rxbuf)->sequence != server->sequence) {\n\t\t\t\t\t\tpr_err(\"tcp: Bad sequence number\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tif ((((struct ncp_reply_header*)server->rxbuf)->conn_low | (((struct ncp_reply_header*)server->rxbuf)->conn_high << 8)) != server->connection) {\n\t\t\t\t\t\tpr_err(\"tcp: Connection number mismatch\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\t\tif (server->sign_active && req->tx_type != NCP_DEALLOC_SLOT_REQUEST) {\n\t\t\t\t\tif (sign_verify_reply(server, server->rxbuf + 6, req->datalen - 6, cpu_to_be32(req->datalen + 16), &server->rcv.buf.type)) {\n\t\t\t\t\t\tpr_err(\"tcp: Signature violation\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\t\t\t\t\n\t\t\t\tncp_finish_request(server, req, req->datalen);\n\t\t\tnextreq:;\n\t\t\t\t__ncp_next_request(server);\n\t\t\tcase 2:\n\t\t\tnext:;\n\t\t\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf;\n\t\t\t\tserver->rcv.len = 10;\n\t\t\t\tserver->rcv.state = 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tncp_finish_request(server, server->rcv.creq, -EIO);\n\t\t\t\tgoto nextreq;\n\t\t\tcase 5:\n\t\t\t\tinfo_server(server, 0, server->unexpected_packet.data, server->unexpected_packet.len);\n\t\t\t\tgoto next;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define NCP_TCP_RCVD_MAGIC\t(0x744E6350)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\n#define NCP_TCP_RCVD_MAGIC\t(0x744E6350)\n\nstatic int __ncptcp_rcv_proc(struct ncp_server *server)\n{\n\t/* We have to check the result, so store the complete header */\n\twhile (1) {\n\t\tint result;\n\t\tstruct ncp_request_reply *req;\n\t\tint datalen;\n\t\tint type;\n\n\t\twhile (server->rcv.len) {\n\t\t\tresult = do_tcp_rcv(server, server->rcv.ptr, server->rcv.len);\n\t\t\tif (result == -EAGAIN) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (result <= 0) {\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (req) {\n\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t}\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tpr_err(\"tcp: error in recvmsg: %d\\n\", result);\n\t\t\t\t} else {\n\t\t\t\t\tncp_dbg(1, \"tcp: EOF\\n\");\n\t\t\t\t}\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (server->rcv.ptr) {\n\t\t\t\tserver->rcv.ptr += result;\n\t\t\t}\n\t\t\tserver->rcv.len -= result;\n\t\t}\n\t\tswitch (server->rcv.state) {\n\t\t\tcase 0:\n\t\t\t\tif (server->rcv.buf.magic != htonl(NCP_TCP_RCVD_MAGIC)) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply type %08X\\n\", ntohl(server->rcv.buf.magic));\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tdatalen = ntohl(server->rcv.buf.len) & 0x0FFFFFFF;\n\t\t\t\tif (datalen < 10) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d\\n\", datalen);\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\t\tif (server->sign_active) {\n\t\t\t\t\tif (datalen < 18) {\n\t\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d\\n\", datalen);\n\t\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tserver->rcv.buf.len = datalen - 8;\n\t\t\t\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf.p1;\n\t\t\t\t\tserver->rcv.len = 8;\n\t\t\t\t\tserver->rcv.state = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\t\t\t\t\n\t\t\t\ttype = ntohs(server->rcv.buf.type);\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\ncont:;\t\t\t\t\n#endif\n\t\t\t\tif (type != NCP_REPLY) {\n\t\t\t\t\tif (datalen - 8 <= sizeof(server->unexpected_packet.data)) {\n\t\t\t\t\t\t*(__u16*)(server->unexpected_packet.data) = htons(type);\n\t\t\t\t\t\tserver->unexpected_packet.len = datalen - 8;\n\n\t\t\t\t\t\tserver->rcv.state = 5;\n\t\t\t\t\t\tserver->rcv.ptr = server->unexpected_packet.data + 2;\n\t\t\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\tncp_dbg(1, \"tcp: Unexpected NCP type %02X\\n\", type);\nskipdata2:;\n\t\t\t\t\tserver->rcv.state = 2;\nskipdata:;\n\t\t\t\t\tserver->rcv.ptr = NULL;\n\t\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (!req) {\n\t\t\t\t\tncp_dbg(1, \"Reply without appropriate request\\n\");\n\t\t\t\t\tgoto skipdata2;\n\t\t\t\t}\n\t\t\t\tif (datalen > req->datalen + 8) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d (expected at most %Zd)\\n\", datalen, req->datalen + 8);\n\t\t\t\t\tserver->rcv.state = 3;\n\t\t\t\t\tgoto skipdata;\n\t\t\t\t}\n\t\t\t\treq->datalen = datalen - 8;\n\t\t\t\t((struct ncp_reply_header*)server->rxbuf)->type = NCP_REPLY;\n\t\t\t\tserver->rcv.ptr = server->rxbuf + 2;\n\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\tserver->rcv.state = 1;\n\t\t\t\tbreak;\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\tcase 4:\n\t\t\t\tdatalen = server->rcv.buf.len;\n\t\t\t\ttype = ntohs(server->rcv.buf.type2);\n\t\t\t\tgoto cont;\n#endif\n\t\t\tcase 1:\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (req->tx_type != NCP_ALLOC_SLOT_REQUEST) {\n\t\t\t\t\tif (((struct ncp_reply_header*)server->rxbuf)->sequence != server->sequence) {\n\t\t\t\t\t\tpr_err(\"tcp: Bad sequence number\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tif ((((struct ncp_reply_header*)server->rxbuf)->conn_low | (((struct ncp_reply_header*)server->rxbuf)->conn_high << 8)) != server->connection) {\n\t\t\t\t\t\tpr_err(\"tcp: Connection number mismatch\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\t\tif (server->sign_active && req->tx_type != NCP_DEALLOC_SLOT_REQUEST) {\n\t\t\t\t\tif (sign_verify_reply(server, server->rxbuf + 6, req->datalen - 6, cpu_to_be32(req->datalen + 16), &server->rcv.buf.type)) {\n\t\t\t\t\t\tpr_err(\"tcp: Signature violation\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\t\t\t\t\n\t\t\t\tncp_finish_request(server, req, req->datalen);\n\t\t\tnextreq:;\n\t\t\t\t__ncp_next_request(server);\n\t\t\tcase 2:\n\t\t\tnext:;\n\t\t\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf;\n\t\t\t\tserver->rcv.len = 10;\n\t\t\t\tserver->rcv.state = 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tncp_finish_request(server, server->rcv.creq, -EIO);\n\t\t\t\tgoto nextreq;\n\t\t\tcase 5:\n\t\t\t\tinfo_server(server, 0, server->unexpected_packet.data, server->unexpected_packet.len);\n\t\t\t\tgoto next;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structncp_server",
            "rcv.tq"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_tcp_rcv_proc(struct work_struct *work)\n{\n\tstruct ncp_server *server =\n\t\tcontainer_of(work, struct ncp_server, rcv.tq);\n\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncptcp_rcv_proc(server);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}"
  },
  {
    "function_name": "__ncptcp_rcv_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "534-678",
    "snippet": "static int __ncptcp_rcv_proc(struct ncp_server *server)\n{\n\t/* We have to check the result, so store the complete header */\n\twhile (1) {\n\t\tint result;\n\t\tstruct ncp_request_reply *req;\n\t\tint datalen;\n\t\tint type;\n\n\t\twhile (server->rcv.len) {\n\t\t\tresult = do_tcp_rcv(server, server->rcv.ptr, server->rcv.len);\n\t\t\tif (result == -EAGAIN) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (result <= 0) {\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (req) {\n\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t}\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tpr_err(\"tcp: error in recvmsg: %d\\n\", result);\n\t\t\t\t} else {\n\t\t\t\t\tncp_dbg(1, \"tcp: EOF\\n\");\n\t\t\t\t}\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (server->rcv.ptr) {\n\t\t\t\tserver->rcv.ptr += result;\n\t\t\t}\n\t\t\tserver->rcv.len -= result;\n\t\t}\n\t\tswitch (server->rcv.state) {\n\t\t\tcase 0:\n\t\t\t\tif (server->rcv.buf.magic != htonl(NCP_TCP_RCVD_MAGIC)) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply type %08X\\n\", ntohl(server->rcv.buf.magic));\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tdatalen = ntohl(server->rcv.buf.len) & 0x0FFFFFFF;\n\t\t\t\tif (datalen < 10) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d\\n\", datalen);\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\t\tif (server->sign_active) {\n\t\t\t\t\tif (datalen < 18) {\n\t\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d\\n\", datalen);\n\t\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tserver->rcv.buf.len = datalen - 8;\n\t\t\t\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf.p1;\n\t\t\t\t\tserver->rcv.len = 8;\n\t\t\t\t\tserver->rcv.state = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\t\t\t\t\n\t\t\t\ttype = ntohs(server->rcv.buf.type);\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\ncont:;\t\t\t\t\n#endif\n\t\t\t\tif (type != NCP_REPLY) {\n\t\t\t\t\tif (datalen - 8 <= sizeof(server->unexpected_packet.data)) {\n\t\t\t\t\t\t*(__u16*)(server->unexpected_packet.data) = htons(type);\n\t\t\t\t\t\tserver->unexpected_packet.len = datalen - 8;\n\n\t\t\t\t\t\tserver->rcv.state = 5;\n\t\t\t\t\t\tserver->rcv.ptr = server->unexpected_packet.data + 2;\n\t\t\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\tncp_dbg(1, \"tcp: Unexpected NCP type %02X\\n\", type);\nskipdata2:;\n\t\t\t\t\tserver->rcv.state = 2;\nskipdata:;\n\t\t\t\t\tserver->rcv.ptr = NULL;\n\t\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (!req) {\n\t\t\t\t\tncp_dbg(1, \"Reply without appropriate request\\n\");\n\t\t\t\t\tgoto skipdata2;\n\t\t\t\t}\n\t\t\t\tif (datalen > req->datalen + 8) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d (expected at most %Zd)\\n\", datalen, req->datalen + 8);\n\t\t\t\t\tserver->rcv.state = 3;\n\t\t\t\t\tgoto skipdata;\n\t\t\t\t}\n\t\t\t\treq->datalen = datalen - 8;\n\t\t\t\t((struct ncp_reply_header*)server->rxbuf)->type = NCP_REPLY;\n\t\t\t\tserver->rcv.ptr = server->rxbuf + 2;\n\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\tserver->rcv.state = 1;\n\t\t\t\tbreak;\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\tcase 4:\n\t\t\t\tdatalen = server->rcv.buf.len;\n\t\t\t\ttype = ntohs(server->rcv.buf.type2);\n\t\t\t\tgoto cont;\n#endif\n\t\t\tcase 1:\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (req->tx_type != NCP_ALLOC_SLOT_REQUEST) {\n\t\t\t\t\tif (((struct ncp_reply_header*)server->rxbuf)->sequence != server->sequence) {\n\t\t\t\t\t\tpr_err(\"tcp: Bad sequence number\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tif ((((struct ncp_reply_header*)server->rxbuf)->conn_low | (((struct ncp_reply_header*)server->rxbuf)->conn_high << 8)) != server->connection) {\n\t\t\t\t\t\tpr_err(\"tcp: Connection number mismatch\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\t\tif (server->sign_active && req->tx_type != NCP_DEALLOC_SLOT_REQUEST) {\n\t\t\t\t\tif (sign_verify_reply(server, server->rxbuf + 6, req->datalen - 6, cpu_to_be32(req->datalen + 16), &server->rcv.buf.type)) {\n\t\t\t\t\t\tpr_err(\"tcp: Signature violation\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\t\t\t\t\n\t\t\t\tncp_finish_request(server, req, req->datalen);\n\t\t\tnextreq:;\n\t\t\t\t__ncp_next_request(server);\n\t\t\tcase 2:\n\t\t\tnext:;\n\t\t\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf;\n\t\t\t\tserver->rcv.len = 10;\n\t\t\t\tserver->rcv.state = 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tncp_finish_request(server, server->rcv.creq, -EIO);\n\t\t\t\tgoto nextreq;\n\t\t\tcase 5:\n\t\t\t\tinfo_server(server, 0, server->unexpected_packet.data, server->unexpected_packet.len);\n\t\t\t\tgoto next;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define NCP_TCP_RCVD_MAGIC\t(0x744E6350)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "info_server",
          "args": [
            "server",
            "0",
            "server->unexpected_packet.data",
            "server->unexpected_packet.len"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "info_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "364-380",
          "snippet": "static void info_server(struct ncp_server *server, unsigned int id, const void * data, size_t len)\n{\n\tif (server->info_sock) {\n\t\tstruct kvec iov[2];\n\t\t__be32 hdr[2];\n\t\n\t\thdr[0] = cpu_to_be32(len + 8);\n\t\thdr[1] = cpu_to_be32(id);\n\t\n\t\tiov[0].iov_base = hdr;\n\t\tiov[0].iov_len = 8;\n\t\tiov[1].iov_base = (void *) data;\n\t\tiov[1].iov_len = len;\n\n\t\tdo_send(server->info_sock, iov, 2, len + 8, MSG_NOSIGNAL);\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void info_server(struct ncp_server *server, unsigned int id, const void * data, size_t len)\n{\n\tif (server->info_sock) {\n\t\tstruct kvec iov[2];\n\t\t__be32 hdr[2];\n\t\n\t\thdr[0] = cpu_to_be32(len + 8);\n\t\thdr[1] = cpu_to_be32(id);\n\t\n\t\tiov[0].iov_base = hdr;\n\t\tiov[0].iov_len = 8;\n\t\tiov[1].iov_base = (void *) data;\n\t\tiov[1].iov_len = len;\n\n\t\tdo_send(server->info_sock, iov, 2, len + 8, MSG_NOSIGNAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_finish_request",
          "args": [
            "server",
            "server->rcv.creq",
            "-EIO"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_finish_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "134-142",
          "snippet": "static inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ncp_next_request",
          "args": [
            "server"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_next_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "351-362",
          "snippet": "static void __ncp_next_request(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tserver->rcv.creq = NULL;\n\tif (list_empty(&server->tx.requests)) {\n\t\treturn;\n\t}\n\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\tlist_del_init(&req->req);\n\t__ncp_start_request(server, req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __ncp_next_request(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tserver->rcv.creq = NULL;\n\tif (list_empty(&server->tx.requests)) {\n\t\treturn;\n\t}\n\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\tlist_del_init(&req->req);\n\t__ncp_start_request(server, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ncp_abort_request",
          "args": [
            "server",
            "req",
            "-EIO"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_abort_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "175-192",
          "snippet": "static inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Signature violation\\n\""
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sign_verify_reply",
          "args": [
            "server",
            "server->rxbuf + 6",
            "req->datalen - 6",
            "cpu_to_be32(req->datalen + 16)",
            "&server->rcv.buf.type"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "sign_verify_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
          "lines": "110-124",
          "snippet": "int sign_verify_reply(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, const void *sign_buff) {\n\tunsigned char data[64];\n\tunsigned char hash[16];\n\n\tmemcpy(data, server->sign_root, 8);\n\t*(__u32*)(data + 8) = totalsize;\n\tif (size < 52) {\n\t\tmemcpy(data + 12, packet, size);\n\t\tmemset(data + 12 + size, 0, 52 - size);\n\t} else {\n\t\tmemcpy(data + 12, packet, 52);\n\t}\n\tnwsign(server->sign_last, data, hash);\n\treturn memcmp(sign_buff, hash, 8);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/ncp.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nint sign_verify_reply(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, const void *sign_buff) {\n\tunsigned char data[64];\n\tunsigned char hash[16];\n\n\tmemcpy(data, server->sign_root, 8);\n\t*(__u32*)(data + 8) = totalsize;\n\tif (size < 52) {\n\t\tmemcpy(data + 12, packet, size);\n\t\tmemset(data + 12 + size, 0, 52 - size);\n\t} else {\n\t\tmemcpy(data + 12, packet, 52);\n\t}\n\tnwsign(server->sign_last, data, hash);\n\treturn memcmp(sign_buff, hash, 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "req->datalen + 16"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Connection number mismatch\\n\""
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Bad sequence number\\n\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "server->rcv.buf.type2"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Unexpected reply len %d (expected at most %Zd)\\n\"",
            "datalen",
            "req->datalen + 8"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"Reply without appropriate request\\n\""
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"tcp: Unexpected NCP type %02X\\n\"",
            "type"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "type"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "server->rcv.buf.type"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ncptcp_abort",
          "args": [
            "server"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "__ncptcp_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "201-204",
          "snippet": "static inline void __ncptcp_abort(struct ncp_server *server)\n{\n\t__abort_ncp_connection(server);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncptcp_abort(struct ncp_server *server)\n{\n\t__abort_ncp_connection(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Unexpected reply len %d\\n\"",
            "datalen"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Unexpected reply len %d\\n\"",
            "datalen"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->rcv.buf.len"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Unexpected reply type %08X\\n\"",
            "ntohl(server->rcv.buf.magic)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "server->rcv.buf.magic"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NCP_TCP_RCVD_MAGIC"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"tcp: EOF\\n\""
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: error in recvmsg: %d\\n\"",
            "result"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_tcp_rcv",
          "args": [
            "server",
            "server->rcv.ptr",
            "server->rcv.len"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "do_tcp_rcv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "510-532",
          "snippet": "static int do_tcp_rcv(struct ncp_server *server, void *buffer, size_t len)\n{\n\tint result;\n\t\n\tif (buffer) {\n\t\tresult = _recv(server->ncp_sock, buffer, len, MSG_DONTWAIT);\n\t} else {\n\t\tstatic unsigned char dummy[1024];\n\t\t\t\n\t\tif (len > sizeof(dummy)) {\n\t\t\tlen = sizeof(dummy);\n\t\t}\n\t\tresult = _recv(server->ncp_sock, dummy, len, MSG_DONTWAIT);\n\t}\n\tif (result < 0) {\n\t\treturn result;\n\t}\n\tif (result > len) {\n\t\tpr_err(\"tcp: bug in recvmsg (%u > %Zu)\\n\", result, len);\n\t\treturn -EIO;\t\t\t\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int do_tcp_rcv(struct ncp_server *server, void *buffer, size_t len)\n{\n\tint result;\n\t\n\tif (buffer) {\n\t\tresult = _recv(server->ncp_sock, buffer, len, MSG_DONTWAIT);\n\t} else {\n\t\tstatic unsigned char dummy[1024];\n\t\t\t\n\t\tif (len > sizeof(dummy)) {\n\t\t\tlen = sizeof(dummy);\n\t\t}\n\t\tresult = _recv(server->ncp_sock, dummy, len, MSG_DONTWAIT);\n\t}\n\tif (result < 0) {\n\t\treturn result;\n\t}\n\tif (result > len) {\n\t\tpr_err(\"tcp: bug in recvmsg (%u > %Zu)\\n\", result, len);\n\t\treturn -EIO;\t\t\t\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\n#define NCP_TCP_RCVD_MAGIC\t(0x744E6350)\n\nstatic int __ncptcp_rcv_proc(struct ncp_server *server)\n{\n\t/* We have to check the result, so store the complete header */\n\twhile (1) {\n\t\tint result;\n\t\tstruct ncp_request_reply *req;\n\t\tint datalen;\n\t\tint type;\n\n\t\twhile (server->rcv.len) {\n\t\t\tresult = do_tcp_rcv(server, server->rcv.ptr, server->rcv.len);\n\t\t\tif (result == -EAGAIN) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (result <= 0) {\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (req) {\n\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t} else {\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t}\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tpr_err(\"tcp: error in recvmsg: %d\\n\", result);\n\t\t\t\t} else {\n\t\t\t\t\tncp_dbg(1, \"tcp: EOF\\n\");\n\t\t\t\t}\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (server->rcv.ptr) {\n\t\t\t\tserver->rcv.ptr += result;\n\t\t\t}\n\t\t\tserver->rcv.len -= result;\n\t\t}\n\t\tswitch (server->rcv.state) {\n\t\t\tcase 0:\n\t\t\t\tif (server->rcv.buf.magic != htonl(NCP_TCP_RCVD_MAGIC)) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply type %08X\\n\", ntohl(server->rcv.buf.magic));\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tdatalen = ntohl(server->rcv.buf.len) & 0x0FFFFFFF;\n\t\t\t\tif (datalen < 10) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d\\n\", datalen);\n\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\t\tif (server->sign_active) {\n\t\t\t\t\tif (datalen < 18) {\n\t\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d\\n\", datalen);\n\t\t\t\t\t\t__ncptcp_abort(server);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tserver->rcv.buf.len = datalen - 8;\n\t\t\t\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf.p1;\n\t\t\t\t\tserver->rcv.len = 8;\n\t\t\t\t\tserver->rcv.state = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\t\t\t\t\n\t\t\t\ttype = ntohs(server->rcv.buf.type);\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\ncont:;\t\t\t\t\n#endif\n\t\t\t\tif (type != NCP_REPLY) {\n\t\t\t\t\tif (datalen - 8 <= sizeof(server->unexpected_packet.data)) {\n\t\t\t\t\t\t*(__u16*)(server->unexpected_packet.data) = htons(type);\n\t\t\t\t\t\tserver->unexpected_packet.len = datalen - 8;\n\n\t\t\t\t\t\tserver->rcv.state = 5;\n\t\t\t\t\t\tserver->rcv.ptr = server->unexpected_packet.data + 2;\n\t\t\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\tncp_dbg(1, \"tcp: Unexpected NCP type %02X\\n\", type);\nskipdata2:;\n\t\t\t\t\tserver->rcv.state = 2;\nskipdata:;\n\t\t\t\t\tserver->rcv.ptr = NULL;\n\t\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (!req) {\n\t\t\t\t\tncp_dbg(1, \"Reply without appropriate request\\n\");\n\t\t\t\t\tgoto skipdata2;\n\t\t\t\t}\n\t\t\t\tif (datalen > req->datalen + 8) {\n\t\t\t\t\tpr_err(\"tcp: Unexpected reply len %d (expected at most %Zd)\\n\", datalen, req->datalen + 8);\n\t\t\t\t\tserver->rcv.state = 3;\n\t\t\t\t\tgoto skipdata;\n\t\t\t\t}\n\t\t\t\treq->datalen = datalen - 8;\n\t\t\t\t((struct ncp_reply_header*)server->rxbuf)->type = NCP_REPLY;\n\t\t\t\tserver->rcv.ptr = server->rxbuf + 2;\n\t\t\t\tserver->rcv.len = datalen - 10;\n\t\t\t\tserver->rcv.state = 1;\n\t\t\t\tbreak;\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\tcase 4:\n\t\t\t\tdatalen = server->rcv.buf.len;\n\t\t\t\ttype = ntohs(server->rcv.buf.type2);\n\t\t\t\tgoto cont;\n#endif\n\t\t\tcase 1:\n\t\t\t\treq = server->rcv.creq;\n\t\t\t\tif (req->tx_type != NCP_ALLOC_SLOT_REQUEST) {\n\t\t\t\t\tif (((struct ncp_reply_header*)server->rxbuf)->sequence != server->sequence) {\n\t\t\t\t\t\tpr_err(\"tcp: Bad sequence number\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tif ((((struct ncp_reply_header*)server->rxbuf)->conn_low | (((struct ncp_reply_header*)server->rxbuf)->conn_high << 8)) != server->connection) {\n\t\t\t\t\t\tpr_err(\"tcp: Connection number mismatch\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\t\t\t\t\n\t\t\t\tif (server->sign_active && req->tx_type != NCP_DEALLOC_SLOT_REQUEST) {\n\t\t\t\t\tif (sign_verify_reply(server, server->rxbuf + 6, req->datalen - 6, cpu_to_be32(req->datalen + 16), &server->rcv.buf.type)) {\n\t\t\t\t\t\tpr_err(\"tcp: Signature violation\\n\");\n\t\t\t\t\t\t__ncp_abort_request(server, req, -EIO);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\t\t\t\t\n\t\t\t\tncp_finish_request(server, req, req->datalen);\n\t\t\tnextreq:;\n\t\t\t\t__ncp_next_request(server);\n\t\t\tcase 2:\n\t\t\tnext:;\n\t\t\t\tserver->rcv.ptr = (unsigned char*)&server->rcv.buf;\n\t\t\t\tserver->rcv.len = 10;\n\t\t\t\tserver->rcv.state = 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tncp_finish_request(server, server->rcv.creq, -EIO);\n\t\t\t\tgoto nextreq;\n\t\t\tcase 5:\n\t\t\t\tinfo_server(server, 0, server->unexpected_packet.data, server->unexpected_packet.len);\n\t\t\t\tgoto next;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "do_tcp_rcv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "510-532",
    "snippet": "static int do_tcp_rcv(struct ncp_server *server, void *buffer, size_t len)\n{\n\tint result;\n\t\n\tif (buffer) {\n\t\tresult = _recv(server->ncp_sock, buffer, len, MSG_DONTWAIT);\n\t} else {\n\t\tstatic unsigned char dummy[1024];\n\t\t\t\n\t\tif (len > sizeof(dummy)) {\n\t\t\tlen = sizeof(dummy);\n\t\t}\n\t\tresult = _recv(server->ncp_sock, dummy, len, MSG_DONTWAIT);\n\t}\n\tif (result < 0) {\n\t\treturn result;\n\t}\n\tif (result > len) {\n\t\tpr_err(\"tcp: bug in recvmsg (%u > %Zu)\\n\", result, len);\n\t\treturn -EIO;\t\t\t\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: bug in recvmsg (%u > %Zu)\\n\"",
            "result",
            "len"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_recv",
          "args": [
            "server->ncp_sock",
            "dummy",
            "len",
            "MSG_DONTWAIT"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "36-41",
          "snippet": "static int _recv(struct socket *sock, void *buf, int size, unsigned flags)\n{\n\tstruct msghdr msg = {NULL, };\n\tstruct kvec iov = {buf, size};\n\treturn kernel_recvmsg(sock, &msg, &iov, 1, size, flags);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int _recv(struct socket *sock, void *buf, int size, unsigned flags)\n{\n\tstruct msghdr msg = {NULL, };\n\tstruct kvec iov = {buf, size};\n\treturn kernel_recvmsg(sock, &msg, &iov, 1, size, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int do_tcp_rcv(struct ncp_server *server, void *buffer, size_t len)\n{\n\tint result;\n\t\n\tif (buffer) {\n\t\tresult = _recv(server->ncp_sock, buffer, len, MSG_DONTWAIT);\n\t} else {\n\t\tstatic unsigned char dummy[1024];\n\t\t\t\n\t\tif (len > sizeof(dummy)) {\n\t\t\tlen = sizeof(dummy);\n\t\t}\n\t\tresult = _recv(server->ncp_sock, dummy, len, MSG_DONTWAIT);\n\t}\n\tif (result < 0) {\n\t\treturn result;\n\t}\n\tif (result > len) {\n\t\tpr_err(\"tcp: bug in recvmsg (%u > %Zu)\\n\", result, len);\n\t\treturn -EIO;\t\t\t\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "ncpdgram_timeout_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "501-508",
    "snippet": "void ncpdgram_timeout_proc(struct work_struct *work)\n{\n\tstruct ncp_server *server =\n\t\tcontainer_of(work, struct ncp_server, timeout_tq);\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncpdgram_timeout_proc(server);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ncpdgram_timeout_proc",
          "args": [
            "server"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "__ncpdgram_timeout_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "473-499",
          "snippet": "static void __ncpdgram_timeout_proc(struct ncp_server *server)\n{\n\t/* If timer is pending, we are processing another request... */\n\tif (!timer_pending(&server->timeout_tm)) {\n\t\tstruct ncp_request_reply* req;\n\t\t\n\t\treq = server->rcv.creq;\n\t\tif (req) {\n\t\t\tint timeout;\n\t\t\t\n\t\t\tif (server->m.flags & NCP_MOUNT_SOFT) {\n\t\t\t\tif (server->timeout_retries-- == 0) {\n\t\t\t\t\t__ncp_abort_request(server, req, -ETIMEDOUT);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Ignore errors */\n\t\t\tncpdgram_send(server->ncp_sock, req);\n\t\t\ttimeout = server->timeout_last << 1;\n\t\t\tif (timeout > NCP_MAX_RPC_TIMEOUT) {\n\t\t\t\ttimeout = NCP_MAX_RPC_TIMEOUT;\n\t\t\t}\n\t\t\tserver->timeout_last = timeout;\n\t\t\tmod_timer(&server->timeout_tm, jiffies + timeout);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __ncpdgram_timeout_proc(struct ncp_server *server)\n{\n\t/* If timer is pending, we are processing another request... */\n\tif (!timer_pending(&server->timeout_tm)) {\n\t\tstruct ncp_request_reply* req;\n\t\t\n\t\treq = server->rcv.creq;\n\t\tif (req) {\n\t\t\tint timeout;\n\t\t\t\n\t\t\tif (server->m.flags & NCP_MOUNT_SOFT) {\n\t\t\t\tif (server->timeout_retries-- == 0) {\n\t\t\t\t\t__ncp_abort_request(server, req, -ETIMEDOUT);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Ignore errors */\n\t\t\tncpdgram_send(server->ncp_sock, req);\n\t\t\ttimeout = server->timeout_last << 1;\n\t\t\tif (timeout > NCP_MAX_RPC_TIMEOUT) {\n\t\t\t\ttimeout = NCP_MAX_RPC_TIMEOUT;\n\t\t\t}\n\t\t\tserver->timeout_last = timeout;\n\t\t\tmod_timer(&server->timeout_tm, jiffies + timeout);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structncp_server",
            "timeout_tq"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncpdgram_timeout_proc(struct work_struct *work)\n{\n\tstruct ncp_server *server =\n\t\tcontainer_of(work, struct ncp_server, timeout_tq);\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncpdgram_timeout_proc(server);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}"
  },
  {
    "function_name": "__ncpdgram_timeout_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "473-499",
    "snippet": "static void __ncpdgram_timeout_proc(struct ncp_server *server)\n{\n\t/* If timer is pending, we are processing another request... */\n\tif (!timer_pending(&server->timeout_tm)) {\n\t\tstruct ncp_request_reply* req;\n\t\t\n\t\treq = server->rcv.creq;\n\t\tif (req) {\n\t\t\tint timeout;\n\t\t\t\n\t\t\tif (server->m.flags & NCP_MOUNT_SOFT) {\n\t\t\t\tif (server->timeout_retries-- == 0) {\n\t\t\t\t\t__ncp_abort_request(server, req, -ETIMEDOUT);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Ignore errors */\n\t\t\tncpdgram_send(server->ncp_sock, req);\n\t\t\ttimeout = server->timeout_last << 1;\n\t\t\tif (timeout > NCP_MAX_RPC_TIMEOUT) {\n\t\t\t\ttimeout = NCP_MAX_RPC_TIMEOUT;\n\t\t\t}\n\t\t\tserver->timeout_last = timeout;\n\t\t\tmod_timer(&server->timeout_tm, jiffies + timeout);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&server->timeout_tm",
            "jiffies + timeout"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncpdgram_send",
          "args": [
            "server->ncp_sock",
            "req"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ncpdgram_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "206-213",
          "snippet": "static int ncpdgram_send(struct socket *sock, struct ncp_request_reply *req)\n{\n\tstruct kvec vec[3];\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(vec, req->tx_ciov, req->tx_iovlen * sizeof(vec[0]));\n\treturn do_send(sock, vec, req->tx_iovlen,\n\t\t       req->tx_totallen, MSG_DONTWAIT);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncpdgram_send(struct socket *sock, struct ncp_request_reply *req)\n{\n\tstruct kvec vec[3];\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(vec, req->tx_ciov, req->tx_iovlen * sizeof(vec[0]));\n\treturn do_send(sock, vec, req->tx_iovlen,\n\t\t       req->tx_totallen, MSG_DONTWAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ncp_abort_request",
          "args": [
            "server",
            "req",
            "-ETIMEDOUT"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_abort_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "175-192",
          "snippet": "static inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&server->timeout_tm"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __ncpdgram_timeout_proc(struct ncp_server *server)\n{\n\t/* If timer is pending, we are processing another request... */\n\tif (!timer_pending(&server->timeout_tm)) {\n\t\tstruct ncp_request_reply* req;\n\t\t\n\t\treq = server->rcv.creq;\n\t\tif (req) {\n\t\t\tint timeout;\n\t\t\t\n\t\t\tif (server->m.flags & NCP_MOUNT_SOFT) {\n\t\t\t\tif (server->timeout_retries-- == 0) {\n\t\t\t\t\t__ncp_abort_request(server, req, -ETIMEDOUT);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Ignore errors */\n\t\t\tncpdgram_send(server->ncp_sock, req);\n\t\t\ttimeout = server->timeout_last << 1;\n\t\t\tif (timeout > NCP_MAX_RPC_TIMEOUT) {\n\t\t\t\ttimeout = NCP_MAX_RPC_TIMEOUT;\n\t\t\t}\n\t\t\tserver->timeout_last = timeout;\n\t\t\tmod_timer(&server->timeout_tm, jiffies + timeout);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ncpdgram_rcv_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "382-471",
    "snippet": "void ncpdgram_rcv_proc(struct work_struct *work)\n{\n\tstruct ncp_server *server =\n\t\tcontainer_of(work, struct ncp_server, rcv.tq);\n\tstruct socket* sock;\n\t\n\tsock = server->ncp_sock;\n\t\n\twhile (1) {\n\t\tstruct ncp_reply_header reply;\n\t\tint result;\n\n\t\tresult = _recv(sock, &reply, sizeof(reply), MSG_PEEK | MSG_DONTWAIT);\n\t\tif (result < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (result >= sizeof(reply)) {\n\t\t\tstruct ncp_request_reply *req;\n\t\n\t\t\tif (reply.type == NCP_WATCHDOG) {\n\t\t\t\tunsigned char buf[10];\n\n\t\t\t\tif (server->connection != get_conn_number(&reply)) {\n\t\t\t\t\tgoto drop;\n\t\t\t\t}\n\t\t\t\tresult = _recv(sock, buf, sizeof(buf), MSG_DONTWAIT);\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tncp_dbg(1, \"recv failed with %d\\n\", result);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (result < 10) {\n\t\t\t\t\tncp_dbg(1, \"too short (%u) watchdog packet\\n\", result);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (buf[9] != '?') {\n\t\t\t\t\tncp_dbg(1, \"bad signature (%02X) in watchdog packet\\n\", buf[9]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbuf[9] = 'Y';\n\t\t\t\t_send(sock, buf, sizeof(buf));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (reply.type != NCP_POSITIVE_ACK && reply.type != NCP_REPLY) {\n\t\t\t\tresult = _recv(sock, server->unexpected_packet.data, sizeof(server->unexpected_packet.data), MSG_DONTWAIT);\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tinfo_server(server, 0, server->unexpected_packet.data, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmutex_lock(&server->rcv.creq_mutex);\n\t\t\treq = server->rcv.creq;\n\t\t\tif (req && (req->tx_type == NCP_ALLOC_SLOT_REQUEST || (server->sequence == reply.sequence && \n\t\t\t\t\tserver->connection == get_conn_number(&reply)))) {\n\t\t\t\tif (reply.type == NCP_POSITIVE_ACK) {\n\t\t\t\t\tserver->timeout_retries = server->m.retry_count;\n\t\t\t\t\tserver->timeout_last = NCP_MAX_RPC_TIMEOUT;\n\t\t\t\t\tmod_timer(&server->timeout_tm, jiffies + NCP_MAX_RPC_TIMEOUT);\n\t\t\t\t} else if (reply.type == NCP_REPLY) {\n\t\t\t\t\tresult = _recv(sock, server->rxbuf, req->datalen, MSG_DONTWAIT);\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\t\t\t\t\tif (result >= 0 && server->sign_active && req->tx_type != NCP_DEALLOC_SLOT_REQUEST) {\n\t\t\t\t\t\tif (result < 8 + 8) {\n\t\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tunsigned int hdrl;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresult -= 8;\n\t\t\t\t\t\t\thdrl = sock->sk->sk_family == AF_INET ? 8 : 6;\n\t\t\t\t\t\t\tif (sign_verify_reply(server, server->rxbuf + hdrl, result - hdrl, cpu_to_le32(result), server->rxbuf + result)) {\n\t\t\t\t\t\t\t\tpr_info(\"Signature violation\\n\");\n\t\t\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tdel_timer(&server->timeout_tm);\n\t\t\t\t     \tserver->rcv.creq = NULL;\n\t\t\t\t\tncp_finish_request(server, req, result);\n\t\t\t\t\t__ncp_next_request(server);\n\t\t\t\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\t}\ndrop:;\t\t\n\t\t_recv(sock, &reply, sizeof(reply), MSG_DONTWAIT);\n\t}\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_recv",
          "args": [
            "sock",
            "&reply",
            "sizeof(reply)",
            "MSG_DONTWAIT"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "36-41",
          "snippet": "static int _recv(struct socket *sock, void *buf, int size, unsigned flags)\n{\n\tstruct msghdr msg = {NULL, };\n\tstruct kvec iov = {buf, size};\n\treturn kernel_recvmsg(sock, &msg, &iov, 1, size, flags);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int _recv(struct socket *sock, void *buf, int size, unsigned flags)\n{\n\tstruct msghdr msg = {NULL, };\n\tstruct kvec iov = {buf, size};\n\treturn kernel_recvmsg(sock, &msg, &iov, 1, size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ncp_next_request",
          "args": [
            "server"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_next_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "351-362",
          "snippet": "static void __ncp_next_request(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tserver->rcv.creq = NULL;\n\tif (list_empty(&server->tx.requests)) {\n\t\treturn;\n\t}\n\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\tlist_del_init(&req->req);\n\t__ncp_start_request(server, req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __ncp_next_request(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tserver->rcv.creq = NULL;\n\tif (list_empty(&server->tx.requests)) {\n\t\treturn;\n\t}\n\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\tlist_del_init(&req->req);\n\t__ncp_start_request(server, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_finish_request",
          "args": [
            "server",
            "req",
            "result"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_finish_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "134-142",
          "snippet": "static inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&server->timeout_tm"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Signature violation\\n\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sign_verify_reply",
          "args": [
            "server",
            "server->rxbuf + hdrl",
            "result - hdrl",
            "cpu_to_le32(result)",
            "server->rxbuf + result"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "sign_verify_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.c",
          "lines": "110-124",
          "snippet": "int sign_verify_reply(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, const void *sign_buff) {\n\tunsigned char data[64];\n\tunsigned char hash[16];\n\n\tmemcpy(data, server->sign_root, 8);\n\t*(__u32*)(data + 8) = totalsize;\n\tif (size < 52) {\n\t\tmemcpy(data + 12, packet, size);\n\t\tmemset(data + 12 + size, 0, 52 - size);\n\t} else {\n\t\tmemcpy(data + 12, packet, 52);\n\t}\n\tnwsign(server->sign_last, data, hash);\n\treturn memcmp(sign_buff, hash, 8);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/ncp.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/bitops.h>\n#include <linux/ncp.h>\n#include <linux/string.h>\n\nint sign_verify_reply(struct ncp_server *server, const char *packet, size_t size, __u32 totalsize, const void *sign_buff) {\n\tunsigned char data[64];\n\tunsigned char hash[16];\n\n\tmemcpy(data, server->sign_root, 8);\n\t*(__u32*)(data + 8) = totalsize;\n\tif (size < 52) {\n\t\tmemcpy(data + 12, packet, size);\n\t\tmemset(data + 12 + size, 0, 52 - size);\n\t} else {\n\t\tmemcpy(data + 12, packet, 52);\n\t}\n\tnwsign(server->sign_last, data, hash);\n\treturn memcmp(sign_buff, hash, 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "result"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&server->timeout_tm",
            "jiffies + NCP_MAX_RPC_TIMEOUT"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_conn_number",
          "args": [
            "&reply"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "get_conn_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "170-173",
          "snippet": "static inline int get_conn_number(struct ncp_reply_header *rp)\n{\n\treturn rp->conn_low | (rp->conn_high << 8);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int get_conn_number(struct ncp_reply_header *rp)\n{\n\treturn rp->conn_low | (rp->conn_high << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info_server",
          "args": [
            "server",
            "0",
            "server->unexpected_packet.data",
            "result"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "info_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "364-380",
          "snippet": "static void info_server(struct ncp_server *server, unsigned int id, const void * data, size_t len)\n{\n\tif (server->info_sock) {\n\t\tstruct kvec iov[2];\n\t\t__be32 hdr[2];\n\t\n\t\thdr[0] = cpu_to_be32(len + 8);\n\t\thdr[1] = cpu_to_be32(id);\n\t\n\t\tiov[0].iov_base = hdr;\n\t\tiov[0].iov_len = 8;\n\t\tiov[1].iov_base = (void *) data;\n\t\tiov[1].iov_len = len;\n\n\t\tdo_send(server->info_sock, iov, 2, len + 8, MSG_NOSIGNAL);\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void info_server(struct ncp_server *server, unsigned int id, const void * data, size_t len)\n{\n\tif (server->info_sock) {\n\t\tstruct kvec iov[2];\n\t\t__be32 hdr[2];\n\t\n\t\thdr[0] = cpu_to_be32(len + 8);\n\t\thdr[1] = cpu_to_be32(id);\n\t\n\t\tiov[0].iov_base = hdr;\n\t\tiov[0].iov_len = 8;\n\t\tiov[1].iov_base = (void *) data;\n\t\tiov[1].iov_len = len;\n\n\t\tdo_send(server->info_sock, iov, 2, len + 8, MSG_NOSIGNAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_send",
          "args": [
            "sock",
            "buf",
            "sizeof(buf)"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "50-56",
          "snippet": "static int _send(struct socket *sock, const void *buff, int len)\n{\n\tstruct kvec vec;\n\tvec.iov_base = (void *) buff;\n\tvec.iov_len = len;\n\treturn do_send(sock, &vec, 1, len, 0);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int _send(struct socket *sock, const void *buff, int len)\n{\n\tstruct kvec vec;\n\tvec.iov_base = (void *) buff;\n\tvec.iov_len = len;\n\treturn do_send(sock, &vec, 1, len, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"bad signature (%02X) in watchdog packet\\n\"",
            "buf[9]"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"too short (%u) watchdog packet\\n\"",
            "result"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"recv failed with %d\\n\"",
            "result"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structncp_server",
            "rcv.tq"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncpdgram_rcv_proc(struct work_struct *work)\n{\n\tstruct ncp_server *server =\n\t\tcontainer_of(work, struct ncp_server, rcv.tq);\n\tstruct socket* sock;\n\t\n\tsock = server->ncp_sock;\n\t\n\twhile (1) {\n\t\tstruct ncp_reply_header reply;\n\t\tint result;\n\n\t\tresult = _recv(sock, &reply, sizeof(reply), MSG_PEEK | MSG_DONTWAIT);\n\t\tif (result < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (result >= sizeof(reply)) {\n\t\t\tstruct ncp_request_reply *req;\n\t\n\t\t\tif (reply.type == NCP_WATCHDOG) {\n\t\t\t\tunsigned char buf[10];\n\n\t\t\t\tif (server->connection != get_conn_number(&reply)) {\n\t\t\t\t\tgoto drop;\n\t\t\t\t}\n\t\t\t\tresult = _recv(sock, buf, sizeof(buf), MSG_DONTWAIT);\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tncp_dbg(1, \"recv failed with %d\\n\", result);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (result < 10) {\n\t\t\t\t\tncp_dbg(1, \"too short (%u) watchdog packet\\n\", result);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (buf[9] != '?') {\n\t\t\t\t\tncp_dbg(1, \"bad signature (%02X) in watchdog packet\\n\", buf[9]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbuf[9] = 'Y';\n\t\t\t\t_send(sock, buf, sizeof(buf));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (reply.type != NCP_POSITIVE_ACK && reply.type != NCP_REPLY) {\n\t\t\t\tresult = _recv(sock, server->unexpected_packet.data, sizeof(server->unexpected_packet.data), MSG_DONTWAIT);\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tinfo_server(server, 0, server->unexpected_packet.data, result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmutex_lock(&server->rcv.creq_mutex);\n\t\t\treq = server->rcv.creq;\n\t\t\tif (req && (req->tx_type == NCP_ALLOC_SLOT_REQUEST || (server->sequence == reply.sequence && \n\t\t\t\t\tserver->connection == get_conn_number(&reply)))) {\n\t\t\t\tif (reply.type == NCP_POSITIVE_ACK) {\n\t\t\t\t\tserver->timeout_retries = server->m.retry_count;\n\t\t\t\t\tserver->timeout_last = NCP_MAX_RPC_TIMEOUT;\n\t\t\t\t\tmod_timer(&server->timeout_tm, jiffies + NCP_MAX_RPC_TIMEOUT);\n\t\t\t\t} else if (reply.type == NCP_REPLY) {\n\t\t\t\t\tresult = _recv(sock, server->rxbuf, req->datalen, MSG_DONTWAIT);\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\t\t\t\t\tif (result >= 0 && server->sign_active && req->tx_type != NCP_DEALLOC_SLOT_REQUEST) {\n\t\t\t\t\t\tif (result < 8 + 8) {\n\t\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tunsigned int hdrl;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresult -= 8;\n\t\t\t\t\t\t\thdrl = sock->sk->sk_family == AF_INET ? 8 : 6;\n\t\t\t\t\t\t\tif (sign_verify_reply(server, server->rxbuf + hdrl, result - hdrl, cpu_to_le32(result), server->rxbuf + result)) {\n\t\t\t\t\t\t\t\tpr_info(\"Signature violation\\n\");\n\t\t\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tdel_timer(&server->timeout_tm);\n\t\t\t\t     \tserver->rcv.creq = NULL;\n\t\t\t\t\tncp_finish_request(server, req, result);\n\t\t\t\t\t__ncp_next_request(server);\n\t\t\t\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\t}\ndrop:;\t\t\n\t\t_recv(sock, &reply, sizeof(reply), MSG_DONTWAIT);\n\t}\n}"
  },
  {
    "function_name": "info_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "364-380",
    "snippet": "static void info_server(struct ncp_server *server, unsigned int id, const void * data, size_t len)\n{\n\tif (server->info_sock) {\n\t\tstruct kvec iov[2];\n\t\t__be32 hdr[2];\n\t\n\t\thdr[0] = cpu_to_be32(len + 8);\n\t\thdr[1] = cpu_to_be32(id);\n\t\n\t\tiov[0].iov_base = hdr;\n\t\tiov[0].iov_len = 8;\n\t\tiov[1].iov_base = (void *) data;\n\t\tiov[1].iov_len = len;\n\n\t\tdo_send(server->info_sock, iov, 2, len + 8, MSG_NOSIGNAL);\n\t}\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send",
          "args": [
            "server->info_sock",
            "iov",
            "2",
            "len + 8",
            "MSG_NOSIGNAL"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "do_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "43-48",
          "snippet": "static inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "id"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len + 8"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void info_server(struct ncp_server *server, unsigned int id, const void * data, size_t len)\n{\n\tif (server->info_sock) {\n\t\tstruct kvec iov[2];\n\t\t__be32 hdr[2];\n\t\n\t\thdr[0] = cpu_to_be32(len + 8);\n\t\thdr[1] = cpu_to_be32(id);\n\t\n\t\tiov[0].iov_base = hdr;\n\t\tiov[0].iov_len = 8;\n\t\tiov[1].iov_base = (void *) data;\n\t\tiov[1].iov_len = len;\n\n\t\tdo_send(server->info_sock, iov, 2, len + 8, MSG_NOSIGNAL);\n\t}\n}"
  },
  {
    "function_name": "__ncp_next_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "351-362",
    "snippet": "static void __ncp_next_request(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tserver->rcv.creq = NULL;\n\tif (list_empty(&server->tx.requests)) {\n\t\treturn;\n\t}\n\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\tlist_del_init(&req->req);\n\t__ncp_start_request(server, req);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ncp_start_request",
          "args": [
            "server",
            "req"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_start_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "318-329",
          "snippet": "static inline void __ncp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\t/* we copy the data so that we do not depend on the caller\n\t   staying alive */\n\tmemcpy(server->txbuf, req->tx_iov[1].iov_base, req->tx_iov[1].iov_len);\n\treq->tx_iov[1].iov_base = server->txbuf;\n\n\tif (server->ncp_sock->type == SOCK_STREAM)\n\t\tncptcp_start_request(server, req);\n\telse\n\t\tncpdgram_start_request(server, req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\t/* we copy the data so that we do not depend on the caller\n\t   staying alive */\n\tmemcpy(server->txbuf, req->tx_iov[1].iov_base, req->tx_iov[1].iov_len);\n\treq->tx_iov[1].iov_base = server->txbuf;\n\n\tif (server->ncp_sock->type == SOCK_STREAM)\n\t\tncptcp_start_request(server, req);\n\telse\n\t\tncpdgram_start_request(server, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->req"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "server->tx.requests.next",
            "structncp_request_reply",
            "req"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&server->tx.requests"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __ncp_next_request(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tserver->rcv.creq = NULL;\n\tif (list_empty(&server->tx.requests)) {\n\t\treturn;\n\t}\n\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\tlist_del_init(&req->req);\n\t__ncp_start_request(server, req);\n}"
  },
  {
    "function_name": "ncp_add_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "331-349",
    "snippet": "static int ncp_add_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tmutex_lock(&server->rcv.creq_mutex);\n\tif (!ncp_conn_valid(server)) {\n\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\tpr_err(\"tcp: Server died\\n\");\n\t\treturn -EIO;\n\t}\n\tncp_req_get(req);\n\tif (server->tx.creq || server->rcv.creq) {\n\t\treq->status = RQ_QUEUED;\n\t\tlist_add_tail(&req->req, &server->tx.requests);\n\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\treturn 0;\n\t}\n\t__ncp_start_request(server, req);\n\tmutex_unlock(&server->rcv.creq_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ncp_start_request",
          "args": [
            "server",
            "req"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_start_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "318-329",
          "snippet": "static inline void __ncp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\t/* we copy the data so that we do not depend on the caller\n\t   staying alive */\n\tmemcpy(server->txbuf, req->tx_iov[1].iov_base, req->tx_iov[1].iov_len);\n\treq->tx_iov[1].iov_base = server->txbuf;\n\n\tif (server->ncp_sock->type == SOCK_STREAM)\n\t\tncptcp_start_request(server, req);\n\telse\n\t\tncpdgram_start_request(server, req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\t/* we copy the data so that we do not depend on the caller\n\t   staying alive */\n\tmemcpy(server->txbuf, req->tx_iov[1].iov_base, req->tx_iov[1].iov_len);\n\treq->tx_iov[1].iov_base = server->txbuf;\n\n\tif (server->ncp_sock->type == SOCK_STREAM)\n\t\tncptcp_start_request(server, req);\n\telse\n\t\tncpdgram_start_request(server, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->req",
            "&server->tx.requests"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_req_get",
          "args": [
            "req"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_req_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "89-92",
          "snippet": "static void ncp_req_get(struct ncp_request_reply *req)\n{\n\tatomic_inc(&req->refs);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_req_get(struct ncp_request_reply *req)\n{\n\tatomic_inc(&req->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Server died\\n\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_conn_valid",
          "args": [
            "server"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_conn_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs_sb.h",
          "lines": "164-167",
          "snippet": "static inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/net.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/ncp_mount.h>\n#include <linux/types.h>\n\nstatic inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_add_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tmutex_lock(&server->rcv.creq_mutex);\n\tif (!ncp_conn_valid(server)) {\n\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\tpr_err(\"tcp: Server died\\n\");\n\t\treturn -EIO;\n\t}\n\tncp_req_get(req);\n\tif (server->tx.creq || server->rcv.creq) {\n\t\treq->status = RQ_QUEUED;\n\t\tlist_add_tail(&req->req, &server->tx.requests);\n\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\treturn 0;\n\t}\n\t__ncp_start_request(server, req);\n\tmutex_unlock(&server->rcv.creq_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "__ncp_start_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "318-329",
    "snippet": "static inline void __ncp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\t/* we copy the data so that we do not depend on the caller\n\t   staying alive */\n\tmemcpy(server->txbuf, req->tx_iov[1].iov_base, req->tx_iov[1].iov_len);\n\treq->tx_iov[1].iov_base = server->txbuf;\n\n\tif (server->ncp_sock->type == SOCK_STREAM)\n\t\tncptcp_start_request(server, req);\n\telse\n\t\tncpdgram_start_request(server, req);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncpdgram_start_request",
          "args": [
            "server",
            "req"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ncpdgram_start_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "264-287",
          "snippet": "static void ncpdgram_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tsize_t signlen;\n\tstruct ncp_request_header* h;\n\t\n\treq->tx_ciov = req->tx_iov + 1;\n\n\th = req->tx_iov[1].iov_base;\n\tncp_init_header(server, req, h);\n\tsignlen = sign_packet(server, req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1, \n\t\t\treq->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1,\n\t\t\tcpu_to_le32(req->tx_totallen), req->sign);\n\tif (signlen) {\n\t\treq->tx_ciov[1].iov_base = req->sign;\n\t\treq->tx_ciov[1].iov_len = signlen;\n\t\treq->tx_iovlen += 1;\n\t\treq->tx_totallen += signlen;\n\t}\n\tserver->rcv.creq = req;\n\tserver->timeout_last = server->m.time_out;\n\tserver->timeout_retries = server->m.retry_count;\n\tncpdgram_send(server->ncp_sock, req);\n\tmod_timer(&server->timeout_tm, jiffies + server->m.time_out);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncpdgram_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tsize_t signlen;\n\tstruct ncp_request_header* h;\n\t\n\treq->tx_ciov = req->tx_iov + 1;\n\n\th = req->tx_iov[1].iov_base;\n\tncp_init_header(server, req, h);\n\tsignlen = sign_packet(server, req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1, \n\t\t\treq->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1,\n\t\t\tcpu_to_le32(req->tx_totallen), req->sign);\n\tif (signlen) {\n\t\treq->tx_ciov[1].iov_base = req->sign;\n\t\treq->tx_ciov[1].iov_len = signlen;\n\t\treq->tx_iovlen += 1;\n\t\treq->tx_totallen += signlen;\n\t}\n\tserver->rcv.creq = req;\n\tserver->timeout_last = server->m.time_out;\n\tserver->timeout_retries = server->m.retry_count;\n\tncpdgram_send(server->ncp_sock, req);\n\tmod_timer(&server->timeout_tm, jiffies + server->m.time_out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncptcp_start_request",
          "args": [
            "server",
            "req"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ncptcp_start_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "293-316",
          "snippet": "static void ncptcp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tsize_t signlen;\n\tstruct ncp_request_header* h;\n\n\treq->tx_ciov = req->tx_iov;\n\th = req->tx_iov[1].iov_base;\n\tncp_init_header(server, req, h);\n\tsignlen = sign_packet(server, req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1,\n\t\t\treq->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1,\n\t\t\tcpu_to_be32(req->tx_totallen + 24), req->sign + 4) + 16;\n\n\treq->sign[0] = htonl(NCP_TCP_XMIT_MAGIC);\n\treq->sign[1] = htonl(req->tx_totallen + signlen);\n\treq->sign[2] = htonl(NCP_TCP_XMIT_VERSION);\n\treq->sign[3] = htonl(req->datalen + 8);\n\treq->tx_iov[0].iov_base = req->sign;\n\treq->tx_iov[0].iov_len = signlen;\n\treq->tx_iovlen += 1;\n\treq->tx_totallen += signlen;\n\n\tserver->tx.creq = req;\n\t__ncptcp_try_send(server);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define NCP_TCP_XMIT_VERSION\t(1)",
            "#define NCP_TCP_XMIT_MAGIC\t(0x446D6454)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\n#define NCP_TCP_XMIT_VERSION\t(1)\n#define NCP_TCP_XMIT_MAGIC\t(0x446D6454)\n\nstatic void ncptcp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tsize_t signlen;\n\tstruct ncp_request_header* h;\n\n\treq->tx_ciov = req->tx_iov;\n\th = req->tx_iov[1].iov_base;\n\tncp_init_header(server, req, h);\n\tsignlen = sign_packet(server, req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1,\n\t\t\treq->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1,\n\t\t\tcpu_to_be32(req->tx_totallen + 24), req->sign + 4) + 16;\n\n\treq->sign[0] = htonl(NCP_TCP_XMIT_MAGIC);\n\treq->sign[1] = htonl(req->tx_totallen + signlen);\n\treq->sign[2] = htonl(NCP_TCP_XMIT_VERSION);\n\treq->sign[3] = htonl(req->datalen + 8);\n\treq->tx_iov[0].iov_base = req->sign;\n\treq->tx_iov[0].iov_len = signlen;\n\treq->tx_iovlen += 1;\n\treq->tx_totallen += signlen;\n\n\tserver->tx.creq = req;\n\t__ncptcp_try_send(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server->txbuf",
            "req->tx_iov[1].iov_base",
            "req->tx_iov[1].iov_len"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\t/* we copy the data so that we do not depend on the caller\n\t   staying alive */\n\tmemcpy(server->txbuf, req->tx_iov[1].iov_base, req->tx_iov[1].iov_len);\n\treq->tx_iov[1].iov_base = server->txbuf;\n\n\tif (server->ncp_sock->type == SOCK_STREAM)\n\t\tncptcp_start_request(server, req);\n\telse\n\t\tncpdgram_start_request(server, req);\n}"
  },
  {
    "function_name": "ncptcp_start_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "293-316",
    "snippet": "static void ncptcp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tsize_t signlen;\n\tstruct ncp_request_header* h;\n\n\treq->tx_ciov = req->tx_iov;\n\th = req->tx_iov[1].iov_base;\n\tncp_init_header(server, req, h);\n\tsignlen = sign_packet(server, req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1,\n\t\t\treq->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1,\n\t\t\tcpu_to_be32(req->tx_totallen + 24), req->sign + 4) + 16;\n\n\treq->sign[0] = htonl(NCP_TCP_XMIT_MAGIC);\n\treq->sign[1] = htonl(req->tx_totallen + signlen);\n\treq->sign[2] = htonl(NCP_TCP_XMIT_VERSION);\n\treq->sign[3] = htonl(req->datalen + 8);\n\treq->tx_iov[0].iov_base = req->sign;\n\treq->tx_iov[0].iov_len = signlen;\n\treq->tx_iovlen += 1;\n\treq->tx_totallen += signlen;\n\n\tserver->tx.creq = req;\n\t__ncptcp_try_send(server);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define NCP_TCP_XMIT_VERSION\t(1)",
      "#define NCP_TCP_XMIT_MAGIC\t(0x446D6454)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ncptcp_try_send",
          "args": [
            "server"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__ncptcp_try_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "215-254",
          "snippet": "static void __ncptcp_try_send(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *rq;\n\tstruct kvec *iov;\n\tstruct kvec iovc[3];\n\tint result;\n\n\trq = server->tx.creq;\n\tif (!rq)\n\t\treturn;\n\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(iovc, rq->tx_ciov, rq->tx_iovlen * sizeof(iov[0]));\n\tresult = do_send(server->ncp_sock, iovc, rq->tx_iovlen,\n\t\t\t rq->tx_totallen, MSG_NOSIGNAL | MSG_DONTWAIT);\n\n\tif (result == -EAGAIN)\n\t\treturn;\n\n\tif (result < 0) {\n\t\tpr_err(\"tcp: Send failed: %d\\n\", result);\n\t\t__ncp_abort_request(server, rq, result);\n\t\treturn;\n\t}\n\tif (result >= rq->tx_totallen) {\n\t\tserver->rcv.creq = rq;\n\t\tserver->tx.creq = NULL;\n\t\treturn;\n\t}\n\trq->tx_totallen -= result;\n\tiov = rq->tx_ciov;\n\twhile (iov->iov_len <= result) {\n\t\tresult -= iov->iov_len;\n\t\tiov++;\n\t\trq->tx_iovlen--;\n\t}\n\tiov->iov_base += result;\n\tiov->iov_len -= result;\n\trq->tx_ciov = iov;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __ncptcp_try_send(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *rq;\n\tstruct kvec *iov;\n\tstruct kvec iovc[3];\n\tint result;\n\n\trq = server->tx.creq;\n\tif (!rq)\n\t\treturn;\n\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(iovc, rq->tx_ciov, rq->tx_iovlen * sizeof(iov[0]));\n\tresult = do_send(server->ncp_sock, iovc, rq->tx_iovlen,\n\t\t\t rq->tx_totallen, MSG_NOSIGNAL | MSG_DONTWAIT);\n\n\tif (result == -EAGAIN)\n\t\treturn;\n\n\tif (result < 0) {\n\t\tpr_err(\"tcp: Send failed: %d\\n\", result);\n\t\t__ncp_abort_request(server, rq, result);\n\t\treturn;\n\t}\n\tif (result >= rq->tx_totallen) {\n\t\tserver->rcv.creq = rq;\n\t\tserver->tx.creq = NULL;\n\t\treturn;\n\t}\n\trq->tx_totallen -= result;\n\tiov = rq->tx_ciov;\n\twhile (iov->iov_len <= result) {\n\t\tresult -= iov->iov_len;\n\t\tiov++;\n\t\trq->tx_iovlen--;\n\t}\n\tiov->iov_base += result;\n\tiov->iov_len -= result;\n\trq->tx_ciov = iov;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "req->datalen + 8"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NCP_TCP_XMIT_VERSION"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "req->tx_totallen + signlen"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NCP_TCP_XMIT_MAGIC"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sign_packet",
          "args": [
            "server",
            "req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1",
            "req->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1",
            "cpu_to_be32(req->tx_totallen + 24)",
            "req->sign + 4"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "sign_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.h",
          "lines": "16-24",
          "snippet": "static inline size_t sign_packet(struct ncp_server *server, const char *data, size_t size, __u32 totalsize, void *sign_buff) {\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tif (server->sign_active) {\n\t\t__sign_packet(server, data, size, totalsize, sign_buff);\n\t\treturn 8;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline size_t sign_packet(struct ncp_server *server, const char *data, size_t size, __u32 totalsize, void *sign_buff) {\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tif (server->sign_active) {\n\t\t__sign_packet(server, data, size, totalsize, sign_buff);\n\t\treturn 8;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "req->tx_totallen + 24"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_init_header",
          "args": [
            "server",
            "req",
            "h"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "256-262",
          "snippet": "static inline void ncp_init_header(struct ncp_server *server, struct ncp_request_reply *req, struct ncp_request_header *h)\n{\n\treq->status = RQ_INPROGRESS;\n\th->conn_low = server->connection;\n\th->conn_high = server->connection >> 8;\n\th->sequence = ++server->sequence;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_init_header(struct ncp_server *server, struct ncp_request_reply *req, struct ncp_request_header *h)\n{\n\treq->status = RQ_INPROGRESS;\n\th->conn_low = server->connection;\n\th->conn_high = server->connection >> 8;\n\th->sequence = ++server->sequence;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\n#define NCP_TCP_XMIT_VERSION\t(1)\n#define NCP_TCP_XMIT_MAGIC\t(0x446D6454)\n\nstatic void ncptcp_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tsize_t signlen;\n\tstruct ncp_request_header* h;\n\n\treq->tx_ciov = req->tx_iov;\n\th = req->tx_iov[1].iov_base;\n\tncp_init_header(server, req, h);\n\tsignlen = sign_packet(server, req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1,\n\t\t\treq->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1,\n\t\t\tcpu_to_be32(req->tx_totallen + 24), req->sign + 4) + 16;\n\n\treq->sign[0] = htonl(NCP_TCP_XMIT_MAGIC);\n\treq->sign[1] = htonl(req->tx_totallen + signlen);\n\treq->sign[2] = htonl(NCP_TCP_XMIT_VERSION);\n\treq->sign[3] = htonl(req->datalen + 8);\n\treq->tx_iov[0].iov_base = req->sign;\n\treq->tx_iov[0].iov_len = signlen;\n\treq->tx_iovlen += 1;\n\treq->tx_totallen += signlen;\n\n\tserver->tx.creq = req;\n\t__ncptcp_try_send(server);\n}"
  },
  {
    "function_name": "ncpdgram_start_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "264-287",
    "snippet": "static void ncpdgram_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tsize_t signlen;\n\tstruct ncp_request_header* h;\n\t\n\treq->tx_ciov = req->tx_iov + 1;\n\n\th = req->tx_iov[1].iov_base;\n\tncp_init_header(server, req, h);\n\tsignlen = sign_packet(server, req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1, \n\t\t\treq->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1,\n\t\t\tcpu_to_le32(req->tx_totallen), req->sign);\n\tif (signlen) {\n\t\treq->tx_ciov[1].iov_base = req->sign;\n\t\treq->tx_ciov[1].iov_len = signlen;\n\t\treq->tx_iovlen += 1;\n\t\treq->tx_totallen += signlen;\n\t}\n\tserver->rcv.creq = req;\n\tserver->timeout_last = server->m.time_out;\n\tserver->timeout_retries = server->m.retry_count;\n\tncpdgram_send(server->ncp_sock, req);\n\tmod_timer(&server->timeout_tm, jiffies + server->m.time_out);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&server->timeout_tm",
            "jiffies + server->m.time_out"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncpdgram_send",
          "args": [
            "server->ncp_sock",
            "req"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ncpdgram_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "206-213",
          "snippet": "static int ncpdgram_send(struct socket *sock, struct ncp_request_reply *req)\n{\n\tstruct kvec vec[3];\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(vec, req->tx_ciov, req->tx_iovlen * sizeof(vec[0]));\n\treturn do_send(sock, vec, req->tx_iovlen,\n\t\t       req->tx_totallen, MSG_DONTWAIT);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncpdgram_send(struct socket *sock, struct ncp_request_reply *req)\n{\n\tstruct kvec vec[3];\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(vec, req->tx_ciov, req->tx_iovlen * sizeof(vec[0]));\n\treturn do_send(sock, vec, req->tx_iovlen,\n\t\t       req->tx_totallen, MSG_DONTWAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sign_packet",
          "args": [
            "server",
            "req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1",
            "req->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1",
            "cpu_to_le32(req->tx_totallen)",
            "req->sign"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "sign_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncpsign_kernel.h",
          "lines": "16-24",
          "snippet": "static inline size_t sign_packet(struct ncp_server *server, const char *data, size_t size, __u32 totalsize, void *sign_buff) {\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tif (server->sign_active) {\n\t\t__sign_packet(server, data, size, totalsize, sign_buff);\n\t\treturn 8;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline size_t sign_packet(struct ncp_server *server, const char *data, size_t size, __u32 totalsize, void *sign_buff) {\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tif (server->sign_active) {\n\t\t__sign_packet(server, data, size, totalsize, sign_buff);\n\t\treturn 8;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "req->tx_totallen"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_init_header",
          "args": [
            "server",
            "req",
            "h"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "256-262",
          "snippet": "static inline void ncp_init_header(struct ncp_server *server, struct ncp_request_reply *req, struct ncp_request_header *h)\n{\n\treq->status = RQ_INPROGRESS;\n\th->conn_low = server->connection;\n\th->conn_high = server->connection >> 8;\n\th->sequence = ++server->sequence;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_init_header(struct ncp_server *server, struct ncp_request_reply *req, struct ncp_request_header *h)\n{\n\treq->status = RQ_INPROGRESS;\n\th->conn_low = server->connection;\n\th->conn_high = server->connection >> 8;\n\th->sequence = ++server->sequence;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncpdgram_start_request(struct ncp_server *server, struct ncp_request_reply *req)\n{\n\tsize_t signlen;\n\tstruct ncp_request_header* h;\n\t\n\treq->tx_ciov = req->tx_iov + 1;\n\n\th = req->tx_iov[1].iov_base;\n\tncp_init_header(server, req, h);\n\tsignlen = sign_packet(server, req->tx_iov[1].iov_base + sizeof(struct ncp_request_header) - 1, \n\t\t\treq->tx_iov[1].iov_len - sizeof(struct ncp_request_header) + 1,\n\t\t\tcpu_to_le32(req->tx_totallen), req->sign);\n\tif (signlen) {\n\t\treq->tx_ciov[1].iov_base = req->sign;\n\t\treq->tx_ciov[1].iov_len = signlen;\n\t\treq->tx_iovlen += 1;\n\t\treq->tx_totallen += signlen;\n\t}\n\tserver->rcv.creq = req;\n\tserver->timeout_last = server->m.time_out;\n\tserver->timeout_retries = server->m.retry_count;\n\tncpdgram_send(server->ncp_sock, req);\n\tmod_timer(&server->timeout_tm, jiffies + server->m.time_out);\n}"
  },
  {
    "function_name": "ncp_init_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "256-262",
    "snippet": "static inline void ncp_init_header(struct ncp_server *server, struct ncp_request_reply *req, struct ncp_request_header *h)\n{\n\treq->status = RQ_INPROGRESS;\n\th->conn_low = server->connection;\n\th->conn_high = server->connection >> 8;\n\th->sequence = ++server->sequence;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_init_header(struct ncp_server *server, struct ncp_request_reply *req, struct ncp_request_header *h)\n{\n\treq->status = RQ_INPROGRESS;\n\th->conn_low = server->connection;\n\th->conn_high = server->connection >> 8;\n\th->sequence = ++server->sequence;\n}"
  },
  {
    "function_name": "__ncptcp_try_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "215-254",
    "snippet": "static void __ncptcp_try_send(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *rq;\n\tstruct kvec *iov;\n\tstruct kvec iovc[3];\n\tint result;\n\n\trq = server->tx.creq;\n\tif (!rq)\n\t\treturn;\n\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(iovc, rq->tx_ciov, rq->tx_iovlen * sizeof(iov[0]));\n\tresult = do_send(server->ncp_sock, iovc, rq->tx_iovlen,\n\t\t\t rq->tx_totallen, MSG_NOSIGNAL | MSG_DONTWAIT);\n\n\tif (result == -EAGAIN)\n\t\treturn;\n\n\tif (result < 0) {\n\t\tpr_err(\"tcp: Send failed: %d\\n\", result);\n\t\t__ncp_abort_request(server, rq, result);\n\t\treturn;\n\t}\n\tif (result >= rq->tx_totallen) {\n\t\tserver->rcv.creq = rq;\n\t\tserver->tx.creq = NULL;\n\t\treturn;\n\t}\n\trq->tx_totallen -= result;\n\tiov = rq->tx_ciov;\n\twhile (iov->iov_len <= result) {\n\t\tresult -= iov->iov_len;\n\t\tiov++;\n\t\trq->tx_iovlen--;\n\t}\n\tiov->iov_base += result;\n\tiov->iov_len -= result;\n\trq->tx_ciov = iov;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ncp_abort_request",
          "args": [
            "server",
            "rq",
            "result"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_abort_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "175-192",
          "snippet": "static inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"tcp: Send failed: %d\\n\"",
            "result"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_send",
          "args": [
            "server->ncp_sock",
            "iovc",
            "rq->tx_iovlen",
            "rq->tx_totallen",
            "MSG_NOSIGNAL | MSG_DONTWAIT"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "do_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "43-48",
          "snippet": "static inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iovc",
            "rq->tx_ciov",
            "rq->tx_iovlen * sizeof(iov[0])"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __ncptcp_try_send(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *rq;\n\tstruct kvec *iov;\n\tstruct kvec iovc[3];\n\tint result;\n\n\trq = server->tx.creq;\n\tif (!rq)\n\t\treturn;\n\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(iovc, rq->tx_ciov, rq->tx_iovlen * sizeof(iov[0]));\n\tresult = do_send(server->ncp_sock, iovc, rq->tx_iovlen,\n\t\t\t rq->tx_totallen, MSG_NOSIGNAL | MSG_DONTWAIT);\n\n\tif (result == -EAGAIN)\n\t\treturn;\n\n\tif (result < 0) {\n\t\tpr_err(\"tcp: Send failed: %d\\n\", result);\n\t\t__ncp_abort_request(server, rq, result);\n\t\treturn;\n\t}\n\tif (result >= rq->tx_totallen) {\n\t\tserver->rcv.creq = rq;\n\t\tserver->tx.creq = NULL;\n\t\treturn;\n\t}\n\trq->tx_totallen -= result;\n\tiov = rq->tx_ciov;\n\twhile (iov->iov_len <= result) {\n\t\tresult -= iov->iov_len;\n\t\tiov++;\n\t\trq->tx_iovlen--;\n\t}\n\tiov->iov_base += result;\n\tiov->iov_len -= result;\n\trq->tx_ciov = iov;\n}"
  },
  {
    "function_name": "ncpdgram_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "206-213",
    "snippet": "static int ncpdgram_send(struct socket *sock, struct ncp_request_reply *req)\n{\n\tstruct kvec vec[3];\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(vec, req->tx_ciov, req->tx_iovlen * sizeof(vec[0]));\n\treturn do_send(sock, vec, req->tx_iovlen,\n\t\t       req->tx_totallen, MSG_DONTWAIT);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send",
          "args": [
            "sock",
            "vec",
            "req->tx_iovlen",
            "req->tx_totallen",
            "MSG_DONTWAIT"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "do_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "43-48",
          "snippet": "static inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vec",
            "req->tx_ciov",
            "req->tx_iovlen * sizeof(vec[0])"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncpdgram_send(struct socket *sock, struct ncp_request_reply *req)\n{\n\tstruct kvec vec[3];\n\t/* sock_sendmsg updates iov pointers for us :-( */\n\tmemcpy(vec, req->tx_ciov, req->tx_iovlen * sizeof(vec[0]));\n\treturn do_send(sock, vec, req->tx_iovlen,\n\t\t       req->tx_totallen, MSG_DONTWAIT);\n}"
  },
  {
    "function_name": "__ncptcp_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "201-204",
    "snippet": "static inline void __ncptcp_abort(struct ncp_server *server)\n{\n\t__abort_ncp_connection(server);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__abort_ncp_connection",
          "args": [
            "server"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__abort_ncp_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "144-168",
          "snippet": "static void __abort_ncp_connection(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tncp_invalidate_conn(server);\n\tdel_timer(&server->timeout_tm);\n\twhile (!list_empty(&server->tx.requests)) {\n\t\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\t\t\n\t\tlist_del_init(&req->req);\n\t\tncp_finish_request(server, req, -EIO);\n\t}\n\treq = server->rcv.creq;\n\tif (req) {\n\t\tserver->rcv.creq = NULL;\n\t\tncp_finish_request(server, req, -EIO);\n\t\tserver->rcv.ptr = NULL;\n\t\tserver->rcv.state = 0;\n\t}\n\treq = server->tx.creq;\n\tif (req) {\n\t\tserver->tx.creq = NULL;\n\t\tncp_finish_request(server, req, -EIO);\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __abort_ncp_connection(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tncp_invalidate_conn(server);\n\tdel_timer(&server->timeout_tm);\n\twhile (!list_empty(&server->tx.requests)) {\n\t\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\t\t\n\t\tlist_del_init(&req->req);\n\t\tncp_finish_request(server, req, -EIO);\n\t}\n\treq = server->rcv.creq;\n\tif (req) {\n\t\tserver->rcv.creq = NULL;\n\t\tncp_finish_request(server, req, -EIO);\n\t\tserver->rcv.ptr = NULL;\n\t\tserver->rcv.state = 0;\n\t}\n\treq = server->tx.creq;\n\tif (req) {\n\t\tserver->tx.creq = NULL;\n\t\tncp_finish_request(server, req, -EIO);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncptcp_abort(struct ncp_server *server)\n{\n\t__abort_ncp_connection(server);\n}"
  },
  {
    "function_name": "ncp_abort_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "194-199",
    "snippet": "static inline void ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncp_abort_request(server, req, err);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ncp_abort_request",
          "args": [
            "server",
            "req",
            "err"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_abort_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "175-192",
          "snippet": "static inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\tmutex_lock(&server->rcv.creq_mutex);\n\t__ncp_abort_request(server, req, err);\n\tmutex_unlock(&server->rcv.creq_mutex);\n}"
  },
  {
    "function_name": "__ncp_abort_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "175-192",
    "snippet": "static inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_finish_request",
          "args": [
            "server",
            "req",
            "err"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_finish_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "134-142",
          "snippet": "static inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->req"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void __ncp_abort_request(struct ncp_server *server, struct ncp_request_reply *req, int err)\n{\n\t/* If req is done, we got signal, but we also received answer... */\n\tswitch (req->status) {\n\t\tcase RQ_IDLE:\n\t\tcase RQ_DONE:\n\t\t\tbreak;\n\t\tcase RQ_QUEUED:\n\t\t\tlist_del_init(&req->req);\n\t\t\tncp_finish_request(server, req, err);\n\t\t\tbreak;\n\t\tcase RQ_INPROGRESS:\n\t\t\treq->status = RQ_ABANDONED;\n\t\t\tbreak;\n\t\tcase RQ_ABANDONED:\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "get_conn_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "170-173",
    "snippet": "static inline int get_conn_number(struct ncp_reply_header *rp)\n{\n\treturn rp->conn_low | (rp->conn_high << 8);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int get_conn_number(struct ncp_reply_header *rp)\n{\n\treturn rp->conn_low | (rp->conn_high << 8);\n}"
  },
  {
    "function_name": "__abort_ncp_connection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "144-168",
    "snippet": "static void __abort_ncp_connection(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tncp_invalidate_conn(server);\n\tdel_timer(&server->timeout_tm);\n\twhile (!list_empty(&server->tx.requests)) {\n\t\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\t\t\n\t\tlist_del_init(&req->req);\n\t\tncp_finish_request(server, req, -EIO);\n\t}\n\treq = server->rcv.creq;\n\tif (req) {\n\t\tserver->rcv.creq = NULL;\n\t\tncp_finish_request(server, req, -EIO);\n\t\tserver->rcv.ptr = NULL;\n\t\tserver->rcv.state = 0;\n\t}\n\treq = server->tx.creq;\n\tif (req) {\n\t\tserver->tx.creq = NULL;\n\t\tncp_finish_request(server, req, -EIO);\n\t}\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_finish_request",
          "args": [
            "server",
            "req",
            "-EIO"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_finish_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "134-142",
          "snippet": "static inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->req"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "server->tx.requests.next",
            "structncp_request_reply",
            "req"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&server->tx.requests"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&server->timeout_tm"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_invalidate_conn",
          "args": [
            "server"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_invalidate_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs_sb.h",
          "lines": "169-172",
          "snippet": "static inline void ncp_invalidate_conn(struct ncp_server *server)\n{\n\tserver->conn_status |= 0x01;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/net.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/ncp_mount.h>\n#include <linux/types.h>\n\nstatic inline void ncp_invalidate_conn(struct ncp_server *server)\n{\n\tserver->conn_status |= 0x01;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void __abort_ncp_connection(struct ncp_server *server)\n{\n\tstruct ncp_request_reply *req;\n\n\tncp_invalidate_conn(server);\n\tdel_timer(&server->timeout_tm);\n\twhile (!list_empty(&server->tx.requests)) {\n\t\treq = list_entry(server->tx.requests.next, struct ncp_request_reply, req);\n\t\t\n\t\tlist_del_init(&req->req);\n\t\tncp_finish_request(server, req, -EIO);\n\t}\n\treq = server->rcv.creq;\n\tif (req) {\n\t\tserver->rcv.creq = NULL;\n\t\tncp_finish_request(server, req, -EIO);\n\t\tserver->rcv.ptr = NULL;\n\t\tserver->rcv.state = 0;\n\t}\n\treq = server->tx.creq;\n\tif (req) {\n\t\tserver->tx.creq = NULL;\n\t\tncp_finish_request(server, req, -EIO);\n\t}\n}"
  },
  {
    "function_name": "ncp_finish_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "134-142",
    "snippet": "static inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_req_put",
          "args": [
            "req"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_req_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "94-98",
          "snippet": "static void ncp_req_put(struct ncp_request_reply *req)\n{\n\tif (atomic_dec_and_test(&req->refs))\n\t\tkfree(req);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_req_put(struct ncp_request_reply *req)\n{\n\tif (atomic_dec_and_test(&req->refs))\n\t\tkfree(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&req->wq"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "req->reply_buf",
            "server->rxbuf",
            "req->datalen"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline void ncp_finish_request(struct ncp_server *server, struct ncp_request_reply *req, int result)\n{\n\treq->result = result;\n\tif (req->status != RQ_ABANDONED)\n\t\tmemcpy(req->reply_buf, server->rxbuf, req->datalen);\n\treq->status = RQ_DONE;\n\twake_up_all(&req->wq);\n\tncp_req_put(req);\n}"
  },
  {
    "function_name": "ncpdgram_timeout_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "127-132",
    "snippet": "void ncpdgram_timeout_call(unsigned long v)\n{\n\tstruct ncp_server *server = (void*)v;\n\t\n\tschedule_work(&server->timeout_tq);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&server->timeout_tq"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncpdgram_timeout_call(unsigned long v)\n{\n\tstruct ncp_server *server = (void*)v;\n\t\n\tschedule_work(&server->timeout_tq);\n}"
  },
  {
    "function_name": "ncp_tcp_write_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "116-125",
    "snippet": "void ncp_tcp_write_space(struct sock *sk)\n{\n\tstruct ncp_server *server = sk->sk_user_data;\n\t\n\t/* We do not need any locking: we first set tx.creq, and then we do sendmsg,\n\t   not vice versa... */\n\tserver->write_space(sk);\n\tif (server->tx.creq)\n\t\tschedule_work(&server->tx.tq);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&server->tx.tq"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->write_space",
          "args": [
            "sk"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_tcp_write_space(struct sock *sk)\n{\n\tstruct ncp_server *server = sk->sk_user_data;\n\t\n\t/* We do not need any locking: we first set tx.creq, and then we do sendmsg,\n\t   not vice versa... */\n\tserver->write_space(sk);\n\tif (server->tx.creq)\n\t\tschedule_work(&server->tx.tq);\n}"
  },
  {
    "function_name": "ncp_tcp_error_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "108-114",
    "snippet": "void ncp_tcp_error_report(struct sock *sk)\n{\n\tstruct ncp_server *server = sk->sk_user_data;\n\t\n\tserver->error_report(sk);\n\tschedule_work(&server->rcv.tq);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&server->rcv.tq"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->error_report",
          "args": [
            "sk"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_tcp_error_report(struct sock *sk)\n{\n\tstruct ncp_server *server = sk->sk_user_data;\n\t\n\tserver->error_report(sk);\n\tschedule_work(&server->rcv.tq);\n}"
  },
  {
    "function_name": "ncp_tcp_data_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "100-106",
    "snippet": "void ncp_tcp_data_ready(struct sock *sk)\n{\n\tstruct ncp_server *server = sk->sk_user_data;\n\n\tserver->data_ready(sk);\n\tschedule_work(&server->rcv.tq);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&server->rcv.tq"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->data_ready",
          "args": [
            "sk"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_tcp_data_ready(struct sock *sk)\n{\n\tstruct ncp_server *server = sk->sk_user_data;\n\n\tserver->data_ready(sk);\n\tschedule_work(&server->rcv.tq);\n}"
  },
  {
    "function_name": "ncp_req_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "94-98",
    "snippet": "static void ncp_req_put(struct ncp_request_reply *req)\n{\n\tif (atomic_dec_and_test(&req->refs))\n\t\tkfree(req);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&req->refs"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_req_put(struct ncp_request_reply *req)\n{\n\tif (atomic_dec_and_test(&req->refs))\n\t\tkfree(req);\n}"
  },
  {
    "function_name": "ncp_req_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "89-92",
    "snippet": "static void ncp_req_get(struct ncp_request_reply *req)\n{\n\tatomic_inc(&req->refs);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&req->refs"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_req_get(struct ncp_request_reply *req)\n{\n\tatomic_inc(&req->refs);\n}"
  },
  {
    "function_name": "ncp_alloc_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "74-87",
    "snippet": "static inline struct ncp_request_reply* ncp_alloc_req(void)\n{\n\tstruct ncp_request_reply *req;\n\n\treq = kmalloc(sizeof(struct ncp_request_reply), GFP_KERNEL);\n\tif (!req)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&req->wq);\n\tatomic_set(&req->refs, (1));\n\treq->status = RQ_IDLE;\n\n\treturn req;\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&req->refs",
            "(1)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&req->wq"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ncp_request_reply)",
            "GFP_KERNEL"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline struct ncp_request_reply* ncp_alloc_req(void)\n{\n\tstruct ncp_request_reply *req;\n\n\treq = kmalloc(sizeof(struct ncp_request_reply), GFP_KERNEL);\n\tif (!req)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&req->wq);\n\tatomic_set(&req->refs, (1));\n\treq->status = RQ_IDLE;\n\n\treturn req;\n}"
  },
  {
    "function_name": "_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "50-56",
    "snippet": "static int _send(struct socket *sock, const void *buff, int len)\n{\n\tstruct kvec vec;\n\tvec.iov_base = (void *) buff;\n\tvec.iov_len = len;\n\treturn do_send(sock, &vec, 1, len, 0);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send",
          "args": [
            "sock",
            "&vec",
            "1",
            "len",
            "0"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "do_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "43-48",
          "snippet": "static inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int _send(struct socket *sock, const void *buff, int len)\n{\n\tstruct kvec vec;\n\tvec.iov_base = (void *) buff;\n\tvec.iov_len = len;\n\treturn do_send(sock, &vec, 1, len, 0);\n}"
  },
  {
    "function_name": "do_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "43-48",
    "snippet": "static inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_sendmsg",
          "args": [
            "sock",
            "&msg",
            "vec",
            "count",
            "len"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int do_send(struct socket *sock, struct kvec *vec, int count,\n\t\t\t  int len, unsigned flags)\n{\n\tstruct msghdr msg = { .msg_flags = flags };\n\treturn kernel_sendmsg(sock, &msg, vec, count, len);\n}"
  },
  {
    "function_name": "_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
    "lines": "36-41",
    "snippet": "static int _recv(struct socket *sock, void *buf, int size, unsigned flags)\n{\n\tstruct msghdr msg = {NULL, };\n\tstruct kvec iov = {buf, size};\n\treturn kernel_recvmsg(sock, &msg, &iov, 1, size, flags);\n}",
    "includes": [
      "#include \"ncpsign_kernel.h\"",
      "#include \"ncp_fs.h\"",
      "#include <linux/file.h>",
      "#include <linux/poll.h>",
      "#include <linux/ipx.h>",
      "#include <net/sock.h>",
      "#include <net/scm.h>",
      "#include <linux/slab.h>",
      "#include <linux/signal.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/mm.h>",
      "#include <linux/net.h>",
      "#include <linux/in.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/socket.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_recvmsg",
          "args": [
            "sock",
            "&msg",
            "&iov",
            "1",
            "size",
            "flags"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int _recv(struct socket *sock, void *buf, int size, unsigned flags)\n{\n\tstruct msghdr msg = {NULL, };\n\tstruct kvec iov = {buf, size};\n\treturn kernel_recvmsg(sock, &msg, &iov, 1, size, flags);\n}"
  }
]