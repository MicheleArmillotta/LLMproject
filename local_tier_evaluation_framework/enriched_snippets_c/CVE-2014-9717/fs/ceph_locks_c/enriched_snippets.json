[
  {
    "function_name": "lock_to_ceph_filelock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "355-381",
    "snippet": "int lock_to_ceph_filelock(struct file_lock *lock,\n\t\t\t  struct ceph_filelock *cephlock)\n{\n\tint err = 0;\n\tcephlock->start = cpu_to_le64(lock->fl_start);\n\tcephlock->length = cpu_to_le64(lock->fl_end - lock->fl_start + 1);\n\tcephlock->client = cpu_to_le64(0);\n\tcephlock->pid = cpu_to_le64((u64)lock->fl_pid);\n\tcephlock->owner = cpu_to_le64(secure_addr(lock->fl_owner));\n\n\tswitch (lock->fl_type) {\n\tcase F_RDLCK:\n\t\tcephlock->type = CEPH_LOCK_SHARED;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tcephlock->type = CEPH_LOCK_EXCL;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tcephlock->type = CEPH_LOCK_UNLOCK;\n\t\tbreak;\n\tdefault:\n\t\tdout(\"Have unknown lock type %d\", lock->fl_type);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"Have unknown lock type %d\"",
            "lock->fl_type"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "secure_addr(lock->fl_owner)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "secure_addr",
          "args": [
            "lock->fl_owner"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "secure_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "15-25",
          "snippet": "static inline u64 secure_addr(void *addr)\n{\n\tu64 v = lock_secret ^ (u64)(unsigned long)addr;\n\t/*\n\t * Set the most significant bit, so that MDS knows the 'owner'\n\t * is sufficient to identify the owner of lock. (old code uses\n\t * both 'owner' and 'pid')\n\t */\n\tv |= (1ULL << 63);\n\treturn v;\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 lock_secret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u64 lock_secret;\n\nstatic inline u64 secure_addr(void *addr)\n{\n\tu64 v = lock_secret ^ (u64)(unsigned long)addr;\n\t/*\n\t * Set the most significant bit, so that MDS knows the 'owner'\n\t * is sufficient to identify the owner of lock. (old code uses\n\t * both 'owner' and 'pid')\n\t */\n\tv |= (1ULL << 63);\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "(u64)lock->fl_pid"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "0"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "lock->fl_end - lock->fl_start + 1"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "lock->fl_start"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nint lock_to_ceph_filelock(struct file_lock *lock,\n\t\t\t  struct ceph_filelock *cephlock)\n{\n\tint err = 0;\n\tcephlock->start = cpu_to_le64(lock->fl_start);\n\tcephlock->length = cpu_to_le64(lock->fl_end - lock->fl_start + 1);\n\tcephlock->client = cpu_to_le64(0);\n\tcephlock->pid = cpu_to_le64((u64)lock->fl_pid);\n\tcephlock->owner = cpu_to_le64(secure_addr(lock->fl_owner));\n\n\tswitch (lock->fl_type) {\n\tcase F_RDLCK:\n\t\tcephlock->type = CEPH_LOCK_SHARED;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tcephlock->type = CEPH_LOCK_EXCL;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tcephlock->type = CEPH_LOCK_UNLOCK;\n\t\tbreak;\n\tdefault:\n\t\tdout(\"Have unknown lock type %d\", lock->fl_type);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_locks_to_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "323-350",
    "snippet": "int ceph_locks_to_pagelist(struct ceph_filelock *flocks,\n\t\t\t   struct ceph_pagelist *pagelist,\n\t\t\t   int num_fcntl_locks, int num_flock_locks)\n{\n\tint err = 0;\n\t__le32 nlocks;\n\n\tnlocks = cpu_to_le32(num_fcntl_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ceph_pagelist_append(pagelist, flocks,\n\t\t\t\t   num_fcntl_locks * sizeof(*flocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\tnlocks = cpu_to_le32(num_flock_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ceph_pagelist_append(pagelist,\n\t\t\t\t   &flocks[num_fcntl_locks],\n\t\t\t\t   num_flock_locks * sizeof(*flocks));\nout_fail:\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "&flocks[num_fcntl_locks]",
            "num_flock_locks * sizeof(*flocks)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "&nlocks",
            "sizeof(nlocks)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "num_flock_locks"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "flocks",
            "num_fcntl_locks * sizeof(*flocks)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "&nlocks",
            "sizeof(nlocks)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "num_fcntl_locks"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_locks_to_pagelist(struct ceph_filelock *flocks,\n\t\t\t   struct ceph_pagelist *pagelist,\n\t\t\t   int num_fcntl_locks, int num_flock_locks)\n{\n\tint err = 0;\n\t__le32 nlocks;\n\n\tnlocks = cpu_to_le32(num_fcntl_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ceph_pagelist_append(pagelist, flocks,\n\t\t\t\t   num_fcntl_locks * sizeof(*flocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\tnlocks = cpu_to_le32(num_flock_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ceph_pagelist_append(pagelist,\n\t\t\t\t   &flocks[num_fcntl_locks],\n\t\t\t\t   num_flock_locks * sizeof(*flocks));\nout_fail:\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_encode_locks_to_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "272-315",
    "snippet": "int ceph_encode_locks_to_buffer(struct inode *inode,\n\t\t\t\tstruct ceph_filelock *flocks,\n\t\t\t\tint num_fcntl_locks, int num_flock_locks)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tint err = 0;\n\tint seen_fcntl = 0;\n\tint seen_flock = 0;\n\tint l = 0;\n\n\tdout(\"encoding %d flock and %d fcntl locks\", num_flock_locks,\n\t     num_fcntl_locks);\n\n\tif (!ctx)\n\t\treturn 0;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_fcntl;\n\t\tif (seen_fcntl > num_fcntl_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_flock;\n\t\tif (seen_flock > num_flock_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\nfail:\n\tspin_unlock(&ctx->flc_lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_to_ceph_filelock",
          "args": [
            "lock",
            "&flocks[l]"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "lock_to_ceph_filelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "355-381",
          "snippet": "int lock_to_ceph_filelock(struct file_lock *lock,\n\t\t\t  struct ceph_filelock *cephlock)\n{\n\tint err = 0;\n\tcephlock->start = cpu_to_le64(lock->fl_start);\n\tcephlock->length = cpu_to_le64(lock->fl_end - lock->fl_start + 1);\n\tcephlock->client = cpu_to_le64(0);\n\tcephlock->pid = cpu_to_le64((u64)lock->fl_pid);\n\tcephlock->owner = cpu_to_le64(secure_addr(lock->fl_owner));\n\n\tswitch (lock->fl_type) {\n\tcase F_RDLCK:\n\t\tcephlock->type = CEPH_LOCK_SHARED;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tcephlock->type = CEPH_LOCK_EXCL;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tcephlock->type = CEPH_LOCK_UNLOCK;\n\t\tbreak;\n\tdefault:\n\t\tdout(\"Have unknown lock type %d\", lock->fl_type);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nint lock_to_ceph_filelock(struct file_lock *lock,\n\t\t\t  struct ceph_filelock *cephlock)\n{\n\tint err = 0;\n\tcephlock->start = cpu_to_le64(lock->fl_start);\n\tcephlock->length = cpu_to_le64(lock->fl_end - lock->fl_start + 1);\n\tcephlock->client = cpu_to_le64(0);\n\tcephlock->pid = cpu_to_le64((u64)lock->fl_pid);\n\tcephlock->owner = cpu_to_le64(secure_addr(lock->fl_owner));\n\n\tswitch (lock->fl_type) {\n\tcase F_RDLCK:\n\t\tcephlock->type = CEPH_LOCK_SHARED;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tcephlock->type = CEPH_LOCK_EXCL;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tcephlock->type = CEPH_LOCK_UNLOCK;\n\t\tbreak;\n\tdefault:\n\t\tdout(\"Have unknown lock type %d\", lock->fl_type);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&ctx->flc_flock",
            "fl_list"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&ctx->flc_flock",
            "fl_list"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"encoding %d flock and %d fcntl locks\"",
            "num_flock_locks",
            "num_fcntl_locks"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_encode_locks_to_buffer(struct inode *inode,\n\t\t\t\tstruct ceph_filelock *flocks,\n\t\t\t\tint num_fcntl_locks, int num_flock_locks)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tint err = 0;\n\tint seen_fcntl = 0;\n\tint seen_flock = 0;\n\tint l = 0;\n\n\tdout(\"encoding %d flock and %d fcntl locks\", num_flock_locks,\n\t     num_fcntl_locks);\n\n\tif (!ctx)\n\t\treturn 0;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_fcntl;\n\t\tif (seen_fcntl > num_fcntl_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_flock;\n\t\tif (seen_flock > num_flock_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\nfail:\n\tspin_unlock(&ctx->flc_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_count_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "246-265",
    "snippet": "void ceph_count_locks(struct inode *inode, int *fcntl_count, int *flock_count)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx;\n\n\t*fcntl_count = 0;\n\t*flock_count = 0;\n\n\tctx = inode->i_flctx;\n\tif (ctx) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tlist_for_each_entry(lock, &ctx->flc_posix, fl_list)\n\t\t\t++(*fcntl_count);\n\t\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list)\n\t\t\t++(*flock_count);\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\tdout(\"counted %d flock locks and %d fcntl locks\",\n\t     *flock_count, *fcntl_count);\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"counted %d flock locks and %d fcntl locks\"",
            "*flock_count",
            "*fcntl_count"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "*flock_count"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&ctx->flc_flock",
            "fl_list"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "*fcntl_count"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_count_locks(struct inode *inode, int *fcntl_count, int *flock_count)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx;\n\n\t*fcntl_count = 0;\n\t*flock_count = 0;\n\n\tctx = inode->i_flctx;\n\tif (ctx) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tlist_for_each_entry(lock, &ctx->flc_posix, fl_list)\n\t\t\t++(*fcntl_count);\n\t\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list)\n\t\t\t++(*flock_count);\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\tdout(\"counted %d flock locks and %d fcntl locks\",\n\t     *flock_count, *fcntl_count);\n}"
  },
  {
    "function_name": "ceph_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "204-240",
    "snippet": "int ceph_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tu8 lock_cmd;\n\tint err;\n\tu8 wait = 0;\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\t/* No mandatory locks */\n\tif (__mandatory_lock(file->f_mapping->host) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tdout(\"ceph_flock, fl_file: %p\", fl->fl_file);\n\n\tif (IS_SETLKW(cmd))\n\t\twait = 1;\n\n\tif (F_RDLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_SHARED;\n\telse if (F_WRLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_EXCL;\n\telse\n\t\tlock_cmd = CEPH_LOCK_UNLOCK;\n\n\terr = ceph_lock_message(CEPH_LOCK_FLOCK, CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\tfile, lock_cmd, wait, fl);\n\tif (!err) {\n\t\terr = flock_lock_file_wait(file, fl);\n\t\tif (err) {\n\t\t\tceph_lock_message(CEPH_LOCK_FLOCK,\n\t\t\t\t\t  CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\t\t  file, CEPH_LOCK_UNLOCK, 0, fl);\n\t\t\tdout(\"got %d on flock_lock_file_wait, undid lock\", err);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"got %d on flock_lock_file_wait, undid lock\"",
            "err"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_lock_message",
          "args": [
            "CEPH_LOCK_FLOCK",
            "CEPH_MDS_OP_SETFILELOCK",
            "file",
            "CEPH_LOCK_UNLOCK",
            "0",
            "fl"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_lock_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "35-105",
          "snippet": "static int ceph_lock_message(u8 lock_type, u16 operation, struct file *file,\n\t\t\t     int cmd, u8 wait, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\tu64 length = 0;\n\tu64 owner;\n\n\tif (operation != CEPH_MDS_OP_SETFILELOCK || cmd == CEPH_LOCK_UNLOCK)\n\t\twait = 0;\n\n\treq = ceph_mdsc_create_request(mdsc, operation, USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\t/* mds requires start and length rather than start and end */\n\tif (LLONG_MAX == fl->fl_end)\n\t\tlength = 0;\n\telse\n\t\tlength = fl->fl_end - fl->fl_start + 1;\n\n\towner = secure_addr(fl->fl_owner);\n\n\tdout(\"ceph_lock_message: rule: %d, op: %d, owner: %llx, pid: %llu, \"\n\t     \"start: %llu, length: %llu, wait: %d, type: %d\", (int)lock_type,\n\t     (int)operation, owner, (u64)fl->fl_pid, fl->fl_start, length,\n\t     wait, fl->fl_type);\n\n\treq->r_args.filelock_change.rule = lock_type;\n\treq->r_args.filelock_change.type = cmd;\n\treq->r_args.filelock_change.owner = cpu_to_le64(owner);\n\treq->r_args.filelock_change.pid = cpu_to_le64((u64)fl->fl_pid);\n\treq->r_args.filelock_change.start = cpu_to_le64(fl->fl_start);\n\treq->r_args.filelock_change.length = cpu_to_le64(length);\n\treq->r_args.filelock_change.wait = wait;\n\n\tif (wait)\n\t\treq->r_wait_for_completion = ceph_lock_wait_for_completion;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\n\tif (operation == CEPH_MDS_OP_GETFILELOCK) {\n\t\tfl->fl_pid = le64_to_cpu(req->r_reply_info.filelock_reply->pid);\n\t\tif (CEPH_LOCK_SHARED == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\telse if (CEPH_LOCK_EXCL == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_WRLCK;\n\t\telse\n\t\t\tfl->fl_type = F_UNLCK;\n\n\t\tfl->fl_start = le64_to_cpu(req->r_reply_info.filelock_reply->start);\n\t\tlength = le64_to_cpu(req->r_reply_info.filelock_reply->start) +\n\t\t\t\t\t\t le64_to_cpu(req->r_reply_info.filelock_reply->length);\n\t\tif (length >= 1)\n\t\t\tfl->fl_end = length -1;\n\t\telse\n\t\t\tfl->fl_end = 0;\n\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"ceph_lock_message: rule: %d, op: %d, pid: %llu, start: %llu, \"\n\t     \"length: %llu, wait: %d, type: %d, err code %d\", (int)lock_type,\n\t     (int)operation, (u64)fl->fl_pid, fl->fl_start,\n\t     length, wait, fl->fl_type, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);\n\nstatic int ceph_lock_message(u8 lock_type, u16 operation, struct file *file,\n\t\t\t     int cmd, u8 wait, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\tu64 length = 0;\n\tu64 owner;\n\n\tif (operation != CEPH_MDS_OP_SETFILELOCK || cmd == CEPH_LOCK_UNLOCK)\n\t\twait = 0;\n\n\treq = ceph_mdsc_create_request(mdsc, operation, USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\t/* mds requires start and length rather than start and end */\n\tif (LLONG_MAX == fl->fl_end)\n\t\tlength = 0;\n\telse\n\t\tlength = fl->fl_end - fl->fl_start + 1;\n\n\towner = secure_addr(fl->fl_owner);\n\n\tdout(\"ceph_lock_message: rule: %d, op: %d, owner: %llx, pid: %llu, \"\n\t     \"start: %llu, length: %llu, wait: %d, type: %d\", (int)lock_type,\n\t     (int)operation, owner, (u64)fl->fl_pid, fl->fl_start, length,\n\t     wait, fl->fl_type);\n\n\treq->r_args.filelock_change.rule = lock_type;\n\treq->r_args.filelock_change.type = cmd;\n\treq->r_args.filelock_change.owner = cpu_to_le64(owner);\n\treq->r_args.filelock_change.pid = cpu_to_le64((u64)fl->fl_pid);\n\treq->r_args.filelock_change.start = cpu_to_le64(fl->fl_start);\n\treq->r_args.filelock_change.length = cpu_to_le64(length);\n\treq->r_args.filelock_change.wait = wait;\n\n\tif (wait)\n\t\treq->r_wait_for_completion = ceph_lock_wait_for_completion;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\n\tif (operation == CEPH_MDS_OP_GETFILELOCK) {\n\t\tfl->fl_pid = le64_to_cpu(req->r_reply_info.filelock_reply->pid);\n\t\tif (CEPH_LOCK_SHARED == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\telse if (CEPH_LOCK_EXCL == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_WRLCK;\n\t\telse\n\t\t\tfl->fl_type = F_UNLCK;\n\n\t\tfl->fl_start = le64_to_cpu(req->r_reply_info.filelock_reply->start);\n\t\tlength = le64_to_cpu(req->r_reply_info.filelock_reply->start) +\n\t\t\t\t\t\t le64_to_cpu(req->r_reply_info.filelock_reply->length);\n\t\tif (length >= 1)\n\t\t\tfl->fl_end = length -1;\n\t\telse\n\t\t\tfl->fl_end = 0;\n\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"ceph_lock_message: rule: %d, op: %d, pid: %llu, start: %llu, \"\n\t     \"length: %llu, wait: %d, type: %d, err code %d\", (int)lock_type,\n\t     (int)operation, (u64)fl->fl_pid, fl->fl_start,\n\t     length, wait, fl->fl_type, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_flock, fl_file: %p\"",
            "fl->fl_file"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tu8 lock_cmd;\n\tint err;\n\tu8 wait = 0;\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\t/* No mandatory locks */\n\tif (__mandatory_lock(file->f_mapping->host) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tdout(\"ceph_flock, fl_file: %p\", fl->fl_file);\n\n\tif (IS_SETLKW(cmd))\n\t\twait = 1;\n\n\tif (F_RDLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_SHARED;\n\telse if (F_WRLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_EXCL;\n\telse\n\t\tlock_cmd = CEPH_LOCK_UNLOCK;\n\n\terr = ceph_lock_message(CEPH_LOCK_FLOCK, CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\tfile, lock_cmd, wait, fl);\n\tif (!err) {\n\t\terr = flock_lock_file_wait(file, fl);\n\t\tif (err) {\n\t\t\tceph_lock_message(CEPH_LOCK_FLOCK,\n\t\t\t\t\t  CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\t\t  file, CEPH_LOCK_UNLOCK, 0, fl);\n\t\t\tdout(\"got %d on flock_lock_file_wait, undid lock\", err);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "157-202",
    "snippet": "int ceph_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tu8 lock_cmd;\n\tint err;\n\tu8 wait = 0;\n\tu16 op = CEPH_MDS_OP_SETFILELOCK;\n\n\tif (!(fl->fl_flags & FL_POSIX))\n\t\treturn -ENOLCK;\n\t/* No mandatory locks */\n\tif (__mandatory_lock(file->f_mapping->host) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tdout(\"ceph_lock, fl_owner: %p\", fl->fl_owner);\n\n\t/* set wait bit as appropriate, then make command as Ceph expects it*/\n\tif (IS_GETLK(cmd))\n\t\top = CEPH_MDS_OP_GETFILELOCK;\n\telse if (IS_SETLKW(cmd))\n\t\twait = 1;\n\n\tif (F_RDLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_SHARED;\n\telse if (F_WRLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_EXCL;\n\telse\n\t\tlock_cmd = CEPH_LOCK_UNLOCK;\n\n\terr = ceph_lock_message(CEPH_LOCK_FCNTL, op, file, lock_cmd, wait, fl);\n\tif (!err) {\n\t\tif (op != CEPH_MDS_OP_GETFILELOCK) {\n\t\t\tdout(\"mds locked, locking locally\");\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\t\tif (err && (CEPH_MDS_OP_SETFILELOCK == op)) {\n\t\t\t\t/* undo! This should only happen if\n\t\t\t\t * the kernel detects local\n\t\t\t\t * deadlock. */\n\t\t\t\tceph_lock_message(CEPH_LOCK_FCNTL, op, file,\n\t\t\t\t\t\t  CEPH_LOCK_UNLOCK, 0, fl);\n\t\t\t\tdout(\"got %d on posix_lock_file, undid lock\",\n\t\t\t\t     err);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"got %d on posix_lock_file, undid lock\"",
            "err"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_lock_message",
          "args": [
            "CEPH_LOCK_FCNTL",
            "op",
            "file",
            "CEPH_LOCK_UNLOCK",
            "0",
            "fl"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_lock_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "35-105",
          "snippet": "static int ceph_lock_message(u8 lock_type, u16 operation, struct file *file,\n\t\t\t     int cmd, u8 wait, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\tu64 length = 0;\n\tu64 owner;\n\n\tif (operation != CEPH_MDS_OP_SETFILELOCK || cmd == CEPH_LOCK_UNLOCK)\n\t\twait = 0;\n\n\treq = ceph_mdsc_create_request(mdsc, operation, USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\t/* mds requires start and length rather than start and end */\n\tif (LLONG_MAX == fl->fl_end)\n\t\tlength = 0;\n\telse\n\t\tlength = fl->fl_end - fl->fl_start + 1;\n\n\towner = secure_addr(fl->fl_owner);\n\n\tdout(\"ceph_lock_message: rule: %d, op: %d, owner: %llx, pid: %llu, \"\n\t     \"start: %llu, length: %llu, wait: %d, type: %d\", (int)lock_type,\n\t     (int)operation, owner, (u64)fl->fl_pid, fl->fl_start, length,\n\t     wait, fl->fl_type);\n\n\treq->r_args.filelock_change.rule = lock_type;\n\treq->r_args.filelock_change.type = cmd;\n\treq->r_args.filelock_change.owner = cpu_to_le64(owner);\n\treq->r_args.filelock_change.pid = cpu_to_le64((u64)fl->fl_pid);\n\treq->r_args.filelock_change.start = cpu_to_le64(fl->fl_start);\n\treq->r_args.filelock_change.length = cpu_to_le64(length);\n\treq->r_args.filelock_change.wait = wait;\n\n\tif (wait)\n\t\treq->r_wait_for_completion = ceph_lock_wait_for_completion;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\n\tif (operation == CEPH_MDS_OP_GETFILELOCK) {\n\t\tfl->fl_pid = le64_to_cpu(req->r_reply_info.filelock_reply->pid);\n\t\tif (CEPH_LOCK_SHARED == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\telse if (CEPH_LOCK_EXCL == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_WRLCK;\n\t\telse\n\t\t\tfl->fl_type = F_UNLCK;\n\n\t\tfl->fl_start = le64_to_cpu(req->r_reply_info.filelock_reply->start);\n\t\tlength = le64_to_cpu(req->r_reply_info.filelock_reply->start) +\n\t\t\t\t\t\t le64_to_cpu(req->r_reply_info.filelock_reply->length);\n\t\tif (length >= 1)\n\t\t\tfl->fl_end = length -1;\n\t\telse\n\t\t\tfl->fl_end = 0;\n\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"ceph_lock_message: rule: %d, op: %d, pid: %llu, start: %llu, \"\n\t     \"length: %llu, wait: %d, type: %d, err code %d\", (int)lock_type,\n\t     (int)operation, (u64)fl->fl_pid, fl->fl_start,\n\t     length, wait, fl->fl_type, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);\n\nstatic int ceph_lock_message(u8 lock_type, u16 operation, struct file *file,\n\t\t\t     int cmd, u8 wait, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\tu64 length = 0;\n\tu64 owner;\n\n\tif (operation != CEPH_MDS_OP_SETFILELOCK || cmd == CEPH_LOCK_UNLOCK)\n\t\twait = 0;\n\n\treq = ceph_mdsc_create_request(mdsc, operation, USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\t/* mds requires start and length rather than start and end */\n\tif (LLONG_MAX == fl->fl_end)\n\t\tlength = 0;\n\telse\n\t\tlength = fl->fl_end - fl->fl_start + 1;\n\n\towner = secure_addr(fl->fl_owner);\n\n\tdout(\"ceph_lock_message: rule: %d, op: %d, owner: %llx, pid: %llu, \"\n\t     \"start: %llu, length: %llu, wait: %d, type: %d\", (int)lock_type,\n\t     (int)operation, owner, (u64)fl->fl_pid, fl->fl_start, length,\n\t     wait, fl->fl_type);\n\n\treq->r_args.filelock_change.rule = lock_type;\n\treq->r_args.filelock_change.type = cmd;\n\treq->r_args.filelock_change.owner = cpu_to_le64(owner);\n\treq->r_args.filelock_change.pid = cpu_to_le64((u64)fl->fl_pid);\n\treq->r_args.filelock_change.start = cpu_to_le64(fl->fl_start);\n\treq->r_args.filelock_change.length = cpu_to_le64(length);\n\treq->r_args.filelock_change.wait = wait;\n\n\tif (wait)\n\t\treq->r_wait_for_completion = ceph_lock_wait_for_completion;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\n\tif (operation == CEPH_MDS_OP_GETFILELOCK) {\n\t\tfl->fl_pid = le64_to_cpu(req->r_reply_info.filelock_reply->pid);\n\t\tif (CEPH_LOCK_SHARED == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\telse if (CEPH_LOCK_EXCL == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_WRLCK;\n\t\telse\n\t\t\tfl->fl_type = F_UNLCK;\n\n\t\tfl->fl_start = le64_to_cpu(req->r_reply_info.filelock_reply->start);\n\t\tlength = le64_to_cpu(req->r_reply_info.filelock_reply->start) +\n\t\t\t\t\t\t le64_to_cpu(req->r_reply_info.filelock_reply->length);\n\t\tif (length >= 1)\n\t\t\tfl->fl_end = length -1;\n\t\telse\n\t\t\tfl->fl_end = 0;\n\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"ceph_lock_message: rule: %d, op: %d, pid: %llu, start: %llu, \"\n\t     \"length: %llu, wait: %d, type: %d, err code %d\", (int)lock_type,\n\t     (int)operation, (u64)fl->fl_pid, fl->fl_start,\n\t     length, wait, fl->fl_type, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "file",
            "fl",
            "NULL"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1157-1161",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mds locked, locking locally\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_GETLK",
          "args": [
            "cmd"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_lock, fl_owner: %p\"",
            "fl->fl_owner"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tu8 lock_cmd;\n\tint err;\n\tu8 wait = 0;\n\tu16 op = CEPH_MDS_OP_SETFILELOCK;\n\n\tif (!(fl->fl_flags & FL_POSIX))\n\t\treturn -ENOLCK;\n\t/* No mandatory locks */\n\tif (__mandatory_lock(file->f_mapping->host) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\tdout(\"ceph_lock, fl_owner: %p\", fl->fl_owner);\n\n\t/* set wait bit as appropriate, then make command as Ceph expects it*/\n\tif (IS_GETLK(cmd))\n\t\top = CEPH_MDS_OP_GETFILELOCK;\n\telse if (IS_SETLKW(cmd))\n\t\twait = 1;\n\n\tif (F_RDLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_SHARED;\n\telse if (F_WRLCK == fl->fl_type)\n\t\tlock_cmd = CEPH_LOCK_EXCL;\n\telse\n\t\tlock_cmd = CEPH_LOCK_UNLOCK;\n\n\terr = ceph_lock_message(CEPH_LOCK_FCNTL, op, file, lock_cmd, wait, fl);\n\tif (!err) {\n\t\tif (op != CEPH_MDS_OP_GETFILELOCK) {\n\t\t\tdout(\"mds locked, locking locally\");\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\t\tif (err && (CEPH_MDS_OP_SETFILELOCK == op)) {\n\t\t\t\t/* undo! This should only happen if\n\t\t\t\t * the kernel detects local\n\t\t\t\t * deadlock. */\n\t\t\t\tceph_lock_message(CEPH_LOCK_FCNTL, op, file,\n\t\t\t\t\t\t  CEPH_LOCK_UNLOCK, 0, fl);\n\t\t\t\tdout(\"got %d on posix_lock_file, undid lock\",\n\t\t\t\t     err);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_lock_wait_for_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "107-151",
    "snippet": "static int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req)\n{\n\tstruct ceph_mds_request *intr_req;\n\tstruct inode *inode = req->r_inode;\n\tint err, lock_type;\n\n\tBUG_ON(req->r_op != CEPH_MDS_OP_SETFILELOCK);\n\tif (req->r_args.filelock_change.rule == CEPH_LOCK_FCNTL)\n\t\tlock_type = CEPH_LOCK_FCNTL_INTR;\n\telse if (req->r_args.filelock_change.rule == CEPH_LOCK_FLOCK)\n\t\tlock_type = CEPH_LOCK_FLOCK_INTR;\n\telse\n\t\tBUG_ON(1);\n\tBUG_ON(req->r_args.filelock_change.type == CEPH_LOCK_UNLOCK);\n\n\terr = wait_for_completion_interruptible(&req->r_completion);\n\tif (!err)\n\t\treturn 0;\n\n\tdout(\"ceph_lock_wait_for_completion: request %llu was interrupted\\n\",\n\t     req->r_tid);\n\n\tintr_req = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\t\t    USE_AUTH_MDS);\n\tif (IS_ERR(intr_req))\n\t\treturn PTR_ERR(intr_req);\n\n\tintr_req->r_inode = inode;\n\tihold(inode);\n\tintr_req->r_num_caps = 1;\n\n\tintr_req->r_args.filelock_change = req->r_args.filelock_change;\n\tintr_req->r_args.filelock_change.rule = lock_type;\n\tintr_req->r_args.filelock_change.type = CEPH_LOCK_UNLOCK;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, intr_req);\n\tceph_mdsc_put_request(intr_req);\n\n\tif (err && err != -ERESTARTSYS)\n\t\treturn err;\n\n\twait_for_completion(&req->r_completion);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&req->r_completion"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "intr_req"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "inode",
            "intr_req"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "intr_req"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "intr_req"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_SETFILELOCK",
            "USE_AUTH_MDS"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_lock_wait_for_completion: request %llu was interrupted\\n\"",
            "req->r_tid"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion_interruptible",
          "args": [
            "&req->r_completion"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "req->r_args.filelock_change.type == CEPH_LOCK_UNLOCK"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "req->r_op != CEPH_MDS_OP_SETFILELOCK"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);\n\nstatic int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req)\n{\n\tstruct ceph_mds_request *intr_req;\n\tstruct inode *inode = req->r_inode;\n\tint err, lock_type;\n\n\tBUG_ON(req->r_op != CEPH_MDS_OP_SETFILELOCK);\n\tif (req->r_args.filelock_change.rule == CEPH_LOCK_FCNTL)\n\t\tlock_type = CEPH_LOCK_FCNTL_INTR;\n\telse if (req->r_args.filelock_change.rule == CEPH_LOCK_FLOCK)\n\t\tlock_type = CEPH_LOCK_FLOCK_INTR;\n\telse\n\t\tBUG_ON(1);\n\tBUG_ON(req->r_args.filelock_change.type == CEPH_LOCK_UNLOCK);\n\n\terr = wait_for_completion_interruptible(&req->r_completion);\n\tif (!err)\n\t\treturn 0;\n\n\tdout(\"ceph_lock_wait_for_completion: request %llu was interrupted\\n\",\n\t     req->r_tid);\n\n\tintr_req = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETFILELOCK,\n\t\t\t\t\t    USE_AUTH_MDS);\n\tif (IS_ERR(intr_req))\n\t\treturn PTR_ERR(intr_req);\n\n\tintr_req->r_inode = inode;\n\tihold(inode);\n\tintr_req->r_num_caps = 1;\n\n\tintr_req->r_args.filelock_change = req->r_args.filelock_change;\n\tintr_req->r_args.filelock_change.rule = lock_type;\n\tintr_req->r_args.filelock_change.type = CEPH_LOCK_UNLOCK;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, intr_req);\n\tceph_mdsc_put_request(intr_req);\n\n\tif (err && err != -ERESTARTSYS)\n\t\treturn err;\n\n\twait_for_completion(&req->r_completion);\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_lock_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "35-105",
    "snippet": "static int ceph_lock_message(u8 lock_type, u16 operation, struct file *file,\n\t\t\t     int cmd, u8 wait, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\tu64 length = 0;\n\tu64 owner;\n\n\tif (operation != CEPH_MDS_OP_SETFILELOCK || cmd == CEPH_LOCK_UNLOCK)\n\t\twait = 0;\n\n\treq = ceph_mdsc_create_request(mdsc, operation, USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\t/* mds requires start and length rather than start and end */\n\tif (LLONG_MAX == fl->fl_end)\n\t\tlength = 0;\n\telse\n\t\tlength = fl->fl_end - fl->fl_start + 1;\n\n\towner = secure_addr(fl->fl_owner);\n\n\tdout(\"ceph_lock_message: rule: %d, op: %d, owner: %llx, pid: %llu, \"\n\t     \"start: %llu, length: %llu, wait: %d, type: %d\", (int)lock_type,\n\t     (int)operation, owner, (u64)fl->fl_pid, fl->fl_start, length,\n\t     wait, fl->fl_type);\n\n\treq->r_args.filelock_change.rule = lock_type;\n\treq->r_args.filelock_change.type = cmd;\n\treq->r_args.filelock_change.owner = cpu_to_le64(owner);\n\treq->r_args.filelock_change.pid = cpu_to_le64((u64)fl->fl_pid);\n\treq->r_args.filelock_change.start = cpu_to_le64(fl->fl_start);\n\treq->r_args.filelock_change.length = cpu_to_le64(length);\n\treq->r_args.filelock_change.wait = wait;\n\n\tif (wait)\n\t\treq->r_wait_for_completion = ceph_lock_wait_for_completion;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\n\tif (operation == CEPH_MDS_OP_GETFILELOCK) {\n\t\tfl->fl_pid = le64_to_cpu(req->r_reply_info.filelock_reply->pid);\n\t\tif (CEPH_LOCK_SHARED == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\telse if (CEPH_LOCK_EXCL == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_WRLCK;\n\t\telse\n\t\t\tfl->fl_type = F_UNLCK;\n\n\t\tfl->fl_start = le64_to_cpu(req->r_reply_info.filelock_reply->start);\n\t\tlength = le64_to_cpu(req->r_reply_info.filelock_reply->start) +\n\t\t\t\t\t\t le64_to_cpu(req->r_reply_info.filelock_reply->length);\n\t\tif (length >= 1)\n\t\t\tfl->fl_end = length -1;\n\t\telse\n\t\t\tfl->fl_end = 0;\n\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"ceph_lock_message: rule: %d, op: %d, pid: %llu, start: %llu, \"\n\t     \"length: %llu, wait: %d, type: %d, err code %d\", (int)lock_type,\n\t     (int)operation, (u64)fl->fl_pid, fl->fl_start,\n\t     length, wait, fl->fl_type, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_lock_message: rule: %d, op: %d, pid: %llu, start: %llu, \"\n\t     \"length: %llu, wait: %d, type: %d, err code %d\"",
            "(int)lock_type",
            "(int)operation",
            "(u64)fl->fl_pid",
            "fl->fl_start",
            "length",
            "wait",
            "fl->fl_type",
            "err"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "req->r_reply_info.filelock_reply->length"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "inode",
            "req"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "length"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "fl->fl_start"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "(u64)fl->fl_pid"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "owner"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_lock_message: rule: %d, op: %d, owner: %llx, pid: %llu, \"\n\t     \"start: %llu, length: %llu, wait: %d, type: %d\"",
            "(int)lock_type",
            "(int)operation",
            "owner",
            "(u64)fl->fl_pid",
            "fl->fl_start",
            "length",
            "wait",
            "fl->fl_type"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "secure_addr",
          "args": [
            "fl->fl_owner"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "secure_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "15-25",
          "snippet": "static inline u64 secure_addr(void *addr)\n{\n\tu64 v = lock_secret ^ (u64)(unsigned long)addr;\n\t/*\n\t * Set the most significant bit, so that MDS knows the 'owner'\n\t * is sufficient to identify the owner of lock. (old code uses\n\t * both 'owner' and 'pid')\n\t */\n\tv |= (1ULL << 63);\n\treturn v;\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 lock_secret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u64 lock_secret;\n\nstatic inline u64 secure_addr(void *addr)\n{\n\tu64 v = lock_secret ^ (u64)(unsigned long)addr;\n\t/*\n\t * Set the most significant bit, so that MDS knows the 'owner'\n\t * is sufficient to identify the owner of lock. (old code uses\n\t * both 'owner' and 'pid')\n\t */\n\tv |= (1ULL << 63);\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "operation",
            "USE_AUTH_MDS"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_lock_wait_for_completion(struct ceph_mds_client *mdsc,\n                                         struct ceph_mds_request *req);\n\nstatic int ceph_lock_message(u8 lock_type, u16 operation, struct file *file,\n\t\t\t     int cmd, u8 wait, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\tu64 length = 0;\n\tu64 owner;\n\n\tif (operation != CEPH_MDS_OP_SETFILELOCK || cmd == CEPH_LOCK_UNLOCK)\n\t\twait = 0;\n\n\treq = ceph_mdsc_create_request(mdsc, operation, USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\t/* mds requires start and length rather than start and end */\n\tif (LLONG_MAX == fl->fl_end)\n\t\tlength = 0;\n\telse\n\t\tlength = fl->fl_end - fl->fl_start + 1;\n\n\towner = secure_addr(fl->fl_owner);\n\n\tdout(\"ceph_lock_message: rule: %d, op: %d, owner: %llx, pid: %llu, \"\n\t     \"start: %llu, length: %llu, wait: %d, type: %d\", (int)lock_type,\n\t     (int)operation, owner, (u64)fl->fl_pid, fl->fl_start, length,\n\t     wait, fl->fl_type);\n\n\treq->r_args.filelock_change.rule = lock_type;\n\treq->r_args.filelock_change.type = cmd;\n\treq->r_args.filelock_change.owner = cpu_to_le64(owner);\n\treq->r_args.filelock_change.pid = cpu_to_le64((u64)fl->fl_pid);\n\treq->r_args.filelock_change.start = cpu_to_le64(fl->fl_start);\n\treq->r_args.filelock_change.length = cpu_to_le64(length);\n\treq->r_args.filelock_change.wait = wait;\n\n\tif (wait)\n\t\treq->r_wait_for_completion = ceph_lock_wait_for_completion;\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\n\tif (operation == CEPH_MDS_OP_GETFILELOCK) {\n\t\tfl->fl_pid = le64_to_cpu(req->r_reply_info.filelock_reply->pid);\n\t\tif (CEPH_LOCK_SHARED == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_RDLCK;\n\t\telse if (CEPH_LOCK_EXCL == req->r_reply_info.filelock_reply->type)\n\t\t\tfl->fl_type = F_WRLCK;\n\t\telse\n\t\t\tfl->fl_type = F_UNLCK;\n\n\t\tfl->fl_start = le64_to_cpu(req->r_reply_info.filelock_reply->start);\n\t\tlength = le64_to_cpu(req->r_reply_info.filelock_reply->start) +\n\t\t\t\t\t\t le64_to_cpu(req->r_reply_info.filelock_reply->length);\n\t\tif (length >= 1)\n\t\t\tfl->fl_end = length -1;\n\t\telse\n\t\t\tfl->fl_end = 0;\n\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"ceph_lock_message: rule: %d, op: %d, pid: %llu, start: %llu, \"\n\t     \"length: %llu, wait: %d, type: %d, err code %d\", (int)lock_type,\n\t     (int)operation, (u64)fl->fl_pid, fl->fl_start,\n\t     length, wait, fl->fl_type, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_flock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "27-30",
    "snippet": "void __init ceph_flock_init(void)\n{\n\tget_random_bytes(&lock_secret, sizeof(lock_secret));\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 lock_secret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&lock_secret",
            "sizeof(lock_secret)"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u64 lock_secret;\n\nvoid __init ceph_flock_init(void)\n{\n\tget_random_bytes(&lock_secret, sizeof(lock_secret));\n}"
  },
  {
    "function_name": "secure_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
    "lines": "15-25",
    "snippet": "static inline u64 secure_addr(void *addr)\n{\n\tu64 v = lock_secret ^ (u64)(unsigned long)addr;\n\t/*\n\t * Set the most significant bit, so that MDS knows the 'owner'\n\t * is sufficient to identify the owner of lock. (old code uses\n\t * both 'owner' and 'pid')\n\t */\n\tv |= (1ULL << 63);\n\treturn v;\n}",
    "includes": [
      "#include <linux/ceph/pagelist.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/file.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 lock_secret;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u64 lock_secret;\n\nstatic inline u64 secure_addr(void *addr)\n{\n\tu64 v = lock_secret ^ (u64)(unsigned long)addr;\n\t/*\n\t * Set the most significant bit, so that MDS knows the 'owner'\n\t * is sufficient to identify the owner of lock. (old code uses\n\t * both 'owner' and 'pid')\n\t */\n\tv |= (1ULL << 63);\n\treturn v;\n}"
  }
]