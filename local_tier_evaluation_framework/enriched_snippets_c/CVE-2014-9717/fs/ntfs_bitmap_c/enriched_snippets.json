[
  {
    "function_name": "__ntfs_bitmap_set_bits_in_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.c",
    "lines": "47-191",
    "snippet": "int __ntfs_bitmap_set_bits_in_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count, const u8 value, const bool is_rollback)\n{\n\ts64 cnt = count;\n\tpgoff_t index, end_index;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tint pos, len;\n\tu8 bit;\n\n\tBUG_ON(!vi);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_bit 0x%llx, count 0x%llx, \"\n\t\t\t\"value %u.%s\", vi->i_ino, (unsigned long long)start_bit,\n\t\t\t(unsigned long long)cnt, (unsigned int)value,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tBUG_ON(start_bit < 0);\n\tBUG_ON(cnt < 0);\n\tBUG_ON(value > 1);\n\t/*\n\t * Calculate the indices for the pages containing the first and last\n\t * bits, i.e. @start_bit and @start_bit + @cnt - 1, respectively.\n\t */\n\tindex = start_bit >> (3 + PAGE_CACHE_SHIFT);\n\tend_index = (start_bit + cnt - 1) >> (3 + PAGE_CACHE_SHIFT);\n\n\t/* Get the page containing the first bit (@start_bit). */\n\tmapping = vi->i_mapping;\n\tpage = ntfs_map_page(mapping, index);\n\tif (IS_ERR(page)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vi->i_sb, \"Failed to map first page (error \"\n\t\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\tkaddr = page_address(page);\n\n\t/* Set @pos to the position of the byte containing @start_bit. */\n\tpos = (start_bit >> 3) & ~PAGE_CACHE_MASK;\n\n\t/* Calculate the position of @start_bit in the first byte. */\n\tbit = start_bit & 7;\n\n\t/* If the first byte is partial, modify the appropriate bits in it. */\n\tif (bit) {\n\t\tu8 *byte = kaddr + pos;\n\t\twhile ((bit & 7) && cnt) {\n\t\t\tcnt--;\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit++;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit++);\n\t\t}\n\t\t/* If we are done, unmap the page and return success. */\n\t\tif (!cnt)\n\t\t\tgoto done;\n\n\t\t/* Update @pos to the new position. */\n\t\tpos++;\n\t}\n\t/*\n\t * Depending on @value, modify all remaining whole bytes in the page up\n\t * to @cnt.\n\t */\n\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE - pos);\n\tmemset(kaddr + pos, value ? 0xff : 0, len);\n\tcnt -= len << 3;\n\n\t/* Update @len to point to the first not-done byte in the page. */\n\tif (cnt < 8)\n\t\tlen += pos;\n\n\t/* If we are not in the last page, deal with all subsequent pages. */\n\twhile (index < end_index) {\n\t\tBUG_ON(cnt <= 0);\n\n\t\t/* Update @index and get the next page. */\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tntfs_unmap_page(page);\n\t\tpage = ntfs_map_page(mapping, ++index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto rollback;\n\t\tkaddr = page_address(page);\n\t\t/*\n\t\t * Depending on @value, modify all remaining whole bytes in the\n\t\t * page up to @cnt.\n\t\t */\n\t\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE);\n\t\tmemset(kaddr, value ? 0xff : 0, len);\n\t\tcnt -= len << 3;\n\t}\n\t/*\n\t * The currently mapped page is the last one.  If the last byte is\n\t * partial, modify the appropriate bits in it.  Note, @len is the\n\t * position of the last byte inside the page.\n\t */\n\tif (cnt) {\n\t\tu8 *byte;\n\n\t\tBUG_ON(cnt > 7);\n\n\t\tbit = cnt;\n\t\tbyte = kaddr + len;\n\t\twhile (bit--) {\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit);\n\t\t}\n\t}\ndone:\n\t/* We are done.  Unmap the page and return success. */\n\tflush_dcache_page(page);\n\tset_page_dirty(page);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrollback:\n\t/*\n\t * Current state:\n\t *\t- no pages are mapped\n\t *\t- @count - @cnt is the number of bits that have been modified\n\t */\n\tif (is_rollback)\n\t\treturn PTR_ERR(page);\n\tif (count != cnt)\n\t\tpos = __ntfs_bitmap_set_bits_in_run(vi, start_bit, count - cnt,\n\t\t\t\tvalue ? 0 : 1, true);\n\telse\n\t\tpos = 0;\n\tif (!pos) {\n\t\t/* Rollback was successful. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t} else {\n\t\t/* Rollback failed. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li) and rollback failed (error %i).  \"\n\t\t\t\t\"Aborting and leaving inconsistent metadata.  \"\n\t\t\t\t\"Unmount and run chkdsk.\", PTR_ERR(page), pos);\n\t\tNVolSetErrors(NTFS_SB(vi->i_sb));\n\t}\n\treturn PTR_ERR(page);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"aops.h\"",
      "#include \"debug.h\"",
      "#include \"bitmap.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "NTFS_SB(vi->i_sb)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "vi->i_sb"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to map subsequent page (error \"\n\t\t\t\t\"%li) and rollback failed (error %i).  \"\n\t\t\t\t\"Aborting and leaving inconsistent metadata.  \"\n\t\t\t\t\"Unmount and run chkdsk.\"",
            "PTR_ERR(page)",
            "pos"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ntfs_bitmap_set_bits_in_run",
          "args": [
            "vi",
            "start_bit",
            "count - cnt",
            "value ? 0 : 1",
            "true"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_bitmap_set_bits_in_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.c",
          "lines": "47-191",
          "snippet": "int __ntfs_bitmap_set_bits_in_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count, const u8 value, const bool is_rollback)\n{\n\ts64 cnt = count;\n\tpgoff_t index, end_index;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tint pos, len;\n\tu8 bit;\n\n\tBUG_ON(!vi);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_bit 0x%llx, count 0x%llx, \"\n\t\t\t\"value %u.%s\", vi->i_ino, (unsigned long long)start_bit,\n\t\t\t(unsigned long long)cnt, (unsigned int)value,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tBUG_ON(start_bit < 0);\n\tBUG_ON(cnt < 0);\n\tBUG_ON(value > 1);\n\t/*\n\t * Calculate the indices for the pages containing the first and last\n\t * bits, i.e. @start_bit and @start_bit + @cnt - 1, respectively.\n\t */\n\tindex = start_bit >> (3 + PAGE_CACHE_SHIFT);\n\tend_index = (start_bit + cnt - 1) >> (3 + PAGE_CACHE_SHIFT);\n\n\t/* Get the page containing the first bit (@start_bit). */\n\tmapping = vi->i_mapping;\n\tpage = ntfs_map_page(mapping, index);\n\tif (IS_ERR(page)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vi->i_sb, \"Failed to map first page (error \"\n\t\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\tkaddr = page_address(page);\n\n\t/* Set @pos to the position of the byte containing @start_bit. */\n\tpos = (start_bit >> 3) & ~PAGE_CACHE_MASK;\n\n\t/* Calculate the position of @start_bit in the first byte. */\n\tbit = start_bit & 7;\n\n\t/* If the first byte is partial, modify the appropriate bits in it. */\n\tif (bit) {\n\t\tu8 *byte = kaddr + pos;\n\t\twhile ((bit & 7) && cnt) {\n\t\t\tcnt--;\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit++;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit++);\n\t\t}\n\t\t/* If we are done, unmap the page and return success. */\n\t\tif (!cnt)\n\t\t\tgoto done;\n\n\t\t/* Update @pos to the new position. */\n\t\tpos++;\n\t}\n\t/*\n\t * Depending on @value, modify all remaining whole bytes in the page up\n\t * to @cnt.\n\t */\n\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE - pos);\n\tmemset(kaddr + pos, value ? 0xff : 0, len);\n\tcnt -= len << 3;\n\n\t/* Update @len to point to the first not-done byte in the page. */\n\tif (cnt < 8)\n\t\tlen += pos;\n\n\t/* If we are not in the last page, deal with all subsequent pages. */\n\twhile (index < end_index) {\n\t\tBUG_ON(cnt <= 0);\n\n\t\t/* Update @index and get the next page. */\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tntfs_unmap_page(page);\n\t\tpage = ntfs_map_page(mapping, ++index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto rollback;\n\t\tkaddr = page_address(page);\n\t\t/*\n\t\t * Depending on @value, modify all remaining whole bytes in the\n\t\t * page up to @cnt.\n\t\t */\n\t\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE);\n\t\tmemset(kaddr, value ? 0xff : 0, len);\n\t\tcnt -= len << 3;\n\t}\n\t/*\n\t * The currently mapped page is the last one.  If the last byte is\n\t * partial, modify the appropriate bits in it.  Note, @len is the\n\t * position of the last byte inside the page.\n\t */\n\tif (cnt) {\n\t\tu8 *byte;\n\n\t\tBUG_ON(cnt > 7);\n\n\t\tbit = cnt;\n\t\tbyte = kaddr + len;\n\t\twhile (bit--) {\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit);\n\t\t}\n\t}\ndone:\n\t/* We are done.  Unmap the page and return success. */\n\tflush_dcache_page(page);\n\tset_page_dirty(page);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrollback:\n\t/*\n\t * Current state:\n\t *\t- no pages are mapped\n\t *\t- @count - @cnt is the number of bits that have been modified\n\t */\n\tif (is_rollback)\n\t\treturn PTR_ERR(page);\n\tif (count != cnt)\n\t\tpos = __ntfs_bitmap_set_bits_in_run(vi, start_bit, count - cnt,\n\t\t\t\tvalue ? 0 : 1, true);\n\telse\n\t\tpos = 0;\n\tif (!pos) {\n\t\t/* Rollback was successful. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t} else {\n\t\t/* Rollback failed. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li) and rollback failed (error %i).  \"\n\t\t\t\t\"Aborting and leaving inconsistent metadata.  \"\n\t\t\t\t\"Unmount and run chkdsk.\", PTR_ERR(page), pos);\n\t\tNVolSetErrors(NTFS_SB(vi->i_sb));\n\t}\n\treturn PTR_ERR(page);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cnt > 7"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr",
            "value ? 0xff : 0",
            "len"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "s64",
            "cnt >> 3",
            "PAGE_CACHE_SIZE"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "mapping",
            "++index"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cnt <= 0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + pos",
            "value ? 0xff : 0",
            "len"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "s64",
            "cnt >> 3",
            "PAGE_CACHE_SIZE - pos"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "value > 1"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cnt < 0"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start_bit < 0"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx, start_bit 0x%llx, count 0x%llx, \"\n\t\t\t\"value %u.%s\"",
            "vi->i_ino",
            "(unsigned long long)start_bit",
            "(unsigned long long)cnt",
            "(unsigned int)value",
            "is_rollback ? \" (rollback)\" : \"\""
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vi"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include <linux/pagemap.h>\n\nint __ntfs_bitmap_set_bits_in_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count, const u8 value, const bool is_rollback)\n{\n\ts64 cnt = count;\n\tpgoff_t index, end_index;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tint pos, len;\n\tu8 bit;\n\n\tBUG_ON(!vi);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_bit 0x%llx, count 0x%llx, \"\n\t\t\t\"value %u.%s\", vi->i_ino, (unsigned long long)start_bit,\n\t\t\t(unsigned long long)cnt, (unsigned int)value,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tBUG_ON(start_bit < 0);\n\tBUG_ON(cnt < 0);\n\tBUG_ON(value > 1);\n\t/*\n\t * Calculate the indices for the pages containing the first and last\n\t * bits, i.e. @start_bit and @start_bit + @cnt - 1, respectively.\n\t */\n\tindex = start_bit >> (3 + PAGE_CACHE_SHIFT);\n\tend_index = (start_bit + cnt - 1) >> (3 + PAGE_CACHE_SHIFT);\n\n\t/* Get the page containing the first bit (@start_bit). */\n\tmapping = vi->i_mapping;\n\tpage = ntfs_map_page(mapping, index);\n\tif (IS_ERR(page)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vi->i_sb, \"Failed to map first page (error \"\n\t\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\tkaddr = page_address(page);\n\n\t/* Set @pos to the position of the byte containing @start_bit. */\n\tpos = (start_bit >> 3) & ~PAGE_CACHE_MASK;\n\n\t/* Calculate the position of @start_bit in the first byte. */\n\tbit = start_bit & 7;\n\n\t/* If the first byte is partial, modify the appropriate bits in it. */\n\tif (bit) {\n\t\tu8 *byte = kaddr + pos;\n\t\twhile ((bit & 7) && cnt) {\n\t\t\tcnt--;\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit++;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit++);\n\t\t}\n\t\t/* If we are done, unmap the page and return success. */\n\t\tif (!cnt)\n\t\t\tgoto done;\n\n\t\t/* Update @pos to the new position. */\n\t\tpos++;\n\t}\n\t/*\n\t * Depending on @value, modify all remaining whole bytes in the page up\n\t * to @cnt.\n\t */\n\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE - pos);\n\tmemset(kaddr + pos, value ? 0xff : 0, len);\n\tcnt -= len << 3;\n\n\t/* Update @len to point to the first not-done byte in the page. */\n\tif (cnt < 8)\n\t\tlen += pos;\n\n\t/* If we are not in the last page, deal with all subsequent pages. */\n\twhile (index < end_index) {\n\t\tBUG_ON(cnt <= 0);\n\n\t\t/* Update @index and get the next page. */\n\t\tflush_dcache_page(page);\n\t\tset_page_dirty(page);\n\t\tntfs_unmap_page(page);\n\t\tpage = ntfs_map_page(mapping, ++index);\n\t\tif (IS_ERR(page))\n\t\t\tgoto rollback;\n\t\tkaddr = page_address(page);\n\t\t/*\n\t\t * Depending on @value, modify all remaining whole bytes in the\n\t\t * page up to @cnt.\n\t\t */\n\t\tlen = min_t(s64, cnt >> 3, PAGE_CACHE_SIZE);\n\t\tmemset(kaddr, value ? 0xff : 0, len);\n\t\tcnt -= len << 3;\n\t}\n\t/*\n\t * The currently mapped page is the last one.  If the last byte is\n\t * partial, modify the appropriate bits in it.  Note, @len is the\n\t * position of the last byte inside the page.\n\t */\n\tif (cnt) {\n\t\tu8 *byte;\n\n\t\tBUG_ON(cnt > 7);\n\n\t\tbit = cnt;\n\t\tbyte = kaddr + len;\n\t\twhile (bit--) {\n\t\t\tif (value)\n\t\t\t\t*byte |= 1 << bit;\n\t\t\telse\n\t\t\t\t*byte &= ~(1 << bit);\n\t\t}\n\t}\ndone:\n\t/* We are done.  Unmap the page and return success. */\n\tflush_dcache_page(page);\n\tset_page_dirty(page);\n\tntfs_unmap_page(page);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nrollback:\n\t/*\n\t * Current state:\n\t *\t- no pages are mapped\n\t *\t- @count - @cnt is the number of bits that have been modified\n\t */\n\tif (is_rollback)\n\t\treturn PTR_ERR(page);\n\tif (count != cnt)\n\t\tpos = __ntfs_bitmap_set_bits_in_run(vi, start_bit, count - cnt,\n\t\t\t\tvalue ? 0 : 1, true);\n\telse\n\t\tpos = 0;\n\tif (!pos) {\n\t\t/* Rollback was successful. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li), aborting.\", PTR_ERR(page));\n\t} else {\n\t\t/* Rollback failed. */\n\t\tntfs_error(vi->i_sb, \"Failed to map subsequent page (error \"\n\t\t\t\t\"%li) and rollback failed (error %i).  \"\n\t\t\t\t\"Aborting and leaving inconsistent metadata.  \"\n\t\t\t\t\"Unmount and run chkdsk.\", PTR_ERR(page), pos);\n\t\tNVolSetErrors(NTFS_SB(vi->i_sb));\n\t}\n\treturn PTR_ERR(page);\n}"
  }
]