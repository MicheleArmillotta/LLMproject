[
  {
    "function_name": "btrfs_defrag_leaves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-defrag.c",
    "lines": "32-139",
    "snippet": "int btrfs_defrag_leaves(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root)\n{\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tint next_key_ret = 0;\n\tu64 last_ret = 0;\n\tu64 min_trans = 0;\n\n\tif (root->fs_info->extent_root == root) {\n\t\t/*\n\t\t * there's recursion here right now in the tree locking,\n\t\t * we can't defrag the extent root without deadlock\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tgoto out;\n\n\tif (btrfs_test_opt(root, SSD))\n\t\tgoto out;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(root->node);\n\n\tif (level == 0)\n\t\tgoto out;\n\n\tif (root->defrag_progress.objectid == 0) {\n\t\tstruct extent_buffer *root_node;\n\t\tu32 nritems;\n\n\t\troot_node = btrfs_lock_root_node(root);\n\t\tbtrfs_set_lock_blocking(root_node);\n\t\tnritems = btrfs_header_nritems(root_node);\n\t\troot->defrag_max.objectid = 0;\n\t\t/* from above we know this is not a leaf */\n\t\tbtrfs_node_key_to_cpu(root_node, &root->defrag_max,\n\t\t\t\t      nritems - 1);\n\t\tbtrfs_tree_unlock(root_node);\n\t\tfree_extent_buffer(root_node);\n\t\tmemset(&key, 0, sizeof(key));\n\t} else {\n\t\tmemcpy(&key, &root->defrag_progress, sizeof(key));\n\t}\n\n\tpath->keep_locks = 1;\n\n\tret = btrfs_search_forward(root, &key, path, min_trans);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\twret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\n\tif (wret < 0) {\n\t\tret = wret;\n\t\tgoto out;\n\t}\n\tif (!path->nodes[1]) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tpath->slots[1] = btrfs_header_nritems(path->nodes[1]);\n\tnext_key_ret = btrfs_find_next_key(root, path, &key, 1,\n\t\t\t\t\t   min_trans);\n\tret = btrfs_realloc_node(trans, root,\n\t\t\t\t path->nodes[1], 0,\n\t\t\t\t &last_ret,\n\t\t\t\t &root->defrag_progress);\n\tif (ret) {\n\t\tWARN_ON(ret == -EAGAIN);\n\t\tgoto out;\n\t}\n\tif (next_key_ret == 0) {\n\t\tmemcpy(&root->defrag_progress, &key, sizeof(key));\n\t\tret = -EAGAIN;\n\t}\nout:\n\tif (path)\n\t\tbtrfs_free_path(path);\n\tif (ret == -EAGAIN) {\n\t\tif (root->defrag_max.objectid > root->defrag_progress.objectid)\n\t\t\tgoto done;\n\t\tif (root->defrag_max.type > root->defrag_progress.type)\n\t\t\tgoto done;\n\t\tif (root->defrag_max.offset > root->defrag_progress.offset)\n\t\t\tgoto done;\n\t\tret = 0;\n\t}\ndone:\n\tif (ret != -EAGAIN) {\n\t\tmemset(&root->defrag_progress, 0,\n\t\t       sizeof(root->defrag_progress));\n\t\troot->defrag_trans_start = trans->transid;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"print-tree.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root->defrag_progress",
            "0",
            "sizeof(root->defrag_progress)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&root->defrag_progress",
            "&key",
            "sizeof(key)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_realloc_node",
          "args": [
            "trans",
            "root",
            "path->nodes[1]",
            "0",
            "&last_ret",
            "&root->defrag_progress"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_realloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1620-1722",
          "snippet": "int btrfs_realloc_node(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct extent_buffer *parent,\n\t\t       int start_slot, u64 *last_ret,\n\t\t       struct btrfs_key *progress)\n{\n\tstruct extent_buffer *cur;\n\tu64 blocknr;\n\tu64 gen;\n\tu64 search_start = *last_ret;\n\tu64 last_block = 0;\n\tu64 other;\n\tu32 parent_nritems;\n\tint end_slot;\n\tint i;\n\tint err = 0;\n\tint parent_level;\n\tint uptodate;\n\tu32 blocksize;\n\tint progress_passed = 0;\n\tstruct btrfs_disk_key disk_key;\n\n\tparent_level = btrfs_header_level(parent);\n\n\tWARN_ON(trans->transaction != root->fs_info->running_transaction);\n\tWARN_ON(trans->transid != root->fs_info->generation);\n\n\tparent_nritems = btrfs_header_nritems(parent);\n\tblocksize = root->nodesize;\n\tend_slot = parent_nritems - 1;\n\n\tif (parent_nritems <= 1)\n\t\treturn 0;\n\n\tbtrfs_set_lock_blocking(parent);\n\n\tfor (i = start_slot; i <= end_slot; i++) {\n\t\tint close = 1;\n\n\t\tbtrfs_node_key(parent, &disk_key, i);\n\t\tif (!progress_passed && comp_keys(&disk_key, progress) < 0)\n\t\t\tcontinue;\n\n\t\tprogress_passed = 1;\n\t\tblocknr = btrfs_node_blockptr(parent, i);\n\t\tgen = btrfs_node_ptr_generation(parent, i);\n\t\tif (last_block == 0)\n\t\t\tlast_block = blocknr;\n\n\t\tif (i > 0) {\n\t\t\tother = btrfs_node_blockptr(parent, i - 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (!close && i < end_slot) {\n\t\t\tother = btrfs_node_blockptr(parent, i + 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (close) {\n\t\t\tlast_block = blocknr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur = btrfs_find_tree_block(root, blocknr);\n\t\tif (cur)\n\t\t\tuptodate = btrfs_buffer_uptodate(cur, gen, 0);\n\t\telse\n\t\t\tuptodate = 0;\n\t\tif (!cur || !uptodate) {\n\t\t\tif (!cur) {\n\t\t\t\tcur = read_tree_block(root, blocknr, gen);\n\t\t\t\tif (!cur || !extent_buffer_uptodate(cur)) {\n\t\t\t\t\tfree_extent_buffer(cur);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t} else if (!uptodate) {\n\t\t\t\terr = btrfs_read_buffer(cur, gen);\n\t\t\t\tif (err) {\n\t\t\t\t\tfree_extent_buffer(cur);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (search_start == 0)\n\t\t\tsearch_start = last_block;\n\n\t\tbtrfs_tree_lock(cur);\n\t\tbtrfs_set_lock_blocking(cur);\n\t\terr = __btrfs_cow_block(trans, root, cur, parent, i,\n\t\t\t\t\t&cur, search_start,\n\t\t\t\t\tmin(16 * blocksize,\n\t\t\t\t\t    (end_slot - i) * blocksize));\n\t\tif (err) {\n\t\t\tbtrfs_tree_unlock(cur);\n\t\t\tfree_extent_buffer(cur);\n\t\t\tbreak;\n\t\t}\n\t\tsearch_start = cur->start;\n\t\tlast_block = cur->start;\n\t\t*last_ret = search_start;\n\t\tbtrfs_tree_unlock(cur);\n\t\tfree_extent_buffer(cur);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_realloc_node(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct extent_buffer *parent,\n\t\t       int start_slot, u64 *last_ret,\n\t\t       struct btrfs_key *progress)\n{\n\tstruct extent_buffer *cur;\n\tu64 blocknr;\n\tu64 gen;\n\tu64 search_start = *last_ret;\n\tu64 last_block = 0;\n\tu64 other;\n\tu32 parent_nritems;\n\tint end_slot;\n\tint i;\n\tint err = 0;\n\tint parent_level;\n\tint uptodate;\n\tu32 blocksize;\n\tint progress_passed = 0;\n\tstruct btrfs_disk_key disk_key;\n\n\tparent_level = btrfs_header_level(parent);\n\n\tWARN_ON(trans->transaction != root->fs_info->running_transaction);\n\tWARN_ON(trans->transid != root->fs_info->generation);\n\n\tparent_nritems = btrfs_header_nritems(parent);\n\tblocksize = root->nodesize;\n\tend_slot = parent_nritems - 1;\n\n\tif (parent_nritems <= 1)\n\t\treturn 0;\n\n\tbtrfs_set_lock_blocking(parent);\n\n\tfor (i = start_slot; i <= end_slot; i++) {\n\t\tint close = 1;\n\n\t\tbtrfs_node_key(parent, &disk_key, i);\n\t\tif (!progress_passed && comp_keys(&disk_key, progress) < 0)\n\t\t\tcontinue;\n\n\t\tprogress_passed = 1;\n\t\tblocknr = btrfs_node_blockptr(parent, i);\n\t\tgen = btrfs_node_ptr_generation(parent, i);\n\t\tif (last_block == 0)\n\t\t\tlast_block = blocknr;\n\n\t\tif (i > 0) {\n\t\t\tother = btrfs_node_blockptr(parent, i - 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (!close && i < end_slot) {\n\t\t\tother = btrfs_node_blockptr(parent, i + 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (close) {\n\t\t\tlast_block = blocknr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur = btrfs_find_tree_block(root, blocknr);\n\t\tif (cur)\n\t\t\tuptodate = btrfs_buffer_uptodate(cur, gen, 0);\n\t\telse\n\t\t\tuptodate = 0;\n\t\tif (!cur || !uptodate) {\n\t\t\tif (!cur) {\n\t\t\t\tcur = read_tree_block(root, blocknr, gen);\n\t\t\t\tif (!cur || !extent_buffer_uptodate(cur)) {\n\t\t\t\t\tfree_extent_buffer(cur);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t} else if (!uptodate) {\n\t\t\t\terr = btrfs_read_buffer(cur, gen);\n\t\t\t\tif (err) {\n\t\t\t\t\tfree_extent_buffer(cur);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (search_start == 0)\n\t\t\tsearch_start = last_block;\n\n\t\tbtrfs_tree_lock(cur);\n\t\tbtrfs_set_lock_blocking(cur);\n\t\terr = __btrfs_cow_block(trans, root, cur, parent, i,\n\t\t\t\t\t&cur, search_start,\n\t\t\t\t\tmin(16 * blocksize,\n\t\t\t\t\t    (end_slot - i) * blocksize));\n\t\tif (err) {\n\t\t\tbtrfs_tree_unlock(cur);\n\t\t\tfree_extent_buffer(cur);\n\t\t\tbreak;\n\t\t}\n\t\tsearch_start = cur->start;\n\t\tlast_block = cur->start;\n\t\t*last_ret = search_start;\n\t\tbtrfs_tree_unlock(cur);\n\t\tfree_extent_buffer(cur);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_next_key",
          "args": [
            "root",
            "path",
            "&key",
            "1",
            "min_trans"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_next_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5576-5639",
          "snippet": "int btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, int level, u64 min_trans)\n{\n\tint slot;\n\tstruct extent_buffer *c;\n\n\tWARN_ON(!path->keep_locks);\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\treturn 1;\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\nnext:\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tint ret;\n\t\t\tint orig_lowest;\n\t\t\tstruct btrfs_key cur_key;\n\t\t\tif (level + 1 >= BTRFS_MAX_LEVEL ||\n\t\t\t    !path->nodes[level + 1])\n\t\t\t\treturn 1;\n\n\t\t\tif (path->locks[level + 1]) {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslot = btrfs_header_nritems(c) - 1;\n\t\t\tif (level == 0)\n\t\t\t\tbtrfs_item_key_to_cpu(c, &cur_key, slot);\n\t\t\telse\n\t\t\t\tbtrfs_node_key_to_cpu(c, &cur_key, slot);\n\n\t\t\torig_lowest = path->lowest_level;\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->lowest_level = level;\n\t\t\tret = btrfs_search_slot(NULL, root, &cur_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tpath->lowest_level = orig_lowest;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tc = path->nodes[level];\n\t\t\tslot = path->slots[level];\n\t\t\tif (ret == 0)\n\t\t\t\tslot++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tbtrfs_item_key_to_cpu(c, key, slot);\n\t\telse {\n\t\t\tu64 gen = btrfs_node_ptr_generation(c, slot);\n\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbtrfs_node_key_to_cpu(c, key, slot);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, int level, u64 min_trans)\n{\n\tint slot;\n\tstruct extent_buffer *c;\n\n\tWARN_ON(!path->keep_locks);\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\treturn 1;\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\nnext:\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tint ret;\n\t\t\tint orig_lowest;\n\t\t\tstruct btrfs_key cur_key;\n\t\t\tif (level + 1 >= BTRFS_MAX_LEVEL ||\n\t\t\t    !path->nodes[level + 1])\n\t\t\t\treturn 1;\n\n\t\t\tif (path->locks[level + 1]) {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslot = btrfs_header_nritems(c) - 1;\n\t\t\tif (level == 0)\n\t\t\t\tbtrfs_item_key_to_cpu(c, &cur_key, slot);\n\t\t\telse\n\t\t\t\tbtrfs_node_key_to_cpu(c, &cur_key, slot);\n\n\t\t\torig_lowest = path->lowest_level;\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->lowest_level = level;\n\t\t\tret = btrfs_search_slot(NULL, root, &cur_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tpath->lowest_level = orig_lowest;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tc = path->nodes[level];\n\t\t\tslot = path->slots[level];\n\t\t\tif (ret == 0)\n\t\t\t\tslot++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tbtrfs_item_key_to_cpu(c, key, slot);\n\t\telse {\n\t\t\tu64 gen = btrfs_node_ptr_generation(c, slot);\n\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbtrfs_node_key_to_cpu(c, key, slot);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[1]"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_forward",
          "args": [
            "root",
            "&key",
            "path",
            "min_trans"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5113-5211",
          "snippet": "int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&key",
            "&root->defrag_progress",
            "sizeof(key)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&key",
            "0",
            "sizeof(key)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "root_node"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "root_node"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "root_node",
            "&root->defrag_max",
            "nritems - 1"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "root_node"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "root_node"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lock_root_node",
          "args": [
            "root"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "176-189",
          "snippet": "struct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "root->node"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SSD"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"transaction.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/sched.h>\n\nint btrfs_defrag_leaves(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root)\n{\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tint next_key_ret = 0;\n\tu64 last_ret = 0;\n\tu64 min_trans = 0;\n\n\tif (root->fs_info->extent_root == root) {\n\t\t/*\n\t\t * there's recursion here right now in the tree locking,\n\t\t * we can't defrag the extent root without deadlock\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tgoto out;\n\n\tif (btrfs_test_opt(root, SSD))\n\t\tgoto out;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(root->node);\n\n\tif (level == 0)\n\t\tgoto out;\n\n\tif (root->defrag_progress.objectid == 0) {\n\t\tstruct extent_buffer *root_node;\n\t\tu32 nritems;\n\n\t\troot_node = btrfs_lock_root_node(root);\n\t\tbtrfs_set_lock_blocking(root_node);\n\t\tnritems = btrfs_header_nritems(root_node);\n\t\troot->defrag_max.objectid = 0;\n\t\t/* from above we know this is not a leaf */\n\t\tbtrfs_node_key_to_cpu(root_node, &root->defrag_max,\n\t\t\t\t      nritems - 1);\n\t\tbtrfs_tree_unlock(root_node);\n\t\tfree_extent_buffer(root_node);\n\t\tmemset(&key, 0, sizeof(key));\n\t} else {\n\t\tmemcpy(&key, &root->defrag_progress, sizeof(key));\n\t}\n\n\tpath->keep_locks = 1;\n\n\tret = btrfs_search_forward(root, &key, path, min_trans);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\twret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\n\tif (wret < 0) {\n\t\tret = wret;\n\t\tgoto out;\n\t}\n\tif (!path->nodes[1]) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tpath->slots[1] = btrfs_header_nritems(path->nodes[1]);\n\tnext_key_ret = btrfs_find_next_key(root, path, &key, 1,\n\t\t\t\t\t   min_trans);\n\tret = btrfs_realloc_node(trans, root,\n\t\t\t\t path->nodes[1], 0,\n\t\t\t\t &last_ret,\n\t\t\t\t &root->defrag_progress);\n\tif (ret) {\n\t\tWARN_ON(ret == -EAGAIN);\n\t\tgoto out;\n\t}\n\tif (next_key_ret == 0) {\n\t\tmemcpy(&root->defrag_progress, &key, sizeof(key));\n\t\tret = -EAGAIN;\n\t}\nout:\n\tif (path)\n\t\tbtrfs_free_path(path);\n\tif (ret == -EAGAIN) {\n\t\tif (root->defrag_max.objectid > root->defrag_progress.objectid)\n\t\t\tgoto done;\n\t\tif (root->defrag_max.type > root->defrag_progress.type)\n\t\t\tgoto done;\n\t\tif (root->defrag_max.offset > root->defrag_progress.offset)\n\t\t\tgoto done;\n\t\tret = 0;\n\t}\ndone:\n\tif (ret != -EAGAIN) {\n\t\tmemset(&root->defrag_progress, 0,\n\t\t       sizeof(root->defrag_progress));\n\t\troot->defrag_trans_start = trans->transid;\n\t}\n\treturn ret;\n}"
  }
]