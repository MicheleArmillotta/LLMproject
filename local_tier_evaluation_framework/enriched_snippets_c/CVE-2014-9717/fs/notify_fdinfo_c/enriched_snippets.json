[
  {
    "function_name": "fanotify_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
    "lines": "132-159",
    "snippet": "void fanotify_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tunsigned int flags = 0;\n\n\tswitch (group->priority) {\n\tcase FS_PRIO_0:\n\t\tflags |= FAN_CLASS_NOTIF;\n\t\tbreak;\n\tcase FS_PRIO_1:\n\t\tflags |= FAN_CLASS_CONTENT;\n\t\tbreak;\n\tcase FS_PRIO_2:\n\t\tflags |= FAN_CLASS_PRE_CONTENT;\n\t\tbreak;\n\t}\n\n\tif (group->max_events == UINT_MAX)\n\t\tflags |= FAN_UNLIMITED_QUEUE;\n\n\tif (group->fanotify_data.max_marks == UINT_MAX)\n\t\tflags |= FAN_UNLIMITED_MARKS;\n\n\tseq_printf(m, \"fanotify flags:%x event-flags:%x\\n\",\n\t\t   flags, group->fanotify_data.f_flags);\n\n\tshow_fdinfo(m, f, fanotify_fdinfo);\n}",
    "includes": [
      "#include \"../fs/mount.h\"",
      "#include \"inotify/inotify.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fanotify.h>",
      "#include <linux/inotify.h>",
      "#include <linux/init.h>",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_fdinfo",
          "args": [
            "m",
            "f",
            "fanotify_fdinfo"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "show_fdinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
          "lines": "23-37",
          "snippet": "static void show_fdinfo(struct seq_file *m, struct file *f,\n\t\t\tvoid (*show)(struct seq_file *m,\n\t\t\t\t     struct fsnotify_mark *mark))\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tstruct fsnotify_mark *mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tlist_for_each_entry(mark, &group->marks_list, g_list) {\n\t\tshow(m, mark);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}",
          "includes": [
            "#include \"../fs/mount.h\"",
            "#include \"inotify/inotify.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fanotify.h>",
            "#include <linux/inotify.h>",
            "#include <linux/init.h>",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void show_fdinfo(struct seq_file *m, struct file *f,\n\t\t\tvoid (*show)(struct seq_file *m,\n\t\t\t\t     struct fsnotify_mark *mark))\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tstruct fsnotify_mark *mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tlist_for_each_entry(mark, &group->marks_list, g_list) {\n\t\tshow(m, mark);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"fanotify flags:%x event-flags:%x\\n\"",
            "flags",
            "group->fanotify_data.f_flags"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid fanotify_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tunsigned int flags = 0;\n\n\tswitch (group->priority) {\n\tcase FS_PRIO_0:\n\t\tflags |= FAN_CLASS_NOTIF;\n\t\tbreak;\n\tcase FS_PRIO_1:\n\t\tflags |= FAN_CLASS_CONTENT;\n\t\tbreak;\n\tcase FS_PRIO_2:\n\t\tflags |= FAN_CLASS_PRE_CONTENT;\n\t\tbreak;\n\t}\n\n\tif (group->max_events == UINT_MAX)\n\t\tflags |= FAN_UNLIMITED_QUEUE;\n\n\tif (group->fanotify_data.max_marks == UINT_MAX)\n\t\tflags |= FAN_UNLIMITED_MARKS;\n\n\tseq_printf(m, \"fanotify flags:%x event-flags:%x\\n\",\n\t\t   flags, group->fanotify_data.f_flags);\n\n\tshow_fdinfo(m, f, fanotify_fdinfo);\n}"
  },
  {
    "function_name": "fanotify_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
    "lines": "103-130",
    "snippet": "static void fanotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\n{\n\tunsigned int mflags = 0;\n\tstruct inode *inode;\n\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE))\n\t\treturn;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)\n\t\tmflags |= FAN_MARK_IGNORED_SURV_MODIFY;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = igrab(mark->inode);\n\t\tif (!inode)\n\t\t\treturn;\n\t\tseq_printf(m, \"fanotify ino:%lx sdev:%x mflags:%x mask:%x ignored_mask:%x \",\n\t\t\t   inode->i_ino, inode->i_sb->s_dev,\n\t\t\t   mflags, mark->mask, mark->ignored_mask);\n\t\tshow_mark_fhandle(m, inode);\n\t\tseq_putc(m, '\\n');\n\t\tiput(inode);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT) {\n\t\tstruct mount *mnt = real_mount(mark->mnt);\n\n\t\tseq_printf(m, \"fanotify mnt_id:%x mflags:%x mask:%x ignored_mask:%x\\n\",\n\t\t\t   mnt->mnt_id, mflags, mark->mask, mark->ignored_mask);\n\t}\n}",
    "includes": [
      "#include \"../fs/mount.h\"",
      "#include \"inotify/inotify.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fanotify.h>",
      "#include <linux/inotify.h>",
      "#include <linux/init.h>",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"fanotify mnt_id:%x mflags:%x mask:%x ignored_mask:%x\\n\"",
            "mnt->mnt_id",
            "mflags",
            "mark->mask",
            "mark->ignored_mask"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mark->mnt"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_mark_fhandle",
          "args": [
            "m",
            "inode"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "show_mark_fhandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
          "lines": "67-69",
          "snippet": "static void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n}",
          "includes": [
            "#include \"../fs/mount.h\"",
            "#include \"inotify/inotify.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fanotify.h>",
            "#include <linux/inotify.h>",
            "#include <linux/init.h>",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "mark->inode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void fanotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\n{\n\tunsigned int mflags = 0;\n\tstruct inode *inode;\n\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE))\n\t\treturn;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)\n\t\tmflags |= FAN_MARK_IGNORED_SURV_MODIFY;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = igrab(mark->inode);\n\t\tif (!inode)\n\t\t\treturn;\n\t\tseq_printf(m, \"fanotify ino:%lx sdev:%x mflags:%x mask:%x ignored_mask:%x \",\n\t\t\t   inode->i_ino, inode->i_sb->s_dev,\n\t\t\t   mflags, mark->mask, mark->ignored_mask);\n\t\tshow_mark_fhandle(m, inode);\n\t\tseq_putc(m, '\\n');\n\t\tiput(inode);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT) {\n\t\tstruct mount *mnt = real_mount(mark->mnt);\n\n\t\tseq_printf(m, \"fanotify mnt_id:%x mflags:%x mask:%x ignored_mask:%x\\n\",\n\t\t\t   mnt->mnt_id, mflags, mark->mask, mark->ignored_mask);\n\t}\n}"
  },
  {
    "function_name": "inotify_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
    "lines": "94-97",
    "snippet": "void inotify_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tshow_fdinfo(m, f, inotify_fdinfo);\n}",
    "includes": [
      "#include \"../fs/mount.h\"",
      "#include \"inotify/inotify.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fanotify.h>",
      "#include <linux/inotify.h>",
      "#include <linux/init.h>",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_fdinfo",
          "args": [
            "m",
            "f",
            "inotify_fdinfo"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "show_fdinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
          "lines": "23-37",
          "snippet": "static void show_fdinfo(struct seq_file *m, struct file *f,\n\t\t\tvoid (*show)(struct seq_file *m,\n\t\t\t\t     struct fsnotify_mark *mark))\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tstruct fsnotify_mark *mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tlist_for_each_entry(mark, &group->marks_list, g_list) {\n\t\tshow(m, mark);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}",
          "includes": [
            "#include \"../fs/mount.h\"",
            "#include \"inotify/inotify.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fanotify.h>",
            "#include <linux/inotify.h>",
            "#include <linux/init.h>",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void show_fdinfo(struct seq_file *m, struct file *f,\n\t\t\tvoid (*show)(struct seq_file *m,\n\t\t\t\t     struct fsnotify_mark *mark))\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tstruct fsnotify_mark *mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tlist_for_each_entry(mark, &group->marks_list, g_list) {\n\t\tshow(m, mark);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid inotify_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tshow_fdinfo(m, f, inotify_fdinfo);\n}"
  },
  {
    "function_name": "inotify_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
    "lines": "74-92",
    "snippet": "static void inotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\n{\n\tstruct inotify_inode_mark *inode_mark;\n\tstruct inode *inode;\n\n\tif (!(mark->flags & (FSNOTIFY_MARK_FLAG_ALIVE | FSNOTIFY_MARK_FLAG_INODE)))\n\t\treturn;\n\n\tinode_mark = container_of(mark, struct inotify_inode_mark, fsn_mark);\n\tinode = igrab(mark->inode);\n\tif (inode) {\n\t\tseq_printf(m, \"inotify wd:%x ino:%lx sdev:%x mask:%x ignored_mask:%x \",\n\t\t\t   inode_mark->wd, inode->i_ino, inode->i_sb->s_dev,\n\t\t\t   mark->mask, mark->ignored_mask);\n\t\tshow_mark_fhandle(m, inode);\n\t\tseq_putc(m, '\\n');\n\t\tiput(inode);\n\t}\n}",
    "includes": [
      "#include \"../fs/mount.h\"",
      "#include \"inotify/inotify.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fanotify.h>",
      "#include <linux/inotify.h>",
      "#include <linux/init.h>",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_mark_fhandle",
          "args": [
            "m",
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "show_mark_fhandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
          "lines": "67-69",
          "snippet": "static void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n}",
          "includes": [
            "#include \"../fs/mount.h\"",
            "#include \"inotify/inotify.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fanotify.h>",
            "#include <linux/inotify.h>",
            "#include <linux/init.h>",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"inotify wd:%x ino:%lx sdev:%x mask:%x ignored_mask:%x \"",
            "inode_mark->wd",
            "inode->i_ino",
            "inode->i_sb->s_dev",
            "mark->mask",
            "mark->ignored_mask"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "mark->inode"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "mark",
            "structinotify_inode_mark",
            "fsn_mark"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void inotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\n{\n\tstruct inotify_inode_mark *inode_mark;\n\tstruct inode *inode;\n\n\tif (!(mark->flags & (FSNOTIFY_MARK_FLAG_ALIVE | FSNOTIFY_MARK_FLAG_INODE)))\n\t\treturn;\n\n\tinode_mark = container_of(mark, struct inotify_inode_mark, fsn_mark);\n\tinode = igrab(mark->inode);\n\tif (inode) {\n\t\tseq_printf(m, \"inotify wd:%x ino:%lx sdev:%x mask:%x ignored_mask:%x \",\n\t\t\t   inode_mark->wd, inode->i_ino, inode->i_sb->s_dev,\n\t\t\t   mark->mask, mark->ignored_mask);\n\t\tshow_mark_fhandle(m, inode);\n\t\tseq_putc(m, '\\n');\n\t\tiput(inode);\n\t}\n}"
  },
  {
    "function_name": "show_mark_fhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
    "lines": "67-69",
    "snippet": "static void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n}",
    "includes": [
      "#include \"../fs/mount.h\"",
      "#include \"inotify/inotify.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fanotify.h>",
      "#include <linux/inotify.h>",
      "#include <linux/init.h>",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n}"
  },
  {
    "function_name": "show_mark_fhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
    "lines": "40-65",
    "snippet": "static void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n\tstruct {\n\t\tstruct file_handle handle;\n\t\tu8 pad[MAX_HANDLE_SZ];\n\t} f;\n\tint size, ret, i;\n\n\tf.handle.handle_bytes = sizeof(f.pad);\n\tsize = f.handle.handle_bytes >> 2;\n\n\tret = exportfs_encode_inode_fh(inode, (struct fid *)f.handle.f_handle, &size, 0);\n\tif ((ret == FILEID_INVALID) || (ret < 0)) {\n\t\tWARN_ONCE(1, \"Can't encode file handler for inotify: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tf.handle.handle_type = ret;\n\tf.handle.handle_bytes = size * sizeof(u32);\n\n\tseq_printf(m, \"fhandle-bytes:%x fhandle-type:%x f_handle:\",\n\t\t   f.handle.handle_bytes, f.handle.handle_type);\n\n\tfor (i = 0; i < f.handle.handle_bytes; i++)\n\t\tseq_printf(m, \"%02x\", (int)f.handle.f_handle[i]);\n}",
    "includes": [
      "#include \"../fs/mount.h\"",
      "#include \"inotify/inotify.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fanotify.h>",
      "#include <linux/inotify.h>",
      "#include <linux/init.h>",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%02x\"",
            "(int)f.handle.f_handle[i]"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Can't encode file handler for inotify: %d\\n\"",
            "ret"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportfs_encode_inode_fh",
          "args": [
            "inode",
            "(struct fid *)f.handle.f_handle",
            "&size",
            "0"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_encode_inode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "377-386",
          "snippet": "int exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\n\t\t\t     int *max_len, struct inode *parent)\n{\n\tconst struct export_operations *nop = inode->i_sb->s_export_op;\n\n\tif (nop && nop->encode_fh)\n\t\treturn nop->encode_fh(inode, fid->raw, max_len, parent);\n\n\treturn export_encode_fh(inode, fid, max_len, parent);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nint exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\n\t\t\t     int *max_len, struct inode *parent)\n{\n\tconst struct export_operations *nop = inode->i_sb->s_export_op;\n\n\tif (nop && nop->encode_fh)\n\t\treturn nop->encode_fh(inode, fid->raw, max_len, parent);\n\n\treturn export_encode_fh(inode, fid, max_len, parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void show_mark_fhandle(struct seq_file *m, struct inode *inode)\n{\n\tstruct {\n\t\tstruct file_handle handle;\n\t\tu8 pad[MAX_HANDLE_SZ];\n\t} f;\n\tint size, ret, i;\n\n\tf.handle.handle_bytes = sizeof(f.pad);\n\tsize = f.handle.handle_bytes >> 2;\n\n\tret = exportfs_encode_inode_fh(inode, (struct fid *)f.handle.f_handle, &size, 0);\n\tif ((ret == FILEID_INVALID) || (ret < 0)) {\n\t\tWARN_ONCE(1, \"Can't encode file handler for inotify: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tf.handle.handle_type = ret;\n\tf.handle.handle_bytes = size * sizeof(u32);\n\n\tseq_printf(m, \"fhandle-bytes:%x fhandle-type:%x f_handle:\",\n\t\t   f.handle.handle_bytes, f.handle.handle_type);\n\n\tfor (i = 0; i < f.handle.handle_bytes; i++)\n\t\tseq_printf(m, \"%02x\", (int)f.handle.f_handle[i]);\n}"
  },
  {
    "function_name": "show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
    "lines": "23-37",
    "snippet": "static void show_fdinfo(struct seq_file *m, struct file *f,\n\t\t\tvoid (*show)(struct seq_file *m,\n\t\t\t\t     struct fsnotify_mark *mark))\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tstruct fsnotify_mark *mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tlist_for_each_entry(mark, &group->marks_list, g_list) {\n\t\tshow(m, mark);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}",
    "includes": [
      "#include \"../fs/mount.h\"",
      "#include \"inotify/inotify.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fanotify.h>",
      "#include <linux/inotify.h>",
      "#include <linux/init.h>",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "m"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show",
          "args": [
            "m",
            "mark"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_show_fdinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fdinfo.c",
          "lines": "132-159",
          "snippet": "void fanotify_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tunsigned int flags = 0;\n\n\tswitch (group->priority) {\n\tcase FS_PRIO_0:\n\t\tflags |= FAN_CLASS_NOTIF;\n\t\tbreak;\n\tcase FS_PRIO_1:\n\t\tflags |= FAN_CLASS_CONTENT;\n\t\tbreak;\n\tcase FS_PRIO_2:\n\t\tflags |= FAN_CLASS_PRE_CONTENT;\n\t\tbreak;\n\t}\n\n\tif (group->max_events == UINT_MAX)\n\t\tflags |= FAN_UNLIMITED_QUEUE;\n\n\tif (group->fanotify_data.max_marks == UINT_MAX)\n\t\tflags |= FAN_UNLIMITED_MARKS;\n\n\tseq_printf(m, \"fanotify flags:%x event-flags:%x\\n\",\n\t\t   flags, group->fanotify_data.f_flags);\n\n\tshow_fdinfo(m, f, fanotify_fdinfo);\n}",
          "includes": [
            "#include \"../fs/mount.h\"",
            "#include \"inotify/inotify.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fanotify.h>",
            "#include <linux/inotify.h>",
            "#include <linux/init.h>",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid fanotify_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tunsigned int flags = 0;\n\n\tswitch (group->priority) {\n\tcase FS_PRIO_0:\n\t\tflags |= FAN_CLASS_NOTIF;\n\t\tbreak;\n\tcase FS_PRIO_1:\n\t\tflags |= FAN_CLASS_CONTENT;\n\t\tbreak;\n\tcase FS_PRIO_2:\n\t\tflags |= FAN_CLASS_PRE_CONTENT;\n\t\tbreak;\n\t}\n\n\tif (group->max_events == UINT_MAX)\n\t\tflags |= FAN_UNLIMITED_QUEUE;\n\n\tif (group->fanotify_data.max_marks == UINT_MAX)\n\t\tflags |= FAN_UNLIMITED_MARKS;\n\n\tseq_printf(m, \"fanotify flags:%x event-flags:%x\\n\",\n\t\t   flags, group->fanotify_data.f_flags);\n\n\tshow_fdinfo(m, f, fanotify_fdinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mark",
            "&group->marks_list",
            "g_list"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../fs/mount.h\"\n#include \"inotify/inotify.h\"\n#include <linux/exportfs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/fanotify.h>\n#include <linux/inotify.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void show_fdinfo(struct seq_file *m, struct file *f,\n\t\t\tvoid (*show)(struct seq_file *m,\n\t\t\t\t     struct fsnotify_mark *mark))\n{\n\tstruct fsnotify_group *group = f->private_data;\n\tstruct fsnotify_mark *mark;\n\n\tmutex_lock(&group->mark_mutex);\n\tlist_for_each_entry(mark, &group->marks_list, g_list) {\n\t\tshow(m, mark);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}"
  }
]