[
  {
    "function_name": "reiserfs_unpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ioctl.c",
    "lines": "171-230",
    "snippet": "int reiserfs_unpack(struct inode *inode, struct file *filp)\n{\n\tint retval = 0;\n\tint index;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tunsigned long write_from;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\n\tif (inode->i_size == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\treturn 0;\n\t}\n\t/* ioctl already done */\n\tif (REISERFS_I(inode)->i_flags & i_nopack_mask) {\n\t\treturn 0;\n\t}\n\n\t/* we need to make sure nobody is changing the file size beneath us */\n\treiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);\n\n\treiserfs_write_lock(inode->i_sb);\n\n\twrite_from = inode->i_size & (blocksize - 1);\n\t/* if we are on a block boundary, we are already unpacked.  */\n\tif (write_from == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we unpack by finding the page with the tail, and calling\n\t * __reiserfs_write_begin on that page.  This will force a\n\t * reiserfs_get_block to unpack the tail for us.\n\t */\n\tindex = inode->i_size >> PAGE_CACHE_SHIFT;\n\tmapping = inode->i_mapping;\n\tpage = grab_cache_page(mapping, index);\n\tretval = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\tretval = __reiserfs_write_begin(page, write_from, 0);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\t/* conversion can change page contents, must flush */\n\tflush_dcache_page(page);\n\tretval = reiserfs_commit_write(NULL, page, write_from, write_from);\n\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_commit_write",
          "args": [
            "NULL",
            "page",
            "write_from",
            "write_from"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2994-3068",
          "snippet": "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around\n\t\t * on the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around\n\t\t * on the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reiserfs_write_begin",
          "args": [
            "page",
            "write_from",
            "0"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2831-2884",
          "snippet": "int __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_mutex_lock_safe",
          "args": [
            "&inode->i_mutex",
            "inode->i_sb"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_mutex_lock_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "809-817",
          "snippet": "static inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_unpack(struct inode *inode, struct file *filp)\n{\n\tint retval = 0;\n\tint index;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tunsigned long write_from;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\n\tif (inode->i_size == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\treturn 0;\n\t}\n\t/* ioctl already done */\n\tif (REISERFS_I(inode)->i_flags & i_nopack_mask) {\n\t\treturn 0;\n\t}\n\n\t/* we need to make sure nobody is changing the file size beneath us */\n\treiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);\n\n\treiserfs_write_lock(inode->i_sb);\n\n\twrite_from = inode->i_size & (blocksize - 1);\n\t/* if we are on a block boundary, we are already unpacked.  */\n\tif (write_from == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we unpack by finding the page with the tail, and calling\n\t * __reiserfs_write_begin on that page.  This will force a\n\t * reiserfs_get_block to unpack the tail for us.\n\t */\n\tindex = inode->i_size >> PAGE_CACHE_SHIFT;\n\tmapping = inode->i_mapping;\n\tpage = grab_cache_page(mapping, index);\n\tretval = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\tretval = __reiserfs_write_begin(page, write_from, 0);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\t/* conversion can change page contents, must flush */\n\tflush_dcache_page(page);\n\tretval = reiserfs_commit_write(NULL, page, write_from, write_from);\n\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ioctl.c",
    "lines": "133-161",
    "snippet": "long reiserfs_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t/*\n\t * These are just misnamed, they actually\n\t * get/put from/to user an int\n\t */\n\tswitch (cmd) {\n\tcase REISERFS_IOC32_UNPACK:\n\t\tcmd = REISERFS_IOC_UNPACK;\n\t\tbreak;\n\tcase REISERFS_IOC32_GETFLAGS:\n\t\tcmd = REISERFS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase REISERFS_IOC32_SETFLAGS:\n\t\tcmd = REISERFS_IOC_SETFLAGS;\n\t\tbreak;\n\tcase REISERFS_IOC32_GETVERSION:\n\t\tcmd = REISERFS_IOC_GETVERSION;\n\t\tbreak;\n\tcase REISERFS_IOC32_SETVERSION:\n\t\tcmd = REISERFS_IOC_SETVERSION;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn reiserfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_ioctl",
          "args": [
            "file",
            "cmd",
            "(unsigned long) compat_ptr(arg)"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ioctl.c",
          "lines": "23-130",
          "snippet": "long reiserfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunsigned int flags;\n\tint err = 0;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tswitch (cmd) {\n\tcase REISERFS_IOC_UNPACK:\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (arg)\n\t\t\t\terr = reiserfs_unpack(inode, filp);\n\t\t} else\n\t\t\terr = -ENOTTY;\n\t\tbreak;\n\t\t/*\n\t\t * following two cases are taken from fs/ext2/ioctl.c by Remy\n\t\t * Card (card@masi.ibp.fr)\n\t\t */\n\tcase REISERFS_IOC_GETFLAGS:\n\t\tif (!reiserfs_attrs(inode->i_sb)) {\n\t\t\terr = -ENOTTY;\n\t\t\tbreak;\n\t\t}\n\n\t\tflags = REISERFS_I(inode)->i_attrs;\n\t\ti_attrs_to_sd_attrs(inode, (__u16 *) & flags);\n\t\terr = put_user(flags, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETFLAGS:{\n\t\t\tif (!reiserfs_attrs(inode->i_sb)) {\n\t\t\t\terr = -ENOTTY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = mnt_want_write_file(filp);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif (get_user(flags, (int __user *)arg)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Is it quota file? Do not allow user to mess with it\n\t\t\t */\n\t\t\tif (IS_NOQUOTA(inode)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif (((flags ^ REISERFS_I(inode)->\n\t\t\t      i_attrs) & (REISERFS_IMMUTABLE_FL |\n\t\t\t\t\t  REISERFS_APPEND_FL))\n\t\t\t    && !capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif ((flags & REISERFS_NOTAIL_FL) &&\n\t\t\t    S_ISREG(inode->i_mode)) {\n\t\t\t\tint result;\n\n\t\t\t\tresult = reiserfs_unpack(inode, filp);\n\t\t\t\tif (result) {\n\t\t\t\t\terr = result;\n\t\t\t\t\tgoto setflags_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsd_attrs_to_i_attrs(flags, inode);\n\t\t\tREISERFS_I(inode)->i_attrs = flags;\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\t\tmnt_drop_write_file(filp);\n\t\t\tbreak;\n\t\t}\n\tcase REISERFS_IOC_GETVERSION:\n\t\terr = put_user(inode->i_generation, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETVERSION:\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (get_user(inode->i_generation, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nlong reiserfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunsigned int flags;\n\tint err = 0;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tswitch (cmd) {\n\tcase REISERFS_IOC_UNPACK:\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (arg)\n\t\t\t\terr = reiserfs_unpack(inode, filp);\n\t\t} else\n\t\t\terr = -ENOTTY;\n\t\tbreak;\n\t\t/*\n\t\t * following two cases are taken from fs/ext2/ioctl.c by Remy\n\t\t * Card (card@masi.ibp.fr)\n\t\t */\n\tcase REISERFS_IOC_GETFLAGS:\n\t\tif (!reiserfs_attrs(inode->i_sb)) {\n\t\t\terr = -ENOTTY;\n\t\t\tbreak;\n\t\t}\n\n\t\tflags = REISERFS_I(inode)->i_attrs;\n\t\ti_attrs_to_sd_attrs(inode, (__u16 *) & flags);\n\t\terr = put_user(flags, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETFLAGS:{\n\t\t\tif (!reiserfs_attrs(inode->i_sb)) {\n\t\t\t\terr = -ENOTTY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = mnt_want_write_file(filp);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif (get_user(flags, (int __user *)arg)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Is it quota file? Do not allow user to mess with it\n\t\t\t */\n\t\t\tif (IS_NOQUOTA(inode)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif (((flags ^ REISERFS_I(inode)->\n\t\t\t      i_attrs) & (REISERFS_IMMUTABLE_FL |\n\t\t\t\t\t  REISERFS_APPEND_FL))\n\t\t\t    && !capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif ((flags & REISERFS_NOTAIL_FL) &&\n\t\t\t    S_ISREG(inode->i_mode)) {\n\t\t\t\tint result;\n\n\t\t\t\tresult = reiserfs_unpack(inode, filp);\n\t\t\t\tif (result) {\n\t\t\t\t\terr = result;\n\t\t\t\t\tgoto setflags_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsd_attrs_to_i_attrs(flags, inode);\n\t\t\tREISERFS_I(inode)->i_attrs = flags;\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\t\tmnt_drop_write_file(filp);\n\t\t\tbreak;\n\t\t}\n\tcase REISERFS_IOC_GETVERSION:\n\t\terr = put_user(inode->i_generation, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETVERSION:\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (get_user(inode->i_generation, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nlong reiserfs_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\t/*\n\t * These are just misnamed, they actually\n\t * get/put from/to user an int\n\t */\n\tswitch (cmd) {\n\tcase REISERFS_IOC32_UNPACK:\n\t\tcmd = REISERFS_IOC_UNPACK;\n\t\tbreak;\n\tcase REISERFS_IOC32_GETFLAGS:\n\t\tcmd = REISERFS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase REISERFS_IOC32_SETFLAGS:\n\t\tcmd = REISERFS_IOC_SETFLAGS;\n\t\tbreak;\n\tcase REISERFS_IOC32_GETVERSION:\n\t\tcmd = REISERFS_IOC_GETVERSION;\n\t\tbreak;\n\tcase REISERFS_IOC32_SETVERSION:\n\t\tcmd = REISERFS_IOC_SETVERSION;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn reiserfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}"
  },
  {
    "function_name": "reiserfs_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ioctl.c",
    "lines": "23-130",
    "snippet": "long reiserfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunsigned int flags;\n\tint err = 0;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tswitch (cmd) {\n\tcase REISERFS_IOC_UNPACK:\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (arg)\n\t\t\t\terr = reiserfs_unpack(inode, filp);\n\t\t} else\n\t\t\terr = -ENOTTY;\n\t\tbreak;\n\t\t/*\n\t\t * following two cases are taken from fs/ext2/ioctl.c by Remy\n\t\t * Card (card@masi.ibp.fr)\n\t\t */\n\tcase REISERFS_IOC_GETFLAGS:\n\t\tif (!reiserfs_attrs(inode->i_sb)) {\n\t\t\terr = -ENOTTY;\n\t\t\tbreak;\n\t\t}\n\n\t\tflags = REISERFS_I(inode)->i_attrs;\n\t\ti_attrs_to_sd_attrs(inode, (__u16 *) & flags);\n\t\terr = put_user(flags, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETFLAGS:{\n\t\t\tif (!reiserfs_attrs(inode->i_sb)) {\n\t\t\t\terr = -ENOTTY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = mnt_want_write_file(filp);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif (get_user(flags, (int __user *)arg)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Is it quota file? Do not allow user to mess with it\n\t\t\t */\n\t\t\tif (IS_NOQUOTA(inode)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif (((flags ^ REISERFS_I(inode)->\n\t\t\t      i_attrs) & (REISERFS_IMMUTABLE_FL |\n\t\t\t\t\t  REISERFS_APPEND_FL))\n\t\t\t    && !capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif ((flags & REISERFS_NOTAIL_FL) &&\n\t\t\t    S_ISREG(inode->i_mode)) {\n\t\t\t\tint result;\n\n\t\t\t\tresult = reiserfs_unpack(inode, filp);\n\t\t\t\tif (result) {\n\t\t\t\t\terr = result;\n\t\t\t\t\tgoto setflags_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsd_attrs_to_i_attrs(flags, inode);\n\t\t\tREISERFS_I(inode)->i_attrs = flags;\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\t\tmnt_drop_write_file(filp);\n\t\t\tbreak;\n\t\t}\n\tcase REISERFS_IOC_GETVERSION:\n\t\terr = put_user(inode->i_generation, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETVERSION:\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (get_user(inode->i_generation, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/time.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "inode->i_generation",
            "(int __user *)arg"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_generation",
            "(int __user *)arg"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_attrs_to_i_attrs",
          "args": [
            "flags",
            "inode"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "sd_attrs_to_i_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "3070-3094",
          "snippet": "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (sd_attrs & REISERFS_SYNC_FL)\n\t\t\tinode->i_flags |= S_SYNC;\n\t\telse\n\t\t\tinode->i_flags &= ~S_SYNC;\n\t\tif (sd_attrs & REISERFS_IMMUTABLE_FL)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t\tif (sd_attrs & REISERFS_APPEND_FL)\n\t\t\tinode->i_flags |= S_APPEND;\n\t\telse\n\t\t\tinode->i_flags &= ~S_APPEND;\n\t\tif (sd_attrs & REISERFS_NOATIME_FL)\n\t\t\tinode->i_flags |= S_NOATIME;\n\t\telse\n\t\t\tinode->i_flags &= ~S_NOATIME;\n\t\tif (sd_attrs & REISERFS_NOTAIL_FL)\n\t\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_nopack_mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_unpack",
          "args": [
            "inode",
            "filp"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ioctl.c",
          "lines": "171-230",
          "snippet": "int reiserfs_unpack(struct inode *inode, struct file *filp)\n{\n\tint retval = 0;\n\tint index;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tunsigned long write_from;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\n\tif (inode->i_size == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\treturn 0;\n\t}\n\t/* ioctl already done */\n\tif (REISERFS_I(inode)->i_flags & i_nopack_mask) {\n\t\treturn 0;\n\t}\n\n\t/* we need to make sure nobody is changing the file size beneath us */\n\treiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);\n\n\treiserfs_write_lock(inode->i_sb);\n\n\twrite_from = inode->i_size & (blocksize - 1);\n\t/* if we are on a block boundary, we are already unpacked.  */\n\tif (write_from == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we unpack by finding the page with the tail, and calling\n\t * __reiserfs_write_begin on that page.  This will force a\n\t * reiserfs_get_block to unpack the tail for us.\n\t */\n\tindex = inode->i_size >> PAGE_CACHE_SHIFT;\n\tmapping = inode->i_mapping;\n\tpage = grab_cache_page(mapping, index);\n\tretval = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\tretval = __reiserfs_write_begin(page, write_from, 0);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\t/* conversion can change page contents, must flush */\n\tflush_dcache_page(page);\n\tretval = reiserfs_commit_write(NULL, page, write_from, write_from);\n\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_unpack(struct inode *inode, struct file *filp)\n{\n\tint retval = 0;\n\tint index;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tunsigned long write_from;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\n\tif (inode->i_size == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\treturn 0;\n\t}\n\t/* ioctl already done */\n\tif (REISERFS_I(inode)->i_flags & i_nopack_mask) {\n\t\treturn 0;\n\t}\n\n\t/* we need to make sure nobody is changing the file size beneath us */\n\treiserfs_mutex_lock_safe(&inode->i_mutex, inode->i_sb);\n\n\treiserfs_write_lock(inode->i_sb);\n\n\twrite_from = inode->i_size & (blocksize - 1);\n\t/* if we are on a block boundary, we are already unpacked.  */\n\tif (write_from == 0) {\n\t\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * we unpack by finding the page with the tail, and calling\n\t * __reiserfs_write_begin on that page.  This will force a\n\t * reiserfs_get_block to unpack the tail for us.\n\t */\n\tindex = inode->i_size >> PAGE_CACHE_SHIFT;\n\tmapping = inode->i_mapping;\n\tpage = grab_cache_page(mapping, index);\n\tretval = -ENOMEM;\n\tif (!page) {\n\t\tgoto out;\n\t}\n\tretval = __reiserfs_write_begin(page, write_from, 0);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\t/* conversion can change page contents, must flush */\n\tflush_dcache_page(page);\n\tretval = reiserfs_commit_write(NULL, page, write_from, write_from);\n\tREISERFS_I(inode)->i_flags |= i_nopack_mask;\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treiserfs_write_unlock(inode->i_sb);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOQUOTA",
          "args": [
            "inode"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_attrs",
          "args": [
            "inode->i_sb"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "(int __user *)arg"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_attrs_to_sd_attrs",
          "args": [
            "inode",
            "(__u16 *) & flags"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "i_attrs_to_sd_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "3096-3116",
          "snippet": "void i_attrs_to_sd_attrs(struct inode *inode, __u16 * sd_attrs)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (inode->i_flags & S_IMMUTABLE)\n\t\t\t*sd_attrs |= REISERFS_IMMUTABLE_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_IMMUTABLE_FL;\n\t\tif (inode->i_flags & S_SYNC)\n\t\t\t*sd_attrs |= REISERFS_SYNC_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_SYNC_FL;\n\t\tif (inode->i_flags & S_NOATIME)\n\t\t\t*sd_attrs |= REISERFS_NOATIME_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOATIME_FL;\n\t\tif (REISERFS_I(inode)->i_flags & i_nopack_mask)\n\t\t\t*sd_attrs |= REISERFS_NOTAIL_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOTAIL_FL;\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid i_attrs_to_sd_attrs(struct inode *inode, __u16 * sd_attrs)\n{\n\tif (reiserfs_attrs(inode->i_sb)) {\n\t\tif (inode->i_flags & S_IMMUTABLE)\n\t\t\t*sd_attrs |= REISERFS_IMMUTABLE_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_IMMUTABLE_FL;\n\t\tif (inode->i_flags & S_SYNC)\n\t\t\t*sd_attrs |= REISERFS_SYNC_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_SYNC_FL;\n\t\tif (inode->i_flags & S_NOATIME)\n\t\t\t*sd_attrs |= REISERFS_NOATIME_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOATIME_FL;\n\t\tif (REISERFS_I(inode)->i_flags & i_nopack_mask)\n\t\t\t*sd_attrs |= REISERFS_NOTAIL_FL;\n\t\telse\n\t\t\t*sd_attrs &= ~REISERFS_NOTAIL_FL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_attrs",
          "args": [
            "inode->i_sb"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include \"reiserfs.h\"\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nlong reiserfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunsigned int flags;\n\tint err = 0;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\tswitch (cmd) {\n\tcase REISERFS_IOC_UNPACK:\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (arg)\n\t\t\t\terr = reiserfs_unpack(inode, filp);\n\t\t} else\n\t\t\terr = -ENOTTY;\n\t\tbreak;\n\t\t/*\n\t\t * following two cases are taken from fs/ext2/ioctl.c by Remy\n\t\t * Card (card@masi.ibp.fr)\n\t\t */\n\tcase REISERFS_IOC_GETFLAGS:\n\t\tif (!reiserfs_attrs(inode->i_sb)) {\n\t\t\terr = -ENOTTY;\n\t\t\tbreak;\n\t\t}\n\n\t\tflags = REISERFS_I(inode)->i_attrs;\n\t\ti_attrs_to_sd_attrs(inode, (__u16 *) & flags);\n\t\terr = put_user(flags, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETFLAGS:{\n\t\t\tif (!reiserfs_attrs(inode->i_sb)) {\n\t\t\t\terr = -ENOTTY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = mnt_want_write_file(filp);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif (get_user(flags, (int __user *)arg)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Is it quota file? Do not allow user to mess with it\n\t\t\t */\n\t\t\tif (IS_NOQUOTA(inode)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif (((flags ^ REISERFS_I(inode)->\n\t\t\t      i_attrs) & (REISERFS_IMMUTABLE_FL |\n\t\t\t\t\t  REISERFS_APPEND_FL))\n\t\t\t    && !capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t\tif ((flags & REISERFS_NOTAIL_FL) &&\n\t\t\t    S_ISREG(inode->i_mode)) {\n\t\t\t\tint result;\n\n\t\t\t\tresult = reiserfs_unpack(inode, filp);\n\t\t\t\tif (result) {\n\t\t\t\t\terr = result;\n\t\t\t\t\tgoto setflags_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsd_attrs_to_i_attrs(flags, inode);\n\t\t\tREISERFS_I(inode)->i_attrs = flags;\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\t\tmnt_drop_write_file(filp);\n\t\t\tbreak;\n\t\t}\n\tcase REISERFS_IOC_GETVERSION:\n\t\terr = put_user(inode->i_generation, (int __user *)arg);\n\t\tbreak;\n\tcase REISERFS_IOC_SETVERSION:\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (get_user(inode->i_generation, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treiserfs_write_unlock(inode->i_sb);\n\n\treturn err;\n}"
  }
]