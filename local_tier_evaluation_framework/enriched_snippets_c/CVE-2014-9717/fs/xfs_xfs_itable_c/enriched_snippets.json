[
  {
    "function_name": "xfs_inumbers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "549-652",
    "snippet": "int\t\t\t\t\t/* error status */\nxfs_inumbers(\n\tstruct xfs_mount\t*mp,/* mount point for filesystem */\n\txfs_ino_t\t\t*lastino,/* last inode returned */\n\tint\t\t\t*count,/* size of buffer/count returned */\n\tvoid\t\t\t__user *ubuffer,/* buffer with inode descriptions */\n\tinumbers_fmt_pf\t\tformatter)\n{\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, *lastino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, *lastino);\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_buf\t\t*agbp = NULL;\n\tstruct xfs_inogrp\t*buffer;\n\tint\t\t\tbcount;\n\tint\t\t\tleft = *count;\n\tint\t\t\tbufidx = 0;\n\tint\t\t\terror = 0;\n\n\t*count = 0;\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastino != XFS_AGINO_TO_INO(mp, agno, agino))\n\t\treturn error;\n\n\tbcount = MIN(left, (int)(PAGE_SIZE / sizeof(*buffer)));\n\tbuffer = kmem_alloc(bcount * sizeof(*buffer), KM_SLEEP);\n\tdo {\n\t\tstruct xfs_inobt_rec_incore\tr;\n\t\tint\t\t\t\tstat;\n\n\t\tif (!agbp) {\n\t\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t\t    XFS_BTNUM_INO);\n\t\t\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_GE,\n\t\t\t\t\t\t &stat);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (!stat)\n\t\t\t\tgoto next_ag;\n\t\t}\n\n\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (!stat)\n\t\t\tgoto next_ag;\n\n\t\tagino = r.ir_startino + XFS_INODES_PER_CHUNK - 1;\n\t\tbuffer[bufidx].xi_startino =\n\t\t\tXFS_AGINO_TO_INO(mp, agno, r.ir_startino);\n\t\tbuffer[bufidx].xi_alloccount =\n\t\t\tXFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\tbuffer[bufidx].xi_allocmask = ~r.ir_free;\n\t\tif (++bufidx == bcount) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tubuffer += written;\n\t\t\t*count += bufidx;\n\t\t\tbufidx = 0;\n\t\t}\n\t\tif (!--left)\n\t\t\tbreak;\n\n\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (stat)\n\t\t\tcontinue;\n\nnext_ag:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\tcur = NULL;\n\t\txfs_buf_relse(agbp);\n\t\tagbp = NULL;\n\t\tagino = 0;\n\t\tagno++;\n\t} while (agno < mp->m_sb.sb_agcount);\n\n\tif (!error) {\n\t\tif (bufidx) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (!error)\n\t\t\t\t*count += bufidx;\n\t\t}\n\t\t*lastino = XFS_AGINO_TO_INO(mp, agno, agino);\n\t}\n\n\tkmem_free(buffer);\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, (error ? XFS_BTREE_ERROR :\n\t\t\t\t\t   XFS_BTREE_NOERROR));\n\tif (agbp)\n\t\txfs_buf_relse(agbp);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "agbp"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "(error ? XFS_BTREE_ERROR :\n\t\t\t\t\t   XFS_BTREE_NOERROR)"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "buffer"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "formatter",
          "args": [
            "ubuffer",
            "buffer",
            "bufidx",
            "&written"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "0",
            "&stat"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "formatter",
          "args": [
            "ubuffer",
            "buffer",
            "bufidx",
            "&written"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "r.ir_startino"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "&r",
            "&stat"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "agino",
            "XFS_LOOKUP_GE",
            "&stat"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "mp",
            "NULL",
            "agbp",
            "agno",
            "XFS_BTNUM_INO"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_read_agi",
          "args": [
            "mp",
            "NULL",
            "agno",
            "&agbp"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2144-2177",
          "snippet": "int\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "bcount * sizeof(*buffer)",
            "KM_SLEEP"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "left",
            "(int)(PAGE_SIZE / sizeof(*buffer))"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "*lastino"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "*lastino"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error status */\nxfs_inumbers(\n\tstruct xfs_mount\t*mp,/* mount point for filesystem */\n\txfs_ino_t\t\t*lastino,/* last inode returned */\n\tint\t\t\t*count,/* size of buffer/count returned */\n\tvoid\t\t\t__user *ubuffer,/* buffer with inode descriptions */\n\tinumbers_fmt_pf\t\tformatter)\n{\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, *lastino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, *lastino);\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_buf\t\t*agbp = NULL;\n\tstruct xfs_inogrp\t*buffer;\n\tint\t\t\tbcount;\n\tint\t\t\tleft = *count;\n\tint\t\t\tbufidx = 0;\n\tint\t\t\terror = 0;\n\n\t*count = 0;\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastino != XFS_AGINO_TO_INO(mp, agno, agino))\n\t\treturn error;\n\n\tbcount = MIN(left, (int)(PAGE_SIZE / sizeof(*buffer)));\n\tbuffer = kmem_alloc(bcount * sizeof(*buffer), KM_SLEEP);\n\tdo {\n\t\tstruct xfs_inobt_rec_incore\tr;\n\t\tint\t\t\t\tstat;\n\n\t\tif (!agbp) {\n\t\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t\t    XFS_BTNUM_INO);\n\t\t\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_GE,\n\t\t\t\t\t\t &stat);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (!stat)\n\t\t\t\tgoto next_ag;\n\t\t}\n\n\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (!stat)\n\t\t\tgoto next_ag;\n\n\t\tagino = r.ir_startino + XFS_INODES_PER_CHUNK - 1;\n\t\tbuffer[bufidx].xi_startino =\n\t\t\tXFS_AGINO_TO_INO(mp, agno, r.ir_startino);\n\t\tbuffer[bufidx].xi_alloccount =\n\t\t\tXFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\tbuffer[bufidx].xi_allocmask = ~r.ir_free;\n\t\tif (++bufidx == bcount) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tubuffer += written;\n\t\t\t*count += bufidx;\n\t\t\tbufidx = 0;\n\t\t}\n\t\tif (!--left)\n\t\t\tbreak;\n\n\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (stat)\n\t\t\tcontinue;\n\nnext_ag:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\tcur = NULL;\n\t\txfs_buf_relse(agbp);\n\t\tagbp = NULL;\n\t\tagino = 0;\n\t\tagno++;\n\t} while (agno < mp->m_sb.sb_agcount);\n\n\tif (!error) {\n\t\tif (bufidx) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (!error)\n\t\t\t\t*count += bufidx;\n\t\t}\n\t\t*lastino = XFS_AGINO_TO_INO(mp, agno, agino);\n\t}\n\n\tkmem_free(buffer);\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, (error ? XFS_BTREE_ERROR :\n\t\t\t\t\t   XFS_BTREE_NOERROR));\n\tif (agbp)\n\t\txfs_buf_relse(agbp);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_inumbers_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "533-544",
    "snippet": "int\nxfs_inumbers_fmt(\n\tvoid\t\t\t__user *ubuffer, /* buffer to write to */\n\tconst struct xfs_inogrp\t*buffer,\t/* buffer to read from */\n\tlong\t\t\tcount,\t\t/* # of elements to read */\n\tlong\t\t\t*written)\t/* # of bytes written */\n{\n\tif (copy_to_user(ubuffer, buffer, count * sizeof(*buffer)))\n\t\treturn -EFAULT;\n\t*written = count * sizeof(*buffer);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuffer",
            "buffer",
            "count * sizeof(*buffer)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inumbers_fmt(\n\tvoid\t\t\t__user *ubuffer, /* buffer to write to */\n\tconst struct xfs_inogrp\t*buffer,\t/* buffer to read from */\n\tlong\t\t\tcount,\t\t/* # of elements to read */\n\tlong\t\t\t*written)\t/* # of bytes written */\n{\n\tif (copy_to_user(ubuffer, buffer, count * sizeof(*buffer)))\n\t\treturn -EFAULT;\n\t*written = count * sizeof(*buffer);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bulkstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "340-531",
    "snippet": "int\t\t\t\t\t/* error status */\nxfs_bulkstat(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_ino_t\t\t*lastinop, /* last inode returned */\n\tint\t\t\t*ubcountp, /* size of buffer/count returned */\n\tbulkstat_one_pf\t\tformatter, /* func that'd fill a single buf */\n\tsize_t\t\t\tstatstruct_size, /* sizeof struct filling */\n\tchar\t\t\t__user *ubuffer, /* buffer with inode stats */\n\tint\t\t\t*done)\t/* 1 if there are more stats to get */\n{\n\txfs_buf_t\t\t*agbp;\t/* agi header buffer */\n\txfs_agino_t\t\tagino;\t/* inode # in allocation group */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor for ialloc btree */\n\tsize_t\t\t\tirbsize; /* size of irec buffer in bytes */\n\txfs_inobt_rec_incore_t\t*irbuf;\t/* start of irec buffer */\n\tint\t\t\tnirbuf;\t/* size of irbuf */\n\tint\t\t\tubcount; /* size of user's buffer */\n\tstruct xfs_bulkstat_agichunk ac;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Get the last inode value, see if there's nothing to do.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, *lastinop);\n\tagino = XFS_INO_TO_AGINO(mp, *lastinop);\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t*done = 1;\n\t\t*ubcountp = 0;\n\t\treturn 0;\n\t}\n\n\tubcount = *ubcountp; /* statstruct's */\n\tac.ac_ubuffer = &ubuffer;\n\tac.ac_ubleft = ubcount * statstruct_size; /* bytes */;\n\tac.ac_ubelem = 0;\n\n\t*ubcountp = 0;\n\t*done = 0;\n\n\tirbuf = kmem_zalloc_greedy(&irbsize, PAGE_SIZE, PAGE_SIZE * 4);\n\tif (!irbuf)\n\t\treturn -ENOMEM;\n\n\tnirbuf = irbsize / sizeof(*irbuf);\n\n\t/*\n\t * Loop over the allocation groups, starting from the last\n\t * inode returned; 0 means start of the allocation group.\n\t */\n\twhile (agno < mp->m_sb.sb_agcount) {\n\t\tstruct xfs_inobt_rec_incore\t*irbp = irbuf;\n\t\tstruct xfs_inobt_rec_incore\t*irbufend = irbuf + nirbuf;\n\t\tbool\t\t\t\tend_of_ag = false;\n\t\tint\t\t\t\ticount = 0;\n\t\tint\t\t\t\tstat;\n\n\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Allocate and initialize a btree cursor for ialloc btree.\n\t\t */\n\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t    XFS_BTNUM_INO);\n\t\tif (agino > 0) {\n\t\t\t/*\n\t\t\t * In the middle of an allocation group, we need to get\n\t\t\t * the remainder of the chunk we're in.\n\t\t\t */\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_bulkstat_grab_ichunk(cur, agino, &icount, &r);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tif (icount) {\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t}\n\t\t\t/* Increment to the next record */\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t} else {\n\t\t\t/* Start of ag.  Lookup the first inode chunk */\n\t\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);\n\t\t}\n\t\tif (error || stat == 0) {\n\t\t\tend_of_ag = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * Loop through inode btree records in this ag,\n\t\t * until we run out of inodes or space in the buffer.\n\t\t */\n\t\twhile (irbp < irbufend && icount < ubcount) {\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this chunk has any allocated inodes, save it.\n\t\t\t * Also start read-ahead now for this chunk.\n\t\t\t */\n\t\t\tif (r.ir_freecount < XFS_INODES_PER_CHUNK) {\n\t\t\t\txfs_bulkstat_ichunk_ra(mp, agno, &r);\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t\ticount += XFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\t\t}\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Drop the btree buffers and the agi buffer as we can't hold any\n\t\t * of the locks these represent when calling iget. If there is a\n\t\t * pending error, then we are done.\n\t\t */\ndel_cursor:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\txfs_buf_relse(agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Now format all the good inodes into the user's buffer. The\n\t\t * call to xfs_bulkstat_ag_ichunk() sets up the agino pointer\n\t\t * for the next loop iteration.\n\t\t */\n\t\tirbufend = irbp;\n\t\tfor (irbp = irbuf;\n\t\t     irbp < irbufend && ac.ac_ubleft >= statstruct_size;\n\t\t     irbp++) {\n\t\t\terror = xfs_bulkstat_ag_ichunk(mp, agno, irbp,\n\t\t\t\t\tformatter, statstruct_size, &ac,\n\t\t\t\t\t&agino);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * If we've run out of space or had a formatting error, we\n\t\t * are now done\n\t\t */\n\t\tif (ac.ac_ubleft < statstruct_size || error)\n\t\t\tbreak;\n\n\t\tif (end_of_ag) {\n\t\t\tagno++;\n\t\t\tagino = 0;\n\t\t}\n\t}\n\t/*\n\t * Done, we're either out of filesystem or space to put the data.\n\t */\n\tkmem_free(irbuf);\n\t*ubcountp = ac.ac_ubelem;\n\n\t/*\n\t * We found some inodes, so clear the error status and return them.\n\t * The lastino pointer will point directly at the inode that triggered\n\t * any error that occurred, so on the next call the error will be\n\t * triggered again and propagated to userspace as there will be no\n\t * formatted inodes in the buffer.\n\t */\n\tif (ac.ac_ubelem)\n\t\terror = 0;\n\n\t/*\n\t * If we ran out of filesystem, lastino will point off the end of\n\t * the filesystem so the next call will return immediately.\n\t */\n\t*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);\n\tif (agno >= mp->m_sb.sb_agcount)\n\t\t*done = 1;\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "irbuf"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bulkstat_ag_ichunk",
          "args": [
            "mp",
            "agno",
            "irbp",
            "formatter",
            "statstruct_size",
            "&ac",
            "&agino"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat_ag_ichunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "273-335",
          "snippet": "static int\nxfs_bulkstat_ag_ichunk(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*irbp,\n\tbulkstat_one_pf\t\t\tformatter,\n\tsize_t\t\t\t\tstatstruct_size,\n\tstruct xfs_bulkstat_agichunk\t*acp,\n\txfs_agino_t\t\t\t*last_agino)\n{\n\tchar\t\t\t\t__user **ubufp = acp->ac_ubuffer;\n\tint\t\t\t\tchunkidx;\n\tint\t\t\t\terror = 0;\n\txfs_agino_t\t\t\tagino = irbp->ir_startino;\n\n\tfor (chunkidx = 0; chunkidx < XFS_INODES_PER_CHUNK;\n\t     chunkidx++, agino++) {\n\t\tint\t\tfmterror;\n\t\tint\t\tubused;\n\n\t\t/* inode won't fit in buffer, we are done */\n\t\tif (acp->ac_ubleft < statstruct_size)\n\t\t\tbreak;\n\n\t\t/* Skip if this inode is free */\n\t\tif (XFS_INOBT_MASK(chunkidx) & irbp->ir_free)\n\t\t\tcontinue;\n\n\t\t/* Get the inode and fill in a single buffer */\n\t\tubused = statstruct_size;\n\t\terror = formatter(mp, XFS_AGINO_TO_INO(mp, agno, agino),\n\t\t\t\t  *ubufp, acp->ac_ubleft, &ubused, &fmterror);\n\n\t\tif (fmterror == BULKSTAT_RV_GIVEUP ||\n\t\t    (error && error != -ENOENT && error != -EINVAL)) {\n\t\t\tacp->ac_ubleft = 0;\n\t\t\tASSERT(error);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* be careful not to leak error if at end of chunk */\n\t\tif (fmterror == BULKSTAT_RV_NOTHING || error) {\n\t\t\terror = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*ubufp += ubused;\n\t\tacp->ac_ubleft -= ubused;\n\t\tacp->ac_ubelem++;\n\t}\n\n\t/*\n\t * Post-update *last_agino. At this point, agino will always point one\n\t * inode past the last inode we processed successfully. Hence we\n\t * substract that inode when setting the *last_agino cursor so that we\n\t * return the correct cookie to userspace. On the next bulkstat call,\n\t * the inode under the lastino cookie will be skipped as we have already\n\t * processed it here.\n\t */\n\t*last_agino = agino - 1;\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_bulkstat_ag_ichunk(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*irbp,\n\tbulkstat_one_pf\t\t\tformatter,\n\tsize_t\t\t\t\tstatstruct_size,\n\tstruct xfs_bulkstat_agichunk\t*acp,\n\txfs_agino_t\t\t\t*last_agino)\n{\n\tchar\t\t\t\t__user **ubufp = acp->ac_ubuffer;\n\tint\t\t\t\tchunkidx;\n\tint\t\t\t\terror = 0;\n\txfs_agino_t\t\t\tagino = irbp->ir_startino;\n\n\tfor (chunkidx = 0; chunkidx < XFS_INODES_PER_CHUNK;\n\t     chunkidx++, agino++) {\n\t\tint\t\tfmterror;\n\t\tint\t\tubused;\n\n\t\t/* inode won't fit in buffer, we are done */\n\t\tif (acp->ac_ubleft < statstruct_size)\n\t\t\tbreak;\n\n\t\t/* Skip if this inode is free */\n\t\tif (XFS_INOBT_MASK(chunkidx) & irbp->ir_free)\n\t\t\tcontinue;\n\n\t\t/* Get the inode and fill in a single buffer */\n\t\tubused = statstruct_size;\n\t\terror = formatter(mp, XFS_AGINO_TO_INO(mp, agno, agino),\n\t\t\t\t  *ubufp, acp->ac_ubleft, &ubused, &fmterror);\n\n\t\tif (fmterror == BULKSTAT_RV_GIVEUP ||\n\t\t    (error && error != -ENOENT && error != -EINVAL)) {\n\t\t\tacp->ac_ubleft = 0;\n\t\t\tASSERT(error);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* be careful not to leak error if at end of chunk */\n\t\tif (fmterror == BULKSTAT_RV_NOTHING || error) {\n\t\t\terror = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*ubufp += ubused;\n\t\tacp->ac_ubleft -= ubused;\n\t\tacp->ac_ubelem++;\n\t}\n\n\t/*\n\t * Post-update *last_agino. At this point, agino will always point one\n\t * inode past the last inode we processed successfully. Hence we\n\t * substract that inode when setting the *last_agino cursor so that we\n\t * return the correct cookie to userspace. On the next bulkstat call,\n\t * the inode under the lastino cookie will be skipped as we have already\n\t * processed it here.\n\t */\n\t*last_agino = agino - 1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "agbp"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_NOERROR"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "0",
            "&stat"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bulkstat_ichunk_ra",
          "args": [
            "mp",
            "agno",
            "&r"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat_ichunk_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "175-200",
          "snippet": "STATIC void\nxfs_bulkstat_ichunk_ra(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*irec)\n{\n\txfs_agblock_t\t\t\tagbno;\n\tstruct blk_plug\t\t\tplug;\n\tint\t\t\t\tblks_per_cluster;\n\tint\t\t\t\tinodes_per_cluster;\n\tint\t\t\t\ti;\t/* inode chunk index */\n\n\tagbno = XFS_AGINO_TO_AGBNO(mp, irec->ir_startino);\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < XFS_INODES_PER_CHUNK;\n\t     i += inodes_per_cluster, agbno += blks_per_cluster) {\n\t\tif (xfs_inobt_maskn(i, inodes_per_cluster) & ~irec->ir_free) {\n\t\t\txfs_btree_reada_bufs(mp, agno, agbno, blks_per_cluster,\n\t\t\t\t\t     &xfs_inode_buf_ops);\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bulkstat_ichunk_ra(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*irec)\n{\n\txfs_agblock_t\t\t\tagbno;\n\tstruct blk_plug\t\t\tplug;\n\tint\t\t\t\tblks_per_cluster;\n\tint\t\t\t\tinodes_per_cluster;\n\tint\t\t\t\ti;\t/* inode chunk index */\n\n\tagbno = XFS_AGINO_TO_AGBNO(mp, irec->ir_startino);\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < XFS_INODES_PER_CHUNK;\n\t     i += inodes_per_cluster, agbno += blks_per_cluster) {\n\t\tif (xfs_inobt_maskn(i, inodes_per_cluster) & ~irec->ir_free) {\n\t\t\txfs_btree_reada_bufs(mp, agno, agbno, blks_per_cluster,\n\t\t\t\t\t     &xfs_inode_buf_ops);\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "&r",
            "&stat"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "0",
            "XFS_LOOKUP_GE",
            "&stat"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bulkstat_grab_ichunk",
          "args": [
            "cur",
            "agino",
            "&icount",
            "&r"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat_grab_ichunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "208-259",
          "snippet": "STATIC int\nxfs_bulkstat_grab_ichunk(\n\tstruct xfs_btree_cur\t\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\t\tagino,\t/* starting inode of chunk */\n\tint\t\t\t\t*icount,/* return # of inodes grabbed */\n\tstruct xfs_inobt_rec_incore\t*irec)\t/* btree record */\n{\n\tint\t\t\t\tidx;\t/* index into inode chunk */\n\tint\t\t\t\tstat;\n\tint\t\t\t\terror = 0;\n\n\t/* Lookup the inode chunk that this inode lives in */\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &stat);\n\tif (error)\n\t\treturn error;\n\tif (!stat) {\n\t\t*icount = 0;\n\t\treturn error;\n\t}\n\n\t/* Get the record, should always work */\n\terror = xfs_inobt_get_rec(cur, irec, &stat);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(stat == 1);\n\n\t/* Check if the record contains the inode in request */\n\tif (irec->ir_startino + XFS_INODES_PER_CHUNK <= agino) {\n\t\t*icount = 0;\n\t\treturn 0;\n\t}\n\n\tidx = agino - irec->ir_startino + 1;\n\tif (idx < XFS_INODES_PER_CHUNK &&\n\t    (xfs_inobt_maskn(idx, XFS_INODES_PER_CHUNK - idx) & ~irec->ir_free)) {\n\t\tint\ti;\n\n\t\t/* We got a right chunk with some left inodes allocated at it.\n\t\t * Grab the chunk record.  Mark all the uninteresting inodes\n\t\t * free -- because they're before our start point.\n\t\t */\n\t\tfor (i = 0; i < idx; i++) {\n\t\t\tif (XFS_INOBT_MASK(i) & ~irec->ir_free)\n\t\t\t\tirec->ir_freecount++;\n\t\t}\n\n\t\tirec->ir_free |= xfs_inobt_maskn(0, idx);\n\t\t*icount = XFS_INODES_PER_CHUNK - irec->ir_freecount;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bulkstat_grab_ichunk(\n\tstruct xfs_btree_cur\t\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\t\tagino,\t/* starting inode of chunk */\n\tint\t\t\t\t*icount,/* return # of inodes grabbed */\n\tstruct xfs_inobt_rec_incore\t*irec)\t/* btree record */\n{\n\tint\t\t\t\tidx;\t/* index into inode chunk */\n\tint\t\t\t\tstat;\n\tint\t\t\t\terror = 0;\n\n\t/* Lookup the inode chunk that this inode lives in */\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &stat);\n\tif (error)\n\t\treturn error;\n\tif (!stat) {\n\t\t*icount = 0;\n\t\treturn error;\n\t}\n\n\t/* Get the record, should always work */\n\terror = xfs_inobt_get_rec(cur, irec, &stat);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(stat == 1);\n\n\t/* Check if the record contains the inode in request */\n\tif (irec->ir_startino + XFS_INODES_PER_CHUNK <= agino) {\n\t\t*icount = 0;\n\t\treturn 0;\n\t}\n\n\tidx = agino - irec->ir_startino + 1;\n\tif (idx < XFS_INODES_PER_CHUNK &&\n\t    (xfs_inobt_maskn(idx, XFS_INODES_PER_CHUNK - idx) & ~irec->ir_free)) {\n\t\tint\ti;\n\n\t\t/* We got a right chunk with some left inodes allocated at it.\n\t\t * Grab the chunk record.  Mark all the uninteresting inodes\n\t\t * free -- because they're before our start point.\n\t\t */\n\t\tfor (i = 0; i < idx; i++) {\n\t\t\tif (XFS_INOBT_MASK(i) & ~irec->ir_free)\n\t\t\t\tirec->ir_freecount++;\n\t\t}\n\n\t\tirec->ir_free |= xfs_inobt_maskn(0, idx);\n\t\t*icount = XFS_INODES_PER_CHUNK - irec->ir_freecount;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_init_cursor",
          "args": [
            "mp",
            "NULL",
            "agbp",
            "agno",
            "XFS_BTNUM_INO"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "371-404",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};",
            "static const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_inobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_inobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_inobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\nstatic const struct xfs_btree_ops xfs_finobt_ops = {\n\t.rec_len\t\t= sizeof(xfs_inobt_rec_t),\n\t.key_len\t\t= sizeof(xfs_inobt_key_t),\n\n\t.dup_cursor\t\t= xfs_inobt_dup_cursor,\n\t.set_root\t\t= xfs_finobt_set_root,\n\t.alloc_block\t\t= xfs_inobt_alloc_block,\n\t.free_block\t\t= xfs_inobt_free_block,\n\t.get_minrecs\t\t= xfs_inobt_get_minrecs,\n\t.get_maxrecs\t\t= xfs_inobt_get_maxrecs,\n\t.init_key_from_rec\t= xfs_inobt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_inobt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_inobt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_finobt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_inobt_key_diff,\n\t.buf_ops\t\t= &xfs_inobt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_inobt_keys_inorder,\n\t.recs_inorder\t\t= xfs_inobt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new inode btree cursor */\nxfs_inobt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_buf\t\t*agbp,\t\t/* buffer for agi structure */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_btnum_t\t\tbtnum)\t\t/* ialloc or free ino btree */\n{\n\tstruct xfs_agi\t\t*agi = XFS_BUF_TO_AGI(agbp);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_btnum = btnum;\n\tif (btnum == XFS_BTNUM_INO) {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_level);\n\t\tcur->bc_ops = &xfs_inobt_ops;\n\t} else {\n\t\tcur->bc_nlevels = be32_to_cpu(agi->agi_free_level);\n\t\tcur->bc_ops = &xfs_finobt_ops;\n\t}\n\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.a.agbp = agbp;\n\tcur->bc_private.a.agno = agno;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_read_agi",
          "args": [
            "mp",
            "NULL",
            "agno",
            "&agbp"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_read_agi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2144-2177",
          "snippet": "int\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_read_agi(\n\tstruct xfs_mount\t*mp,\t/* file system mount structure */\n\tstruct xfs_trans\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tstruct xfs_buf\t\t**bpp)\t/* allocation group hdr buf */\n{\n\tstruct xfs_agi\t\t*agi;\t/* allocation group header */\n\tstruct xfs_perag\t*pag;\t/* per allocation group data */\n\tint\t\t\terror;\n\n\ttrace_xfs_ialloc_read_agi(mp, agno);\n\n\terror = xfs_read_agi(mp, tp, agno, bpp);\n\tif (error)\n\t\treturn error;\n\n\tagi = XFS_BUF_TO_AGI(*bpp);\n\tpag = xfs_perag_get(mp, agno);\n\tif (!pag->pagi_init) {\n\t\tpag->pagi_freecount = be32_to_cpu(agi->agi_freecount);\n\t\tpag->pagi_count = be32_to_cpu(agi->agi_count);\n\t\tpag->pagi_init = 1;\n\t}\n\n\t/*\n\t * It's possible for these to be out of sync if\n\t * we are in the middle of a forced shutdown.\n\t */\n\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n\t\tXFS_FORCED_SHUTDOWN(mp));\n\txfs_perag_put(pag);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc_greedy",
          "args": [
            "&irbsize",
            "PAGE_SIZE",
            "PAGE_SIZE * 4"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_greedy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "30-43",
          "snippet": "void *\nkmem_zalloc_greedy(size_t *size, size_t minsize, size_t maxsize)\n{\n\tvoid\t\t*ptr;\n\tsize_t\t\tkmsize = maxsize;\n\n\twhile (!(ptr = vzalloc(kmsize))) {\n\t\tif ((kmsize >>= 1) <= minsize)\n\t\t\tkmsize = minsize;\n\t}\n\tif (ptr)\n\t\t*size = kmsize;\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_greedy(size_t *size, size_t minsize, size_t maxsize)\n{\n\tvoid\t\t*ptr;\n\tsize_t\t\tkmsize = maxsize;\n\n\twhile (!(ptr = vzalloc(kmsize))) {\n\t\tif ((kmsize >>= 1) <= minsize)\n\t\t\tkmsize = minsize;\n\t}\n\tif (ptr)\n\t\t*size = kmsize;\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGINO",
          "args": [
            "mp",
            "*lastinop"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "*lastinop"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error status */\nxfs_bulkstat(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_ino_t\t\t*lastinop, /* last inode returned */\n\tint\t\t\t*ubcountp, /* size of buffer/count returned */\n\tbulkstat_one_pf\t\tformatter, /* func that'd fill a single buf */\n\tsize_t\t\t\tstatstruct_size, /* sizeof struct filling */\n\tchar\t\t\t__user *ubuffer, /* buffer with inode stats */\n\tint\t\t\t*done)\t/* 1 if there are more stats to get */\n{\n\txfs_buf_t\t\t*agbp;\t/* agi header buffer */\n\txfs_agino_t\t\tagino;\t/* inode # in allocation group */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor for ialloc btree */\n\tsize_t\t\t\tirbsize; /* size of irec buffer in bytes */\n\txfs_inobt_rec_incore_t\t*irbuf;\t/* start of irec buffer */\n\tint\t\t\tnirbuf;\t/* size of irbuf */\n\tint\t\t\tubcount; /* size of user's buffer */\n\tstruct xfs_bulkstat_agichunk ac;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Get the last inode value, see if there's nothing to do.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, *lastinop);\n\tagino = XFS_INO_TO_AGINO(mp, *lastinop);\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t*done = 1;\n\t\t*ubcountp = 0;\n\t\treturn 0;\n\t}\n\n\tubcount = *ubcountp; /* statstruct's */\n\tac.ac_ubuffer = &ubuffer;\n\tac.ac_ubleft = ubcount * statstruct_size; /* bytes */;\n\tac.ac_ubelem = 0;\n\n\t*ubcountp = 0;\n\t*done = 0;\n\n\tirbuf = kmem_zalloc_greedy(&irbsize, PAGE_SIZE, PAGE_SIZE * 4);\n\tif (!irbuf)\n\t\treturn -ENOMEM;\n\n\tnirbuf = irbsize / sizeof(*irbuf);\n\n\t/*\n\t * Loop over the allocation groups, starting from the last\n\t * inode returned; 0 means start of the allocation group.\n\t */\n\twhile (agno < mp->m_sb.sb_agcount) {\n\t\tstruct xfs_inobt_rec_incore\t*irbp = irbuf;\n\t\tstruct xfs_inobt_rec_incore\t*irbufend = irbuf + nirbuf;\n\t\tbool\t\t\t\tend_of_ag = false;\n\t\tint\t\t\t\ticount = 0;\n\t\tint\t\t\t\tstat;\n\n\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Allocate and initialize a btree cursor for ialloc btree.\n\t\t */\n\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t    XFS_BTNUM_INO);\n\t\tif (agino > 0) {\n\t\t\t/*\n\t\t\t * In the middle of an allocation group, we need to get\n\t\t\t * the remainder of the chunk we're in.\n\t\t\t */\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_bulkstat_grab_ichunk(cur, agino, &icount, &r);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tif (icount) {\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t}\n\t\t\t/* Increment to the next record */\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t} else {\n\t\t\t/* Start of ag.  Lookup the first inode chunk */\n\t\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);\n\t\t}\n\t\tif (error || stat == 0) {\n\t\t\tend_of_ag = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * Loop through inode btree records in this ag,\n\t\t * until we run out of inodes or space in the buffer.\n\t\t */\n\t\twhile (irbp < irbufend && icount < ubcount) {\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this chunk has any allocated inodes, save it.\n\t\t\t * Also start read-ahead now for this chunk.\n\t\t\t */\n\t\t\tif (r.ir_freecount < XFS_INODES_PER_CHUNK) {\n\t\t\t\txfs_bulkstat_ichunk_ra(mp, agno, &r);\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t\ticount += XFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\t\t}\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Drop the btree buffers and the agi buffer as we can't hold any\n\t\t * of the locks these represent when calling iget. If there is a\n\t\t * pending error, then we are done.\n\t\t */\ndel_cursor:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\txfs_buf_relse(agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Now format all the good inodes into the user's buffer. The\n\t\t * call to xfs_bulkstat_ag_ichunk() sets up the agino pointer\n\t\t * for the next loop iteration.\n\t\t */\n\t\tirbufend = irbp;\n\t\tfor (irbp = irbuf;\n\t\t     irbp < irbufend && ac.ac_ubleft >= statstruct_size;\n\t\t     irbp++) {\n\t\t\terror = xfs_bulkstat_ag_ichunk(mp, agno, irbp,\n\t\t\t\t\tformatter, statstruct_size, &ac,\n\t\t\t\t\t&agino);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * If we've run out of space or had a formatting error, we\n\t\t * are now done\n\t\t */\n\t\tif (ac.ac_ubleft < statstruct_size || error)\n\t\t\tbreak;\n\n\t\tif (end_of_ag) {\n\t\t\tagno++;\n\t\t\tagino = 0;\n\t\t}\n\t}\n\t/*\n\t * Done, we're either out of filesystem or space to put the data.\n\t */\n\tkmem_free(irbuf);\n\t*ubcountp = ac.ac_ubelem;\n\n\t/*\n\t * We found some inodes, so clear the error status and return them.\n\t * The lastino pointer will point directly at the inode that triggered\n\t * any error that occurred, so on the next call the error will be\n\t * triggered again and propagated to userspace as there will be no\n\t * formatted inodes in the buffer.\n\t */\n\tif (ac.ac_ubelem)\n\t\terror = 0;\n\n\t/*\n\t * If we ran out of filesystem, lastino will point off the end of\n\t * the filesystem so the next call will return immediately.\n\t */\n\t*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);\n\tif (agno >= mp->m_sb.sb_agcount)\n\t\t*done = 1;\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bulkstat_ag_ichunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "273-335",
    "snippet": "static int\nxfs_bulkstat_ag_ichunk(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*irbp,\n\tbulkstat_one_pf\t\t\tformatter,\n\tsize_t\t\t\t\tstatstruct_size,\n\tstruct xfs_bulkstat_agichunk\t*acp,\n\txfs_agino_t\t\t\t*last_agino)\n{\n\tchar\t\t\t\t__user **ubufp = acp->ac_ubuffer;\n\tint\t\t\t\tchunkidx;\n\tint\t\t\t\terror = 0;\n\txfs_agino_t\t\t\tagino = irbp->ir_startino;\n\n\tfor (chunkidx = 0; chunkidx < XFS_INODES_PER_CHUNK;\n\t     chunkidx++, agino++) {\n\t\tint\t\tfmterror;\n\t\tint\t\tubused;\n\n\t\t/* inode won't fit in buffer, we are done */\n\t\tif (acp->ac_ubleft < statstruct_size)\n\t\t\tbreak;\n\n\t\t/* Skip if this inode is free */\n\t\tif (XFS_INOBT_MASK(chunkidx) & irbp->ir_free)\n\t\t\tcontinue;\n\n\t\t/* Get the inode and fill in a single buffer */\n\t\tubused = statstruct_size;\n\t\terror = formatter(mp, XFS_AGINO_TO_INO(mp, agno, agino),\n\t\t\t\t  *ubufp, acp->ac_ubleft, &ubused, &fmterror);\n\n\t\tif (fmterror == BULKSTAT_RV_GIVEUP ||\n\t\t    (error && error != -ENOENT && error != -EINVAL)) {\n\t\t\tacp->ac_ubleft = 0;\n\t\t\tASSERT(error);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* be careful not to leak error if at end of chunk */\n\t\tif (fmterror == BULKSTAT_RV_NOTHING || error) {\n\t\t\terror = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*ubufp += ubused;\n\t\tacp->ac_ubleft -= ubused;\n\t\tacp->ac_ubelem++;\n\t}\n\n\t/*\n\t * Post-update *last_agino. At this point, agino will always point one\n\t * inode past the last inode we processed successfully. Hence we\n\t * substract that inode when setting the *last_agino cursor so that we\n\t * return the correct cookie to userspace. On the next bulkstat call,\n\t * the inode under the lastino cookie will be skipped as we have already\n\t * processed it here.\n\t */\n\t*last_agino = agino - 1;\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "formatter",
          "args": [
            "mp",
            "XFS_AGINO_TO_INO(mp, agno, agino)",
            "*ubufp",
            "acp->ac_ubleft",
            "&ubused",
            "&fmterror"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_INO",
          "args": [
            "mp",
            "agno",
            "agino"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "chunkidx"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_bulkstat_ag_ichunk(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*irbp,\n\tbulkstat_one_pf\t\t\tformatter,\n\tsize_t\t\t\t\tstatstruct_size,\n\tstruct xfs_bulkstat_agichunk\t*acp,\n\txfs_agino_t\t\t\t*last_agino)\n{\n\tchar\t\t\t\t__user **ubufp = acp->ac_ubuffer;\n\tint\t\t\t\tchunkidx;\n\tint\t\t\t\terror = 0;\n\txfs_agino_t\t\t\tagino = irbp->ir_startino;\n\n\tfor (chunkidx = 0; chunkidx < XFS_INODES_PER_CHUNK;\n\t     chunkidx++, agino++) {\n\t\tint\t\tfmterror;\n\t\tint\t\tubused;\n\n\t\t/* inode won't fit in buffer, we are done */\n\t\tif (acp->ac_ubleft < statstruct_size)\n\t\t\tbreak;\n\n\t\t/* Skip if this inode is free */\n\t\tif (XFS_INOBT_MASK(chunkidx) & irbp->ir_free)\n\t\t\tcontinue;\n\n\t\t/* Get the inode and fill in a single buffer */\n\t\tubused = statstruct_size;\n\t\terror = formatter(mp, XFS_AGINO_TO_INO(mp, agno, agino),\n\t\t\t\t  *ubufp, acp->ac_ubleft, &ubused, &fmterror);\n\n\t\tif (fmterror == BULKSTAT_RV_GIVEUP ||\n\t\t    (error && error != -ENOENT && error != -EINVAL)) {\n\t\t\tacp->ac_ubleft = 0;\n\t\t\tASSERT(error);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* be careful not to leak error if at end of chunk */\n\t\tif (fmterror == BULKSTAT_RV_NOTHING || error) {\n\t\t\terror = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*ubufp += ubused;\n\t\tacp->ac_ubleft -= ubused;\n\t\tacp->ac_ubelem++;\n\t}\n\n\t/*\n\t * Post-update *last_agino. At this point, agino will always point one\n\t * inode past the last inode we processed successfully. Hence we\n\t * substract that inode when setting the *last_agino cursor so that we\n\t * return the correct cookie to userspace. On the next bulkstat call,\n\t * the inode under the lastino cookie will be skipped as we have already\n\t * processed it here.\n\t */\n\t*last_agino = agino - 1;\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bulkstat_grab_ichunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "208-259",
    "snippet": "STATIC int\nxfs_bulkstat_grab_ichunk(\n\tstruct xfs_btree_cur\t\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\t\tagino,\t/* starting inode of chunk */\n\tint\t\t\t\t*icount,/* return # of inodes grabbed */\n\tstruct xfs_inobt_rec_incore\t*irec)\t/* btree record */\n{\n\tint\t\t\t\tidx;\t/* index into inode chunk */\n\tint\t\t\t\tstat;\n\tint\t\t\t\terror = 0;\n\n\t/* Lookup the inode chunk that this inode lives in */\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &stat);\n\tif (error)\n\t\treturn error;\n\tif (!stat) {\n\t\t*icount = 0;\n\t\treturn error;\n\t}\n\n\t/* Get the record, should always work */\n\terror = xfs_inobt_get_rec(cur, irec, &stat);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(stat == 1);\n\n\t/* Check if the record contains the inode in request */\n\tif (irec->ir_startino + XFS_INODES_PER_CHUNK <= agino) {\n\t\t*icount = 0;\n\t\treturn 0;\n\t}\n\n\tidx = agino - irec->ir_startino + 1;\n\tif (idx < XFS_INODES_PER_CHUNK &&\n\t    (xfs_inobt_maskn(idx, XFS_INODES_PER_CHUNK - idx) & ~irec->ir_free)) {\n\t\tint\ti;\n\n\t\t/* We got a right chunk with some left inodes allocated at it.\n\t\t * Grab the chunk record.  Mark all the uninteresting inodes\n\t\t * free -- because they're before our start point.\n\t\t */\n\t\tfor (i = 0; i < idx; i++) {\n\t\t\tif (XFS_INOBT_MASK(i) & ~irec->ir_free)\n\t\t\t\tirec->ir_freecount++;\n\t\t}\n\n\t\tirec->ir_free |= xfs_inobt_maskn(0, idx);\n\t\t*icount = XFS_INODES_PER_CHUNK - irec->ir_freecount;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inobt_maskn",
          "args": [
            "0",
            "idx"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_maskn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1281-1284",
          "snippet": "static inline xfs_inofree_t xfs_inobt_maskn(int i, int n)\n{\n\treturn ((n >= XFS_INODES_PER_CHUNK ? 0 : XFS_INOBT_MASK(n)) - 1) << i;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_INODES_PER_CHUNK\t\t(NBBY * sizeof(xfs_inofree_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_INODES_PER_CHUNK\t\t(NBBY * sizeof(xfs_inofree_t))\n\nstatic inline xfs_inofree_t xfs_inobt_maskn(int i, int n)\n{\n\treturn ((n >= XFS_INODES_PER_CHUNK ? 0 : XFS_INOBT_MASK(n)) - 1) << i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INOBT_MASK",
          "args": [
            "i"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "stat == 1"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inobt_get_rec",
          "args": [
            "cur",
            "irec",
            "&stat"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_get_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "93-109",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_inobt_rec_incore_t\t*irec,\t/* btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tunion xfs_btree_rec\t*rec;\n\tint\t\t\terror;\n\n\terror = xfs_btree_get_rec(cur, &rec, stat);\n\tif (!error && *stat == 1) {\n\t\tirec->ir_startino = be32_to_cpu(rec->inobt.ir_startino);\n\t\tirec->ir_freecount = be32_to_cpu(rec->inobt.ir_freecount);\n\t\tirec->ir_free = be64_to_cpu(rec->inobt.ir_free);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_lookup",
          "args": [
            "cur",
            "agino",
            "XFS_LOOKUP_LE",
            "&stat"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "60-71",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_inobt_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\tino,\t/* starting inode of chunk */\n\txfs_lookup_t\t\tdir,\t/* <=, >=, == */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.i.ir_startino = ino;\n\tcur->bc_rec.i.ir_freecount = 0;\n\tcur->bc_rec.i.ir_free = 0;\n\treturn xfs_btree_lookup(cur, dir, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bulkstat_grab_ichunk(\n\tstruct xfs_btree_cur\t\t*cur,\t/* btree cursor */\n\txfs_agino_t\t\t\tagino,\t/* starting inode of chunk */\n\tint\t\t\t\t*icount,/* return # of inodes grabbed */\n\tstruct xfs_inobt_rec_incore\t*irec)\t/* btree record */\n{\n\tint\t\t\t\tidx;\t/* index into inode chunk */\n\tint\t\t\t\tstat;\n\tint\t\t\t\terror = 0;\n\n\t/* Lookup the inode chunk that this inode lives in */\n\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &stat);\n\tif (error)\n\t\treturn error;\n\tif (!stat) {\n\t\t*icount = 0;\n\t\treturn error;\n\t}\n\n\t/* Get the record, should always work */\n\terror = xfs_inobt_get_rec(cur, irec, &stat);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(stat == 1);\n\n\t/* Check if the record contains the inode in request */\n\tif (irec->ir_startino + XFS_INODES_PER_CHUNK <= agino) {\n\t\t*icount = 0;\n\t\treturn 0;\n\t}\n\n\tidx = agino - irec->ir_startino + 1;\n\tif (idx < XFS_INODES_PER_CHUNK &&\n\t    (xfs_inobt_maskn(idx, XFS_INODES_PER_CHUNK - idx) & ~irec->ir_free)) {\n\t\tint\ti;\n\n\t\t/* We got a right chunk with some left inodes allocated at it.\n\t\t * Grab the chunk record.  Mark all the uninteresting inodes\n\t\t * free -- because they're before our start point.\n\t\t */\n\t\tfor (i = 0; i < idx; i++) {\n\t\t\tif (XFS_INOBT_MASK(i) & ~irec->ir_free)\n\t\t\t\tirec->ir_freecount++;\n\t\t}\n\n\t\tirec->ir_free |= xfs_inobt_maskn(0, idx);\n\t\t*icount = XFS_INODES_PER_CHUNK - irec->ir_freecount;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bulkstat_ichunk_ra",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "175-200",
    "snippet": "STATIC void\nxfs_bulkstat_ichunk_ra(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*irec)\n{\n\txfs_agblock_t\t\t\tagbno;\n\tstruct blk_plug\t\t\tplug;\n\tint\t\t\t\tblks_per_cluster;\n\tint\t\t\t\tinodes_per_cluster;\n\tint\t\t\t\ti;\t/* inode chunk index */\n\n\tagbno = XFS_AGINO_TO_AGBNO(mp, irec->ir_startino);\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < XFS_INODES_PER_CHUNK;\n\t     i += inodes_per_cluster, agbno += blks_per_cluster) {\n\t\tif (xfs_inobt_maskn(i, inodes_per_cluster) & ~irec->ir_free) {\n\t\t\txfs_btree_reada_bufs(mp, agno, agbno, blks_per_cluster,\n\t\t\t\t\t     &xfs_inode_buf_ops);\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_reada_bufs",
          "args": [
            "mp",
            "agno",
            "agbno",
            "blks_per_cluster",
            "&xfs_inode_buf_ops"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_reada_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "749-763",
          "snippet": "void\nxfs_btree_reada_bufs(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\t\tagbno,\t\t/* allocation group block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_reada_bufs(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\t\tagbno,\t\t/* allocation group block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_maskn",
          "args": [
            "i",
            "inodes_per_cluster"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_maskn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1281-1284",
          "snippet": "static inline xfs_inofree_t xfs_inobt_maskn(int i, int n)\n{\n\treturn ((n >= XFS_INODES_PER_CHUNK ? 0 : XFS_INOBT_MASK(n)) - 1) << i;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_INODES_PER_CHUNK\t\t(NBBY * sizeof(xfs_inofree_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_INODES_PER_CHUNK\t\t(NBBY * sizeof(xfs_inofree_t))\n\nstatic inline xfs_inofree_t xfs_inobt_maskn(int i, int n)\n{\n\treturn ((n >= XFS_INODES_PER_CHUNK ? 0 : XFS_INOBT_MASK(n)) - 1) << i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icluster_size_fsb",
          "args": [
            "mp"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icluster_size_fsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.h",
          "lines": "32-39",
          "snippet": "static inline int\nxfs_icluster_size_fsb(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_blocksize >= mp->m_inode_cluster_size)\n\t\treturn 1;\n\treturn mp->m_inode_cluster_size >> mp->m_sb.sb_blocklog;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_icluster_size_fsb(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_sb.sb_blocksize >= mp->m_inode_cluster_size)\n\t\treturn 1;\n\treturn mp->m_inode_cluster_size >> mp->m_sb.sb_blocklog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGINO_TO_AGBNO",
          "args": [
            "mp",
            "irec->ir_startino"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bulkstat_ichunk_ra(\n\tstruct xfs_mount\t\t*mp,\n\txfs_agnumber_t\t\t\tagno,\n\tstruct xfs_inobt_rec_incore\t*irec)\n{\n\txfs_agblock_t\t\t\tagbno;\n\tstruct blk_plug\t\t\tplug;\n\tint\t\t\t\tblks_per_cluster;\n\tint\t\t\t\tinodes_per_cluster;\n\tint\t\t\t\ti;\t/* inode chunk index */\n\n\tagbno = XFS_AGINO_TO_AGBNO(mp, irec->ir_startino);\n\tblks_per_cluster = xfs_icluster_size_fsb(mp);\n\tinodes_per_cluster = blks_per_cluster << mp->m_sb.sb_inopblog;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < XFS_INODES_PER_CHUNK;\n\t     i += inodes_per_cluster, agbno += blks_per_cluster) {\n\t\tif (xfs_inobt_maskn(i, inodes_per_cluster) & ~irec->ir_free) {\n\t\t\txfs_btree_reada_bufs(mp, agno, agbno, blks_per_cluster,\n\t\t\t\t\t     &xfs_inode_buf_ops);\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n}"
  },
  {
    "function_name": "xfs_bulkstat_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "158-169",
    "snippet": "int\nxfs_bulkstat_one(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* buffer to place output in */\n\tint\t\tubsize,\t\t/* size of buffer */\n\tint\t\t*ubused,\t/* bytes used by me */\n\tint\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\treturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\n\t\t\t\t    xfs_bulkstat_one_fmt, ubused, stat);\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bulkstat_one_int",
          "args": [
            "mp",
            "ino",
            "buffer",
            "ubsize",
            "xfs_bulkstat_one_fmt",
            "ubused",
            "stat"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat_one_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "48-139",
          "snippet": "int\nxfs_bulkstat_one_int(\n\tstruct xfs_mount\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\t\tino,\t\t/* inode to get data for */\n\tvoid __user\t\t*buffer,\t/* buffer to place output in */\n\tint\t\t\tubsize,\t\t/* size of buffer */\n\tbulkstat_one_fmt_pf\tformatter,\t/* formatter, copy to user */\n\tint\t\t\t*ubused,\t/* bytes used by me */\n\tint\t\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\tstruct xfs_icdinode\t*dic;\t\t/* dinode core info pointer */\n\tstruct xfs_inode\t*ip;\t\t/* incore inode pointer */\n\tstruct xfs_bstat\t*buf;\t\t/* return buffer */\n\tint\t\t\terror = 0;\t/* error value */\n\n\t*stat = BULKSTAT_RV_NOTHING;\n\n\tif (!buffer || xfs_internal_inum(mp, ino))\n\t\treturn -EINVAL;\n\n\tbuf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iget(mp, NULL, ino,\n\t\t\t (XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED),\n\t\t\t XFS_ILOCK_SHARED, &ip);\n\tif (error)\n\t\tgoto out_free;\n\n\tASSERT(ip != NULL);\n\tASSERT(ip->i_imap.im_blkno != 0);\n\n\tdic = &ip->i_d;\n\n\t/* xfs_iget returns the following without needing\n\t * further change.\n\t */\n\tbuf->bs_nlink = dic->di_nlink;\n\tbuf->bs_projid_lo = dic->di_projid_lo;\n\tbuf->bs_projid_hi = dic->di_projid_hi;\n\tbuf->bs_ino = ino;\n\tbuf->bs_mode = dic->di_mode;\n\tbuf->bs_uid = dic->di_uid;\n\tbuf->bs_gid = dic->di_gid;\n\tbuf->bs_size = dic->di_size;\n\tbuf->bs_atime.tv_sec = dic->di_atime.t_sec;\n\tbuf->bs_atime.tv_nsec = dic->di_atime.t_nsec;\n\tbuf->bs_mtime.tv_sec = dic->di_mtime.t_sec;\n\tbuf->bs_mtime.tv_nsec = dic->di_mtime.t_nsec;\n\tbuf->bs_ctime.tv_sec = dic->di_ctime.t_sec;\n\tbuf->bs_ctime.tv_nsec = dic->di_ctime.t_nsec;\n\tbuf->bs_xflags = xfs_ip2xflags(ip);\n\tbuf->bs_extsize = dic->di_extsize << mp->m_sb.sb_blocklog;\n\tbuf->bs_extents = dic->di_nextents;\n\tbuf->bs_gen = dic->di_gen;\n\tmemset(buf->bs_pad, 0, sizeof(buf->bs_pad));\n\tbuf->bs_dmevmask = dic->di_dmevmask;\n\tbuf->bs_dmstate = dic->di_dmstate;\n\tbuf->bs_aextents = dic->di_anextents;\n\tbuf->bs_forkoff = XFS_IFORK_BOFF(ip);\n\n\tswitch (dic->di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tbuf->bs_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbuf->bs_blksize = BLKDEV_IOSIZE;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = dic->di_nblocks + ip->i_delayed_blks;\n\t\tbreak;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\tIRELE(ip);\n\n\terror = formatter(buffer, ubsize, ubused, buf);\n\tif (!error)\n\t\t*stat = BULKSTAT_RV_DIDONE;\n\n out_free:\n\tkmem_free(buf);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bulkstat_one_int(\n\tstruct xfs_mount\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\t\tino,\t\t/* inode to get data for */\n\tvoid __user\t\t*buffer,\t/* buffer to place output in */\n\tint\t\t\tubsize,\t\t/* size of buffer */\n\tbulkstat_one_fmt_pf\tformatter,\t/* formatter, copy to user */\n\tint\t\t\t*ubused,\t/* bytes used by me */\n\tint\t\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\tstruct xfs_icdinode\t*dic;\t\t/* dinode core info pointer */\n\tstruct xfs_inode\t*ip;\t\t/* incore inode pointer */\n\tstruct xfs_bstat\t*buf;\t\t/* return buffer */\n\tint\t\t\terror = 0;\t/* error value */\n\n\t*stat = BULKSTAT_RV_NOTHING;\n\n\tif (!buffer || xfs_internal_inum(mp, ino))\n\t\treturn -EINVAL;\n\n\tbuf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iget(mp, NULL, ino,\n\t\t\t (XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED),\n\t\t\t XFS_ILOCK_SHARED, &ip);\n\tif (error)\n\t\tgoto out_free;\n\n\tASSERT(ip != NULL);\n\tASSERT(ip->i_imap.im_blkno != 0);\n\n\tdic = &ip->i_d;\n\n\t/* xfs_iget returns the following without needing\n\t * further change.\n\t */\n\tbuf->bs_nlink = dic->di_nlink;\n\tbuf->bs_projid_lo = dic->di_projid_lo;\n\tbuf->bs_projid_hi = dic->di_projid_hi;\n\tbuf->bs_ino = ino;\n\tbuf->bs_mode = dic->di_mode;\n\tbuf->bs_uid = dic->di_uid;\n\tbuf->bs_gid = dic->di_gid;\n\tbuf->bs_size = dic->di_size;\n\tbuf->bs_atime.tv_sec = dic->di_atime.t_sec;\n\tbuf->bs_atime.tv_nsec = dic->di_atime.t_nsec;\n\tbuf->bs_mtime.tv_sec = dic->di_mtime.t_sec;\n\tbuf->bs_mtime.tv_nsec = dic->di_mtime.t_nsec;\n\tbuf->bs_ctime.tv_sec = dic->di_ctime.t_sec;\n\tbuf->bs_ctime.tv_nsec = dic->di_ctime.t_nsec;\n\tbuf->bs_xflags = xfs_ip2xflags(ip);\n\tbuf->bs_extsize = dic->di_extsize << mp->m_sb.sb_blocklog;\n\tbuf->bs_extents = dic->di_nextents;\n\tbuf->bs_gen = dic->di_gen;\n\tmemset(buf->bs_pad, 0, sizeof(buf->bs_pad));\n\tbuf->bs_dmevmask = dic->di_dmevmask;\n\tbuf->bs_dmstate = dic->di_dmstate;\n\tbuf->bs_aextents = dic->di_anextents;\n\tbuf->bs_forkoff = XFS_IFORK_BOFF(ip);\n\n\tswitch (dic->di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tbuf->bs_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbuf->bs_blksize = BLKDEV_IOSIZE;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = dic->di_nblocks + ip->i_delayed_blks;\n\t\tbreak;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\tIRELE(ip);\n\n\terror = formatter(buffer, ubsize, ubused, buf);\n\tif (!error)\n\t\t*stat = BULKSTAT_RV_DIDONE;\n\n out_free:\n\tkmem_free(buf);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bulkstat_one(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* buffer to place output in */\n\tint\t\tubsize,\t\t/* size of buffer */\n\tint\t\t*ubused,\t/* bytes used by me */\n\tint\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\treturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\n\t\t\t\t    xfs_bulkstat_one_fmt, ubused, stat);\n}"
  },
  {
    "function_name": "xfs_bulkstat_one_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "142-156",
    "snippet": "STATIC int\nxfs_bulkstat_one_fmt(\n\tvoid\t\t\t__user *ubuffer,\n\tint\t\t\tubsize,\n\tint\t\t\t*ubused,\n\tconst xfs_bstat_t\t*buffer)\n{\n\tif (ubsize < sizeof(*buffer))\n\t\treturn -ENOMEM;\n\tif (copy_to_user(ubuffer, buffer, sizeof(*buffer)))\n\t\treturn -EFAULT;\n\tif (ubused)\n\t\t*ubused = sizeof(*buffer);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuffer",
            "buffer",
            "sizeof(*buffer)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bulkstat_one_fmt(\n\tvoid\t\t\t__user *ubuffer,\n\tint\t\t\tubsize,\n\tint\t\t\t*ubused,\n\tconst xfs_bstat_t\t*buffer)\n{\n\tif (ubsize < sizeof(*buffer))\n\t\treturn -ENOMEM;\n\tif (copy_to_user(ubuffer, buffer, sizeof(*buffer)))\n\t\treturn -EFAULT;\n\tif (ubused)\n\t\t*ubused = sizeof(*buffer);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bulkstat_one_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "48-139",
    "snippet": "int\nxfs_bulkstat_one_int(\n\tstruct xfs_mount\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\t\tino,\t\t/* inode to get data for */\n\tvoid __user\t\t*buffer,\t/* buffer to place output in */\n\tint\t\t\tubsize,\t\t/* size of buffer */\n\tbulkstat_one_fmt_pf\tformatter,\t/* formatter, copy to user */\n\tint\t\t\t*ubused,\t/* bytes used by me */\n\tint\t\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\tstruct xfs_icdinode\t*dic;\t\t/* dinode core info pointer */\n\tstruct xfs_inode\t*ip;\t\t/* incore inode pointer */\n\tstruct xfs_bstat\t*buf;\t\t/* return buffer */\n\tint\t\t\terror = 0;\t/* error value */\n\n\t*stat = BULKSTAT_RV_NOTHING;\n\n\tif (!buffer || xfs_internal_inum(mp, ino))\n\t\treturn -EINVAL;\n\n\tbuf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iget(mp, NULL, ino,\n\t\t\t (XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED),\n\t\t\t XFS_ILOCK_SHARED, &ip);\n\tif (error)\n\t\tgoto out_free;\n\n\tASSERT(ip != NULL);\n\tASSERT(ip->i_imap.im_blkno != 0);\n\n\tdic = &ip->i_d;\n\n\t/* xfs_iget returns the following without needing\n\t * further change.\n\t */\n\tbuf->bs_nlink = dic->di_nlink;\n\tbuf->bs_projid_lo = dic->di_projid_lo;\n\tbuf->bs_projid_hi = dic->di_projid_hi;\n\tbuf->bs_ino = ino;\n\tbuf->bs_mode = dic->di_mode;\n\tbuf->bs_uid = dic->di_uid;\n\tbuf->bs_gid = dic->di_gid;\n\tbuf->bs_size = dic->di_size;\n\tbuf->bs_atime.tv_sec = dic->di_atime.t_sec;\n\tbuf->bs_atime.tv_nsec = dic->di_atime.t_nsec;\n\tbuf->bs_mtime.tv_sec = dic->di_mtime.t_sec;\n\tbuf->bs_mtime.tv_nsec = dic->di_mtime.t_nsec;\n\tbuf->bs_ctime.tv_sec = dic->di_ctime.t_sec;\n\tbuf->bs_ctime.tv_nsec = dic->di_ctime.t_nsec;\n\tbuf->bs_xflags = xfs_ip2xflags(ip);\n\tbuf->bs_extsize = dic->di_extsize << mp->m_sb.sb_blocklog;\n\tbuf->bs_extents = dic->di_nextents;\n\tbuf->bs_gen = dic->di_gen;\n\tmemset(buf->bs_pad, 0, sizeof(buf->bs_pad));\n\tbuf->bs_dmevmask = dic->di_dmevmask;\n\tbuf->bs_dmstate = dic->di_dmstate;\n\tbuf->bs_aextents = dic->di_anextents;\n\tbuf->bs_forkoff = XFS_IFORK_BOFF(ip);\n\n\tswitch (dic->di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tbuf->bs_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbuf->bs_blksize = BLKDEV_IOSIZE;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = dic->di_nblocks + ip->i_delayed_blks;\n\t\tbreak;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\tIRELE(ip);\n\n\terror = formatter(buffer, ubsize, ubused, buf);\n\tif (!error)\n\t\t*stat = BULKSTAT_RV_DIDONE;\n\n out_free:\n\tkmem_free(buf);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "buf"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "formatter",
          "args": [
            "buffer",
            "ubsize",
            "ubused",
            "buf"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_BOFF",
          "args": [
            "ip"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf->bs_pad",
            "0",
            "sizeof(buf->bs_pad)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ip2xflags",
          "args": [
            "ip"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ip2xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "546-554",
          "snippet": "uint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nuint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_imap.im_blkno != 0"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip != NULL"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "ino",
            "(XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED)",
            "XFS_ILOCK_SHARED",
            "&ip"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sizeof(*buf)",
            "KM_SLEEP | KM_MAYFAIL"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_internal_inum",
          "args": [
            "mp",
            "ino"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_internal_inum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "34-42",
          "snippet": "STATIC int\nxfs_internal_inum(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\treturn (ino == mp->m_sb.sb_rbmino || ino == mp->m_sb.sb_rsumino ||\n\t\t(xfs_sb_version_hasquota(&mp->m_sb) &&\n\t\t xfs_is_quota_inode(&mp->m_sb, ino)));\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_internal_inum(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\treturn (ino == mp->m_sb.sb_rbmino || ino == mp->m_sb.sb_rsumino ||\n\t\t(xfs_sb_version_hasquota(&mp->m_sb) &&\n\t\t xfs_is_quota_inode(&mp->m_sb, ino)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bulkstat_one_int(\n\tstruct xfs_mount\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\t\tino,\t\t/* inode to get data for */\n\tvoid __user\t\t*buffer,\t/* buffer to place output in */\n\tint\t\t\tubsize,\t\t/* size of buffer */\n\tbulkstat_one_fmt_pf\tformatter,\t/* formatter, copy to user */\n\tint\t\t\t*ubused,\t/* bytes used by me */\n\tint\t\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\tstruct xfs_icdinode\t*dic;\t\t/* dinode core info pointer */\n\tstruct xfs_inode\t*ip;\t\t/* incore inode pointer */\n\tstruct xfs_bstat\t*buf;\t\t/* return buffer */\n\tint\t\t\terror = 0;\t/* error value */\n\n\t*stat = BULKSTAT_RV_NOTHING;\n\n\tif (!buffer || xfs_internal_inum(mp, ino))\n\t\treturn -EINVAL;\n\n\tbuf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iget(mp, NULL, ino,\n\t\t\t (XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED),\n\t\t\t XFS_ILOCK_SHARED, &ip);\n\tif (error)\n\t\tgoto out_free;\n\n\tASSERT(ip != NULL);\n\tASSERT(ip->i_imap.im_blkno != 0);\n\n\tdic = &ip->i_d;\n\n\t/* xfs_iget returns the following without needing\n\t * further change.\n\t */\n\tbuf->bs_nlink = dic->di_nlink;\n\tbuf->bs_projid_lo = dic->di_projid_lo;\n\tbuf->bs_projid_hi = dic->di_projid_hi;\n\tbuf->bs_ino = ino;\n\tbuf->bs_mode = dic->di_mode;\n\tbuf->bs_uid = dic->di_uid;\n\tbuf->bs_gid = dic->di_gid;\n\tbuf->bs_size = dic->di_size;\n\tbuf->bs_atime.tv_sec = dic->di_atime.t_sec;\n\tbuf->bs_atime.tv_nsec = dic->di_atime.t_nsec;\n\tbuf->bs_mtime.tv_sec = dic->di_mtime.t_sec;\n\tbuf->bs_mtime.tv_nsec = dic->di_mtime.t_nsec;\n\tbuf->bs_ctime.tv_sec = dic->di_ctime.t_sec;\n\tbuf->bs_ctime.tv_nsec = dic->di_ctime.t_nsec;\n\tbuf->bs_xflags = xfs_ip2xflags(ip);\n\tbuf->bs_extsize = dic->di_extsize << mp->m_sb.sb_blocklog;\n\tbuf->bs_extents = dic->di_nextents;\n\tbuf->bs_gen = dic->di_gen;\n\tmemset(buf->bs_pad, 0, sizeof(buf->bs_pad));\n\tbuf->bs_dmevmask = dic->di_dmevmask;\n\tbuf->bs_dmstate = dic->di_dmstate;\n\tbuf->bs_aextents = dic->di_anextents;\n\tbuf->bs_forkoff = XFS_IFORK_BOFF(ip);\n\n\tswitch (dic->di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tbuf->bs_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbuf->bs_blksize = BLKDEV_IOSIZE;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = dic->di_nblocks + ip->i_delayed_blks;\n\t\tbreak;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\tIRELE(ip);\n\n\terror = formatter(buffer, ubsize, ubused, buf);\n\tif (!error)\n\t\t*stat = BULKSTAT_RV_DIDONE;\n\n out_free:\n\tkmem_free(buf);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_internal_inum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
    "lines": "34-42",
    "snippet": "STATIC int\nxfs_internal_inum(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\treturn (ino == mp->m_sb.sb_rbmino || ino == mp->m_sb.sb_rsumino ||\n\t\t(xfs_sb_version_hasquota(&mp->m_sb) &&\n\t\t xfs_is_quota_inode(&mp->m_sb, ino)));\n}",
    "includes": [
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_is_quota_inode",
          "args": [
            "&mp->m_sb",
            "ino"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_is_quota_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "575-581",
          "snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasquota",
          "args": [
            "&mp->m_sb"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasquota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "389-392",
          "snippet": "static inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n\nstatic inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_internal_inum(\n\txfs_mount_t\t*mp,\n\txfs_ino_t\tino)\n{\n\treturn (ino == mp->m_sb.sb_rbmino || ino == mp->m_sb.sb_rsumino ||\n\t\t(xfs_sb_version_hasquota(&mp->m_sb) &&\n\t\t xfs_is_quota_inode(&mp->m_sb, ino)));\n}"
  }
]