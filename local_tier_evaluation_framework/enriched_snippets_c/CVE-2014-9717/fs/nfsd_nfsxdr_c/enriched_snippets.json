[
  {
    "function_name": "nfssvc_release_fhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "544-550",
    "snippet": "int\nnfssvc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_fhandle *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&resp->fh"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_fhandle *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfssvc_encode_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "496-539",
    "snippet": "int\nnfssvc_encode_entry(void *ccdv, const char *name,\n\t\t    int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd_readdirres *cd = container_of(ccd, struct nfsd_readdirres, common);\n\t__be32\t*p = cd->buffer;\n\tint\tbuflen, slen;\n\n\t/*\n\tdprintk(\"nfsd: entry(%.*s off %ld ino %ld)\\n\",\n\t\t\tnamlen, name, offset, ino);\n\t */\n\n\tif (offset > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\tif (cd->offset)\n\t\t*cd->offset = htonl(offset);\n\n\t/* truncate filename */\n\tnamlen = min(namlen, NFS2_MAXNAMLEN);\n\tslen = XDR_QUADLEN(namlen);\n\n\tif ((buflen = cd->buflen - slen - 4) < 0) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\tif (ino > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\t*p++ = xdr_one;\t\t\t\t/* mark entry present */\n\t*p++ = htonl((u32) ino);\t\t/* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\tcd->offset = p;\t\t\t/* remember pointer */\n\t*p++ = htonl(~0U);\t\t/* offset of next entry */\n\n\tcd->buflen = buflen;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "~0U"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_array",
          "args": [
            "p",
            "name",
            "namlen"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) ino"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "namlen"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "namlen",
            "NFS2_MAXNAMLEN"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "offset"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ccd",
            "structnfsd_readdirres",
            "common"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_encode_entry(void *ccdv, const char *name,\n\t\t    int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd_readdirres *cd = container_of(ccd, struct nfsd_readdirres, common);\n\t__be32\t*p = cd->buffer;\n\tint\tbuflen, slen;\n\n\t/*\n\tdprintk(\"nfsd: entry(%.*s off %ld ino %ld)\\n\",\n\t\t\tnamlen, name, offset, ino);\n\t */\n\n\tif (offset > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\tif (cd->offset)\n\t\t*cd->offset = htonl(offset);\n\n\t/* truncate filename */\n\tnamlen = min(namlen, NFS2_MAXNAMLEN);\n\tslen = XDR_QUADLEN(namlen);\n\n\tif ((buflen = cd->buflen - slen - 4) < 0) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\tif (ino > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\t*p++ = xdr_one;\t\t\t\t/* mark entry present */\n\t*p++ = htonl((u32) ino);\t\t/* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\tcd->offset = p;\t\t\t/* remember pointer */\n\t*p++ = htonl(~0U);\t\t/* offset of next entry */\n\n\tcd->buflen = buflen;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfssvc_encode_statfsres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "482-494",
    "snippet": "int\nnfssvc_encode_statfsres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_statfsres *resp)\n{\n\tstruct kstatfs\t*stat = &resp->stats;\n\n\t*p++ = htonl(NFSSVC_MAXBLKSIZE_V2);\t/* max transfer size */\n\t*p++ = htonl(stat->f_bsize);\n\t*p++ = htonl(stat->f_blocks);\n\t*p++ = htonl(stat->f_bfree);\n\t*p++ = htonl(stat->f_bavail);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "stat->f_bavail"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "stat->f_bfree"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "stat->f_blocks"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "stat->f_bsize"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFSSVC_MAXBLKSIZE_V2"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_encode_statfsres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_statfsres *resp)\n{\n\tstruct kstatfs\t*stat = &resp->stats;\n\n\t*p++ = htonl(NFSSVC_MAXBLKSIZE_V2);\t/* max transfer size */\n\t*p++ = htonl(stat->f_bsize);\n\t*p++ = htonl(stat->f_blocks);\n\t*p++ = htonl(stat->f_bfree);\n\t*p++ = htonl(stat->f_bavail);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_encode_readdirres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "469-480",
    "snippet": "int\nnfssvc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirres *resp)\n{\n\txdr_ressize_check(rqstp, p);\n\tp = resp->buffer;\n\t*p++ = 0;\t\t\t/* no more entries */\n\t*p++ = htonl((resp->common.err == nfserr_eof));\n\trqstp->rq_res.page_len = (((unsigned long)p-1) & ~PAGE_MASK)+1;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(resp->common.err == nfserr_eof)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirres *resp)\n{\n\txdr_ressize_check(rqstp, p);\n\tp = resp->buffer;\n\t*p++ = 0;\t\t\t/* no more entries */\n\t*p++ = htonl((resp->common.err == nfserr_eof));\n\trqstp->rq_res.page_len = (((unsigned long)p-1) & ~PAGE_MASK)+1;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "nfssvc_encode_readres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "450-467",
    "snippet": "int\nnfssvc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readres *resp)\n{\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\t*p++ = htonl(resp->count);\n\txdr_ressize_check(rqstp, p);\n\n\t/* now update rqstp->rq_res to reflect data as well */\n\trqstp->rq_res.page_len = resp->count;\n\tif (resp->count & 3) {\n\t\t/* need to pad the tail */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p = 0;\n\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->count&3);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->count"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_fattr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "200-203",
          "snippet": "__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readres *resp)\n{\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\t*p++ = htonl(resp->count);\n\txdr_ressize_check(rqstp, p);\n\n\t/* now update rqstp->rq_res to reflect data as well */\n\trqstp->rq_res.page_len = resp->count;\n\tif (resp->count & 3) {\n\t\t/* need to pad the tail */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p = 0;\n\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->count&3);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "nfssvc_encode_readlinkres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "434-448",
    "snippet": "int\nnfssvc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readlinkres *resp)\n{\n\t*p++ = htonl(resp->len);\n\txdr_ressize_check(rqstp, p);\n\trqstp->rq_res.page_len = resp->len;\n\tif (resp->len & 3) {\n\t\t/* need to pad the tail */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p = 0;\n\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->len"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readlinkres *resp)\n{\n\t*p++ = htonl(resp->len);\n\txdr_ressize_check(rqstp, p);\n\trqstp->rq_res.page_len = resp->len;\n\tif (resp->len & 3) {\n\t\t/* need to pad the tail */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p = 0;\n\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "nfssvc_encode_diropres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "425-432",
    "snippet": "int\nnfssvc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropres *resp)\n{\n\tp = encode_fh(p, &resp->fh);\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_fattr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "200-203",
          "snippet": "__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_fh",
          "args": [
            "p",
            "&resp->fh"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "45-50",
          "snippet": "static __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tmemcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);\n\treturn p + (NFS_FHSIZE>> 2);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tmemcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);\n\treturn p + (NFS_FHSIZE>> 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropres *resp)\n{\n\tp = encode_fh(p, &resp->fh);\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_encode_attrstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "417-423",
    "snippet": "int\nnfssvc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_attrstat *resp)\n{\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_fattr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "200-203",
          "snippet": "__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_attrstat *resp)\n{\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_encode_void",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "411-415",
    "snippet": "int\nnfssvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_readdirargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "393-406",
    "snippet": "int\nnfssvc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->cookie = ntohl(*p++);\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "*(rqstp->rq_next_page++)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "args->count",
            "PAGE_SIZE"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->cookie = ntohl(*p++);\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_symlinkargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "380-391",
    "snippet": "int\nnfssvc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_symlinkargs *args)\n{\n\tif (   !(p = decode_fh(p, &args->ffh))\n\t    || !(p = decode_filename(p, &args->fname, &args->flen))\n\t    || !(p = decode_pathname(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sattr",
          "args": [
            "p",
            "&args->attrs"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "88-141",
          "snippet": "static __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_pathname",
          "args": [
            "p",
            "&args->tname",
            "&args->tlen"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "decode_pathname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "72-86",
          "snippet": "static __be32 *\ndecode_pathname(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXPATHLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_pathname(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXPATHLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->fname",
            "&args->flen"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "56-70",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->ffh"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_symlinkargs *args)\n{\n\tif (   !(p = decode_fh(p, &args->ffh))\n\t    || !(p = decode_filename(p, &args->fname, &args->flen))\n\t    || !(p = decode_pathname(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_linkargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "368-378",
    "snippet": "int\nnfssvc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_linkargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->tname",
            "&args->tlen"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "56-70",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->tfh"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_linkargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_readlinkargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "357-366",
    "snippet": "int\nnfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readlinkargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "*(rqstp->rq_next_page++)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readlinkargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_renameargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "344-355",
    "snippet": "int\nnfssvc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_renameargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_filename(p, &args->fname, &args->flen))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->tname",
            "&args->tlen"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "56-70",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->tfh"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_renameargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_filename(p, &args->fname, &args->flen))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_createargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "332-342",
    "snippet": "int\nnfssvc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_createargs *args)\n{\n\tif (   !(p = decode_fh(p, &args->fh))\n\t    || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sattr",
          "args": [
            "p",
            "&args->attrs"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "88-141",
          "snippet": "static __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->name",
            "&args->len"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "56-70",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_createargs *args)\n{\n\tif (   !(p = decode_fh(p, &args->fh))\n\t    || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_writeargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "278-330",
    "snippet": "int\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - rqstp->rq_arg.head[0].iov_base;\n\tdlen = rqstp->rq_arg.head[0].iov_len + rqstp->rq_arg.page_len\n\t\t- hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = rqstp->rq_arg.head[0].iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "rqstp->rq_pages[v]"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "len"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - rqstp->rq_arg.head[0].iov_base;\n\tdlen = rqstp->rq_arg.head[0].iov_len + rqstp->rq_arg.page_len\n\t\t- hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = rqstp->rq_arg.head[0].iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "nfssvc_decode_readargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "246-276",
    "snippet": "int\nnfssvc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readargs *args)\n{\n\tunsigned int len;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\targs->offset    = ntohl(*p++);\n\tlen = args->count     = ntohl(*p++);\n\tp++; /* totalcount - unused */\n\n\tlen = min_t(unsigned int, len, NFSSVC_MAXBLKSIZE_V2);\n\n\t/* set up somewhere to store response.\n\t * We take pages, put them on reslist and include in iovec\n\t */\n\tv=0;\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\n\t\trqstp->rq_vec[v].iov_base = page_address(p);\n\t\trqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t}\n\targs->vlen = v;\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "len",
            "PAGE_SIZE"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "len",
            "NFSSVC_MAXBLKSIZE_V2"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readargs *args)\n{\n\tunsigned int len;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\targs->offset    = ntohl(*p++);\n\tlen = args->count     = ntohl(*p++);\n\tp++; /* totalcount - unused */\n\n\tlen = min_t(unsigned int, len, NFSSVC_MAXBLKSIZE_V2);\n\n\t/* set up somewhere to store response.\n\t * We take pages, put them on reslist and include in iovec\n\t */\n\tv=0;\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\n\t\trqstp->rq_vec[v].iov_base = page_address(p);\n\t\trqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t}\n\targs->vlen = v;\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_diropargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "235-244",
    "snippet": "int\nnfssvc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\t return xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->name",
            "&args->len"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "56-70",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\t return xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_sattrargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "223-233",
    "snippet": "int\nnfssvc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_sattrargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sattr",
          "args": [
            "p",
            "&args->attrs"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "88-141",
          "snippet": "static __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_sattrargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_fhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "214-221",
    "snippet": "int\nnfssvc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfssvc_decode_void",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "208-212",
    "snippet": "int\nnfssvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nint\nnfssvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs2svc_encode_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "200-203",
    "snippet": "__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_fattr",
          "args": [
            "rqstp",
            "p",
            "fhp",
            "stat"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "200-203",
          "snippet": "__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}"
  },
  {
    "function_name": "encode_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "143-197",
    "snippet": "static __be32 *\nencode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t     struct kstat *stat)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\tint type;\n\tstruct timespec time;\n\tu32 f;\n\n\ttype = (stat->mode & S_IFMT);\n\n\t*p++ = htonl(nfs_ftypes[type >> 12]);\n\t*p++ = htonl((u32) stat->mode);\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\n\tif (S_ISLNK(type) && stat->size > NFS_MAXPATHLEN) {\n\t\t*p++ = htonl(NFS_MAXPATHLEN);\n\t} else {\n\t\t*p++ = htonl((u32) stat->size);\n\t}\n\t*p++ = htonl((u32) stat->blksize);\n\tif (S_ISCHR(type) || S_ISBLK(type))\n\t\t*p++ = htonl(new_encode_dev(stat->rdev));\n\telse\n\t\t*p++ = htonl(0xffffffff);\n\t*p++ = htonl((u32) stat->blocks);\n\tswitch (fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\t*p++ = htonl(new_encode_dev(stat->dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\t*p++ = htonl((u32) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u32*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[1];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[2];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[3];\n\t\t*p++ = htonl(f);\n\t\tbreak;\n\t}\n\t*p++ = htonl((u32) stat->ino);\n\t*p++ = htonl((u32) stat->atime.tv_sec);\n\t*p++ = htonl(stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0);\n\tlease_get_mtime(dentry->d_inode, &time); \n\t*p++ = htonl((u32) time.tv_sec);\n\t*p++ = htonl(time.tv_nsec ? time.tv_nsec / 1000 : 0); \n\t*p++ = htonl((u32) stat->ctime.tv_sec);\n\t*p++ = htonl(stat->ctime.tv_nsec ? stat->ctime.tv_nsec / 1000 : 0);\n\n\treturn p;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\tnfs_ftypes[] = {\n\tNFNON,  NFCHR,  NFCHR, NFBAD,\n\tNFDIR,  NFBAD,  NFBLK, NFBAD,\n\tNFREG,  NFBAD,  NFLNK, NFBAD,\n\tNFSOCK, NFBAD,  NFLNK, NFBAD,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "stat->ctime.tv_nsec ? stat->ctime.tv_nsec / 1000 : 0"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->ctime.tv_sec"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "time.tv_nsec ? time.tv_nsec / 1000 : 0"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) time.tv_sec"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_get_mtime",
          "args": [
            "dentry->d_inode",
            "&time"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "lease_get_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1495-1516",
          "snippet": "void lease_get_mtime(struct inode *inode, struct timespec *time)\n{\n\tbool has_lease = false;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tif (!list_empty(&ctx->flc_lease)) {\n\t\t\tfl = list_first_entry(&ctx->flc_lease,\n\t\t\t\t\t\tstruct file_lock, fl_list);\n\t\t\tif (fl->fl_type == F_WRLCK)\n\t\t\t\thas_lease = true;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\n\tif (has_lease)\n\t\t*time = current_fs_time(inode->i_sb);\n\telse\n\t\t*time = inode->i_mtime;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid lease_get_mtime(struct inode *inode, struct timespec *time)\n{\n\tbool has_lease = false;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tif (!list_empty(&ctx->flc_lease)) {\n\t\t\tfl = list_first_entry(&ctx->flc_lease,\n\t\t\t\t\t\tstruct file_lock, fl_list);\n\t\t\tif (fl->fl_type == F_WRLCK)\n\t\t\t\thas_lease = true;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\n\tif (has_lease)\n\t\t*time = current_fs_time(inode->i_sb);\n\telse\n\t\t*time = inode->i_mtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->atime.tv_sec"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->ino"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "f"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) fhp->fh_export->ex_fsid"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "new_encode_dev(stat->dev)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "stat->dev"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsid_source",
          "args": [
            "fhp"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "fsid_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "666-692",
          "snippet": "enum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nenum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->blocks"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0xffffffff"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "new_encode_dev(stat->rdev)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "stat->rdev"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "type"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "type"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->blksize"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->size"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS_MAXPATHLEN"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "type"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) from_kgid(&init_user_ns, stat->gid)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "stat->gid"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) from_kuid(&init_user_ns, stat->uid)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "stat->uid"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->nlink"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->mode"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "nfs_ftypes[type >> 12]"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic u32\tnfs_ftypes[] = {\n\tNFNON,  NFCHR,  NFCHR, NFBAD,\n\tNFDIR,  NFBAD,  NFBLK, NFBAD,\n\tNFREG,  NFBAD,  NFLNK, NFBAD,\n\tNFSOCK, NFBAD,  NFLNK, NFBAD,\n};\n\nstatic __be32 *\nencode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t     struct kstat *stat)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\tint type;\n\tstruct timespec time;\n\tu32 f;\n\n\ttype = (stat->mode & S_IFMT);\n\n\t*p++ = htonl(nfs_ftypes[type >> 12]);\n\t*p++ = htonl((u32) stat->mode);\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\n\tif (S_ISLNK(type) && stat->size > NFS_MAXPATHLEN) {\n\t\t*p++ = htonl(NFS_MAXPATHLEN);\n\t} else {\n\t\t*p++ = htonl((u32) stat->size);\n\t}\n\t*p++ = htonl((u32) stat->blksize);\n\tif (S_ISCHR(type) || S_ISBLK(type))\n\t\t*p++ = htonl(new_encode_dev(stat->rdev));\n\telse\n\t\t*p++ = htonl(0xffffffff);\n\t*p++ = htonl((u32) stat->blocks);\n\tswitch (fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\t*p++ = htonl(new_encode_dev(stat->dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\t*p++ = htonl((u32) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u32*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[1];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[2];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[3];\n\t\t*p++ = htonl(f);\n\t\tbreak;\n\t}\n\t*p++ = htonl((u32) stat->ino);\n\t*p++ = htonl((u32) stat->atime.tv_sec);\n\t*p++ = htonl(stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0);\n\tlease_get_mtime(dentry->d_inode, &time); \n\t*p++ = htonl((u32) time.tv_sec);\n\t*p++ = htonl(time.tv_nsec ? time.tv_nsec / 1000 : 0); \n\t*p++ = htonl((u32) stat->ctime.tv_sec);\n\t*p++ = htonl(stat->ctime.tv_nsec ? stat->ctime.tv_nsec / 1000 : 0);\n\n\treturn p;\n}"
  },
  {
    "function_name": "decode_sattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "88-141",
    "snippet": "static __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "iap->ia_gid"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "tmp"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "iap->ia_uid"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "tmp"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "decode_pathname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "72-86",
    "snippet": "static __be32 *\ndecode_pathname(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXPATHLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_string_inplace",
          "args": [
            "p",
            "namp",
            "lenp",
            "NFS_MAXPATHLEN"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_pathname(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXPATHLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "decode_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "56-70",
    "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_string_inplace",
          "args": [
            "p",
            "namp",
            "lenp",
            "NFS_MAXNAMLEN"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "45-50",
    "snippet": "static __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tmemcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);\n\treturn p + (NFS_FHSIZE>> 2);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "&fhp->fh_handle.fh_base",
            "NFS_FHSIZE"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tmemcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);\n\treturn p + (NFS_FHSIZE>> 2);\n}"
  },
  {
    "function_name": "nfs2svc_decode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "40-43",
    "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "fhp"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
  },
  {
    "function_name": "decode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsxdr.c",
    "lines": "27-37",
    "snippet": "static __be32 *\ndecode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tfh_init(fhp, NFS_FHSIZE);\n\tmemcpy(&fhp->fh_handle.fh_base, p, NFS_FHSIZE);\n\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\n\t/* FIXME: Look up export pointer here and verify\n\t * Sun Secure RPC if requested */\n\treturn p + (NFS_FHSIZE >> 2);\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"xdr.h\"",
      "#include \"vfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fhp->fh_handle.fh_base",
            "p",
            "NFS_FHSIZE"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "fhp",
            "NFS_FHSIZE"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\nstatic __be32 *\ndecode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tfh_init(fhp, NFS_FHSIZE);\n\tmemcpy(&fhp->fh_handle.fh_base, p, NFS_FHSIZE);\n\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\n\t/* FIXME: Look up export pointer here and verify\n\t * Sun Secure RPC if requested */\n\treturn p + (NFS_FHSIZE >> 2);\n}"
  }
]