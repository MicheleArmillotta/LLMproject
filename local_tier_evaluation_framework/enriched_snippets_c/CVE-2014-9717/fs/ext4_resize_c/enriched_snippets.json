[
  {
    "function_name": "ext4_resize_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1866-2021",
    "snippet": "int ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count)\n{\n\tstruct ext4_new_flex_group_data *flex_gd = NULL;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *bh;\n\tstruct inode *resize_inode = NULL;\n\text4_grpblk_t add, offset;\n\tunsigned long n_desc_blocks;\n\tunsigned long o_desc_blocks;\n\text4_group_t o_group;\n\text4_group_t n_group;\n\text4_fsblk_t o_blocks_count;\n\text4_fsblk_t n_blocks_count_retry = 0;\n\tunsigned long last_update_time = 0;\n\tint err = 0, flexbg_size = 1 << sbi->s_log_groups_per_flex;\n\tint meta_bg;\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, n_blocks_count - 1);\n\tif (!bh) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\nretry:\n\to_blocks_count = ext4_blocks_count(es);\n\n\text4_msg(sb, KERN_INFO, \"resizing filesystem from %llu \"\n\t\t \"to %llu blocks\", o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\t/* On-line shrinking not supported */\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count == o_blocks_count)\n\t\t/* Nothing need to do */\n\t\treturn 0;\n\n\tn_group = ext4_get_group_number(sb, n_blocks_count - 1);\n\tif (n_group > (0xFFFFFFFFUL / EXT4_INODES_PER_GROUP(sb))) {\n\t\text4_warning(sb, \"resize would cause inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\text4_get_group_no_and_offset(sb, o_blocks_count - 1, &o_group, &offset);\n\n\tn_desc_blocks = num_desc_blocks(sb, n_group + 1);\n\to_desc_blocks = num_desc_blocks(sb, sbi->s_groups_count);\n\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_RESIZE_INODE)) {\n\t\tif (meta_bg) {\n\t\t\text4_error(sb, \"resize_inode and meta_bg enabled \"\n\t\t\t\t   \"simultaneously\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n_desc_blocks > o_desc_blocks +\n\t\t    le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\tn_blocks_count_retry = n_blocks_count;\n\t\t\tn_desc_blocks = o_desc_blocks +\n\t\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks);\n\t\t\tn_group = n_desc_blocks * EXT4_DESC_PER_BLOCK(sb);\n\t\t\tn_blocks_count = n_group * EXT4_BLOCKS_PER_GROUP(sb);\n\t\t\tn_group--; /* set to last group number */\n\t\t}\n\n\t\tif (!resize_inode)\n\t\t\tresize_inode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(resize_inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(resize_inode);\n\t\t}\n\t}\n\n\tif ((!resize_inode && !meta_bg) || n_blocks_count == o_blocks_count) {\n\t\terr = ext4_convert_meta_bg(sb, resize_inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tif (n_blocks_count_retry) {\n\t\t\tn_blocks_count = n_blocks_count_retry;\n\t\t\tn_blocks_count_retry = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/* extend the last group */\n\tif (n_group == o_group)\n\t\tadd = n_blocks_count - o_blocks_count;\n\telse\n\t\tadd = EXT4_BLOCKS_PER_GROUP(sb) - (offset + 1);\n\tif (add > 0) {\n\t\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (ext4_blocks_count(es) == n_blocks_count)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, n_group + 1);\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_mb_alloc_groupinfo(sb, n_group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd = alloc_flex_gd(flexbg_size);\n\tif (flex_gd == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Add flex groups. Note that a regular group is a\n\t * flex group with 1 group.\n\t */\n\twhile (ext4_setup_next_flex_gd(sb, flex_gd, n_blocks_count,\n\t\t\t\t\t      flexbg_size)) {\n\t\tif (jiffies - last_update_time > HZ * 10) {\n\t\t\tif (last_update_time)\n\t\t\t\text4_msg(sb, KERN_INFO,\n\t\t\t\t\t \"resized to %llu blocks\",\n\t\t\t\t\t ext4_blocks_count(es));\n\t\t\tlast_update_time = jiffies;\n\t\t}\n\t\tif (ext4_alloc_group_tables(sb, flex_gd, flexbg_size) != 0)\n\t\t\tbreak;\n\t\terr = ext4_flex_group_add(sb, resize_inode, flex_gd);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\n\tif (!err && n_blocks_count_retry) {\n\t\tn_blocks_count = n_blocks_count_retry;\n\t\tn_blocks_count_retry = 0;\n\t\tfree_flex_gd(flex_gd);\n\t\tflex_gd = NULL;\n\t\tgoto retry;\n\t}\n\nout:\n\tif (flex_gd)\n\t\tfree_flex_gd(flex_gd);\n\tif (resize_inode != NULL)\n\t\tiput(resize_inode);\n\text4_msg(sb, KERN_INFO, \"resized filesystem to %llu\", n_blocks_count);\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"resized filesystem to %llu\"",
            "n_blocks_count"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "resize_inode"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_flex_gd",
          "args": [
            "flex_gd"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "free_flex_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "224-229",
          "snippet": "static void free_flex_gd(struct ext4_new_flex_group_data *flex_gd)\n{\n\tkfree(flex_gd->bg_flags);\n\tkfree(flex_gd->groups);\n\tkfree(flex_gd);\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic void free_flex_gd(struct ext4_new_flex_group_data *flex_gd)\n{\n\tkfree(flex_gd->bg_flags);\n\tkfree(flex_gd->groups);\n\tkfree(flex_gd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_group_add",
          "args": [
            "sb",
            "resize_inode",
            "flex_gd"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_flex_group_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1410-1495",
          "snippet": "static int ext4_flex_group_add(struct super_block *sb,\n\t\t\t       struct inode *resize_inode,\n\t\t\t       struct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_group_t group;\n\thandle_t *handle;\n\tunsigned reserved_gdb;\n\tint err = 0, err2 = 0, credit;\n\n\tBUG_ON(!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\to_blocks_count = ext4_blocks_count(es);\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\n\terr = setup_new_flex_group_blocks(sb, flex_gd);\n\tif (err)\n\t\tgoto exit;\n\t/*\n\t * We will always be modifying at least the superblock and  GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\tcredit = flex_gd->count * 4 + reserved_gdb;\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credit);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto exit_journal;\n\n\tgroup = flex_gd->groups[0].group;\n\tBUG_ON(group != EXT4_SB(sb)->s_groups_count);\n\terr = ext4_add_new_descs(handle, sb, group,\n\t\t\t\tresize_inode, flex_gd->count);\n\tif (err)\n\t\tgoto exit_journal;\n\n\terr = ext4_setup_new_descs(handle, sb, flex_gd);\n\tif (err)\n\t\tgoto exit_journal;\n\n\text4_update_super(sb, flex_gd);\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\nexit_journal:\n\terr2 = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tint gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\t\tint gdb_num_end = ((group + flex_gd->count - 1) /\n\t\t\t\t   EXT4_DESC_PER_BLOCK(sb));\n\t\tint meta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_INCOMPAT_META_BG);\n\t\tsector_t old_gdb = 0;\n\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block), 0);\n\t\tfor (; gdb_num <= gdb_num_end; gdb_num++) {\n\t\t\tstruct buffer_head *gdb_bh;\n\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tif (old_gdb == gdb_bh->b_blocknr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backups(sb, gdb_bh->b_blocknr, gdb_bh->b_data,\n\t\t\t\t       gdb_bh->b_size, meta_bg);\n\t\t\told_gdb = gdb_bh->b_blocknr;\n\t\t}\n\t}\nexit:\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_flex_group_add(struct super_block *sb,\n\t\t\t       struct inode *resize_inode,\n\t\t\t       struct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_group_t group;\n\thandle_t *handle;\n\tunsigned reserved_gdb;\n\tint err = 0, err2 = 0, credit;\n\n\tBUG_ON(!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\to_blocks_count = ext4_blocks_count(es);\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\n\terr = setup_new_flex_group_blocks(sb, flex_gd);\n\tif (err)\n\t\tgoto exit;\n\t/*\n\t * We will always be modifying at least the superblock and  GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\tcredit = flex_gd->count * 4 + reserved_gdb;\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credit);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto exit_journal;\n\n\tgroup = flex_gd->groups[0].group;\n\tBUG_ON(group != EXT4_SB(sb)->s_groups_count);\n\terr = ext4_add_new_descs(handle, sb, group,\n\t\t\t\tresize_inode, flex_gd->count);\n\tif (err)\n\t\tgoto exit_journal;\n\n\terr = ext4_setup_new_descs(handle, sb, flex_gd);\n\tif (err)\n\t\tgoto exit_journal;\n\n\text4_update_super(sb, flex_gd);\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\nexit_journal:\n\terr2 = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tint gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\t\tint gdb_num_end = ((group + flex_gd->count - 1) /\n\t\t\t\t   EXT4_DESC_PER_BLOCK(sb));\n\t\tint meta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_INCOMPAT_META_BG);\n\t\tsector_t old_gdb = 0;\n\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block), 0);\n\t\tfor (; gdb_num <= gdb_num_end; gdb_num++) {\n\t\t\tstruct buffer_head *gdb_bh;\n\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tif (old_gdb == gdb_bh->b_blocknr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backups(sb, gdb_bh->b_blocknr, gdb_bh->b_data,\n\t\t\t\t       gdb_bh->b_size, meta_bg);\n\t\t\told_gdb = gdb_bh->b_blocknr;\n\t\t}\n\t}\nexit:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_alloc_group_tables",
          "args": [
            "sb",
            "flex_gd",
            "flexbg_size"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_group_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "244-352",
          "snippet": "static int ext4_alloc_group_tables(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\t\tint flexbg_size)\n{\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t start_blk;\n\text4_fsblk_t last_blk;\n\text4_group_t src_group;\n\text4_group_t bb_index = 0;\n\text4_group_t ib_index = 0;\n\text4_group_t it_index = 0;\n\text4_group_t group;\n\text4_group_t last_group;\n\tunsigned overhead;\n\t__u16 uninit_mask = (flexbg_size > 1) ? ~EXT4_BG_BLOCK_UNINIT : ~0;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\n\tsrc_group = group_data[0].group;\n\tlast_group  = src_group + flex_gd->count - 1;\n\n\tBUG_ON((flexbg_size > 1) && ((src_group & ~(flexbg_size - 1)) !=\n\t       (last_group & ~(flexbg_size - 1))));\nnext_group:\n\tgroup = group_data[0].group;\n\tif (src_group >= group_data[0].group + flex_gd->count)\n\t\treturn -ENOSPC;\n\tstart_blk = ext4_group_first_block_no(sb, src_group);\n\tlast_blk = start_blk + group_data[src_group - group].blocks_count;\n\n\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\n\tstart_blk += overhead;\n\n\t/* We collect contiguous blocks as much as possible. */\n\tsrc_group++;\n\tfor (; src_group <= last_group; src_group++) {\n\t\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\t\tif (overhead == 0)\n\t\t\tlast_blk += group_data[src_group - group].blocks_count;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* Allocate block bitmaps */\n\tfor (; bb_index < flex_gd->count; bb_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[bb_index].block_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].free_blocks_count--;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode bitmaps */\n\tfor (; ib_index < flex_gd->count; ib_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[ib_index].inode_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].free_blocks_count--;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode tables */\n\tfor (; it_index < flex_gd->count; it_index++) {\n\t\tunsigned int itb = EXT4_SB(sb)->s_itb_per_group;\n\t\text4_fsblk_t next_group_start;\n\n\t\tif (start_blk + itb > last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[it_index].inode_table = start_blk;\n\t\tgroup = ext4_get_group_number(sb, start_blk);\n\t\tnext_group_start = ext4_group_first_block_no(sb, group + 1);\n\t\tgroup -= group_data[0].group;\n\n\t\tif (start_blk + itb > next_group_start) {\n\t\t\tflex_gd->bg_flags[group + 1] &= uninit_mask;\n\t\t\toverhead = start_blk + itb - next_group_start;\n\t\t\tgroup_data[group + 1].free_blocks_count -= overhead;\n\t\t\titb -= overhead;\n\t\t}\n\n\t\tgroup_data[group].free_blocks_count -= itb;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t\tstart_blk += EXT4_SB(sb)->s_itb_per_group;\n\t}\n\n\tif (test_opt(sb, DEBUG)) {\n\t\tint i;\n\t\tgroup = group_data[0].group;\n\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding a flex group with \"\n\t\t       \"%d groups, flexbg size is %d:\\n\", flex_gd->count,\n\t\t       flexbg_size);\n\n\t\tfor (i = 0; i < flex_gd->count; i++) {\n\t\t\tprintk(KERN_DEBUG \"adding %s group %u: %u \"\n\t\t\t       \"blocks (%d free)\\n\",\n\t\t\t       ext4_bg_has_super(sb, group + i) ? \"normal\" :\n\t\t\t       \"no-super\", group + i,\n\t\t\t       group_data[i].blocks_count,\n\t\t\t       group_data[i].free_blocks_count);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_alloc_group_tables(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\t\tint flexbg_size)\n{\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t start_blk;\n\text4_fsblk_t last_blk;\n\text4_group_t src_group;\n\text4_group_t bb_index = 0;\n\text4_group_t ib_index = 0;\n\text4_group_t it_index = 0;\n\text4_group_t group;\n\text4_group_t last_group;\n\tunsigned overhead;\n\t__u16 uninit_mask = (flexbg_size > 1) ? ~EXT4_BG_BLOCK_UNINIT : ~0;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\n\tsrc_group = group_data[0].group;\n\tlast_group  = src_group + flex_gd->count - 1;\n\n\tBUG_ON((flexbg_size > 1) && ((src_group & ~(flexbg_size - 1)) !=\n\t       (last_group & ~(flexbg_size - 1))));\nnext_group:\n\tgroup = group_data[0].group;\n\tif (src_group >= group_data[0].group + flex_gd->count)\n\t\treturn -ENOSPC;\n\tstart_blk = ext4_group_first_block_no(sb, src_group);\n\tlast_blk = start_blk + group_data[src_group - group].blocks_count;\n\n\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\n\tstart_blk += overhead;\n\n\t/* We collect contiguous blocks as much as possible. */\n\tsrc_group++;\n\tfor (; src_group <= last_group; src_group++) {\n\t\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\t\tif (overhead == 0)\n\t\t\tlast_blk += group_data[src_group - group].blocks_count;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* Allocate block bitmaps */\n\tfor (; bb_index < flex_gd->count; bb_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[bb_index].block_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].free_blocks_count--;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode bitmaps */\n\tfor (; ib_index < flex_gd->count; ib_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[ib_index].inode_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].free_blocks_count--;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode tables */\n\tfor (; it_index < flex_gd->count; it_index++) {\n\t\tunsigned int itb = EXT4_SB(sb)->s_itb_per_group;\n\t\text4_fsblk_t next_group_start;\n\n\t\tif (start_blk + itb > last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[it_index].inode_table = start_blk;\n\t\tgroup = ext4_get_group_number(sb, start_blk);\n\t\tnext_group_start = ext4_group_first_block_no(sb, group + 1);\n\t\tgroup -= group_data[0].group;\n\n\t\tif (start_blk + itb > next_group_start) {\n\t\t\tflex_gd->bg_flags[group + 1] &= uninit_mask;\n\t\t\toverhead = start_blk + itb - next_group_start;\n\t\t\tgroup_data[group + 1].free_blocks_count -= overhead;\n\t\t\titb -= overhead;\n\t\t}\n\n\t\tgroup_data[group].free_blocks_count -= itb;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t\tstart_blk += EXT4_SB(sb)->s_itb_per_group;\n\t}\n\n\tif (test_opt(sb, DEBUG)) {\n\t\tint i;\n\t\tgroup = group_data[0].group;\n\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding a flex group with \"\n\t\t       \"%d groups, flexbg size is %d:\\n\", flex_gd->count,\n\t\t       flexbg_size);\n\n\t\tfor (i = 0; i < flex_gd->count; i++) {\n\t\t\tprintk(KERN_DEBUG \"adding %s group %u: %u \"\n\t\t\t       \"blocks (%d free)\\n\",\n\t\t\t       ext4_bg_has_super(sb, group + i) ? \"normal\" :\n\t\t\t       \"no-super\", group + i,\n\t\t\t       group_data[i].blocks_count,\n\t\t\t       group_data[i].free_blocks_count);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_setup_next_flex_gd",
          "args": [
            "sb",
            "flex_gd",
            "n_blocks_count",
            "flexbg_size"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_setup_next_flex_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1497-1556",
          "snippet": "static int ext4_setup_next_flex_gd(struct super_block *sb,\n\t\t\t\t    struct ext4_new_flex_group_data *flex_gd,\n\t\t\t\t    ext4_fsblk_t n_blocks_count,\n\t\t\t\t    unsigned long flexbg_size)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t o_blocks_count;\n\text4_group_t n_group;\n\text4_group_t group;\n\text4_group_t last_group;\n\text4_grpblk_t last;\n\text4_grpblk_t blocks_per_group;\n\tunsigned long i;\n\n\tblocks_per_group = EXT4_BLOCKS_PER_GROUP(sb);\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (o_blocks_count == n_blocks_count)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\text4_get_group_no_and_offset(sb, n_blocks_count - 1, &n_group, &last);\n\n\tlast_group = group | (flexbg_size - 1);\n\tif (last_group > n_group)\n\t\tlast_group = n_group;\n\n\tflex_gd->count = last_group - group + 1;\n\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tint overhead;\n\n\t\tgroup_data[i].group = group + i;\n\t\tgroup_data[i].blocks_count = blocks_per_group;\n\t\toverhead = ext4_group_overhead_blocks(sb, group + i);\n\t\tgroup_data[i].free_blocks_count = blocks_per_group - overhead;\n\t\tif (ext4_has_group_desc_csum(sb)) {\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_BLOCK_UNINIT |\n\t\t\t\t\t       EXT4_BG_INODE_UNINIT;\n\t\t\tif (!test_opt(sb, INIT_INODE_TABLE))\n\t\t\t\tflex_gd->bg_flags[i] |= EXT4_BG_INODE_ZEROED;\n\t\t} else\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_INODE_ZEROED;\n\t}\n\n\tif (last_group == n_group && ext4_has_group_desc_csum(sb))\n\t\t/* We need to initialize block bitmap of last group. */\n\t\tflex_gd->bg_flags[i - 1] &= ~EXT4_BG_BLOCK_UNINIT;\n\n\tif ((last_group == n_group) && (last != blocks_per_group - 1)) {\n\t\tgroup_data[i - 1].blocks_count = last + 1;\n\t\tgroup_data[i - 1].free_blocks_count -= blocks_per_group-\n\t\t\t\t\tlast - 1;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_setup_next_flex_gd(struct super_block *sb,\n\t\t\t\t    struct ext4_new_flex_group_data *flex_gd,\n\t\t\t\t    ext4_fsblk_t n_blocks_count,\n\t\t\t\t    unsigned long flexbg_size)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t o_blocks_count;\n\text4_group_t n_group;\n\text4_group_t group;\n\text4_group_t last_group;\n\text4_grpblk_t last;\n\text4_grpblk_t blocks_per_group;\n\tunsigned long i;\n\n\tblocks_per_group = EXT4_BLOCKS_PER_GROUP(sb);\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (o_blocks_count == n_blocks_count)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\text4_get_group_no_and_offset(sb, n_blocks_count - 1, &n_group, &last);\n\n\tlast_group = group | (flexbg_size - 1);\n\tif (last_group > n_group)\n\t\tlast_group = n_group;\n\n\tflex_gd->count = last_group - group + 1;\n\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tint overhead;\n\n\t\tgroup_data[i].group = group + i;\n\t\tgroup_data[i].blocks_count = blocks_per_group;\n\t\toverhead = ext4_group_overhead_blocks(sb, group + i);\n\t\tgroup_data[i].free_blocks_count = blocks_per_group - overhead;\n\t\tif (ext4_has_group_desc_csum(sb)) {\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_BLOCK_UNINIT |\n\t\t\t\t\t       EXT4_BG_INODE_UNINIT;\n\t\t\tif (!test_opt(sb, INIT_INODE_TABLE))\n\t\t\t\tflex_gd->bg_flags[i] |= EXT4_BG_INODE_ZEROED;\n\t\t} else\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_INODE_ZEROED;\n\t}\n\n\tif (last_group == n_group && ext4_has_group_desc_csum(sb))\n\t\t/* We need to initialize block bitmap of last group. */\n\t\tflex_gd->bg_flags[i - 1] &= ~EXT4_BG_BLOCK_UNINIT;\n\n\tif ((last_group == n_group) && (last != blocks_per_group - 1)) {\n\t\tgroup_data[i - 1].blocks_count = last + 1;\n\t\tgroup_data[i - 1].free_blocks_count -= blocks_per_group-\n\t\t\t\t\tlast - 1;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_flex_gd",
          "args": [
            "flexbg_size"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_flex_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "193-222",
          "snippet": "static struct ext4_new_flex_group_data *alloc_flex_gd(unsigned long flexbg_size)\n{\n\tstruct ext4_new_flex_group_data *flex_gd;\n\n\tflex_gd = kmalloc(sizeof(*flex_gd), GFP_NOFS);\n\tif (flex_gd == NULL)\n\t\tgoto out3;\n\n\tif (flexbg_size >= UINT_MAX / sizeof(struct ext4_new_flex_group_data))\n\t\tgoto out2;\n\tflex_gd->count = flexbg_size;\n\n\tflex_gd->groups = kmalloc(sizeof(struct ext4_new_group_data) *\n\t\t\t\t  flexbg_size, GFP_NOFS);\n\tif (flex_gd->groups == NULL)\n\t\tgoto out2;\n\n\tflex_gd->bg_flags = kmalloc(flexbg_size * sizeof(__u16), GFP_NOFS);\n\tif (flex_gd->bg_flags == NULL)\n\t\tgoto out1;\n\n\treturn flex_gd;\n\nout1:\n\tkfree(flex_gd->groups);\nout2:\n\tkfree(flex_gd);\nout3:\n\treturn NULL;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct ext4_new_flex_group_data *alloc_flex_gd(unsigned long flexbg_size)\n{\n\tstruct ext4_new_flex_group_data *flex_gd;\n\n\tflex_gd = kmalloc(sizeof(*flex_gd), GFP_NOFS);\n\tif (flex_gd == NULL)\n\t\tgoto out3;\n\n\tif (flexbg_size >= UINT_MAX / sizeof(struct ext4_new_flex_group_data))\n\t\tgoto out2;\n\tflex_gd->count = flexbg_size;\n\n\tflex_gd->groups = kmalloc(sizeof(struct ext4_new_group_data) *\n\t\t\t\t  flexbg_size, GFP_NOFS);\n\tif (flex_gd->groups == NULL)\n\t\tgoto out2;\n\n\tflex_gd->bg_flags = kmalloc(flexbg_size * sizeof(__u16), GFP_NOFS);\n\tif (flex_gd->bg_flags == NULL)\n\t\tgoto out1;\n\n\treturn flex_gd;\n\nout1:\n\tkfree(flex_gd->groups);\nout2:\n\tkfree(flex_gd);\nout3:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_alloc_groupinfo",
          "args": [
            "sb",
            "n_group + 1"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_alloc_groupinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2341-2368",
          "snippet": "int ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\tif (sbi->s_group_info) {\n\t\tmemcpy(new_groupinfo, sbi->s_group_info,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tsbi->s_group_info = new_groupinfo;\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\tif (sbi->s_group_info) {\n\t\tmemcpy(new_groupinfo, sbi->s_group_info,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tsbi->s_group_info = new_groupinfo;\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_alloc_flex_bg_array",
          "args": [
            "sb",
            "n_group + 1"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_flex_bg_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1926-1956",
          "snippet": "int ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups *new_groups;\n\tint size;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(size * sizeof(struct flex_groups));\n\tnew_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %d flex groups\",\n\t\t\t size / (int) sizeof(struct flex_groups));\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sbi->s_flex_groups) {\n\t\tmemcpy(new_groups, sbi->s_flex_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups)));\n\t\tkvfree(sbi->s_flex_groups);\n\t}\n\tsbi->s_flex_groups = new_groups;\n\tsbi->s_flex_groups_allocated = size / sizeof(struct flex_groups);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups *new_groups;\n\tint size;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(size * sizeof(struct flex_groups));\n\tnew_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %d flex groups\",\n\t\t\t size / (int) sizeof(struct flex_groups));\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sbi->s_flex_groups) {\n\t\tmemcpy(new_groups, sbi->s_flex_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups)));\n\t\tkvfree(sbi->s_flex_groups);\n\t}\n\tsbi->s_flex_groups = new_groups;\n\tsbi->s_flex_groups_allocated = size / sizeof(struct flex_groups);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_extend_no_check",
          "args": [
            "sb",
            "o_blocks_count",
            "add"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_extend_no_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1643-1691",
          "snippet": "static int ext4_group_extend_no_check(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t o_blocks_count, ext4_grpblk_t add)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext4_group_add_blocks().\n\t */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text4_warning(sb, \"error %d on journal start\", err);\n\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (err) {\n\t\text4_warning(sb, \"error %d on journal write access\", err);\n\t\tgoto errout;\n\t}\n\n\text4_blocks_count_set(es, o_blocks_count + add);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + add);\n\text4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\n\t/* We add the blocks to the bitmap and set the group need init bit */\n\terr = ext4_group_add_blocks(handle, sb, o_blocks_count, add);\n\tif (err)\n\t\tgoto errout;\n\text4_handle_dirty_super(handle, sb);\n\text4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\nerrout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\", ext4_blocks_count(es));\n\t\tupdate_backups(sb, EXT4_SB(sb)->s_sbh->b_blocknr,\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_group_extend_no_check(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t o_blocks_count, ext4_grpblk_t add)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext4_group_add_blocks().\n\t */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text4_warning(sb, \"error %d on journal start\", err);\n\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (err) {\n\t\text4_warning(sb, \"error %d on journal write access\", err);\n\t\tgoto errout;\n\t}\n\n\text4_blocks_count_set(es, o_blocks_count + add);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + add);\n\text4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\n\t/* We add the blocks to the bitmap and set the group need init bit */\n\terr = ext4_group_add_blocks(handle, sb, o_blocks_count, add);\n\tif (err)\n\t\tgoto errout;\n\text4_handle_dirty_super(handle, sb);\n\text4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\nerrout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\", ext4_blocks_count(es));\n\t\tupdate_backups(sb, EXT4_SB(sb)->s_sbh->b_blocknr,\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_convert_meta_bg",
          "args": [
            "sb",
            "resize_inode"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_convert_meta_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1782-1858",
          "snippet": "static int ext4_convert_meta_bg(struct super_block *sb, struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_fsblk_t nr;\n\tint i, ret, err = 0;\n\tint credits = 1;\n\n\text4_msg(sb, KERN_INFO, \"Converting file system to meta_bg\");\n\tif (inode) {\n\t\tif (es->s_reserved_gdt_blocks) {\n\t\t\text4_error(sb, \"Unexpected non-zero \"\n\t\t\t\t   \"s_reserved_gdt_blocks\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Do a quick sanity check of the resize inode */\n\t\tif (inode->i_blocks != 1 << (inode->i_blkbits - 9))\n\t\t\tgoto invalid_resize_inode;\n\t\tfor (i = 0; i < EXT4_N_BLOCKS; i++) {\n\t\t\tif (i == EXT4_DIND_BLOCK) {\n\t\t\t\tif (ei->i_data[i])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tgoto invalid_resize_inode;\n\t\t\t}\n\t\t\tif (ei->i_data[i])\n\t\t\t\tgoto invalid_resize_inode;\n\t\t}\n\t\tcredits += 3;\t/* block bitmap, bg descriptor, resize inode */\n\t}\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto errout;\n\n\tEXT4_CLEAR_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_RESIZE_INODE);\n\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\tsbi->s_es->s_first_meta_bg =\n\t\tcpu_to_le32(num_desc_blocks(sb, sbi->s_groups_count));\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\n\tif (inode) {\n\t\tnr = le32_to_cpu(ei->i_data[EXT4_DIND_BLOCK]);\n\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\tei->i_data[EXT4_DIND_BLOCK] = 0;\n\t\tinode->i_blocks = 0;\n\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (err)\n\t\t\text4_std_error(sb, err);\n\t}\n\nerrout:\n\tret = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = ret;\n\treturn ret;\n\ninvalid_resize_inode:\n\text4_error(sb, \"corrupted/inconsistent resize inode\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_convert_meta_bg(struct super_block *sb, struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_fsblk_t nr;\n\tint i, ret, err = 0;\n\tint credits = 1;\n\n\text4_msg(sb, KERN_INFO, \"Converting file system to meta_bg\");\n\tif (inode) {\n\t\tif (es->s_reserved_gdt_blocks) {\n\t\t\text4_error(sb, \"Unexpected non-zero \"\n\t\t\t\t   \"s_reserved_gdt_blocks\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Do a quick sanity check of the resize inode */\n\t\tif (inode->i_blocks != 1 << (inode->i_blkbits - 9))\n\t\t\tgoto invalid_resize_inode;\n\t\tfor (i = 0; i < EXT4_N_BLOCKS; i++) {\n\t\t\tif (i == EXT4_DIND_BLOCK) {\n\t\t\t\tif (ei->i_data[i])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tgoto invalid_resize_inode;\n\t\t\t}\n\t\t\tif (ei->i_data[i])\n\t\t\t\tgoto invalid_resize_inode;\n\t\t}\n\t\tcredits += 3;\t/* block bitmap, bg descriptor, resize inode */\n\t}\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto errout;\n\n\tEXT4_CLEAR_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_RESIZE_INODE);\n\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\tsbi->s_es->s_first_meta_bg =\n\t\tcpu_to_le32(num_desc_blocks(sb, sbi->s_groups_count));\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\n\tif (inode) {\n\t\tnr = le32_to_cpu(ei->i_data[EXT4_DIND_BLOCK]);\n\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\tei->i_data[EXT4_DIND_BLOCK] = 0;\n\t\tinode->i_blocks = 0;\n\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (err)\n\t\t\text4_std_error(sb, err);\n\t}\n\nerrout:\n\tret = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = ret;\n\treturn ret;\n\ninvalid_resize_inode:\n\text4_error(sb, \"corrupted/inconsistent resize inode\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "resize_inode"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Error opening resize inode\""
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "resize_inode"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget",
          "args": [
            "sb",
            "EXT4_RESIZE_INO"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_reserved_gdt_blocks"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"resize_inode and meta_bg enabled \"\n\t\t\t\t   \"simultaneously\""
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_RESIZE_INODE"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_desc_blocks",
          "args": [
            "sb",
            "sbi->s_groups_count"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "num_desc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1772-1775",
          "snippet": "static int num_desc_blocks(struct super_block *sb, ext4_group_t groups)\n{\n\treturn (groups + EXT4_DESC_PER_BLOCK(sb) - 1) / EXT4_DESC_PER_BLOCK(sb);\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int num_desc_blocks(struct super_block *sb, ext4_group_t groups)\n{\n\treturn (groups + EXT4_DESC_PER_BLOCK(sb) - 1) / EXT4_DESC_PER_BLOCK(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "o_blocks_count - 1",
            "&o_group",
            "&offset"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"resize would cause inodes_count overflow\""
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_number",
          "args": [
            "sb",
            "n_blocks_count - 1"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "35-47",
          "snippet": "ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"can't shrink FS - resize aborted\""
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"can't read last block, resize aborted\""
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "n_blocks_count - 1"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count)\n{\n\tstruct ext4_new_flex_group_data *flex_gd = NULL;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *bh;\n\tstruct inode *resize_inode = NULL;\n\text4_grpblk_t add, offset;\n\tunsigned long n_desc_blocks;\n\tunsigned long o_desc_blocks;\n\text4_group_t o_group;\n\text4_group_t n_group;\n\text4_fsblk_t o_blocks_count;\n\text4_fsblk_t n_blocks_count_retry = 0;\n\tunsigned long last_update_time = 0;\n\tint err = 0, flexbg_size = 1 << sbi->s_log_groups_per_flex;\n\tint meta_bg;\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, n_blocks_count - 1);\n\tif (!bh) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\nretry:\n\to_blocks_count = ext4_blocks_count(es);\n\n\text4_msg(sb, KERN_INFO, \"resizing filesystem from %llu \"\n\t\t \"to %llu blocks\", o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\t/* On-line shrinking not supported */\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count == o_blocks_count)\n\t\t/* Nothing need to do */\n\t\treturn 0;\n\n\tn_group = ext4_get_group_number(sb, n_blocks_count - 1);\n\tif (n_group > (0xFFFFFFFFUL / EXT4_INODES_PER_GROUP(sb))) {\n\t\text4_warning(sb, \"resize would cause inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\text4_get_group_no_and_offset(sb, o_blocks_count - 1, &o_group, &offset);\n\n\tn_desc_blocks = num_desc_blocks(sb, n_group + 1);\n\to_desc_blocks = num_desc_blocks(sb, sbi->s_groups_count);\n\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_RESIZE_INODE)) {\n\t\tif (meta_bg) {\n\t\t\text4_error(sb, \"resize_inode and meta_bg enabled \"\n\t\t\t\t   \"simultaneously\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n_desc_blocks > o_desc_blocks +\n\t\t    le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\tn_blocks_count_retry = n_blocks_count;\n\t\t\tn_desc_blocks = o_desc_blocks +\n\t\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks);\n\t\t\tn_group = n_desc_blocks * EXT4_DESC_PER_BLOCK(sb);\n\t\t\tn_blocks_count = n_group * EXT4_BLOCKS_PER_GROUP(sb);\n\t\t\tn_group--; /* set to last group number */\n\t\t}\n\n\t\tif (!resize_inode)\n\t\t\tresize_inode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(resize_inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(resize_inode);\n\t\t}\n\t}\n\n\tif ((!resize_inode && !meta_bg) || n_blocks_count == o_blocks_count) {\n\t\terr = ext4_convert_meta_bg(sb, resize_inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tif (n_blocks_count_retry) {\n\t\t\tn_blocks_count = n_blocks_count_retry;\n\t\t\tn_blocks_count_retry = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/* extend the last group */\n\tif (n_group == o_group)\n\t\tadd = n_blocks_count - o_blocks_count;\n\telse\n\t\tadd = EXT4_BLOCKS_PER_GROUP(sb) - (offset + 1);\n\tif (add > 0) {\n\t\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (ext4_blocks_count(es) == n_blocks_count)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, n_group + 1);\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_mb_alloc_groupinfo(sb, n_group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd = alloc_flex_gd(flexbg_size);\n\tif (flex_gd == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Add flex groups. Note that a regular group is a\n\t * flex group with 1 group.\n\t */\n\twhile (ext4_setup_next_flex_gd(sb, flex_gd, n_blocks_count,\n\t\t\t\t\t      flexbg_size)) {\n\t\tif (jiffies - last_update_time > HZ * 10) {\n\t\t\tif (last_update_time)\n\t\t\t\text4_msg(sb, KERN_INFO,\n\t\t\t\t\t \"resized to %llu blocks\",\n\t\t\t\t\t ext4_blocks_count(es));\n\t\t\tlast_update_time = jiffies;\n\t\t}\n\t\tif (ext4_alloc_group_tables(sb, flex_gd, flexbg_size) != 0)\n\t\t\tbreak;\n\t\terr = ext4_flex_group_add(sb, resize_inode, flex_gd);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\n\tif (!err && n_blocks_count_retry) {\n\t\tn_blocks_count = n_blocks_count_retry;\n\t\tn_blocks_count_retry = 0;\n\t\tfree_flex_gd(flex_gd);\n\t\tflex_gd = NULL;\n\t\tgoto retry;\n\t}\n\nout:\n\tif (flex_gd)\n\t\tfree_flex_gd(flex_gd);\n\tif (resize_inode != NULL)\n\t\tiput(resize_inode);\n\text4_msg(sb, KERN_INFO, \"resized filesystem to %llu\", n_blocks_count);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_convert_meta_bg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1782-1858",
    "snippet": "static int ext4_convert_meta_bg(struct super_block *sb, struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_fsblk_t nr;\n\tint i, ret, err = 0;\n\tint credits = 1;\n\n\text4_msg(sb, KERN_INFO, \"Converting file system to meta_bg\");\n\tif (inode) {\n\t\tif (es->s_reserved_gdt_blocks) {\n\t\t\text4_error(sb, \"Unexpected non-zero \"\n\t\t\t\t   \"s_reserved_gdt_blocks\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Do a quick sanity check of the resize inode */\n\t\tif (inode->i_blocks != 1 << (inode->i_blkbits - 9))\n\t\t\tgoto invalid_resize_inode;\n\t\tfor (i = 0; i < EXT4_N_BLOCKS; i++) {\n\t\t\tif (i == EXT4_DIND_BLOCK) {\n\t\t\t\tif (ei->i_data[i])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tgoto invalid_resize_inode;\n\t\t\t}\n\t\t\tif (ei->i_data[i])\n\t\t\t\tgoto invalid_resize_inode;\n\t\t}\n\t\tcredits += 3;\t/* block bitmap, bg descriptor, resize inode */\n\t}\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto errout;\n\n\tEXT4_CLEAR_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_RESIZE_INODE);\n\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\tsbi->s_es->s_first_meta_bg =\n\t\tcpu_to_le32(num_desc_blocks(sb, sbi->s_groups_count));\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\n\tif (inode) {\n\t\tnr = le32_to_cpu(ei->i_data[EXT4_DIND_BLOCK]);\n\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\tei->i_data[EXT4_DIND_BLOCK] = 0;\n\t\tinode->i_blocks = 0;\n\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (err)\n\t\t\text4_std_error(sb, err);\n\t}\n\nerrout:\n\tret = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = ret;\n\treturn ret;\n\ninvalid_resize_inode:\n\text4_error(sb, \"corrupted/inconsistent resize inode\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"corrupted/inconsistent resize inode\""
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "NULL",
            "nr",
            "1",
            "EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ei->i_data[EXT4_DIND_BLOCK]"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "sb"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "num_desc_blocks(sb, sbi->s_groups_count)"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_desc_blocks",
          "args": [
            "sb",
            "sbi->s_groups_count"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "num_desc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1772-1775",
          "snippet": "static int num_desc_blocks(struct super_block *sb, ext4_group_t groups)\n{\n\treturn (groups + EXT4_DESC_PER_BLOCK(sb) - 1) / EXT4_DESC_PER_BLOCK(sb);\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int num_desc_blocks(struct super_block *sb, ext4_group_t groups)\n{\n\treturn (groups + EXT4_DESC_PER_BLOCK(sb) - 1) / EXT4_DESC_PER_BLOCK(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SET_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLEAR_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_RESIZE_INODE"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbi->s_sbh",
            "\"get_write_access\""
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start_sb",
          "args": [
            "sb",
            "EXT4_HT_RESIZE",
            "credits"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Unexpected non-zero \"\n\t\t\t\t   \"s_reserved_gdt_blocks\""
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"Converting file system to meta_bg\""
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_convert_meta_bg(struct super_block *sb, struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_fsblk_t nr;\n\tint i, ret, err = 0;\n\tint credits = 1;\n\n\text4_msg(sb, KERN_INFO, \"Converting file system to meta_bg\");\n\tif (inode) {\n\t\tif (es->s_reserved_gdt_blocks) {\n\t\t\text4_error(sb, \"Unexpected non-zero \"\n\t\t\t\t   \"s_reserved_gdt_blocks\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Do a quick sanity check of the resize inode */\n\t\tif (inode->i_blocks != 1 << (inode->i_blkbits - 9))\n\t\t\tgoto invalid_resize_inode;\n\t\tfor (i = 0; i < EXT4_N_BLOCKS; i++) {\n\t\t\tif (i == EXT4_DIND_BLOCK) {\n\t\t\t\tif (ei->i_data[i])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tgoto invalid_resize_inode;\n\t\t\t}\n\t\t\tif (ei->i_data[i])\n\t\t\t\tgoto invalid_resize_inode;\n\t\t}\n\t\tcredits += 3;\t/* block bitmap, bg descriptor, resize inode */\n\t}\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto errout;\n\n\tEXT4_CLEAR_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_RESIZE_INODE);\n\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\tsbi->s_es->s_first_meta_bg =\n\t\tcpu_to_le32(num_desc_blocks(sb, sbi->s_groups_count));\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\n\tif (inode) {\n\t\tnr = le32_to_cpu(ei->i_data[EXT4_DIND_BLOCK]);\n\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\tei->i_data[EXT4_DIND_BLOCK] = 0;\n\t\tinode->i_blocks = 0;\n\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (err)\n\t\t\text4_std_error(sb, err);\n\t}\n\nerrout:\n\tret = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = ret;\n\treturn ret;\n\ninvalid_resize_inode:\n\text4_error(sb, \"corrupted/inconsistent resize inode\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "num_desc_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1772-1775",
    "snippet": "static int num_desc_blocks(struct super_block *sb, ext4_group_t groups)\n{\n\treturn (groups + EXT4_DESC_PER_BLOCK(sb) - 1) / EXT4_DESC_PER_BLOCK(sb);\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int num_desc_blocks(struct super_block *sb, ext4_group_t groups)\n{\n\treturn (groups + EXT4_DESC_PER_BLOCK(sb) - 1) / EXT4_DESC_PER_BLOCK(sb);\n}"
  },
  {
    "function_name": "ext4_group_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1703-1769",
    "snippet": "int ext4_group_extend(struct super_block *sb, struct ext4_super_block *es,\n\t\t      ext4_fsblk_t n_blocks_count)\n{\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_grpblk_t add;\n\tstruct buffer_head *bh;\n\tint err;\n\text4_group_t group;\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (test_opt(sb, DEBUG))\n\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t \"extending last group from %llu to %llu blocks\",\n\t\t\t o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"filesystem too large to resize to %llu blocks safely\",\n\t\t\t n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_warning(sb, \"CONFIG_LBDAF not enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\n\tif (last == 0) {\n\t\text4_warning(sb, \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT4_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text4_warning(sb, \"will only finish group (%llu blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add - 1);\n\tif (!bh) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_group_extend_no_check",
          "args": [
            "sb",
            "o_blocks_count",
            "add"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_extend_no_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1643-1691",
          "snippet": "static int ext4_group_extend_no_check(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t o_blocks_count, ext4_grpblk_t add)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext4_group_add_blocks().\n\t */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text4_warning(sb, \"error %d on journal start\", err);\n\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (err) {\n\t\text4_warning(sb, \"error %d on journal write access\", err);\n\t\tgoto errout;\n\t}\n\n\text4_blocks_count_set(es, o_blocks_count + add);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + add);\n\text4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\n\t/* We add the blocks to the bitmap and set the group need init bit */\n\terr = ext4_group_add_blocks(handle, sb, o_blocks_count, add);\n\tif (err)\n\t\tgoto errout;\n\text4_handle_dirty_super(handle, sb);\n\text4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\nerrout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\", ext4_blocks_count(es));\n\t\tupdate_backups(sb, EXT4_SB(sb)->s_sbh->b_blocknr,\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_group_extend_no_check(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t o_blocks_count, ext4_grpblk_t add)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext4_group_add_blocks().\n\t */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text4_warning(sb, \"error %d on journal start\", err);\n\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (err) {\n\t\text4_warning(sb, \"error %d on journal write access\", err);\n\t\tgoto errout;\n\t}\n\n\text4_blocks_count_set(es, o_blocks_count + add);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + add);\n\text4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\n\t/* We add the blocks to the bitmap and set the group need init bit */\n\terr = ext4_group_add_blocks(handle, sb, o_blocks_count, add);\n\tif (err)\n\t\tgoto errout;\n\text4_handle_dirty_super(handle, sb);\n\text4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\nerrout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\", ext4_blocks_count(es));\n\t\tupdate_backups(sb, EXT4_SB(sb)->s_sbh->b_blocknr,\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"can't read last block, resize aborted\""
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "o_blocks_count + add - 1"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"will only finish group (%llu blocks, %u new)\"",
            "o_blocks_count + add",
            "add"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"blocks_count overflow\""
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"need to use ext2online to resize further\""
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "o_blocks_count",
            "&group",
            "&last"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"can't shrink FS - resize aborted\""
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"CONFIG_LBDAF not enabled\""
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"filesystem too large to resize to %llu blocks safely\"",
            "n_blocks_count"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "~0ULL"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint ext4_group_extend(struct super_block *sb, struct ext4_super_block *es,\n\t\t      ext4_fsblk_t n_blocks_count)\n{\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_grpblk_t add;\n\tstruct buffer_head *bh;\n\tint err;\n\text4_group_t group;\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (test_opt(sb, DEBUG))\n\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t \"extending last group from %llu to %llu blocks\",\n\t\t\t o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"filesystem too large to resize to %llu blocks safely\",\n\t\t\t n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_warning(sb, \"CONFIG_LBDAF not enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\n\tif (last == 0) {\n\t\text4_warning(sb, \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT4_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text4_warning(sb, \"will only finish group (%llu blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add - 1);\n\tif (!bh) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_group_extend_no_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1643-1691",
    "snippet": "static int ext4_group_extend_no_check(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t o_blocks_count, ext4_grpblk_t add)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext4_group_add_blocks().\n\t */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text4_warning(sb, \"error %d on journal start\", err);\n\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (err) {\n\t\text4_warning(sb, \"error %d on journal write access\", err);\n\t\tgoto errout;\n\t}\n\n\text4_blocks_count_set(es, o_blocks_count + add);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + add);\n\text4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\n\t/* We add the blocks to the bitmap and set the group need init bit */\n\terr = ext4_group_add_blocks(handle, sb, o_blocks_count, add);\n\tif (err)\n\t\tgoto errout;\n\text4_handle_dirty_super(handle, sb);\n\text4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\nerrout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\", ext4_blocks_count(es));\n\t\tupdate_backups(sb, EXT4_SB(sb)->s_sbh->b_blocknr,\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_backups",
          "args": [
            "sb",
            "EXT4_SB(sb)->s_sbh->b_blocknr",
            "(char *)es",
            "sizeof(struct ext4_super_block)",
            "0"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "update_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1043-1139",
          "snippet": "static void update_backups(struct super_block *sb, int blk_off, char *data,\n\t\t\t   int size, int meta_bg)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t last;\n\tconst int bpg = EXT4_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\text4_group_t group = 0;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\tif (meta_bg == 0) {\n\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\tlast = sbi->s_groups_count;\n\t} else {\n\t\tgroup = ext4_meta_bg_first_group(sb, group) + 1;\n\t\tlast = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);\n\t}\n\n\twhile (group < sbi->s_groups_count) {\n\t\tstruct buffer_head *bh;\n\t\text4_fsblk_t backup_block;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (ext4_handle_valid(handle) &&\n\t\t    handle->h_buffer_credits == 0 &&\n\t\t    ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA) &&\n\t\t    (err = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tif (meta_bg == 0)\n\t\t\tbackup_block = ((ext4_fsblk_t)group) * bpg + blk_off;\n\t\telse\n\t\t\tbackup_block = (ext4_group_first_block_no(sb, group) +\n\t\t\t\t\text4_bg_has_super(sb, group));\n\n\t\tbh = sb_getblk(sb, backup_block);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text4_debug(\"update metadata backup %llu(+%llu)\\n\",\n\t\t\t   backup_block, backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group));\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, bh)))\n\t\t\tbreak;\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\text4_std_error(sb, err);\n\t\tbrelse(bh);\n\n\t\tif (meta_bg == 0)\n\t\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\telse if (group == last)\n\t\t\tbreak;\n\t\telse\n\t\t\tgroup = last;\n\t}\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text4_warning(sb, \"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT4_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic void update_backups(struct super_block *sb, int blk_off, char *data,\n\t\t\t   int size, int meta_bg)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t last;\n\tconst int bpg = EXT4_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\text4_group_t group = 0;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\tif (meta_bg == 0) {\n\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\tlast = sbi->s_groups_count;\n\t} else {\n\t\tgroup = ext4_meta_bg_first_group(sb, group) + 1;\n\t\tlast = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);\n\t}\n\n\twhile (group < sbi->s_groups_count) {\n\t\tstruct buffer_head *bh;\n\t\text4_fsblk_t backup_block;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (ext4_handle_valid(handle) &&\n\t\t    handle->h_buffer_credits == 0 &&\n\t\t    ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA) &&\n\t\t    (err = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tif (meta_bg == 0)\n\t\t\tbackup_block = ((ext4_fsblk_t)group) * bpg + blk_off;\n\t\telse\n\t\t\tbackup_block = (ext4_group_first_block_no(sb, group) +\n\t\t\t\t\text4_bg_has_super(sb, group));\n\n\t\tbh = sb_getblk(sb, backup_block);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text4_debug(\"update metadata backup %llu(+%llu)\\n\",\n\t\t\t   backup_block, backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group));\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, bh)))\n\t\t\tbreak;\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\text4_std_error(sb, err);\n\t\tbrelse(bh);\n\n\t\tif (meta_bg == 0)\n\t\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\telse if (group == last)\n\t\t\tbreak;\n\t\telse\n\t\t\tgroup = last;\n\t}\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text4_warning(sb, \"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT4_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\"",
            "ext4_blocks_count(es)"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"freed blocks %llu through %llu\\n\"",
            "o_blocks_count",
            "o_blocks_count + add"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "sb"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_add_blocks",
          "args": [
            "handle",
            "sb",
            "o_blocks_count",
            "add"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_add_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4892-5015",
          "snippet": "int ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t ext4_fsblk_t block, unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\text4_grpblk_t bit;\n\tunsigned int i;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_buddy e4b;\n\tint err = 0, ret, blk_free_count;\n\text4_grpblk_t blocks_freed;\n\n\text4_debug(\"Adding block(s) %llu-%llu\\n\", block, block + count - 1);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\text4_warning(sb, \"too much blocks added to group %u\\n\",\n\t\t\t     block_group);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tdesc = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!desc) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, desc), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, desc), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, desc), sbi->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, desc),\n\t\t     sbi->s_itb_per_group)) {\n\t\text4_error(sb, \"Adding blocks in system zones - \"\n\t\t\t   \"Block = %llu, count = %lu\",\n\t\t\t   block, count);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tfor (i = 0, blocks_freed = 0; i < count; i++) {\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!mb_test_bit(bit + i, bitmap_bh->b_data)) {\n\t\t\text4_error(sb, \"bit already cleared for block %llu\",\n\t\t\t\t   (ext4_fsblk_t)(block + i));\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tblocks_freed++;\n\t\t}\n\t}\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * need to update group_info->bb_free and bitmap\n\t * with group lock held. generate_buddy look at\n\t * them with group lock_held\n\t */\n\text4_lock_group(sb, block_group);\n\tmb_clear_bits(bitmap_bh->b_data, bit, count);\n\tmb_free_blocks(NULL, &e4b, bit, count);\n\tblk_free_count = blocks_freed + ext4_free_group_clusters(sb, desc);\n\text4_free_group_clusters_set(sb, desc, blk_free_count);\n\text4_block_bitmap_csum_set(sb, block_group, desc, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, desc);\n\text4_unlock_group(sb, block_group);\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, blocks_freed));\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, blocks_freed),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t ext4_fsblk_t block, unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\text4_grpblk_t bit;\n\tunsigned int i;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_buddy e4b;\n\tint err = 0, ret, blk_free_count;\n\text4_grpblk_t blocks_freed;\n\n\text4_debug(\"Adding block(s) %llu-%llu\\n\", block, block + count - 1);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\text4_warning(sb, \"too much blocks added to group %u\\n\",\n\t\t\t     block_group);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tdesc = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!desc) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, desc), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, desc), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, desc), sbi->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, desc),\n\t\t     sbi->s_itb_per_group)) {\n\t\text4_error(sb, \"Adding blocks in system zones - \"\n\t\t\t   \"Block = %llu, count = %lu\",\n\t\t\t   block, count);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tfor (i = 0, blocks_freed = 0; i < count; i++) {\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!mb_test_bit(bit + i, bitmap_bh->b_data)) {\n\t\t\text4_error(sb, \"bit already cleared for block %llu\",\n\t\t\t\t   (ext4_fsblk_t)(block + i));\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tblocks_freed++;\n\t\t}\n\t}\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * need to update group_info->bb_free and bitmap\n\t * with group lock held. generate_buddy look at\n\t * them with group lock_held\n\t */\n\text4_lock_group(sb, block_group);\n\tmb_clear_bits(bitmap_bh->b_data, bit, count);\n\tmb_free_blocks(NULL, &e4b, bit, count);\n\tblk_free_count = blocks_freed + ext4_free_group_clusters(sb, desc);\n\text4_free_group_clusters_set(sb, desc, blk_free_count);\n\text4_block_bitmap_csum_set(sb, block_group, desc, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, desc);\n\text4_unlock_group(sb, block_group);\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, blocks_freed));\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, blocks_freed),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"freeing blocks %llu through %llu\\n\"",
            "o_blocks_count",
            "o_blocks_count + add"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count_set",
          "args": [
            "es",
            "ext4_free_blocks_count(es) + add"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count",
          "args": [
            "es"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count_set",
          "args": [
            "es",
            "o_blocks_count + add"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"error %d on journal write access\"",
            "err"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "EXT4_SB(sb)->s_sbh"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "EXT4_SB(sb)->s_sbh",
            "\"get_write_access\""
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"error %d on journal start\"",
            "err"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start_sb",
          "args": [
            "sb",
            "EXT4_HT_RESIZE",
            "3"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_group_extend_no_check(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t o_blocks_count, ext4_grpblk_t add)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext4_group_add_blocks().\n\t */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text4_warning(sb, \"error %d on journal start\", err);\n\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (err) {\n\t\text4_warning(sb, \"error %d on journal write access\", err);\n\t\tgoto errout;\n\t}\n\n\text4_blocks_count_set(es, o_blocks_count + add);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + add);\n\text4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\n\t/* We add the blocks to the bitmap and set the group need init bit */\n\terr = ext4_group_add_blocks(handle, sb, o_blocks_count, add);\n\tif (err)\n\t\tgoto errout;\n\text4_handle_dirty_super(handle, sb);\n\text4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\nerrout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\", ext4_blocks_count(es));\n\t\tupdate_backups(sb, EXT4_SB(sb)->s_sbh->b_blocknr,\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_group_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1571-1638",
    "snippet": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off;\n\tint err;\n\t__u16 bg_flags = 0;\n\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_mb_alloc_groupinfo(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_flex_group_add",
          "args": [
            "sb",
            "inode",
            "&flex_gd"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_flex_group_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1410-1495",
          "snippet": "static int ext4_flex_group_add(struct super_block *sb,\n\t\t\t       struct inode *resize_inode,\n\t\t\t       struct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_group_t group;\n\thandle_t *handle;\n\tunsigned reserved_gdb;\n\tint err = 0, err2 = 0, credit;\n\n\tBUG_ON(!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\to_blocks_count = ext4_blocks_count(es);\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\n\terr = setup_new_flex_group_blocks(sb, flex_gd);\n\tif (err)\n\t\tgoto exit;\n\t/*\n\t * We will always be modifying at least the superblock and  GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\tcredit = flex_gd->count * 4 + reserved_gdb;\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credit);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto exit_journal;\n\n\tgroup = flex_gd->groups[0].group;\n\tBUG_ON(group != EXT4_SB(sb)->s_groups_count);\n\terr = ext4_add_new_descs(handle, sb, group,\n\t\t\t\tresize_inode, flex_gd->count);\n\tif (err)\n\t\tgoto exit_journal;\n\n\terr = ext4_setup_new_descs(handle, sb, flex_gd);\n\tif (err)\n\t\tgoto exit_journal;\n\n\text4_update_super(sb, flex_gd);\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\nexit_journal:\n\terr2 = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tint gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\t\tint gdb_num_end = ((group + flex_gd->count - 1) /\n\t\t\t\t   EXT4_DESC_PER_BLOCK(sb));\n\t\tint meta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_INCOMPAT_META_BG);\n\t\tsector_t old_gdb = 0;\n\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block), 0);\n\t\tfor (; gdb_num <= gdb_num_end; gdb_num++) {\n\t\t\tstruct buffer_head *gdb_bh;\n\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tif (old_gdb == gdb_bh->b_blocknr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backups(sb, gdb_bh->b_blocknr, gdb_bh->b_data,\n\t\t\t\t       gdb_bh->b_size, meta_bg);\n\t\t\told_gdb = gdb_bh->b_blocknr;\n\t\t}\n\t}\nexit:\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_flex_group_add(struct super_block *sb,\n\t\t\t       struct inode *resize_inode,\n\t\t\t       struct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_group_t group;\n\thandle_t *handle;\n\tunsigned reserved_gdb;\n\tint err = 0, err2 = 0, credit;\n\n\tBUG_ON(!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\to_blocks_count = ext4_blocks_count(es);\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\n\terr = setup_new_flex_group_blocks(sb, flex_gd);\n\tif (err)\n\t\tgoto exit;\n\t/*\n\t * We will always be modifying at least the superblock and  GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\tcredit = flex_gd->count * 4 + reserved_gdb;\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credit);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto exit_journal;\n\n\tgroup = flex_gd->groups[0].group;\n\tBUG_ON(group != EXT4_SB(sb)->s_groups_count);\n\terr = ext4_add_new_descs(handle, sb, group,\n\t\t\t\tresize_inode, flex_gd->count);\n\tif (err)\n\t\tgoto exit_journal;\n\n\terr = ext4_setup_new_descs(handle, sb, flex_gd);\n\tif (err)\n\t\tgoto exit_journal;\n\n\text4_update_super(sb, flex_gd);\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\nexit_journal:\n\terr2 = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tint gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\t\tint gdb_num_end = ((group + flex_gd->count - 1) /\n\t\t\t\t   EXT4_DESC_PER_BLOCK(sb));\n\t\tint meta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_INCOMPAT_META_BG);\n\t\tsector_t old_gdb = 0;\n\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block), 0);\n\t\tfor (; gdb_num <= gdb_num_end; gdb_num++) {\n\t\t\tstruct buffer_head *gdb_bh;\n\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tif (old_gdb == gdb_bh->b_blocknr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backups(sb, gdb_bh->b_blocknr, gdb_bh->b_data,\n\t\t\t\t       gdb_bh->b_size, meta_bg);\n\t\t\told_gdb = gdb_bh->b_blocknr;\n\t\t}\n\t}\nexit:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_alloc_groupinfo",
          "args": [
            "sb",
            "input->group + 1"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_alloc_groupinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2341-2368",
          "snippet": "int ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\tif (sbi->s_group_info) {\n\t\tmemcpy(new_groupinfo, sbi->s_group_info,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tsbi->s_group_info = new_groupinfo;\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\tif (sbi->s_group_info) {\n\t\tmemcpy(new_groupinfo, sbi->s_group_info,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tsbi->s_group_info = new_groupinfo;\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_alloc_flex_bg_array",
          "args": [
            "sb",
            "input->group + 1"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_flex_bg_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "1926-1956",
          "snippet": "int ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups *new_groups;\n\tint size;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(size * sizeof(struct flex_groups));\n\tnew_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %d flex groups\",\n\t\t\t size / (int) sizeof(struct flex_groups));\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sbi->s_flex_groups) {\n\t\tmemcpy(new_groups, sbi->s_flex_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups)));\n\t\tkvfree(sbi->s_flex_groups);\n\t}\n\tsbi->s_flex_groups = new_groups;\n\tsbi->s_flex_groups_allocated = size / sizeof(struct flex_groups);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups *new_groups;\n\tint size;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(size * sizeof(struct flex_groups));\n\tnew_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %d flex groups\",\n\t\t\t size / (int) sizeof(struct flex_groups));\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sbi->s_flex_groups) {\n\t\tmemcpy(new_groups, sbi->s_flex_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups)));\n\t\tkvfree(sbi->s_flex_groups);\n\t}\n\tsbi->s_flex_groups = new_groups;\n\tsbi->s_flex_groups_allocated = size / sizeof(struct flex_groups);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_group_input",
          "args": [
            "sb",
            "input"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "verify_group_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "85-172",
          "snippet": "static int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t start = ext4_blocks_count(es);\n\text4_fsblk_t end = start + input->blocks_count;\n\text4_group_t group = input->group;\n\text4_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead;\n\text4_fsblk_t metaend;\n\tstruct buffer_head *bh = NULL;\n\text4_grpblk_t free_blocks_count, offset;\n\tint err = -EINVAL;\n\n\tif (group != sbi->s_groups_count) {\n\t\text4_warning(sb, \"Cannot add at group %u (only %u groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\t\treturn -EINVAL;\n\t}\n\n\toverhead = ext4_group_overhead_blocks(sb, group);\n\tmetaend = start + overhead;\n\tinput->free_blocks_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext4_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\text4_get_group_no_and_offset(sb, start, NULL, &offset);\n\tif (offset != 0)\n\t\t\text4_warning(sb, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text4_warning(sb, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text4_warning(sb, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (!(bh = sb_bread(sb, end - 1)))\n\t\text4_warning(sb, \"Cannot read last block (%llu)\",\n\t\t\t     end - 1);\n\telse if (outside(input->block_bitmap, start, end))\n\t\text4_warning(sb, \"Block bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text4_warning(sb, \"Inode bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t\t outside(itend - 1, start, end))\n\t\text4_warning(sb, \"Inode table not in group (blocks %llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text4_warning(sb, \"Block bitmap same as inode bitmap (%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t\t inside(itend - 1, start, metaend))\n\t\text4_warning(sb, \"Inode table (%llu-%llu) overlaps GDT table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table,\n\t\t\t     itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t start = ext4_blocks_count(es);\n\text4_fsblk_t end = start + input->blocks_count;\n\text4_group_t group = input->group;\n\text4_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead;\n\text4_fsblk_t metaend;\n\tstruct buffer_head *bh = NULL;\n\text4_grpblk_t free_blocks_count, offset;\n\tint err = -EINVAL;\n\n\tif (group != sbi->s_groups_count) {\n\t\text4_warning(sb, \"Cannot add at group %u (only %u groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\t\treturn -EINVAL;\n\t}\n\n\toverhead = ext4_group_overhead_blocks(sb, group);\n\tmetaend = start + overhead;\n\tinput->free_blocks_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext4_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\text4_get_group_no_and_offset(sb, start, NULL, &offset);\n\tif (offset != 0)\n\t\t\text4_warning(sb, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text4_warning(sb, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text4_warning(sb, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (!(bh = sb_bread(sb, end - 1)))\n\t\text4_warning(sb, \"Cannot read last block (%llu)\",\n\t\t\t     end - 1);\n\telse if (outside(input->block_bitmap, start, end))\n\t\text4_warning(sb, \"Block bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text4_warning(sb, \"Inode bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t\t outside(itend - 1, start, end))\n\t\text4_warning(sb, \"Inode table not in group (blocks %llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text4_warning(sb, \"Block bitmap same as inode bitmap (%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t\t inside(itend - 1, start, metaend))\n\t\text4_warning(sb, \"Inode table (%llu-%llu) overlaps GDT table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table,\n\t\t\t     itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Error opening resize inode\""
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget",
          "args": [
            "sb",
            "EXT4_RESIZE_INO"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"No reserved GDT blocks, can't resize\""
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_reserved_gdt_blocks"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_RESIZE_INODE"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"inodes_count overflow\""
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"blocks_count overflow\""
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Can't resize non-sparse filesystem further\""
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "input->group"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off;\n\tint err;\n\t__u16 bg_flags = 0;\n\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_mb_alloc_groupinfo(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_setup_next_flex_gd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1497-1556",
    "snippet": "static int ext4_setup_next_flex_gd(struct super_block *sb,\n\t\t\t\t    struct ext4_new_flex_group_data *flex_gd,\n\t\t\t\t    ext4_fsblk_t n_blocks_count,\n\t\t\t\t    unsigned long flexbg_size)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t o_blocks_count;\n\text4_group_t n_group;\n\text4_group_t group;\n\text4_group_t last_group;\n\text4_grpblk_t last;\n\text4_grpblk_t blocks_per_group;\n\tunsigned long i;\n\n\tblocks_per_group = EXT4_BLOCKS_PER_GROUP(sb);\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (o_blocks_count == n_blocks_count)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\text4_get_group_no_and_offset(sb, n_blocks_count - 1, &n_group, &last);\n\n\tlast_group = group | (flexbg_size - 1);\n\tif (last_group > n_group)\n\t\tlast_group = n_group;\n\n\tflex_gd->count = last_group - group + 1;\n\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tint overhead;\n\n\t\tgroup_data[i].group = group + i;\n\t\tgroup_data[i].blocks_count = blocks_per_group;\n\t\toverhead = ext4_group_overhead_blocks(sb, group + i);\n\t\tgroup_data[i].free_blocks_count = blocks_per_group - overhead;\n\t\tif (ext4_has_group_desc_csum(sb)) {\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_BLOCK_UNINIT |\n\t\t\t\t\t       EXT4_BG_INODE_UNINIT;\n\t\t\tif (!test_opt(sb, INIT_INODE_TABLE))\n\t\t\t\tflex_gd->bg_flags[i] |= EXT4_BG_INODE_ZEROED;\n\t\t} else\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_INODE_ZEROED;\n\t}\n\n\tif (last_group == n_group && ext4_has_group_desc_csum(sb))\n\t\t/* We need to initialize block bitmap of last group. */\n\t\tflex_gd->bg_flags[i - 1] &= ~EXT4_BG_BLOCK_UNINIT;\n\n\tif ((last_group == n_group) && (last != blocks_per_group - 1)) {\n\t\tgroup_data[i - 1].blocks_count = last + 1;\n\t\tgroup_data[i - 1].free_blocks_count -= blocks_per_group-\n\t\t\t\t\tlast - 1;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "sb"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "INIT_INODE_TABLE"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "sb"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_overhead_blocks",
          "args": [
            "sb",
            "group + i"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_overhead_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "72-80",
          "snippet": "static ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "n_blocks_count - 1",
            "&n_group",
            "&last"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_setup_next_flex_gd(struct super_block *sb,\n\t\t\t\t    struct ext4_new_flex_group_data *flex_gd,\n\t\t\t\t    ext4_fsblk_t n_blocks_count,\n\t\t\t\t    unsigned long flexbg_size)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t o_blocks_count;\n\text4_group_t n_group;\n\text4_group_t group;\n\text4_group_t last_group;\n\text4_grpblk_t last;\n\text4_grpblk_t blocks_per_group;\n\tunsigned long i;\n\n\tblocks_per_group = EXT4_BLOCKS_PER_GROUP(sb);\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (o_blocks_count == n_blocks_count)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\text4_get_group_no_and_offset(sb, n_blocks_count - 1, &n_group, &last);\n\n\tlast_group = group | (flexbg_size - 1);\n\tif (last_group > n_group)\n\t\tlast_group = n_group;\n\n\tflex_gd->count = last_group - group + 1;\n\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tint overhead;\n\n\t\tgroup_data[i].group = group + i;\n\t\tgroup_data[i].blocks_count = blocks_per_group;\n\t\toverhead = ext4_group_overhead_blocks(sb, group + i);\n\t\tgroup_data[i].free_blocks_count = blocks_per_group - overhead;\n\t\tif (ext4_has_group_desc_csum(sb)) {\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_BLOCK_UNINIT |\n\t\t\t\t\t       EXT4_BG_INODE_UNINIT;\n\t\t\tif (!test_opt(sb, INIT_INODE_TABLE))\n\t\t\t\tflex_gd->bg_flags[i] |= EXT4_BG_INODE_ZEROED;\n\t\t} else\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_INODE_ZEROED;\n\t}\n\n\tif (last_group == n_group && ext4_has_group_desc_csum(sb))\n\t\t/* We need to initialize block bitmap of last group. */\n\t\tflex_gd->bg_flags[i - 1] &= ~EXT4_BG_BLOCK_UNINIT;\n\n\tif ((last_group == n_group) && (last != blocks_per_group - 1)) {\n\t\tgroup_data[i - 1].blocks_count = last + 1;\n\t\tgroup_data[i - 1].free_blocks_count -= blocks_per_group-\n\t\t\t\t\tlast - 1;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_flex_group_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1410-1495",
    "snippet": "static int ext4_flex_group_add(struct super_block *sb,\n\t\t\t       struct inode *resize_inode,\n\t\t\t       struct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_group_t group;\n\thandle_t *handle;\n\tunsigned reserved_gdb;\n\tint err = 0, err2 = 0, credit;\n\n\tBUG_ON(!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\to_blocks_count = ext4_blocks_count(es);\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\n\terr = setup_new_flex_group_blocks(sb, flex_gd);\n\tif (err)\n\t\tgoto exit;\n\t/*\n\t * We will always be modifying at least the superblock and  GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\tcredit = flex_gd->count * 4 + reserved_gdb;\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credit);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto exit_journal;\n\n\tgroup = flex_gd->groups[0].group;\n\tBUG_ON(group != EXT4_SB(sb)->s_groups_count);\n\terr = ext4_add_new_descs(handle, sb, group,\n\t\t\t\tresize_inode, flex_gd->count);\n\tif (err)\n\t\tgoto exit_journal;\n\n\terr = ext4_setup_new_descs(handle, sb, flex_gd);\n\tif (err)\n\t\tgoto exit_journal;\n\n\text4_update_super(sb, flex_gd);\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\nexit_journal:\n\terr2 = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tint gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\t\tint gdb_num_end = ((group + flex_gd->count - 1) /\n\t\t\t\t   EXT4_DESC_PER_BLOCK(sb));\n\t\tint meta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_INCOMPAT_META_BG);\n\t\tsector_t old_gdb = 0;\n\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block), 0);\n\t\tfor (; gdb_num <= gdb_num_end; gdb_num++) {\n\t\t\tstruct buffer_head *gdb_bh;\n\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tif (old_gdb == gdb_bh->b_blocknr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backups(sb, gdb_bh->b_blocknr, gdb_bh->b_data,\n\t\t\t\t       gdb_bh->b_size, meta_bg);\n\t\t\told_gdb = gdb_bh->b_blocknr;\n\t\t}\n\t}\nexit:\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_backups",
          "args": [
            "sb",
            "gdb_bh->b_blocknr",
            "gdb_bh->b_data",
            "gdb_bh->b_size",
            "meta_bg"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "update_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1043-1139",
          "snippet": "static void update_backups(struct super_block *sb, int blk_off, char *data,\n\t\t\t   int size, int meta_bg)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t last;\n\tconst int bpg = EXT4_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\text4_group_t group = 0;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\tif (meta_bg == 0) {\n\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\tlast = sbi->s_groups_count;\n\t} else {\n\t\tgroup = ext4_meta_bg_first_group(sb, group) + 1;\n\t\tlast = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);\n\t}\n\n\twhile (group < sbi->s_groups_count) {\n\t\tstruct buffer_head *bh;\n\t\text4_fsblk_t backup_block;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (ext4_handle_valid(handle) &&\n\t\t    handle->h_buffer_credits == 0 &&\n\t\t    ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA) &&\n\t\t    (err = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tif (meta_bg == 0)\n\t\t\tbackup_block = ((ext4_fsblk_t)group) * bpg + blk_off;\n\t\telse\n\t\t\tbackup_block = (ext4_group_first_block_no(sb, group) +\n\t\t\t\t\text4_bg_has_super(sb, group));\n\n\t\tbh = sb_getblk(sb, backup_block);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text4_debug(\"update metadata backup %llu(+%llu)\\n\",\n\t\t\t   backup_block, backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group));\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, bh)))\n\t\t\tbreak;\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\text4_std_error(sb, err);\n\t\tbrelse(bh);\n\n\t\tif (meta_bg == 0)\n\t\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\telse if (group == last)\n\t\t\tbreak;\n\t\telse\n\t\t\tgroup = last;\n\t}\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text4_warning(sb, \"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT4_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic void update_backups(struct super_block *sb, int blk_off, char *data,\n\t\t\t   int size, int meta_bg)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t last;\n\tconst int bpg = EXT4_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\text4_group_t group = 0;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\tif (meta_bg == 0) {\n\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\tlast = sbi->s_groups_count;\n\t} else {\n\t\tgroup = ext4_meta_bg_first_group(sb, group) + 1;\n\t\tlast = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);\n\t}\n\n\twhile (group < sbi->s_groups_count) {\n\t\tstruct buffer_head *bh;\n\t\text4_fsblk_t backup_block;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (ext4_handle_valid(handle) &&\n\t\t    handle->h_buffer_credits == 0 &&\n\t\t    ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA) &&\n\t\t    (err = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tif (meta_bg == 0)\n\t\t\tbackup_block = ((ext4_fsblk_t)group) * bpg + blk_off;\n\t\telse\n\t\t\tbackup_block = (ext4_group_first_block_no(sb, group) +\n\t\t\t\t\text4_bg_has_super(sb, group));\n\n\t\tbh = sb_getblk(sb, backup_block);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text4_debug(\"update metadata backup %llu(+%llu)\\n\",\n\t\t\t   backup_block, backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group));\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, bh)))\n\t\t\tbreak;\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\text4_std_error(sb, err);\n\t\tbrelse(bh);\n\n\t\tif (meta_bg == 0)\n\t\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\telse if (group == last)\n\t\t\tbreak;\n\t\telse\n\t\t\tgroup = last;\n\t}\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text4_warning(sb, \"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT4_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "sb"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_super",
          "args": [
            "sb",
            "flex_gd"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1306-1404",
          "snippet": "static void ext4_update_super(struct super_block *sb,\n\t\t\t     struct ext4_new_flex_group_data *flex_gd)\n{\n\text4_fsblk_t blocks_count = 0;\n\text4_fsblk_t free_blocks = 0;\n\text4_fsblk_t reserved_blocks = 0;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tblocks_count += group_data[i].blocks_count;\n\t\tfree_blocks += group_data[i].free_blocks_count;\n\t}\n\n\treserved_blocks = ext4_r_blocks_count(es) * 100;\n\treserved_blocks = div64_u64(reserved_blocks, ext4_blocks_count(es));\n\treserved_blocks *= blocks_count;\n\tdo_div(reserved_blocks, 100);\n\n\text4_blocks_count_set(es, ext4_blocks_count(es) + blocks_count);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + free_blocks);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\tle32_add_cpu(&es->s_free_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\", ext4_free_blocks_count(es));\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers must perform a smp_wmb() after updating all\n\t *   dependent data and before modifying the groups count\n\t *\n\t * * Readers must perform an smp_rmb() after reading the groups\n\t *   count and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count += flex_gd->count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\t\t\treserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, free_blocks));\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb) * flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\",\n\t\t   percpu_counter_read(&sbi->s_freeclusters_counter));\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FLEX_BG) &&\n\t    sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group;\n\t\tflex_group = ext4_flex_group(sbi, group_data[0].group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, free_blocks),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(EXT4_INODES_PER_GROUP(sb) * flex_gd->count,\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t}\n\n\t/*\n\t * Update the fs overhead information\n\t */\n\text4_calculate_overhead(sb);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: added group %u:\"\n\t\t       \"%llu blocks(%llu free %llu reserved)\\n\", flex_gd->count,\n\t\t       blocks_count, free_blocks, reserved_blocks);\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic void ext4_update_super(struct super_block *sb,\n\t\t\t     struct ext4_new_flex_group_data *flex_gd)\n{\n\text4_fsblk_t blocks_count = 0;\n\text4_fsblk_t free_blocks = 0;\n\text4_fsblk_t reserved_blocks = 0;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tblocks_count += group_data[i].blocks_count;\n\t\tfree_blocks += group_data[i].free_blocks_count;\n\t}\n\n\treserved_blocks = ext4_r_blocks_count(es) * 100;\n\treserved_blocks = div64_u64(reserved_blocks, ext4_blocks_count(es));\n\treserved_blocks *= blocks_count;\n\tdo_div(reserved_blocks, 100);\n\n\text4_blocks_count_set(es, ext4_blocks_count(es) + blocks_count);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + free_blocks);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\tle32_add_cpu(&es->s_free_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\", ext4_free_blocks_count(es));\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers must perform a smp_wmb() after updating all\n\t *   dependent data and before modifying the groups count\n\t *\n\t * * Readers must perform an smp_rmb() after reading the groups\n\t *   count and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count += flex_gd->count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\t\t\treserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, free_blocks));\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb) * flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\",\n\t\t   percpu_counter_read(&sbi->s_freeclusters_counter));\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FLEX_BG) &&\n\t    sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group;\n\t\tflex_group = ext4_flex_group(sbi, group_data[0].group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, free_blocks),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(EXT4_INODES_PER_GROUP(sb) * flex_gd->count,\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t}\n\n\t/*\n\t * Update the fs overhead information\n\t */\n\text4_calculate_overhead(sb);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: added group %u:\"\n\t\t       \"%llu blocks(%llu free %llu reserved)\\n\", flex_gd->count,\n\t\t       blocks_count, free_blocks, reserved_blocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_setup_new_descs",
          "args": [
            "handle",
            "sb",
            "flex_gd"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_setup_new_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1237-1297",
          "snippet": "static int ext4_setup_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_new_group_data\t*group_data = flex_gd->groups;\n\tstruct ext4_group_desc\t\t*gdp;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tstruct buffer_head\t\t*gdb_bh;\n\text4_group_t\t\t\tgroup;\n\t__u16\t\t\t\t*bg_flags = flex_gd->bg_flags;\n\tint\t\t\t\ti, gdb_off, gdb_num, err = 0;\n\t\n\n\tfor (i = 0; i < flex_gd->count; i++, group_data++, bg_flags++) {\n\t\tgroup = group_data->group;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * get_write_access() has been called on gdb_bh by ext4_add_new_desc().\n\t\t */\n\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t/* Update group descriptor block for new group */\n\t\tgdp = (struct ext4_group_desc *)(gdb_bh->b_data +\n\t\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\t\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n\t\text4_block_bitmap_set(sb, gdp, group_data->block_bitmap);\n\t\text4_inode_bitmap_set(sb, gdp, group_data->inode_bitmap);\n\t\terr = ext4_set_bitmap_checksums(sb, group, gdp, group_data);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\text4_inode_table_set(sb, gdp, group_data->inode_table);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\tEXT4_NUM_B2C(sbi, group_data->free_blocks_count));\n\t\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t       EXT4_INODES_PER_GROUP(sb));\n\t\tgdp->bg_flags = cpu_to_le16(*bg_flags);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\t\tif (unlikely(err)) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We can allocate memory for mb_alloc based on the new group\n\t\t * descriptor\n\t\t */\n\t\terr = ext4_mb_add_groupinfo(sb, group, gdp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_setup_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_new_group_data\t*group_data = flex_gd->groups;\n\tstruct ext4_group_desc\t\t*gdp;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tstruct buffer_head\t\t*gdb_bh;\n\text4_group_t\t\t\tgroup;\n\t__u16\t\t\t\t*bg_flags = flex_gd->bg_flags;\n\tint\t\t\t\ti, gdb_off, gdb_num, err = 0;\n\t\n\n\tfor (i = 0; i < flex_gd->count; i++, group_data++, bg_flags++) {\n\t\tgroup = group_data->group;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * get_write_access() has been called on gdb_bh by ext4_add_new_desc().\n\t\t */\n\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t/* Update group descriptor block for new group */\n\t\tgdp = (struct ext4_group_desc *)(gdb_bh->b_data +\n\t\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\t\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n\t\text4_block_bitmap_set(sb, gdp, group_data->block_bitmap);\n\t\text4_inode_bitmap_set(sb, gdp, group_data->inode_bitmap);\n\t\terr = ext4_set_bitmap_checksums(sb, group, gdp, group_data);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\text4_inode_table_set(sb, gdp, group_data->inode_table);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\tEXT4_NUM_B2C(sbi, group_data->free_blocks_count));\n\t\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t       EXT4_INODES_PER_GROUP(sb));\n\t\tgdp->bg_flags = cpu_to_le16(*bg_flags);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\t\tif (unlikely(err)) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We can allocate memory for mb_alloc based on the new group\n\t\t * descriptor\n\t\t */\n\t\terr = ext4_mb_add_groupinfo(sb, group, gdp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_add_new_descs",
          "args": [
            "handle",
            "sb",
            "group",
            "resize_inode",
            "flex_gd->count"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_add_new_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1151-1191",
          "snippet": "static int ext4_add_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t      ext4_group_t group, struct inode *resize_inode,\n\t\t\t      ext4_group_t count)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *gdb_bh;\n\tint i, gdb_off, gdb_num, err = 0;\n\tint meta_bg;\n\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\tfor (i = 0; i < count; i++, group++) {\n\t\tint reserved_gdb = ext4_bg_has_super(sb, group) ?\n\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * We will only either add reserved group blocks to a backup group\n\t\t * or remove reserved blocks for the first group in a new group block.\n\t\t * Doing both would be mean more complex code, and sane people don't\n\t\t * use non-sparse filesystems anymore.  This is already checked above.\n\t\t */\n\t\tif (gdb_off) {\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\n\t\t\tif (!err && reserved_gdb && ext4_bg_num_gdb(sb, group))\n\t\t\t\terr = reserve_backup_gdb(handle, resize_inode, group);\n\t\t} else if (meta_bg != 0) {\n\t\t\terr = add_new_gdb_meta_bg(sb, handle, group);\n\t\t} else {\n\t\t\terr = add_new_gdb(handle, resize_inode, group);\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_add_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t      ext4_group_t group, struct inode *resize_inode,\n\t\t\t      ext4_group_t count)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *gdb_bh;\n\tint i, gdb_off, gdb_num, err = 0;\n\tint meta_bg;\n\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\tfor (i = 0; i < count; i++, group++) {\n\t\tint reserved_gdb = ext4_bg_has_super(sb, group) ?\n\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * We will only either add reserved group blocks to a backup group\n\t\t * or remove reserved blocks for the first group in a new group block.\n\t\t * Doing both would be mean more complex code, and sane people don't\n\t\t * use non-sparse filesystems anymore.  This is already checked above.\n\t\t */\n\t\tif (gdb_off) {\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\n\t\t\tif (!err && reserved_gdb && ext4_bg_num_gdb(sb, group))\n\t\t\t\terr = reserve_backup_gdb(handle, resize_inode, group);\n\t\t} else if (meta_bg != 0) {\n\t\t\terr = add_new_gdb_meta_bg(sb, handle, group);\n\t\t} else {\n\t\t\terr = add_new_gdb(handle, resize_inode, group);\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "group != EXT4_SB(sb)->s_groups_count"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "sbi->s_sbh",
            "\"get_write_access\""
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start_sb",
          "args": [
            "sb",
            "EXT4_HT_RESIZE",
            "credit"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_new_flex_group_blocks",
          "args": [
            "sb",
            "flex_gd"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_flex_group_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "473-667",
          "snippet": "static int setup_new_flex_group_blocks(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tint group_table_count[] = {1, 1, EXT4_SB(sb)->s_itb_per_group};\n\text4_fsblk_t start;\n\text4_fsblk_t block;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\t__u16 *bg_flags = flex_gd->bg_flags;\n\thandle_t *handle;\n\text4_group_t group, count;\n\tstruct buffer_head *bh = NULL;\n\tint reserved_gdb, i, j, err = 0, err2;\n\tint meta_bg;\n\n\tBUG_ON(!flex_gd->count || !group_data ||\n\t       group_data[0].group != sbi->s_groups_count);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tgroup = group_data[0].group;\n\tfor (i = 0; i < flex_gd->count; i++, group++) {\n\t\tunsigned long gdblocks;\n\t\text4_grpblk_t overhead;\n\n\t\tgdblocks = ext4_bg_num_gdb(sb, group);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\n\t\tif (meta_bg == 0 && !ext4_bg_has_super(sb, group))\n\t\t\tgoto handle_itb;\n\n\t\tif (meta_bg == 1) {\n\t\t\text4_group_t first_group;\n\t\t\tfirst_group = ext4_meta_bg_first_group(sb, group);\n\t\t\tif (first_group != group + 1 &&\n\t\t\t    first_group != group + EXT4_DESC_PER_BLOCK(sb) - 1)\n\t\t\t\tgoto handle_itb;\n\t\t}\n\n\t\tblock = start + ext4_bg_has_super(sb, group);\n\t\t/* Copy all of the GDT blocks into the backup in this group */\n\t\tfor (j = 0; j < gdblocks; j++, block++) {\n\t\t\tstruct buffer_head *gdb;\n\n\t\t\text4_debug(\"update backup group %#04llx\\n\", block);\n\t\t\terr = extend_or_restart_transaction(handle, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tgdb = sb_getblk(sb, block);\n\t\t\tif (unlikely(!gdb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUFFER_TRACE(gdb, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb);\n\t\t\tif (err) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gdb->b_data, sbi->s_group_desc[j]->b_data,\n\t\t\t       gdb->b_size);\n\t\t\tset_buffer_uptodate(gdb);\n\n\t\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbrelse(gdb);\n\t\t}\n\n\t\t/* Zero out all of the reserved backup group descriptor\n\t\t * table blocks\n\t\t */\n\t\tif (ext4_bg_has_super(sb, group)) {\n\t\t\terr = sb_issue_zeroout(sb, gdblocks + start + 1,\n\t\t\t\t\treserved_gdb, GFP_NOFS);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\nhandle_itb:\n\t\t/* Initialize group tables of the grop @group */\n\t\tif (!(bg_flags[i] & EXT4_BG_INODE_ZEROED))\n\t\t\tgoto handle_bb;\n\n\t\t/* Zero out all of the inode table blocks */\n\t\tblock = group_data[i].inode_table;\n\t\text4_debug(\"clear inode table blocks %#04llx -> %#04lx\\n\",\n\t\t\t   block, sbi->s_itb_per_group);\n\t\terr = sb_issue_zeroout(sb, block, sbi->s_itb_per_group,\n\t\t\t\t       GFP_NOFS);\n\t\tif (err)\n\t\t\tgoto out;\n\nhandle_bb:\n\t\tif (bg_flags[i] & EXT4_BG_BLOCK_UNINIT)\n\t\t\tgoto handle_ib;\n\n\t\t/* Initialize block bitmap of the @group */\n\t\tblock = group_data[i].block_bitmap;\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\toverhead = ext4_group_overhead_blocks(sb, group);\n\t\tif (overhead != 0) {\n\t\t\text4_debug(\"mark backup superblock %#04llx (+0)\\n\",\n\t\t\t\t   start);\n\t\t\text4_set_bits(bh->b_data, 0, overhead);\n\t\t}\n\t\text4_mark_bitmap_end(group_data[i].blocks_count,\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbrelse(bh);\n\nhandle_ib:\n\t\tif (bg_flags[i] & EXT4_BG_INODE_UNINIT)\n\t\t\tcontinue;\n\n\t\t/* Initialize inode bitmap of the @group */\n\t\tblock = group_data[i].inode_bitmap;\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t/* Mark unused entries in inode bitmap used */\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbrelse(bh);\n\t}\n\tbh = NULL;\n\n\t/* Mark group tables in block bitmap */\n\tfor (j = 0; j < GROUP_TABLE_COUNT; j++) {\n\t\tcount = group_table_count[j];\n\t\tstart = (&group_data[0].block_bitmap)[j];\n\t\tblock = start;\n\t\tfor (i = 1; i < flex_gd->count; i++) {\n\t\t\tblock += group_table_count[j];\n\t\t\tif (block == (&group_data[i].block_bitmap)[j]) {\n\t\t\t\tcount += group_table_count[j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\tflex_gd, start, count);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tcount = group_table_count[j];\n\t\t\tstart = (&group_data[i].block_bitmap)[j];\n\t\t\tblock = start;\n\t\t}\n\n\t\tif (count) {\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\tflex_gd, start, count);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbrelse(bh);\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int setup_new_flex_group_blocks(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tint group_table_count[] = {1, 1, EXT4_SB(sb)->s_itb_per_group};\n\text4_fsblk_t start;\n\text4_fsblk_t block;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\t__u16 *bg_flags = flex_gd->bg_flags;\n\thandle_t *handle;\n\text4_group_t group, count;\n\tstruct buffer_head *bh = NULL;\n\tint reserved_gdb, i, j, err = 0, err2;\n\tint meta_bg;\n\n\tBUG_ON(!flex_gd->count || !group_data ||\n\t       group_data[0].group != sbi->s_groups_count);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tgroup = group_data[0].group;\n\tfor (i = 0; i < flex_gd->count; i++, group++) {\n\t\tunsigned long gdblocks;\n\t\text4_grpblk_t overhead;\n\n\t\tgdblocks = ext4_bg_num_gdb(sb, group);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\n\t\tif (meta_bg == 0 && !ext4_bg_has_super(sb, group))\n\t\t\tgoto handle_itb;\n\n\t\tif (meta_bg == 1) {\n\t\t\text4_group_t first_group;\n\t\t\tfirst_group = ext4_meta_bg_first_group(sb, group);\n\t\t\tif (first_group != group + 1 &&\n\t\t\t    first_group != group + EXT4_DESC_PER_BLOCK(sb) - 1)\n\t\t\t\tgoto handle_itb;\n\t\t}\n\n\t\tblock = start + ext4_bg_has_super(sb, group);\n\t\t/* Copy all of the GDT blocks into the backup in this group */\n\t\tfor (j = 0; j < gdblocks; j++, block++) {\n\t\t\tstruct buffer_head *gdb;\n\n\t\t\text4_debug(\"update backup group %#04llx\\n\", block);\n\t\t\terr = extend_or_restart_transaction(handle, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tgdb = sb_getblk(sb, block);\n\t\t\tif (unlikely(!gdb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUFFER_TRACE(gdb, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb);\n\t\t\tif (err) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gdb->b_data, sbi->s_group_desc[j]->b_data,\n\t\t\t       gdb->b_size);\n\t\t\tset_buffer_uptodate(gdb);\n\n\t\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbrelse(gdb);\n\t\t}\n\n\t\t/* Zero out all of the reserved backup group descriptor\n\t\t * table blocks\n\t\t */\n\t\tif (ext4_bg_has_super(sb, group)) {\n\t\t\terr = sb_issue_zeroout(sb, gdblocks + start + 1,\n\t\t\t\t\treserved_gdb, GFP_NOFS);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\nhandle_itb:\n\t\t/* Initialize group tables of the grop @group */\n\t\tif (!(bg_flags[i] & EXT4_BG_INODE_ZEROED))\n\t\t\tgoto handle_bb;\n\n\t\t/* Zero out all of the inode table blocks */\n\t\tblock = group_data[i].inode_table;\n\t\text4_debug(\"clear inode table blocks %#04llx -> %#04lx\\n\",\n\t\t\t   block, sbi->s_itb_per_group);\n\t\terr = sb_issue_zeroout(sb, block, sbi->s_itb_per_group,\n\t\t\t\t       GFP_NOFS);\n\t\tif (err)\n\t\t\tgoto out;\n\nhandle_bb:\n\t\tif (bg_flags[i] & EXT4_BG_BLOCK_UNINIT)\n\t\t\tgoto handle_ib;\n\n\t\t/* Initialize block bitmap of the @group */\n\t\tblock = group_data[i].block_bitmap;\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\toverhead = ext4_group_overhead_blocks(sb, group);\n\t\tif (overhead != 0) {\n\t\t\text4_debug(\"mark backup superblock %#04llx (+0)\\n\",\n\t\t\t\t   start);\n\t\t\text4_set_bits(bh->b_data, 0, overhead);\n\t\t}\n\t\text4_mark_bitmap_end(group_data[i].blocks_count,\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbrelse(bh);\n\nhandle_ib:\n\t\tif (bg_flags[i] & EXT4_BG_INODE_UNINIT)\n\t\t\tcontinue;\n\n\t\t/* Initialize inode bitmap of the @group */\n\t\tblock = group_data[i].inode_bitmap;\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t/* Mark unused entries in inode bitmap used */\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbrelse(bh);\n\t}\n\tbh = NULL;\n\n\t/* Mark group tables in block bitmap */\n\tfor (j = 0; j < GROUP_TABLE_COUNT; j++) {\n\t\tcount = group_table_count[j];\n\t\tstart = (&group_data[0].block_bitmap)[j];\n\t\tblock = start;\n\t\tfor (i = 1; i < flex_gd->count; i++) {\n\t\t\tblock += group_table_count[j];\n\t\t\tif (block == (&group_data[i].block_bitmap)[j]) {\n\t\t\t\tcount += group_table_count[j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\tflex_gd, start, count);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tcount = group_table_count[j];\n\t\t\tstart = (&group_data[i].block_bitmap)[j];\n\t\t\tblock = start;\n\t\t}\n\n\t\tif (count) {\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\tflex_gd, start, count);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbrelse(bh);\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "o_blocks_count",
            "&group",
            "&last"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_reserved_gdt_blocks"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_flex_group_add(struct super_block *sb,\n\t\t\t       struct inode *resize_inode,\n\t\t\t       struct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_group_t group;\n\thandle_t *handle;\n\tunsigned reserved_gdb;\n\tint err = 0, err2 = 0, credit;\n\n\tBUG_ON(!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\to_blocks_count = ext4_blocks_count(es);\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\n\terr = setup_new_flex_group_blocks(sb, flex_gd);\n\tif (err)\n\t\tgoto exit;\n\t/*\n\t * We will always be modifying at least the superblock and  GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\tcredit = flex_gd->count * 4 + reserved_gdb;\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credit);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto exit_journal;\n\n\tgroup = flex_gd->groups[0].group;\n\tBUG_ON(group != EXT4_SB(sb)->s_groups_count);\n\terr = ext4_add_new_descs(handle, sb, group,\n\t\t\t\tresize_inode, flex_gd->count);\n\tif (err)\n\t\tgoto exit_journal;\n\n\terr = ext4_setup_new_descs(handle, sb, flex_gd);\n\tif (err)\n\t\tgoto exit_journal;\n\n\text4_update_super(sb, flex_gd);\n\n\terr = ext4_handle_dirty_super(handle, sb);\n\nexit_journal:\n\terr2 = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tint gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\t\tint gdb_num_end = ((group + flex_gd->count - 1) /\n\t\t\t\t   EXT4_DESC_PER_BLOCK(sb));\n\t\tint meta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_INCOMPAT_META_BG);\n\t\tsector_t old_gdb = 0;\n\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block), 0);\n\t\tfor (; gdb_num <= gdb_num_end; gdb_num++) {\n\t\t\tstruct buffer_head *gdb_bh;\n\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tif (old_gdb == gdb_bh->b_blocknr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backups(sb, gdb_bh->b_blocknr, gdb_bh->b_data,\n\t\t\t\t       gdb_bh->b_size, meta_bg);\n\t\t\told_gdb = gdb_bh->b_blocknr;\n\t\t}\n\t}\nexit:\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_update_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1306-1404",
    "snippet": "static void ext4_update_super(struct super_block *sb,\n\t\t\t     struct ext4_new_flex_group_data *flex_gd)\n{\n\text4_fsblk_t blocks_count = 0;\n\text4_fsblk_t free_blocks = 0;\n\text4_fsblk_t reserved_blocks = 0;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tblocks_count += group_data[i].blocks_count;\n\t\tfree_blocks += group_data[i].free_blocks_count;\n\t}\n\n\treserved_blocks = ext4_r_blocks_count(es) * 100;\n\treserved_blocks = div64_u64(reserved_blocks, ext4_blocks_count(es));\n\treserved_blocks *= blocks_count;\n\tdo_div(reserved_blocks, 100);\n\n\text4_blocks_count_set(es, ext4_blocks_count(es) + blocks_count);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + free_blocks);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\tle32_add_cpu(&es->s_free_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\", ext4_free_blocks_count(es));\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers must perform a smp_wmb() after updating all\n\t *   dependent data and before modifying the groups count\n\t *\n\t * * Readers must perform an smp_rmb() after reading the groups\n\t *   count and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count += flex_gd->count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\t\t\treserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, free_blocks));\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb) * flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\",\n\t\t   percpu_counter_read(&sbi->s_freeclusters_counter));\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FLEX_BG) &&\n\t    sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group;\n\t\tflex_group = ext4_flex_group(sbi, group_data[0].group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, free_blocks),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(EXT4_INODES_PER_GROUP(sb) * flex_gd->count,\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t}\n\n\t/*\n\t * Update the fs overhead information\n\t */\n\text4_calculate_overhead(sb);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: added group %u:\"\n\t\t       \"%llu blocks(%llu free %llu reserved)\\n\", flex_gd->count,\n\t\t       blocks_count, free_blocks, reserved_blocks);\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"EXT4-fs: added group %u:\"\n\t\t       \"%llu blocks(%llu free %llu reserved)\\n\"",
            "flex_gd->count",
            "blocks_count",
            "free_blocks",
            "reserved_blocks"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_calculate_overhead",
          "args": [
            "sb"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_calculate_overhead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "3322-3364",
          "snippet": "int ext4_calculate_overhead(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\text4_fsblk_t overhead = 0;\n\tchar *buf = (char *) get_zeroed_page(GFP_NOFS);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Compute the overhead (FS structures).  This is constant\n\t * for a given filesystem unless the number of block groups\n\t * changes so we cache the previous value until it does.\n\t */\n\n\t/*\n\t * All of the blocks before first_data_block are overhead\n\t */\n\toverhead = EXT4_B2C(sbi, le32_to_cpu(es->s_first_data_block));\n\n\t/*\n\t * Add the overhead found in each block group\n\t */\n\tfor (i = 0; i < ngroups; i++) {\n\t\tint blks;\n\n\t\tblks = count_overhead(sb, i, buf);\n\t\toverhead += blks;\n\t\tif (blks)\n\t\t\tmemset(buf, 0, PAGE_SIZE);\n\t\tcond_resched();\n\t}\n\t/* Add the internal journal blocks as well */\n\tif (sbi->s_journal && !sbi->journal_bdev)\n\t\toverhead += EXT4_NUM_B2C(sbi, sbi->s_journal->j_maxlen);\n\n\tsbi->s_overhead = overhead;\n\tsmp_wmb();\n\tfree_page((unsigned long) buf);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nint ext4_calculate_overhead(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\text4_fsblk_t overhead = 0;\n\tchar *buf = (char *) get_zeroed_page(GFP_NOFS);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Compute the overhead (FS structures).  This is constant\n\t * for a given filesystem unless the number of block groups\n\t * changes so we cache the previous value until it does.\n\t */\n\n\t/*\n\t * All of the blocks before first_data_block are overhead\n\t */\n\toverhead = EXT4_B2C(sbi, le32_to_cpu(es->s_first_data_block));\n\n\t/*\n\t * Add the overhead found in each block group\n\t */\n\tfor (i = 0; i < ngroups; i++) {\n\t\tint blks;\n\n\t\tblks = count_overhead(sb, i, buf);\n\t\toverhead += blks;\n\t\tif (blks)\n\t\t\tmemset(buf, 0, PAGE_SIZE);\n\t\tcond_resched();\n\t}\n\t/* Add the internal journal blocks as well */\n\tif (sbi->s_journal && !sbi->journal_bdev)\n\t\toverhead += EXT4_NUM_B2C(sbi, sbi->s_journal->j_maxlen);\n\n\tsbi->s_overhead = overhead;\n\tsmp_wmb();\n\tfree_page((unsigned long) buf);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "EXT4_INODES_PER_GROUP(sb) * flex_gd->count",
            "&sbi->s_flex_groups[flex_group].free_inodes"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "EXT4_NUM_B2C(sbi, free_blocks)",
            "&sbi->s_flex_groups[flex_group].free_clusters"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "free_blocks"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_group",
          "args": [
            "sbi",
            "group_data[0].group"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_FLEX_BG"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"free blocks count %llu\"",
            "percpu_counter_read(&sbi->s_freeclusters_counter)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read",
          "args": [
            "&sbi->s_freeclusters_counter"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeinodes_counter",
            "EXT4_INODES_PER_GROUP(sb) * flex_gd->count"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeclusters_counter",
            "EXT4_NUM_B2C(sbi, free_blocks)"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "free_blocks"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_r_blocks_count_set",
          "args": [
            "es",
            "ext4_r_blocks_count(es) +\n\t\t\t\treserved_blocks"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_r_blocks_count",
          "args": [
            "es"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "ext4_group_t",
            "sbi->s_groups_count",
            "(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb))"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"free blocks count %llu\"",
            "ext4_free_blocks_count(es)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count",
          "args": [
            "es"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&es->s_free_inodes_count",
            "EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&es->s_inodes_count",
            "EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count_set",
          "args": [
            "es",
            "ext4_free_blocks_count(es) + free_blocks"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks_count",
          "args": [
            "es"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count_set",
          "args": [
            "es",
            "ext4_blocks_count(es) + blocks_count"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "reserved_blocks",
            "100"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "reserved_blocks",
            "ext4_blocks_count(es)"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_r_blocks_count",
          "args": [
            "es"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flex_gd->count == 0 || group_data == NULL"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic void ext4_update_super(struct super_block *sb,\n\t\t\t     struct ext4_new_flex_group_data *flex_gd)\n{\n\text4_fsblk_t blocks_count = 0;\n\text4_fsblk_t free_blocks = 0;\n\text4_fsblk_t reserved_blocks = 0;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tblocks_count += group_data[i].blocks_count;\n\t\tfree_blocks += group_data[i].free_blocks_count;\n\t}\n\n\treserved_blocks = ext4_r_blocks_count(es) * 100;\n\treserved_blocks = div64_u64(reserved_blocks, ext4_blocks_count(es));\n\treserved_blocks *= blocks_count;\n\tdo_div(reserved_blocks, 100);\n\n\text4_blocks_count_set(es, ext4_blocks_count(es) + blocks_count);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + free_blocks);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\tle32_add_cpu(&es->s_free_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\", ext4_free_blocks_count(es));\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers must perform a smp_wmb() after updating all\n\t *   dependent data and before modifying the groups count\n\t *\n\t * * Readers must perform an smp_rmb() after reading the groups\n\t *   count and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count += flex_gd->count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\t\t\treserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, free_blocks));\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb) * flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\",\n\t\t   percpu_counter_read(&sbi->s_freeclusters_counter));\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t      EXT4_FEATURE_INCOMPAT_FLEX_BG) &&\n\t    sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group;\n\t\tflex_group = ext4_flex_group(sbi, group_data[0].group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, free_blocks),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(EXT4_INODES_PER_GROUP(sb) * flex_gd->count,\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t}\n\n\t/*\n\t * Update the fs overhead information\n\t */\n\text4_calculate_overhead(sb);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: added group %u:\"\n\t\t       \"%llu blocks(%llu free %llu reserved)\\n\", flex_gd->count,\n\t\t       blocks_count, free_blocks, reserved_blocks);\n}"
  },
  {
    "function_name": "ext4_setup_new_descs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1237-1297",
    "snippet": "static int ext4_setup_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_new_group_data\t*group_data = flex_gd->groups;\n\tstruct ext4_group_desc\t\t*gdp;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tstruct buffer_head\t\t*gdb_bh;\n\text4_group_t\t\t\tgroup;\n\t__u16\t\t\t\t*bg_flags = flex_gd->bg_flags;\n\tint\t\t\t\ti, gdb_off, gdb_num, err = 0;\n\t\n\n\tfor (i = 0; i < flex_gd->count; i++, group_data++, bg_flags++) {\n\t\tgroup = group_data->group;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * get_write_access() has been called on gdb_bh by ext4_add_new_desc().\n\t\t */\n\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t/* Update group descriptor block for new group */\n\t\tgdp = (struct ext4_group_desc *)(gdb_bh->b_data +\n\t\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\t\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n\t\text4_block_bitmap_set(sb, gdp, group_data->block_bitmap);\n\t\text4_inode_bitmap_set(sb, gdp, group_data->inode_bitmap);\n\t\terr = ext4_set_bitmap_checksums(sb, group, gdp, group_data);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\text4_inode_table_set(sb, gdp, group_data->inode_table);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\tEXT4_NUM_B2C(sbi, group_data->free_blocks_count));\n\t\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t       EXT4_INODES_PER_GROUP(sb));\n\t\tgdp->bg_flags = cpu_to_le16(*bg_flags);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\t\tif (unlikely(err)) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We can allocate memory for mb_alloc based on the new group\n\t\t * descriptor\n\t\t */\n\t\terr = ext4_mb_add_groupinfo(sb, group, gdp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_add_groupinfo",
          "args": [
            "sb",
            "group",
            "gdp"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_add_groupinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2371-2451",
          "snippet": "int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t/*\n\t * First check if this group is the first of a reserved block.\n\t * If it's true, we have to allocate a new table of pointers\n\t * to ext4_group_info structures\n\t */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\tgoto exit_meta_group_info;\n\t\t}\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =\n\t\t\tmeta_group_info;\n\t}\n\n\tmeta_group_info =\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t/*\n\t * initialize bb_free to be able to skip\n\t * empty groups without initialization\n\t */\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tmeta_group_info[i]->bb_largest_free_order = -1;  /* uninit */\n\n#ifdef DOUBLE_CHECK\n\t{\n\t\tstruct buffer_head *bh;\n\t\tmeta_group_info[i]->bb_bitmap =\n\t\t\tkmalloc(sb->s_blocksize, GFP_NOFS);\n\t\tBUG_ON(meta_group_info[i]->bb_bitmap == NULL);\n\t\tbh = ext4_read_block_bitmap(sb, group);\n\t\tBUG_ON(bh == NULL);\n\t\tmemcpy(meta_group_info[i]->bb_bitmap, bh->b_data,\n\t\t\tsb->s_blocksize);\n\t\tput_bh(bh);\n\t}\n#endif\n\n\treturn 0;\n\nexit_group_info:\n\t/* If a meta_group_info table has been allocated, release it now */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tkfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;\n\t}\nexit_meta_group_info:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t/*\n\t * First check if this group is the first of a reserved block.\n\t * If it's true, we have to allocate a new table of pointers\n\t * to ext4_group_info structures\n\t */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\tgoto exit_meta_group_info;\n\t\t}\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =\n\t\t\tmeta_group_info;\n\t}\n\n\tmeta_group_info =\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t/*\n\t * initialize bb_free to be able to skip\n\t * empty groups without initialization\n\t */\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tmeta_group_info[i]->bb_largest_free_order = -1;  /* uninit */\n\n#ifdef DOUBLE_CHECK\n\t{\n\t\tstruct buffer_head *bh;\n\t\tmeta_group_info[i]->bb_bitmap =\n\t\t\tkmalloc(sb->s_blocksize, GFP_NOFS);\n\t\tBUG_ON(meta_group_info[i]->bb_bitmap == NULL);\n\t\tbh = ext4_read_block_bitmap(sb, group);\n\t\tBUG_ON(bh == NULL);\n\t\tmemcpy(meta_group_info[i]->bb_bitmap, bh->b_data,\n\t\t\tsb->s_blocksize);\n\t\tput_bh(bh);\n\t}\n#endif\n\n\treturn 0;\n\nexit_group_info:\n\t/* If a meta_group_info table has been allocated, release it now */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tkfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;\n\t}\nexit_meta_group_info:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "gdb_bh"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_set",
          "args": [
            "sb",
            "group",
            "gdp"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "*bg_flags"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_itable_unused_set",
          "args": [
            "sb",
            "gdp",
            "EXT4_INODES_PER_GROUP(sb)"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_itable_unused_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "283-289",
          "snippet": "void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_itable_unused_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_itable_unused_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_itable_unused_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_itable_unused_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_itable_unused_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "sb"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_inodes_set",
          "args": [
            "sb",
            "gdp",
            "EXT4_INODES_PER_GROUP(sb)"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_inodes_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "267-273",
          "snippet": "void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_inodes_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_inodes_count_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_inodes_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_inodes_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_inodes_count_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters_set",
          "args": [
            "sb",
            "gdp",
            "EXT4_NUM_B2C(sbi, group_data->free_blocks_count)"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "259-265",
          "snippet": "void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "group_data->free_blocks_count"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_table_set",
          "args": [
            "sb",
            "gdp",
            "group_data->inode_table"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "251-257",
          "snippet": "void ext4_inode_table_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_table_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_table_hi = cpu_to_le32(blk >> 32);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_inode_table_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_table_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_table_hi = cpu_to_le32(blk >> 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bitmap_checksums",
          "args": [
            "sb",
            "group",
            "gdp",
            "group_data"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_bitmap_checksums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1208-1232",
          "snippet": "static int ext4_set_bitmap_checksums(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     struct ext4_group_desc *gdp,\n\t\t\t\t     struct ext4_new_group_data *group_data)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 0;\n\n\tbh = ext4_get_bitmap(sb, group_data->inode_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_inode_bitmap_csum_set(sb, group, gdp, bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\tbrelse(bh);\n\n\tbh = ext4_get_bitmap(sb, group_data->block_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_block_bitmap_csum_set(sb, group, gdp, bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_set_bitmap_checksums(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     struct ext4_group_desc *gdp,\n\t\t\t\t     struct ext4_new_group_data *group_data)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 0;\n\n\tbh = ext4_get_bitmap(sb, group_data->inode_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_inode_bitmap_csum_set(sb, group, gdp, bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\tbrelse(bh);\n\n\tbh = ext4_get_bitmap(sb, group_data->block_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_block_bitmap_csum_set(sb, group, gdp, bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap_set",
          "args": [
            "sb",
            "gdp",
            "group_data->inode_bitmap"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "243-249",
          "snippet": "void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_bitmap_lo  = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_bitmap_hi = cpu_to_le32(blk >> 32);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_bitmap_lo  = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_bitmap_hi = cpu_to_le32(blk >> 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap_set",
          "args": [
            "sb",
            "gdp",
            "group_data->block_bitmap"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "235-241",
          "snippet": "void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_block_bitmap_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_block_bitmap_hi = cpu_to_le32(blk >> 32);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_block_bitmap_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_block_bitmap_hi = cpu_to_le32(blk >> 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "gdp",
            "0",
            "EXT4_DESC_SIZE(sb)"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_SIZE",
          "args": [
            "sb"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_setup_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_new_group_data\t*group_data = flex_gd->groups;\n\tstruct ext4_group_desc\t\t*gdp;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tstruct buffer_head\t\t*gdb_bh;\n\text4_group_t\t\t\tgroup;\n\t__u16\t\t\t\t*bg_flags = flex_gd->bg_flags;\n\tint\t\t\t\ti, gdb_off, gdb_num, err = 0;\n\t\n\n\tfor (i = 0; i < flex_gd->count; i++, group_data++, bg_flags++) {\n\t\tgroup = group_data->group;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * get_write_access() has been called on gdb_bh by ext4_add_new_desc().\n\t\t */\n\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t/* Update group descriptor block for new group */\n\t\tgdp = (struct ext4_group_desc *)(gdb_bh->b_data +\n\t\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\t\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n\t\text4_block_bitmap_set(sb, gdp, group_data->block_bitmap);\n\t\text4_inode_bitmap_set(sb, gdp, group_data->inode_bitmap);\n\t\terr = ext4_set_bitmap_checksums(sb, group, gdp, group_data);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\text4_inode_table_set(sb, gdp, group_data->inode_table);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\tEXT4_NUM_B2C(sbi, group_data->free_blocks_count));\n\t\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t       EXT4_INODES_PER_GROUP(sb));\n\t\tgdp->bg_flags = cpu_to_le16(*bg_flags);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\t\tif (unlikely(err)) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We can allocate memory for mb_alloc based on the new group\n\t\t * descriptor\n\t\t */\n\t\terr = ext4_mb_add_groupinfo(sb, group, gdp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_set_bitmap_checksums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1208-1232",
    "snippet": "static int ext4_set_bitmap_checksums(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     struct ext4_group_desc *gdp,\n\t\t\t\t     struct ext4_new_group_data *group_data)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 0;\n\n\tbh = ext4_get_bitmap(sb, group_data->inode_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_inode_bitmap_csum_set(sb, group, gdp, bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\tbrelse(bh);\n\n\tbh = ext4_get_bitmap(sb, group_data->block_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_block_bitmap_csum_set(sb, group, gdp, bh);\n\tbrelse(bh);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap_csum_set",
          "args": [
            "sb",
            "group",
            "gdp",
            "bh"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "83-98",
          "snippet": "void ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nvoid ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_bitmap",
          "args": [
            "sb",
            "group_data->block_bitmap"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "1193-1206",
          "snippet": "static struct buffer_head *ext4_get_bitmap(struct super_block *sb, __u64 block)\n{\n\tstruct buffer_head *bh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\tif (bh_submit_read(bh) < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bh;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct buffer_head *ext4_get_bitmap(struct super_block *sb, __u64 block)\n{\n\tstruct buffer_head *bh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\tif (bh_submit_read(bh) < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap_csum_set",
          "args": [
            "sb",
            "group",
            "gdp",
            "bh",
            "EXT4_INODES_PER_GROUP(sb) / 8"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "41-55",
          "snippet": "void ext4_inode_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh, int sz)\n{\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_inode_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_INODE_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_inode_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nvoid ext4_inode_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh, int sz)\n{\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_inode_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_INODE_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_inode_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_set_bitmap_checksums(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     struct ext4_group_desc *gdp,\n\t\t\t\t     struct ext4_new_group_data *group_data)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 0;\n\n\tbh = ext4_get_bitmap(sb, group_data->inode_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_inode_bitmap_csum_set(sb, group, gdp, bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\tbrelse(bh);\n\n\tbh = ext4_get_bitmap(sb, group_data->block_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_block_bitmap_csum_set(sb, group, gdp, bh);\n\tbrelse(bh);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_get_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1193-1206",
    "snippet": "static struct buffer_head *ext4_get_bitmap(struct super_block *sb, __u64 block)\n{\n\tstruct buffer_head *bh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\tif (bh_submit_read(bh) < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bh;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_submit_read",
          "args": [
            "bh"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "bh"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct buffer_head *ext4_get_bitmap(struct super_block *sb, __u64 block)\n{\n\tstruct buffer_head *bh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\tif (bh_submit_read(bh) < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bh;\n}"
  },
  {
    "function_name": "ext4_add_new_descs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1151-1191",
    "snippet": "static int ext4_add_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t      ext4_group_t group, struct inode *resize_inode,\n\t\t\t      ext4_group_t count)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *gdb_bh;\n\tint i, gdb_off, gdb_num, err = 0;\n\tint meta_bg;\n\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\tfor (i = 0; i < count; i++, group++) {\n\t\tint reserved_gdb = ext4_bg_has_super(sb, group) ?\n\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * We will only either add reserved group blocks to a backup group\n\t\t * or remove reserved blocks for the first group in a new group block.\n\t\t * Doing both would be mean more complex code, and sane people don't\n\t\t * use non-sparse filesystems anymore.  This is already checked above.\n\t\t */\n\t\tif (gdb_off) {\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\n\t\t\tif (!err && reserved_gdb && ext4_bg_num_gdb(sb, group))\n\t\t\t\terr = reserve_backup_gdb(handle, resize_inode, group);\n\t\t} else if (meta_bg != 0) {\n\t\t\terr = add_new_gdb_meta_bg(sb, handle, group);\n\t\t} else {\n\t\t\terr = add_new_gdb(handle, resize_inode, group);\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_new_gdb",
          "args": [
            "handle",
            "resize_inode",
            "group"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "add_new_gdb_meta_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "883-918",
          "snippet": "static int add_new_gdb_meta_bg(struct super_block *sb,\n\t\t\t       handle_t *handle, ext4_group_t group) {\n\text4_fsblk_t gdblock;\n\tstruct buffer_head *gdb_bh;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\tint err;\n\n\tgdblock = ext4_meta_bg_first_block_no(sb, group) +\n\t\t   ext4_bg_has_super(sb, group);\n\tgdb_bh = sb_bread(sb, gdblock);\n\tif (!gdb_bh)\n\t\treturn -EIO;\n\tn_group_desc = ext4_kvmalloc((gdb_num + 1) *\n\t\t\t\t     sizeof(struct buffer_head *),\n\t\t\t\t     GFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\treturn err;\n\t}\n\n\to_group_desc = EXT4_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = gdb_bh;\n\tEXT4_SB(sb)->s_group_desc = n_group_desc;\n\tEXT4_SB(sb)->s_gdb_count++;\n\tkvfree(o_group_desc);\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (unlikely(err))\n\t\tbrelse(gdb_bh);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int add_new_gdb_meta_bg(struct super_block *sb,\n\t\t\t       handle_t *handle, ext4_group_t group) {\n\text4_fsblk_t gdblock;\n\tstruct buffer_head *gdb_bh;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\tint err;\n\n\tgdblock = ext4_meta_bg_first_block_no(sb, group) +\n\t\t   ext4_bg_has_super(sb, group);\n\tgdb_bh = sb_bread(sb, gdblock);\n\tif (!gdb_bh)\n\t\treturn -EIO;\n\tn_group_desc = ext4_kvmalloc((gdb_num + 1) *\n\t\t\t\t     sizeof(struct buffer_head *),\n\t\t\t\t     GFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\treturn err;\n\t}\n\n\to_group_desc = EXT4_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = gdb_bh;\n\tEXT4_SB(sb)->s_group_desc = n_group_desc;\n\tEXT4_SB(sb)->s_gdb_count++;\n\tkvfree(o_group_desc);\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (unlikely(err))\n\t\tbrelse(gdb_bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_backup_gdb",
          "args": [
            "handle",
            "resize_inode",
            "group"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_backup_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "933-1025",
          "snippet": "static int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext4_iloc iloc;\n\text4_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc(reserved_gdb * sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + EXT4_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT4_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT4_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT4_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text4_warning(sb, \"reserved block %llu\"\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = sb_bread(sb, blk);\n\t\tif (!primary[res]) {\n\t\t\terr = -EIO;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tgdbackups = verify_reserved_gdb(sb, group, primary[res]);\n\t\tif (gdbackups < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tBUFFER_TRACE(primary[i], \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, primary[i])))\n\t\t\tgoto exit_bh;\n\t}\n\n\tif ((err = ext4_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = group * EXT4_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext4_handle_dirty_metadata(handle, NULL, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext4_iloc iloc;\n\text4_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc(reserved_gdb * sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + EXT4_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT4_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT4_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT4_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text4_warning(sb, \"reserved block %llu\"\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = sb_bread(sb, blk);\n\t\tif (!primary[res]) {\n\t\t\terr = -EIO;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tgdbackups = verify_reserved_gdb(sb, group, primary[res]);\n\t\tif (gdbackups < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tBUFFER_TRACE(primary[i], \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, primary[i])))\n\t\t\tgoto exit_bh;\n\t}\n\n\tif ((err = ext4_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = group * EXT4_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext4_handle_dirty_metadata(handle, NULL, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_num_gdb",
          "args": [
            "sb",
            "group"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "797-809",
          "snippet": "unsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nunsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "gdb_bh"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdb_bh",
            "\"get_write_access\""
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_reserved_gdt_blocks"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "group"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_add_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t      ext4_group_t group, struct inode *resize_inode,\n\t\t\t      ext4_group_t count)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *gdb_bh;\n\tint i, gdb_off, gdb_num, err = 0;\n\tint meta_bg;\n\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\tfor (i = 0; i < count; i++, group++) {\n\t\tint reserved_gdb = ext4_bg_has_super(sb, group) ?\n\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t/*\n\t\t * We will only either add reserved group blocks to a backup group\n\t\t * or remove reserved blocks for the first group in a new group block.\n\t\t * Doing both would be mean more complex code, and sane people don't\n\t\t * use non-sparse filesystems anymore.  This is already checked above.\n\t\t */\n\t\tif (gdb_off) {\n\t\t\tgdb_bh = sbi->s_group_desc[gdb_num];\n\t\t\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\n\t\t\tif (!err && reserved_gdb && ext4_bg_num_gdb(sb, group))\n\t\t\t\terr = reserve_backup_gdb(handle, resize_inode, group);\n\t\t} else if (meta_bg != 0) {\n\t\t\terr = add_new_gdb_meta_bg(sb, handle, group);\n\t\t} else {\n\t\t\terr = add_new_gdb(handle, resize_inode, group);\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "update_backups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "1043-1139",
    "snippet": "static void update_backups(struct super_block *sb, int blk_off, char *data,\n\t\t\t   int size, int meta_bg)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t last;\n\tconst int bpg = EXT4_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\text4_group_t group = 0;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\tif (meta_bg == 0) {\n\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\tlast = sbi->s_groups_count;\n\t} else {\n\t\tgroup = ext4_meta_bg_first_group(sb, group) + 1;\n\t\tlast = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);\n\t}\n\n\twhile (group < sbi->s_groups_count) {\n\t\tstruct buffer_head *bh;\n\t\text4_fsblk_t backup_block;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (ext4_handle_valid(handle) &&\n\t\t    handle->h_buffer_credits == 0 &&\n\t\t    ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA) &&\n\t\t    (err = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tif (meta_bg == 0)\n\t\t\tbackup_block = ((ext4_fsblk_t)group) * bpg + blk_off;\n\t\telse\n\t\t\tbackup_block = (ext4_group_first_block_no(sb, group) +\n\t\t\t\t\text4_bg_has_super(sb, group));\n\n\t\tbh = sb_getblk(sb, backup_block);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text4_debug(\"update metadata backup %llu(+%llu)\\n\",\n\t\t\t   backup_block, backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group));\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, bh)))\n\t\t\tbreak;\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\text4_std_error(sb, err);\n\t\tbrelse(bh);\n\n\t\tif (meta_bg == 0)\n\t\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\telse if (group == last)\n\t\t\tbreak;\n\t\telse\n\t\t\tgroup = last;\n\t}\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text4_warning(sb, \"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT4_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~EXT4_VALID_FS"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\"",
            "group",
            "err"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_list_backups",
          "args": [
            "sb",
            "&three",
            "&five",
            "&seven"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_list_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "676-703",
          "snippet": "static unsigned ext4_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic unsigned ext4_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bh"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data + size",
            "0",
            "rest"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data",
            "data",
            "size"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"update metadata backup %llu(+%llu)\\n\"",
            "backup_block",
            "backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group)"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "backup_block"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "group"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_restart",
          "args": [
            "handle",
            "EXT4_MAX_TRANS_DATA"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "343-348",
          "snippet": "static inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_extend",
          "args": [
            "handle",
            "EXT4_MAX_TRANS_DATA"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "336-341",
          "snippet": "static inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "group + EXT4_DESC_PER_BLOCK(sb) - 2"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_meta_bg_first_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_meta_bg_first_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "60-64",
          "snippet": "static ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start_sb",
          "args": [
            "sb",
            "EXT4_HT_RESIZE",
            "EXT4_MAX_TRANS_DATA"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic void update_backups(struct super_block *sb, int blk_off, char *data,\n\t\t\t   int size, int meta_bg)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t last;\n\tconst int bpg = EXT4_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\text4_group_t group = 0;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\tif (meta_bg == 0) {\n\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\tlast = sbi->s_groups_count;\n\t} else {\n\t\tgroup = ext4_meta_bg_first_group(sb, group) + 1;\n\t\tlast = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);\n\t}\n\n\twhile (group < sbi->s_groups_count) {\n\t\tstruct buffer_head *bh;\n\t\text4_fsblk_t backup_block;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (ext4_handle_valid(handle) &&\n\t\t    handle->h_buffer_credits == 0 &&\n\t\t    ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA) &&\n\t\t    (err = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tif (meta_bg == 0)\n\t\t\tbackup_block = ((ext4_fsblk_t)group) * bpg + blk_off;\n\t\telse\n\t\t\tbackup_block = (ext4_group_first_block_no(sb, group) +\n\t\t\t\t\text4_bg_has_super(sb, group));\n\n\t\tbh = sb_getblk(sb, backup_block);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text4_debug(\"update metadata backup %llu(+%llu)\\n\",\n\t\t\t   backup_block, backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group));\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, bh)))\n\t\t\tbreak;\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\text4_std_error(sb, err);\n\t\tbrelse(bh);\n\n\t\tif (meta_bg == 0)\n\t\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\telse if (group == last)\n\t\t\tbreak;\n\t\telse\n\t\t\tgroup = last;\n\t}\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text4_warning(sb, \"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT4_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}"
  },
  {
    "function_name": "reserve_backup_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "933-1025",
    "snippet": "static int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext4_iloc iloc;\n\text4_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc(reserved_gdb * sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + EXT4_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT4_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT4_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT4_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text4_warning(sb, \"reserved block %llu\"\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = sb_bread(sb, blk);\n\t\tif (!primary[res]) {\n\t\t\terr = -EIO;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tgdbackups = verify_reserved_gdb(sb, group, primary[res]);\n\t\tif (gdbackups < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tBUFFER_TRACE(primary[i], \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, primary[i])))\n\t\t\tgoto exit_bh;\n\t}\n\n\tif ((err = ext4_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = group * EXT4_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext4_handle_dirty_metadata(handle, NULL, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "primary"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dind"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "primary[i]"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk + primary[i]->b_blocknr"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4822-4839",
          "snippet": "int\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "primary[i]"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "primary[i]",
            "\"get_write_access\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_reserved_gdb",
          "args": [
            "sb",
            "group",
            "primary[res]"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "verify_reserved_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "710-738",
          "snippet": "static int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       ext4_group_t end,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext4_fsblk_t blk = primary->b_blocknr;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) !=\n\t\t    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text4_warning(sb, \"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT4_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       ext4_group_t end,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext4_fsblk_t blk = primary->b_blocknr;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) !=\n\t\t    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text4_warning(sb, \"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT4_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blk"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"reserved block %llu\"\n\t\t\t\t     \" not at offset %ld\"",
            "blk",
            "(long)(data - (__le32 *)dind->b_data)"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*data"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "le32_to_cpu(*data)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "reserved_gdb * sizeof(*primary)",
            "GFP_NOFS"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_reserved_gdt_blocks"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext4_iloc iloc;\n\text4_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc(reserved_gdb * sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + EXT4_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT4_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT4_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT4_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text4_warning(sb, \"reserved block %llu\"\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = sb_bread(sb, blk);\n\t\tif (!primary[res]) {\n\t\t\terr = -EIO;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tgdbackups = verify_reserved_gdb(sb, group, primary[res]);\n\t\tif (gdbackups < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tBUFFER_TRACE(primary[i], \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, primary[i])))\n\t\t\tgoto exit_bh;\n\t}\n\n\tif ((err = ext4_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = group * EXT4_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext4_handle_dirty_metadata(handle, NULL, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}"
  },
  {
    "function_name": "add_new_gdb_meta_bg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "883-918",
    "snippet": "static int add_new_gdb_meta_bg(struct super_block *sb,\n\t\t\t       handle_t *handle, ext4_group_t group) {\n\text4_fsblk_t gdblock;\n\tstruct buffer_head *gdb_bh;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\tint err;\n\n\tgdblock = ext4_meta_bg_first_block_no(sb, group) +\n\t\t   ext4_bg_has_super(sb, group);\n\tgdb_bh = sb_bread(sb, gdblock);\n\tif (!gdb_bh)\n\t\treturn -EIO;\n\tn_group_desc = ext4_kvmalloc((gdb_num + 1) *\n\t\t\t\t     sizeof(struct buffer_head *),\n\t\t\t\t     GFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\treturn err;\n\t}\n\n\to_group_desc = EXT4_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = gdb_bh;\n\tEXT4_SB(sb)->s_group_desc = n_group_desc;\n\tEXT4_SB(sb)->s_gdb_count++;\n\tkvfree(o_group_desc);\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (unlikely(err))\n\t\tbrelse(gdb_bh);\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "gdb_bh"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "gdb_bh"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdb_bh",
            "\"get_write_access\""
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "o_group_desc"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n_group_desc",
            "o_group_desc",
            "EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"not enough memory for %lu groups\"",
            "gdb_num + 1"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_kvmalloc",
          "args": [
            "(gdb_num + 1) *\n\t\t\t\t     sizeof(struct buffer_head *)",
            "GFP_NOFS"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "159-167",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "gdblock"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "group"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_meta_bg_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_meta_bg_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "66-70",
          "snippet": "static ext4_fsblk_t ext4_meta_bg_first_block_no(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\tgroup = ext4_meta_bg_first_group(sb, group);\n\treturn ext4_group_first_block_no(sb, group);\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_fsblk_t ext4_meta_bg_first_block_no(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\tgroup = ext4_meta_bg_first_group(sb, group);\n\treturn ext4_group_first_block_no(sb, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int add_new_gdb_meta_bg(struct super_block *sb,\n\t\t\t       handle_t *handle, ext4_group_t group) {\n\text4_fsblk_t gdblock;\n\tstruct buffer_head *gdb_bh;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\tint err;\n\n\tgdblock = ext4_meta_bg_first_block_no(sb, group) +\n\t\t   ext4_bg_has_super(sb, group);\n\tgdb_bh = sb_bread(sb, gdblock);\n\tif (!gdb_bh)\n\t\treturn -EIO;\n\tn_group_desc = ext4_kvmalloc((gdb_num + 1) *\n\t\t\t\t     sizeof(struct buffer_head *),\n\t\t\t\t     GFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\treturn err;\n\t}\n\n\to_group_desc = EXT4_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = gdb_bh;\n\tEXT4_SB(sb)->s_group_desc = n_group_desc;\n\tEXT4_SB(sb)->s_gdb_count++;\n\tkvfree(o_group_desc);\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (unlikely(err))\n\t\tbrelse(gdb_bh);\n\treturn err;\n}"
  },
  {
    "function_name": "add_new_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "753-878",
    "snippet": "static int add_new_gdb(handle_t *handle, struct inode *inode,\n\t\t       ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_fsblk_t gdblock = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tstruct buffer_head *dind;\n\tstruct buffer_head *gdb_bh;\n\tint gdbackups;\n\tstruct ext4_iloc iloc;\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       \"EXT4-fs: ext4_add_new_gdb: adding group block %lu\\n\",\n\t\t       gdb_num);\n\n\tgdb_bh = sb_bread(sb, gdblock);\n\tif (!gdb_bh)\n\t\treturn -EIO;\n\n\tgdbackups = verify_reserved_gdb(sb, group, gdb_bh);\n\tif (gdbackups < 0) {\n\t\terr = gdbackups;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT4_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text4_warning(sb, \"new group %u GDT block %llu not reserved\",\n\t\t\t     group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto exit_dind;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (unlikely(err))\n\t\tgoto exit_dind;\n\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (unlikely(err))\n\t\tgoto exit_dind;\n\n\tBUFFER_TRACE(dind, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dind);\n\tif (unlikely(err))\n\t\text4_std_error(sb, err);\n\n\t/* ext4_reserve_inode_write() gets a reference on the iloc */\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (unlikely(err))\n\t\tgoto exit_dind;\n\n\tn_group_desc = ext4_kvmalloc((gdb_num + 1) *\n\t\t\t\t     sizeof(struct buffer_head *),\n\t\t\t\t     GFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\tgoto exit_inode;\n\t}\n\n\t/*\n\t * Finally, we have all of the possible failures behind us...\n\t *\n\t * Remove new GDT block from inode double-indirect block and clear out\n\t * the new GDT block for use (which also \"frees\" the backup GDT blocks\n\t * from the reserved inode).  We don't need to change the bitmaps for\n\t * these blocks, because they are marked as in-use from being in the\n\t * reserved inode, and will become GDT blocks (primary and backup).\n\t */\n\tdata[gdb_num % EXT4_ADDR_PER_BLOCK(sb)] = 0;\n\terr = ext4_handle_dirty_metadata(handle, NULL, dind);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tgoto exit_inode;\n\t}\n\tinode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\tmemset(gdb_bh->b_data, 0, sb->s_blocksize);\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tgoto exit_inode;\n\t}\n\tbrelse(dind);\n\n\to_group_desc = EXT4_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = gdb_bh;\n\tEXT4_SB(sb)->s_group_desc = n_group_desc;\n\tEXT4_SB(sb)->s_gdb_count++;\n\tkvfree(o_group_desc);\n\n\tle16_add_cpu(&es->s_reserved_gdt_blocks, -1);\n\terr = ext4_handle_dirty_super(handle, sb);\n\tif (err)\n\t\text4_std_error(sb, err);\n\n\treturn err;\n\nexit_inode:\n\tkvfree(n_group_desc);\n\tbrelse(iloc.bh);\nexit_dind:\n\tbrelse(dind);\nexit_bh:\n\tbrelse(gdb_bh);\n\n\text4_debug(\"leaving with error %d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"leaving with error %d\\n\"",
            "err"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "gdb_bh"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "n_group_desc"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "sb"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&es->s_reserved_gdt_blocks",
            "-1"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "o_group_desc"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n_group_desc",
            "o_group_desc",
            "EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "gdb_bh"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "gdb_bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "dind"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"not enough memory for %lu groups\"",
            "gdb_num + 1"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_kvmalloc",
          "args": [
            "(gdb_num + 1) *\n\t\t\t\t     sizeof(struct buffer_head *)",
            "GFP_NOFS"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "159-167",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4822-4839",
          "snippet": "int\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "dind"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "dind",
            "\"get_write_access\""
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "gdb_bh"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdb_bh",
            "\"get_write_access\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "EXT4_SB(sb)->s_sbh"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "EXT4_SB(sb)->s_sbh",
            "\"get_write_access\""
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"new group %u GDT block %llu not reserved\"",
            "group",
            "gdblock"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "data[gdb_num % EXT4_ADDR_PER_BLOCK(sb)]"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "le32_to_cpu(*data)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_reserved_gdb",
          "args": [
            "sb",
            "group",
            "gdb_bh"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "verify_reserved_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "710-738",
          "snippet": "static int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       ext4_group_t end,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext4_fsblk_t blk = primary->b_blocknr;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) !=\n\t\t    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text4_warning(sb, \"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT4_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       ext4_group_t end,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext4_fsblk_t blk = primary->b_blocknr;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) !=\n\t\t    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text4_warning(sb, \"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT4_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "gdblock"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t       \"EXT4-fs: ext4_add_new_gdb: adding group block %lu\\n\"",
            "gdb_num"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int add_new_gdb(handle_t *handle, struct inode *inode,\n\t\t       ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_fsblk_t gdblock = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tstruct buffer_head *dind;\n\tstruct buffer_head *gdb_bh;\n\tint gdbackups;\n\tstruct ext4_iloc iloc;\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       \"EXT4-fs: ext4_add_new_gdb: adding group block %lu\\n\",\n\t\t       gdb_num);\n\n\tgdb_bh = sb_bread(sb, gdblock);\n\tif (!gdb_bh)\n\t\treturn -EIO;\n\n\tgdbackups = verify_reserved_gdb(sb, group, gdb_bh);\n\tif (gdbackups < 0) {\n\t\terr = gdbackups;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT4_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text4_warning(sb, \"new group %u GDT block %llu not reserved\",\n\t\t\t     group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto exit_dind;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\tif (unlikely(err))\n\t\tgoto exit_dind;\n\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdb_bh);\n\tif (unlikely(err))\n\t\tgoto exit_dind;\n\n\tBUFFER_TRACE(dind, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dind);\n\tif (unlikely(err))\n\t\text4_std_error(sb, err);\n\n\t/* ext4_reserve_inode_write() gets a reference on the iloc */\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (unlikely(err))\n\t\tgoto exit_dind;\n\n\tn_group_desc = ext4_kvmalloc((gdb_num + 1) *\n\t\t\t\t     sizeof(struct buffer_head *),\n\t\t\t\t     GFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\tgoto exit_inode;\n\t}\n\n\t/*\n\t * Finally, we have all of the possible failures behind us...\n\t *\n\t * Remove new GDT block from inode double-indirect block and clear out\n\t * the new GDT block for use (which also \"frees\" the backup GDT blocks\n\t * from the reserved inode).  We don't need to change the bitmaps for\n\t * these blocks, because they are marked as in-use from being in the\n\t * reserved inode, and will become GDT blocks (primary and backup).\n\t */\n\tdata[gdb_num % EXT4_ADDR_PER_BLOCK(sb)] = 0;\n\terr = ext4_handle_dirty_metadata(handle, NULL, dind);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tgoto exit_inode;\n\t}\n\tinode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\tmemset(gdb_bh->b_data, 0, sb->s_blocksize);\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tgoto exit_inode;\n\t}\n\tbrelse(dind);\n\n\to_group_desc = EXT4_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = gdb_bh;\n\tEXT4_SB(sb)->s_group_desc = n_group_desc;\n\tEXT4_SB(sb)->s_gdb_count++;\n\tkvfree(o_group_desc);\n\n\tle16_add_cpu(&es->s_reserved_gdt_blocks, -1);\n\terr = ext4_handle_dirty_super(handle, sb);\n\tif (err)\n\t\text4_std_error(sb, err);\n\n\treturn err;\n\nexit_inode:\n\tkvfree(n_group_desc);\n\tbrelse(iloc.bh);\nexit_dind:\n\tbrelse(dind);\nexit_bh:\n\tbrelse(gdb_bh);\n\n\text4_debug(\"leaving with error %d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "verify_reserved_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "710-738",
    "snippet": "static int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       ext4_group_t end,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext4_fsblk_t blk = primary->b_blocknr;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) !=\n\t\t    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text4_warning(sb, \"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT4_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\"",
            "blk",
            "grp",
            "grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p++"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_list_backups",
          "args": [
            "sb",
            "&three",
            "&five",
            "&seven"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_list_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "676-703",
          "snippet": "static unsigned ext4_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic unsigned ext4_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       ext4_group_t end,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext4_fsblk_t blk = primary->b_blocknr;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) !=\n\t\t    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text4_warning(sb, \"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT4_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}"
  },
  {
    "function_name": "ext4_list_backups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "676-703",
    "snippet": "static unsigned ext4_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic unsigned ext4_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_new_flex_group_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "473-667",
    "snippet": "static int setup_new_flex_group_blocks(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tint group_table_count[] = {1, 1, EXT4_SB(sb)->s_itb_per_group};\n\text4_fsblk_t start;\n\text4_fsblk_t block;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\t__u16 *bg_flags = flex_gd->bg_flags;\n\thandle_t *handle;\n\text4_group_t group, count;\n\tstruct buffer_head *bh = NULL;\n\tint reserved_gdb, i, j, err = 0, err2;\n\tint meta_bg;\n\n\tBUG_ON(!flex_gd->count || !group_data ||\n\t       group_data[0].group != sbi->s_groups_count);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tgroup = group_data[0].group;\n\tfor (i = 0; i < flex_gd->count; i++, group++) {\n\t\tunsigned long gdblocks;\n\t\text4_grpblk_t overhead;\n\n\t\tgdblocks = ext4_bg_num_gdb(sb, group);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\n\t\tif (meta_bg == 0 && !ext4_bg_has_super(sb, group))\n\t\t\tgoto handle_itb;\n\n\t\tif (meta_bg == 1) {\n\t\t\text4_group_t first_group;\n\t\t\tfirst_group = ext4_meta_bg_first_group(sb, group);\n\t\t\tif (first_group != group + 1 &&\n\t\t\t    first_group != group + EXT4_DESC_PER_BLOCK(sb) - 1)\n\t\t\t\tgoto handle_itb;\n\t\t}\n\n\t\tblock = start + ext4_bg_has_super(sb, group);\n\t\t/* Copy all of the GDT blocks into the backup in this group */\n\t\tfor (j = 0; j < gdblocks; j++, block++) {\n\t\t\tstruct buffer_head *gdb;\n\n\t\t\text4_debug(\"update backup group %#04llx\\n\", block);\n\t\t\terr = extend_or_restart_transaction(handle, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tgdb = sb_getblk(sb, block);\n\t\t\tif (unlikely(!gdb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUFFER_TRACE(gdb, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb);\n\t\t\tif (err) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gdb->b_data, sbi->s_group_desc[j]->b_data,\n\t\t\t       gdb->b_size);\n\t\t\tset_buffer_uptodate(gdb);\n\n\t\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbrelse(gdb);\n\t\t}\n\n\t\t/* Zero out all of the reserved backup group descriptor\n\t\t * table blocks\n\t\t */\n\t\tif (ext4_bg_has_super(sb, group)) {\n\t\t\terr = sb_issue_zeroout(sb, gdblocks + start + 1,\n\t\t\t\t\treserved_gdb, GFP_NOFS);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\nhandle_itb:\n\t\t/* Initialize group tables of the grop @group */\n\t\tif (!(bg_flags[i] & EXT4_BG_INODE_ZEROED))\n\t\t\tgoto handle_bb;\n\n\t\t/* Zero out all of the inode table blocks */\n\t\tblock = group_data[i].inode_table;\n\t\text4_debug(\"clear inode table blocks %#04llx -> %#04lx\\n\",\n\t\t\t   block, sbi->s_itb_per_group);\n\t\terr = sb_issue_zeroout(sb, block, sbi->s_itb_per_group,\n\t\t\t\t       GFP_NOFS);\n\t\tif (err)\n\t\t\tgoto out;\n\nhandle_bb:\n\t\tif (bg_flags[i] & EXT4_BG_BLOCK_UNINIT)\n\t\t\tgoto handle_ib;\n\n\t\t/* Initialize block bitmap of the @group */\n\t\tblock = group_data[i].block_bitmap;\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\toverhead = ext4_group_overhead_blocks(sb, group);\n\t\tif (overhead != 0) {\n\t\t\text4_debug(\"mark backup superblock %#04llx (+0)\\n\",\n\t\t\t\t   start);\n\t\t\text4_set_bits(bh->b_data, 0, overhead);\n\t\t}\n\t\text4_mark_bitmap_end(group_data[i].blocks_count,\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbrelse(bh);\n\nhandle_ib:\n\t\tif (bg_flags[i] & EXT4_BG_INODE_UNINIT)\n\t\t\tcontinue;\n\n\t\t/* Initialize inode bitmap of the @group */\n\t\tblock = group_data[i].inode_bitmap;\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t/* Mark unused entries in inode bitmap used */\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbrelse(bh);\n\t}\n\tbh = NULL;\n\n\t/* Mark group tables in block bitmap */\n\tfor (j = 0; j < GROUP_TABLE_COUNT; j++) {\n\t\tcount = group_table_count[j];\n\t\tstart = (&group_data[0].block_bitmap)[j];\n\t\tblock = start;\n\t\tfor (i = 1; i < flex_gd->count; i++) {\n\t\t\tblock += group_table_count[j];\n\t\t\tif (block == (&group_data[i].block_bitmap)[j]) {\n\t\t\t\tcount += group_table_count[j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\tflex_gd, start, count);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tcount = group_table_count[j];\n\t\t\tstart = (&group_data[i].block_bitmap)[j];\n\t\t\tblock = start;\n\t\t}\n\n\t\tif (count) {\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\tflex_gd, start, count);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbrelse(bh);\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_flexbg_block_bitmap",
          "args": [
            "sb",
            "handle",
            "flex_gd",
            "start",
            "count"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "set_flexbg_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "408-457",
          "snippet": "static int set_flexbg_block_bitmap(struct super_block *sb, handle_t *handle,\n\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\text4_fsblk_t block, ext4_group_t count)\n{\n\text4_group_t count2;\n\n\text4_debug(\"mark blocks [%llu/%u] used\\n\", block, count);\n\tfor (count2 = count; count > 0; count -= count2, block += count2) {\n\t\text4_fsblk_t start;\n\t\tstruct buffer_head *bh;\n\t\text4_group_t group;\n\t\tint err;\n\n\t\tgroup = ext4_get_group_number(sb, block);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\t\tgroup -= flex_gd->groups[0].group;\n\n\t\tcount2 = EXT4_BLOCKS_PER_GROUP(sb) - (block - start);\n\t\tif (count2 > count)\n\t\t\tcount2 = count;\n\n\t\tif (flex_gd->bg_flags[group] & EXT4_BG_BLOCK_UNINIT) {\n\t\t\tBUG_ON(flex_gd->count > 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbh = sb_getblk(sb, flex_gd->groups[group].block_bitmap);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\treturn err;\n\t\text4_debug(\"mark block bitmap %#04llx (+%llu/%u)\\n\", block,\n\t\t\t   block - start, count2);\n\t\text4_set_bits(bh->b_data, block - start, count2);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int set_flexbg_block_bitmap(struct super_block *sb, handle_t *handle,\n\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\text4_fsblk_t block, ext4_group_t count)\n{\n\text4_group_t count2;\n\n\text4_debug(\"mark blocks [%llu/%u] used\\n\", block, count);\n\tfor (count2 = count; count > 0; count -= count2, block += count2) {\n\t\text4_fsblk_t start;\n\t\tstruct buffer_head *bh;\n\t\text4_group_t group;\n\t\tint err;\n\n\t\tgroup = ext4_get_group_number(sb, block);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\t\tgroup -= flex_gd->groups[0].group;\n\n\t\tcount2 = EXT4_BLOCKS_PER_GROUP(sb) - (block - start);\n\t\tif (count2 > count)\n\t\t\tcount2 = count;\n\n\t\tif (flex_gd->bg_flags[group] & EXT4_BG_BLOCK_UNINIT) {\n\t\t\tBUG_ON(flex_gd->count > 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbh = sb_getblk(sb, flex_gd->groups[group].block_bitmap);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\treturn err;\n\t\text4_debug(\"mark block bitmap %#04llx (+%llu/%u)\\n\", block,\n\t\t\t   block - start, count2);\n\t\text4_set_bits(bh->b_data, block - start, count2);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bh"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_bitmap_end",
          "args": [
            "EXT4_INODES_PER_GROUP(sb)",
            "sb->s_blocksize * 8",
            "bh->b_data"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_bitmap_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ialloc.c",
          "lines": "53-65",
          "snippet": "void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text4_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text4_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bitops.h>",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <asm/byteorder.h>\n#include <linux/blkdev.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text4_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text4_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bclean",
          "args": [
            "handle",
            "sb",
            "block"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "bclean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "354-373",
          "snippet": "static struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext4_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tif ((err = ext4_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\treturn bh;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext4_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tif ((err = ext4_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extend_or_restart_transaction",
          "args": [
            "handle",
            "1"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "extend_or_restart_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "380-397",
          "snippet": "static int extend_or_restart_transaction(handle_t *handle, int thresh)\n{\n\tint err;\n\n\tif (ext4_handle_has_enough_credits(handle, thresh))\n\t\treturn 0;\n\n\terr = ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int extend_or_restart_transaction(handle_t *handle, int thresh)\n{\n\tint err;\n\n\tif (ext4_handle_has_enough_credits(handle, thresh))\n\t\treturn 0;\n\n\terr = ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bh"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bits",
          "args": [
            "bh->b_data",
            "0",
            "overhead"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1314-1330",
          "snippet": "void ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"mark backup superblock %#04llx (+0)\\n\"",
            "start"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_overhead_blocks",
          "args": [
            "sb",
            "group"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_overhead_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "72-80",
          "snippet": "static ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_issue_zeroout",
          "args": [
            "sb",
            "block",
            "sbi->s_itb_per_group",
            "GFP_NOFS"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"clear inode table blocks %#04llx -> %#04lx\\n\"",
            "block",
            "sbi->s_itb_per_group"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_issue_zeroout",
          "args": [
            "sb",
            "gdblocks + start + 1",
            "reserved_gdb",
            "GFP_NOFS"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "group"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "gdb"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "gdb"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "gdb->b_data",
            "sbi->s_group_desc[j]->b_data",
            "gdb->b_size"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "gdb"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdb",
            "\"get_write_access\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!gdb"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"update backup group %#04llx\\n\"",
            "block"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_meta_bg_first_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_meta_bg_first_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "60-64",
          "snippet": "static ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_num_gdb",
          "args": [
            "sb",
            "group"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "797-809",
          "snippet": "unsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nunsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start_sb",
          "args": [
            "sb",
            "EXT4_HT_RESIZE",
            "EXT4_MAX_TRANS_DATA"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_reserved_gdt_blocks"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!flex_gd->count || !group_data ||\n\t       group_data[0].group != sbi->s_groups_count"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int setup_new_flex_group_blocks(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tint group_table_count[] = {1, 1, EXT4_SB(sb)->s_itb_per_group};\n\text4_fsblk_t start;\n\text4_fsblk_t block;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\t__u16 *bg_flags = flex_gd->bg_flags;\n\thandle_t *handle;\n\text4_group_t group, count;\n\tstruct buffer_head *bh = NULL;\n\tint reserved_gdb, i, j, err = 0, err2;\n\tint meta_bg;\n\n\tBUG_ON(!flex_gd->count || !group_data ||\n\t       group_data[0].group != sbi->s_groups_count);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\tmeta_bg = EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG);\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tgroup = group_data[0].group;\n\tfor (i = 0; i < flex_gd->count; i++, group++) {\n\t\tunsigned long gdblocks;\n\t\text4_grpblk_t overhead;\n\n\t\tgdblocks = ext4_bg_num_gdb(sb, group);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\n\t\tif (meta_bg == 0 && !ext4_bg_has_super(sb, group))\n\t\t\tgoto handle_itb;\n\n\t\tif (meta_bg == 1) {\n\t\t\text4_group_t first_group;\n\t\t\tfirst_group = ext4_meta_bg_first_group(sb, group);\n\t\t\tif (first_group != group + 1 &&\n\t\t\t    first_group != group + EXT4_DESC_PER_BLOCK(sb) - 1)\n\t\t\t\tgoto handle_itb;\n\t\t}\n\n\t\tblock = start + ext4_bg_has_super(sb, group);\n\t\t/* Copy all of the GDT blocks into the backup in this group */\n\t\tfor (j = 0; j < gdblocks; j++, block++) {\n\t\t\tstruct buffer_head *gdb;\n\n\t\t\text4_debug(\"update backup group %#04llx\\n\", block);\n\t\t\terr = extend_or_restart_transaction(handle, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tgdb = sb_getblk(sb, block);\n\t\t\tif (unlikely(!gdb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUFFER_TRACE(gdb, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, gdb);\n\t\t\tif (err) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gdb->b_data, sbi->s_group_desc[j]->b_data,\n\t\t\t       gdb->b_size);\n\t\t\tset_buffer_uptodate(gdb);\n\n\t\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbrelse(gdb);\n\t\t}\n\n\t\t/* Zero out all of the reserved backup group descriptor\n\t\t * table blocks\n\t\t */\n\t\tif (ext4_bg_has_super(sb, group)) {\n\t\t\terr = sb_issue_zeroout(sb, gdblocks + start + 1,\n\t\t\t\t\treserved_gdb, GFP_NOFS);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\nhandle_itb:\n\t\t/* Initialize group tables of the grop @group */\n\t\tif (!(bg_flags[i] & EXT4_BG_INODE_ZEROED))\n\t\t\tgoto handle_bb;\n\n\t\t/* Zero out all of the inode table blocks */\n\t\tblock = group_data[i].inode_table;\n\t\text4_debug(\"clear inode table blocks %#04llx -> %#04lx\\n\",\n\t\t\t   block, sbi->s_itb_per_group);\n\t\terr = sb_issue_zeroout(sb, block, sbi->s_itb_per_group,\n\t\t\t\t       GFP_NOFS);\n\t\tif (err)\n\t\t\tgoto out;\n\nhandle_bb:\n\t\tif (bg_flags[i] & EXT4_BG_BLOCK_UNINIT)\n\t\t\tgoto handle_ib;\n\n\t\t/* Initialize block bitmap of the @group */\n\t\tblock = group_data[i].block_bitmap;\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\toverhead = ext4_group_overhead_blocks(sb, group);\n\t\tif (overhead != 0) {\n\t\t\text4_debug(\"mark backup superblock %#04llx (+0)\\n\",\n\t\t\t\t   start);\n\t\t\text4_set_bits(bh->b_data, 0, overhead);\n\t\t}\n\t\text4_mark_bitmap_end(group_data[i].blocks_count,\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbrelse(bh);\n\nhandle_ib:\n\t\tif (bg_flags[i] & EXT4_BG_INODE_UNINIT)\n\t\t\tcontinue;\n\n\t\t/* Initialize inode bitmap of the @group */\n\t\tblock = group_data[i].inode_bitmap;\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t/* Mark unused entries in inode bitmap used */\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbrelse(bh);\n\t}\n\tbh = NULL;\n\n\t/* Mark group tables in block bitmap */\n\tfor (j = 0; j < GROUP_TABLE_COUNT; j++) {\n\t\tcount = group_table_count[j];\n\t\tstart = (&group_data[0].block_bitmap)[j];\n\t\tblock = start;\n\t\tfor (i = 1; i < flex_gd->count; i++) {\n\t\t\tblock += group_table_count[j];\n\t\t\tif (block == (&group_data[i].block_bitmap)[j]) {\n\t\t\t\tcount += group_table_count[j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\tflex_gd, start, count);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tcount = group_table_count[j];\n\t\t\tstart = (&group_data[i].block_bitmap)[j];\n\t\t\tblock = start;\n\t\t}\n\n\t\tif (count) {\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\tflex_gd, start, count);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbrelse(bh);\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\treturn err;\n}"
  },
  {
    "function_name": "set_flexbg_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "408-457",
    "snippet": "static int set_flexbg_block_bitmap(struct super_block *sb, handle_t *handle,\n\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\text4_fsblk_t block, ext4_group_t count)\n{\n\text4_group_t count2;\n\n\text4_debug(\"mark blocks [%llu/%u] used\\n\", block, count);\n\tfor (count2 = count; count > 0; count -= count2, block += count2) {\n\t\text4_fsblk_t start;\n\t\tstruct buffer_head *bh;\n\t\text4_group_t group;\n\t\tint err;\n\n\t\tgroup = ext4_get_group_number(sb, block);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\t\tgroup -= flex_gd->groups[0].group;\n\n\t\tcount2 = EXT4_BLOCKS_PER_GROUP(sb) - (block - start);\n\t\tif (count2 > count)\n\t\t\tcount2 = count;\n\n\t\tif (flex_gd->bg_flags[group] & EXT4_BG_BLOCK_UNINIT) {\n\t\t\tBUG_ON(flex_gd->count > 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbh = sb_getblk(sb, flex_gd->groups[group].block_bitmap);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\treturn err;\n\t\text4_debug(\"mark block bitmap %#04llx (+%llu/%u)\\n\", block,\n\t\t\t   block - start, count2);\n\t\text4_set_bits(bh->b_data, block - start, count2);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bh"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bits",
          "args": [
            "bh->b_data",
            "block - start",
            "count2"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1314-1330",
          "snippet": "void ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"mark block bitmap %#04llx (+%llu/%u)\\n\"",
            "block",
            "block - start",
            "count2"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "flex_gd->groups[group].block_bitmap"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extend_or_restart_transaction",
          "args": [
            "handle",
            "1"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "extend_or_restart_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "380-397",
          "snippet": "static int extend_or_restart_transaction(handle_t *handle, int thresh)\n{\n\tint err;\n\n\tif (ext4_handle_has_enough_credits(handle, thresh))\n\t\treturn 0;\n\n\terr = ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int extend_or_restart_transaction(handle_t *handle, int thresh)\n{\n\tint err;\n\n\tif (ext4_handle_has_enough_credits(handle, thresh))\n\t\treturn 0;\n\n\terr = ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flex_gd->count > 1"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_number",
          "args": [
            "sb",
            "block"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "35-47",
          "snippet": "ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"mark blocks [%llu/%u] used\\n\"",
            "block",
            "count"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int set_flexbg_block_bitmap(struct super_block *sb, handle_t *handle,\n\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\text4_fsblk_t block, ext4_group_t count)\n{\n\text4_group_t count2;\n\n\text4_debug(\"mark blocks [%llu/%u] used\\n\", block, count);\n\tfor (count2 = count; count > 0; count -= count2, block += count2) {\n\t\text4_fsblk_t start;\n\t\tstruct buffer_head *bh;\n\t\text4_group_t group;\n\t\tint err;\n\n\t\tgroup = ext4_get_group_number(sb, block);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\t\tgroup -= flex_gd->groups[0].group;\n\n\t\tcount2 = EXT4_BLOCKS_PER_GROUP(sb) - (block - start);\n\t\tif (count2 > count)\n\t\t\tcount2 = count;\n\n\t\tif (flex_gd->bg_flags[group] & EXT4_BG_BLOCK_UNINIT) {\n\t\t\tBUG_ON(flex_gd->count > 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = extend_or_restart_transaction(handle, 1);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbh = sb_getblk(sb, flex_gd->groups[group].block_bitmap);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\treturn err;\n\t\text4_debug(\"mark block bitmap %#04llx (+%llu/%u)\\n\", block,\n\t\t\t   block - start, count2);\n\t\text4_set_bits(bh->b_data, block - start, count2);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "extend_or_restart_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "380-397",
    "snippet": "static int extend_or_restart_transaction(handle_t *handle, int thresh)\n{\n\tint err;\n\n\tif (ext4_handle_has_enough_credits(handle, thresh))\n\t\treturn 0;\n\n\terr = ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_restart",
          "args": [
            "handle",
            "EXT4_MAX_TRANS_DATA"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "343-348",
          "snippet": "static inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_extend",
          "args": [
            "handle",
            "EXT4_MAX_TRANS_DATA"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "336-341",
          "snippet": "static inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_has_enough_credits",
          "args": [
            "handle",
            "thresh"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_has_enough_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "292-297",
          "snippet": "static inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int extend_or_restart_transaction(handle_t *handle, int thresh)\n{\n\tint err;\n\n\tif (ext4_handle_has_enough_credits(handle, thresh))\n\t\treturn 0;\n\n\terr = ext4_journal_extend(handle, EXT4_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext4_journal_restart(handle, EXT4_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bclean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "354-373",
    "snippet": "static struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext4_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tif ((err = ext4_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\treturn bh;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "blk"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext4_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tif ((err = ext4_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\treturn bh;\n}"
  },
  {
    "function_name": "ext4_alloc_group_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "244-352",
    "snippet": "static int ext4_alloc_group_tables(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\t\tint flexbg_size)\n{\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t start_blk;\n\text4_fsblk_t last_blk;\n\text4_group_t src_group;\n\text4_group_t bb_index = 0;\n\text4_group_t ib_index = 0;\n\text4_group_t it_index = 0;\n\text4_group_t group;\n\text4_group_t last_group;\n\tunsigned overhead;\n\t__u16 uninit_mask = (flexbg_size > 1) ? ~EXT4_BG_BLOCK_UNINIT : ~0;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\n\tsrc_group = group_data[0].group;\n\tlast_group  = src_group + flex_gd->count - 1;\n\n\tBUG_ON((flexbg_size > 1) && ((src_group & ~(flexbg_size - 1)) !=\n\t       (last_group & ~(flexbg_size - 1))));\nnext_group:\n\tgroup = group_data[0].group;\n\tif (src_group >= group_data[0].group + flex_gd->count)\n\t\treturn -ENOSPC;\n\tstart_blk = ext4_group_first_block_no(sb, src_group);\n\tlast_blk = start_blk + group_data[src_group - group].blocks_count;\n\n\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\n\tstart_blk += overhead;\n\n\t/* We collect contiguous blocks as much as possible. */\n\tsrc_group++;\n\tfor (; src_group <= last_group; src_group++) {\n\t\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\t\tif (overhead == 0)\n\t\t\tlast_blk += group_data[src_group - group].blocks_count;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* Allocate block bitmaps */\n\tfor (; bb_index < flex_gd->count; bb_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[bb_index].block_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].free_blocks_count--;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode bitmaps */\n\tfor (; ib_index < flex_gd->count; ib_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[ib_index].inode_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].free_blocks_count--;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode tables */\n\tfor (; it_index < flex_gd->count; it_index++) {\n\t\tunsigned int itb = EXT4_SB(sb)->s_itb_per_group;\n\t\text4_fsblk_t next_group_start;\n\n\t\tif (start_blk + itb > last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[it_index].inode_table = start_blk;\n\t\tgroup = ext4_get_group_number(sb, start_blk);\n\t\tnext_group_start = ext4_group_first_block_no(sb, group + 1);\n\t\tgroup -= group_data[0].group;\n\n\t\tif (start_blk + itb > next_group_start) {\n\t\t\tflex_gd->bg_flags[group + 1] &= uninit_mask;\n\t\t\toverhead = start_blk + itb - next_group_start;\n\t\t\tgroup_data[group + 1].free_blocks_count -= overhead;\n\t\t\titb -= overhead;\n\t\t}\n\n\t\tgroup_data[group].free_blocks_count -= itb;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t\tstart_blk += EXT4_SB(sb)->s_itb_per_group;\n\t}\n\n\tif (test_opt(sb, DEBUG)) {\n\t\tint i;\n\t\tgroup = group_data[0].group;\n\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding a flex group with \"\n\t\t       \"%d groups, flexbg size is %d:\\n\", flex_gd->count,\n\t\t       flexbg_size);\n\n\t\tfor (i = 0; i < flex_gd->count; i++) {\n\t\t\tprintk(KERN_DEBUG \"adding %s group %u: %u \"\n\t\t\t       \"blocks (%d free)\\n\",\n\t\t\t       ext4_bg_has_super(sb, group + i) ? \"normal\" :\n\t\t\t       \"no-super\", group + i,\n\t\t\t       group_data[i].blocks_count,\n\t\t\t       group_data[i].free_blocks_count);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"adding %s group %u: %u \"\n\t\t\t       \"blocks (%d free)\\n\"",
            "ext4_bg_has_super(sb, group + i) ? \"normal\" :\n\t\t\t       \"no-super\"",
            "group + i",
            "group_data[i].blocks_count",
            "group_data[i].free_blocks_count"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "group + i"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "group + 1"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_number",
          "args": [
            "sb",
            "start_blk"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "35-47",
          "snippet": "ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_overhead_blocks",
          "args": [
            "sb",
            "src_group"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_overhead_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "72-80",
          "snippet": "static ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(flexbg_size > 1) && ((src_group & ~(flexbg_size - 1)) !=\n\t       (last_group & ~(flexbg_size - 1)))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flex_gd->count == 0 || group_data == NULL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int ext4_alloc_group_tables(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\t\tint flexbg_size)\n{\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t start_blk;\n\text4_fsblk_t last_blk;\n\text4_group_t src_group;\n\text4_group_t bb_index = 0;\n\text4_group_t ib_index = 0;\n\text4_group_t it_index = 0;\n\text4_group_t group;\n\text4_group_t last_group;\n\tunsigned overhead;\n\t__u16 uninit_mask = (flexbg_size > 1) ? ~EXT4_BG_BLOCK_UNINIT : ~0;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\n\tsrc_group = group_data[0].group;\n\tlast_group  = src_group + flex_gd->count - 1;\n\n\tBUG_ON((flexbg_size > 1) && ((src_group & ~(flexbg_size - 1)) !=\n\t       (last_group & ~(flexbg_size - 1))));\nnext_group:\n\tgroup = group_data[0].group;\n\tif (src_group >= group_data[0].group + flex_gd->count)\n\t\treturn -ENOSPC;\n\tstart_blk = ext4_group_first_block_no(sb, src_group);\n\tlast_blk = start_blk + group_data[src_group - group].blocks_count;\n\n\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\n\tstart_blk += overhead;\n\n\t/* We collect contiguous blocks as much as possible. */\n\tsrc_group++;\n\tfor (; src_group <= last_group; src_group++) {\n\t\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\t\tif (overhead == 0)\n\t\t\tlast_blk += group_data[src_group - group].blocks_count;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* Allocate block bitmaps */\n\tfor (; bb_index < flex_gd->count; bb_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[bb_index].block_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].free_blocks_count--;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode bitmaps */\n\tfor (; ib_index < flex_gd->count; ib_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[ib_index].inode_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].free_blocks_count--;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t/* Allocate inode tables */\n\tfor (; it_index < flex_gd->count; it_index++) {\n\t\tunsigned int itb = EXT4_SB(sb)->s_itb_per_group;\n\t\text4_fsblk_t next_group_start;\n\n\t\tif (start_blk + itb > last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[it_index].inode_table = start_blk;\n\t\tgroup = ext4_get_group_number(sb, start_blk);\n\t\tnext_group_start = ext4_group_first_block_no(sb, group + 1);\n\t\tgroup -= group_data[0].group;\n\n\t\tif (start_blk + itb > next_group_start) {\n\t\t\tflex_gd->bg_flags[group + 1] &= uninit_mask;\n\t\t\toverhead = start_blk + itb - next_group_start;\n\t\t\tgroup_data[group + 1].free_blocks_count -= overhead;\n\t\t\titb -= overhead;\n\t\t}\n\n\t\tgroup_data[group].free_blocks_count -= itb;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t\tstart_blk += EXT4_SB(sb)->s_itb_per_group;\n\t}\n\n\tif (test_opt(sb, DEBUG)) {\n\t\tint i;\n\t\tgroup = group_data[0].group;\n\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding a flex group with \"\n\t\t       \"%d groups, flexbg size is %d:\\n\", flex_gd->count,\n\t\t       flexbg_size);\n\n\t\tfor (i = 0; i < flex_gd->count; i++) {\n\t\t\tprintk(KERN_DEBUG \"adding %s group %u: %u \"\n\t\t\t       \"blocks (%d free)\\n\",\n\t\t\t       ext4_bg_has_super(sb, group + i) ? \"normal\" :\n\t\t\t       \"no-super\", group + i,\n\t\t\t       group_data[i].blocks_count,\n\t\t\t       group_data[i].free_blocks_count);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_flex_gd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "224-229",
    "snippet": "static void free_flex_gd(struct ext4_new_flex_group_data *flex_gd)\n{\n\tkfree(flex_gd->bg_flags);\n\tkfree(flex_gd->groups);\n\tkfree(flex_gd);\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "flex_gd"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "flex_gd->groups"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "flex_gd->bg_flags"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic void free_flex_gd(struct ext4_new_flex_group_data *flex_gd)\n{\n\tkfree(flex_gd->bg_flags);\n\tkfree(flex_gd->groups);\n\tkfree(flex_gd);\n}"
  },
  {
    "function_name": "alloc_flex_gd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "193-222",
    "snippet": "static struct ext4_new_flex_group_data *alloc_flex_gd(unsigned long flexbg_size)\n{\n\tstruct ext4_new_flex_group_data *flex_gd;\n\n\tflex_gd = kmalloc(sizeof(*flex_gd), GFP_NOFS);\n\tif (flex_gd == NULL)\n\t\tgoto out3;\n\n\tif (flexbg_size >= UINT_MAX / sizeof(struct ext4_new_flex_group_data))\n\t\tgoto out2;\n\tflex_gd->count = flexbg_size;\n\n\tflex_gd->groups = kmalloc(sizeof(struct ext4_new_group_data) *\n\t\t\t\t  flexbg_size, GFP_NOFS);\n\tif (flex_gd->groups == NULL)\n\t\tgoto out2;\n\n\tflex_gd->bg_flags = kmalloc(flexbg_size * sizeof(__u16), GFP_NOFS);\n\tif (flex_gd->bg_flags == NULL)\n\t\tgoto out1;\n\n\treturn flex_gd;\n\nout1:\n\tkfree(flex_gd->groups);\nout2:\n\tkfree(flex_gd);\nout3:\n\treturn NULL;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "flex_gd"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "flex_gd->groups"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "flexbg_size * sizeof(__u16)",
            "GFP_NOFS"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct ext4_new_flex_group_data *alloc_flex_gd(unsigned long flexbg_size)\n{\n\tstruct ext4_new_flex_group_data *flex_gd;\n\n\tflex_gd = kmalloc(sizeof(*flex_gd), GFP_NOFS);\n\tif (flex_gd == NULL)\n\t\tgoto out3;\n\n\tif (flexbg_size >= UINT_MAX / sizeof(struct ext4_new_flex_group_data))\n\t\tgoto out2;\n\tflex_gd->count = flexbg_size;\n\n\tflex_gd->groups = kmalloc(sizeof(struct ext4_new_group_data) *\n\t\t\t\t  flexbg_size, GFP_NOFS);\n\tif (flex_gd->groups == NULL)\n\t\tgoto out2;\n\n\tflex_gd->bg_flags = kmalloc(flexbg_size * sizeof(__u16), GFP_NOFS);\n\tif (flex_gd->bg_flags == NULL)\n\t\tgoto out1;\n\n\treturn flex_gd;\n\nout1:\n\tkfree(flex_gd->groups);\nout2:\n\tkfree(flex_gd);\nout3:\n\treturn NULL;\n}"
  },
  {
    "function_name": "verify_group_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "85-172",
    "snippet": "static int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t start = ext4_blocks_count(es);\n\text4_fsblk_t end = start + input->blocks_count;\n\text4_group_t group = input->group;\n\text4_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead;\n\text4_fsblk_t metaend;\n\tstruct buffer_head *bh = NULL;\n\text4_grpblk_t free_blocks_count, offset;\n\tint err = -EINVAL;\n\n\tif (group != sbi->s_groups_count) {\n\t\text4_warning(sb, \"Cannot add at group %u (only %u groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\t\treturn -EINVAL;\n\t}\n\n\toverhead = ext4_group_overhead_blocks(sb, group);\n\tmetaend = start + overhead;\n\tinput->free_blocks_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext4_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\text4_get_group_no_and_offset(sb, start, NULL, &offset);\n\tif (offset != 0)\n\t\t\text4_warning(sb, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text4_warning(sb, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text4_warning(sb, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (!(bh = sb_bread(sb, end - 1)))\n\t\text4_warning(sb, \"Cannot read last block (%llu)\",\n\t\t\t     end - 1);\n\telse if (outside(input->block_bitmap, start, end))\n\t\text4_warning(sb, \"Block bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text4_warning(sb, \"Inode bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t\t outside(itend - 1, start, end))\n\t\text4_warning(sb, \"Inode table not in group (blocks %llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text4_warning(sb, \"Block bitmap same as inode bitmap (%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t\t inside(itend - 1, start, metaend))\n\t\text4_warning(sb, \"Inode table (%llu-%llu) overlaps GDT table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table,\n\t\t\t     itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Inode table (%llu-%llu) overlaps GDT table \"\n\t\t\t     \"(%llu-%llu)\"",
            "(unsigned long long)input->inode_table",
            "itend - 1",
            "start",
            "metaend - 1"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "itend - 1",
            "start",
            "metaend"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->inode_table",
            "start",
            "metaend"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->inode_bitmap",
            "start",
            "metaend"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->block_bitmap",
            "start",
            "metaend"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->inode_bitmap",
            "input->inode_table",
            "itend"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->block_bitmap",
            "input->inode_table",
            "itend"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Block bitmap same as inode bitmap (%llu)\"",
            "(unsigned long long)input->block_bitmap"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outside",
          "args": [
            "itend - 1",
            "start",
            "end"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outside",
          "args": [
            "input->inode_table",
            "start",
            "end"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Inode bitmap not in group (block %llu)\"",
            "(unsigned long long)input->inode_bitmap"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outside",
          "args": [
            "input->inode_bitmap",
            "start",
            "end"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Block bitmap not in group (block %llu)\"",
            "(unsigned long long)input->block_bitmap"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outside",
          "args": [
            "input->block_bitmap",
            "start",
            "end"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Cannot read last block (%llu)\"",
            "end - 1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "end - 1"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Bad blocks count %u\"",
            "input->blocks_count"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Reserved blocks too high (%u)\"",
            "input->reserved_blocks"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"Last group not full\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "start",
            "NULL",
            "&offset"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"EXT4-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\"",
            "ext4_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\"",
            "input->group",
            "input->blocks_count",
            "free_blocks_count",
            "input->reserved_blocks"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "input->group"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_overhead_blocks",
          "args": [
            "sb",
            "group"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_overhead_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "72-80",
          "snippet": "static ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t start = ext4_blocks_count(es);\n\text4_fsblk_t end = start + input->blocks_count;\n\text4_group_t group = input->group;\n\text4_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead;\n\text4_fsblk_t metaend;\n\tstruct buffer_head *bh = NULL;\n\text4_grpblk_t free_blocks_count, offset;\n\tint err = -EINVAL;\n\n\tif (group != sbi->s_groups_count) {\n\t\text4_warning(sb, \"Cannot add at group %u (only %u groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\t\treturn -EINVAL;\n\t}\n\n\toverhead = ext4_group_overhead_blocks(sb, group);\n\tmetaend = start + overhead;\n\tinput->free_blocks_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext4_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\text4_get_group_no_and_offset(sb, start, NULL, &offset);\n\tif (offset != 0)\n\t\t\text4_warning(sb, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text4_warning(sb, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text4_warning(sb, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (!(bh = sb_bread(sb, end - 1)))\n\t\text4_warning(sb, \"Cannot read last block (%llu)\",\n\t\t\t     end - 1);\n\telse if (outside(input->block_bitmap, start, end))\n\t\text4_warning(sb, \"Block bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text4_warning(sb, \"Inode bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t\t outside(itend - 1, start, end))\n\t\text4_warning(sb, \"Inode table not in group (blocks %llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text4_warning(sb, \"Block bitmap same as inode bitmap (%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t\t inside(itend - 1, start, metaend))\n\t\text4_warning(sb, \"Inode table (%llu-%llu) overlaps GDT table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table,\n\t\t\t     itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_group_overhead_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "72-80",
    "snippet": "static ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_reserved_gdt_blocks"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_has_super",
          "args": [
            "sb",
            "group"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "740-762",
          "snippet": "int ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_SPARSE_SUPER2)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bg_num_gdb",
          "args": [
            "sb",
            "group"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "797-809",
          "snippet": "unsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nunsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}"
  },
  {
    "function_name": "ext4_meta_bg_first_block_no",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "66-70",
    "snippet": "static ext4_fsblk_t ext4_meta_bg_first_block_no(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\tgroup = ext4_meta_bg_first_group(sb, group);\n\treturn ext4_group_first_block_no(sb, group);\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_meta_bg_first_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_meta_bg_first_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
          "lines": "60-64",
          "snippet": "static ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}",
          "includes": [
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_fsblk_t ext4_meta_bg_first_block_no(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\tgroup = ext4_meta_bg_first_group(sb, group);\n\treturn ext4_group_first_block_no(sb, group);\n}"
  },
  {
    "function_name": "ext4_meta_bg_first_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "60-64",
    "snippet": "static ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}"
  },
  {
    "function_name": "ext4_resize_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "54-58",
    "snippet": "void ext4_resize_end(struct super_block *sb)\n{\n\tclear_bit_unlock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags);\n\tsmp_mb__after_atomic();\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "EXT4_RESIZING",
            "&EXT4_SB(sb)->s_resize_flags"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid ext4_resize_end(struct super_block *sb)\n{\n\tclear_bit_unlock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags);\n\tsmp_mb__after_atomic();\n}"
  },
  {
    "function_name": "ext4_resize_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/resize.c",
    "lines": "19-52",
    "snippet": "int ext4_resize_begin(struct super_block *sb)\n{\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n         * because the user tools have no way of handling this.  Probably a\n         * bad time to do it anyways.\n         */\n\tif (EXT4_SB(sb)->s_sbh->b_blocknr !=\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) {\n\t\text4_warning(sb, \"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We are not allowed to do online-resizing on a filesystem mounted\n\t * with error, because it can destroy the filesystem easily.\n\t */\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (test_and_set_bit_lock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags))\n\t\tret = -EBUSY;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_set_bit_lock",
          "args": [
            "EXT4_RESIZING",
            "&EXT4_SB(sb)->s_resize_flags"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\\n\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"won't resize using backup superblock at %llu\"",
            "(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_first_data_block"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint ext4_resize_begin(struct super_block *sb)\n{\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n         * because the user tools have no way of handling this.  Probably a\n         * bad time to do it anyways.\n         */\n\tif (EXT4_SB(sb)->s_sbh->b_blocknr !=\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) {\n\t\text4_warning(sb, \"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * We are not allowed to do online-resizing on a filesystem mounted\n\t * with error, because it can destroy the filesystem easily.\n\t */\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (test_and_set_bit_lock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags))\n\t\tret = -EBUSY;\n\n\treturn ret;\n}"
  }
]