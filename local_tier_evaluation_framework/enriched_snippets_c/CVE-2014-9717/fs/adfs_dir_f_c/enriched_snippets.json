[
  {
    "function_name": "adfs_f_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "465-477",
    "snippet": "static void\nadfs_f_free(struct adfs_dir *dir)\n{\n\tint i;\n\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--) {\n\t\tbrelse(dir->bh[i]);\n\t\tdir->bh[i] = NULL;\n\t}\n\n\tdir->nr_buffers = 0;\n\tdir->sb = NULL;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dir->bh[i]"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic void\nadfs_f_free(struct adfs_dir *dir)\n{\n\tint i;\n\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--) {\n\t\tbrelse(dir->bh[i]);\n\t\tdir->bh[i] = NULL;\n\t}\n\n\tdir->nr_buffers = 0;\n\tdir->sb = NULL;\n}"
  },
  {
    "function_name": "adfs_f_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "449-463",
    "snippet": "static int\nadfs_f_sync(struct adfs_dir *dir)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--) {\n\t\tstruct buffer_head *bh = dir->bh[i];\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_f_sync(struct adfs_dir *dir)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--) {\n\t\tstruct buffer_head *bh = dir->bh[i];\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "adfs_f_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "391-447",
    "snippet": "static int\nadfs_f_update(struct adfs_dir *dir, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tint ret, i;\n\n\tret = adfs_dir_find_entry(dir, obj->file_id);\n\tif (ret < 0) {\n\t\tadfs_error(dir->sb, \"unable to locate entry to update\");\n\t\tgoto out;\n\t}\n\n\t__adfs_dir_put(dir, ret, obj);\n \n\t/*\n\t * Increment directory sequence number\n\t */\n\tdir->bh[0]->b_data[0] += 1;\n\tdir->bh[dir->nr_buffers - 1]->b_data[sb->s_blocksize - 6] += 1;\n\n\tret = adfs_dir_checkbyte(dir);\n\t/*\n\t * Update directory check byte\n\t */\n\tdir->bh[dir->nr_buffers - 1]->b_data[sb->s_blocksize - 1] = ret;\n\n#if 1\n\t{\n\tconst unsigned int blocksize_bits = sb->s_blocksize_bits;\n\n\tmemcpy(&dir->dirhead, bufoff(dir->bh, 0), sizeof(dir->dirhead));\n\tmemcpy(&dir->dirtail, bufoff(dir->bh, 2007), sizeof(dir->dirtail));\n\n\tif (dir->dirhead.startmasseq != dir->dirtail.new.endmasseq ||\n\t    memcmp(&dir->dirhead.startname, &dir->dirtail.new.endname, 4))\n\t\tgoto bad_dir;\n\n\tif (memcmp(&dir->dirhead.startname, \"Nick\", 4) &&\n\t    memcmp(&dir->dirhead.startname, \"Hugo\", 4))\n\t\tgoto bad_dir;\n\n\tif (adfs_dir_checkbyte(dir) != dir->dirtail.new.dircheckbyte)\n\t\tgoto bad_dir;\n\t}\n#endif\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--)\n\t\tmark_buffer_dirty(dir->bh[i]);\n\n\tret = 0;\nout:\n\treturn ret;\n#if 1\nbad_dir:\n\tadfs_error(dir->sb, \"whoops!  I broke a directory!\");\n\treturn -EIO;\n#endif\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "dir->sb",
            "\"whoops!  I broke a directory!\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "dir->bh[i]"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_dir_checkbyte",
          "args": [
            "dir"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_dir_checkbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "84-137",
          "snippet": "static u8\nadfs_dir_checkbyte(const struct adfs_dir *dir)\n{\n\tstruct buffer_head * const *bh = dir->bh;\n\tconst int blocksize_bits = dir->sb->s_blocksize_bits;\n\tunion { __le32 *ptr32; u8 *ptr8; } ptr, end;\n\tu32 dircheck = 0;\n\tint last = 5 - 26;\n\tint i = 0;\n\n\t/*\n\t * Accumulate each word up to the last whole\n\t * word of the last directory entry.  This\n\t * can spread across several buffer heads.\n\t */\n\tdo {\n\t\tlast += 26;\n\t\tdo {\n\t\t\tdircheck = le32_to_cpu(dir_u32(i)) ^ ror13(dircheck);\n\n\t\t\ti += sizeof(u32);\n\t\t} while (i < (last & ~3));\n\t} while (dir_u8(last) != 0);\n\n\t/*\n\t * Accumulate the last few bytes.  These\n\t * bytes will be within the same bh.\n\t */\n\tif (i != last) {\n\t\tptr.ptr8 = bufoff(bh, i);\n\t\tend.ptr8 = ptr.ptr8 + last - i;\n\n\t\tdo {\n\t\t\tdircheck = *ptr.ptr8++ ^ ror13(dircheck);\n\t\t} while (ptr.ptr8 < end.ptr8);\n\t}\n\n\t/*\n\t * The directory tail is in the final bh\n\t * Note that contary to the RISC OS PRMs,\n\t * the first few bytes are NOT included\n\t * in the check.  All bytes are in the\n\t * same bh.\n\t */\n\tptr.ptr8 = bufoff(bh, 2008);\n\tend.ptr8 = ptr.ptr8 + 36;\n\n\tdo {\n\t\t__le32 v = *ptr.ptr32++;\n\t\tdircheck = le32_to_cpu(v) ^ ror13(dircheck);\n\t} while (ptr.ptr32 < end.ptr32);\n\n\treturn (dircheck ^ (dircheck >> 8) ^ (dircheck >> 16) ^ (dircheck >> 24)) & 0xff;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adfs_f_free(struct adfs_dir *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic u8\nadfs_dir_checkbyte(const struct adfs_dir *dir)\n{\n\tstruct buffer_head * const *bh = dir->bh;\n\tconst int blocksize_bits = dir->sb->s_blocksize_bits;\n\tunion { __le32 *ptr32; u8 *ptr8; } ptr, end;\n\tu32 dircheck = 0;\n\tint last = 5 - 26;\n\tint i = 0;\n\n\t/*\n\t * Accumulate each word up to the last whole\n\t * word of the last directory entry.  This\n\t * can spread across several buffer heads.\n\t */\n\tdo {\n\t\tlast += 26;\n\t\tdo {\n\t\t\tdircheck = le32_to_cpu(dir_u32(i)) ^ ror13(dircheck);\n\n\t\t\ti += sizeof(u32);\n\t\t} while (i < (last & ~3));\n\t} while (dir_u8(last) != 0);\n\n\t/*\n\t * Accumulate the last few bytes.  These\n\t * bytes will be within the same bh.\n\t */\n\tif (i != last) {\n\t\tptr.ptr8 = bufoff(bh, i);\n\t\tend.ptr8 = ptr.ptr8 + last - i;\n\n\t\tdo {\n\t\t\tdircheck = *ptr.ptr8++ ^ ror13(dircheck);\n\t\t} while (ptr.ptr8 < end.ptr8);\n\t}\n\n\t/*\n\t * The directory tail is in the final bh\n\t * Note that contary to the RISC OS PRMs,\n\t * the first few bytes are NOT included\n\t * in the check.  All bytes are in the\n\t * same bh.\n\t */\n\tptr.ptr8 = bufoff(bh, 2008);\n\tend.ptr8 = ptr.ptr8 + 36;\n\n\tdo {\n\t\t__le32 v = *ptr.ptr32++;\n\t\tdircheck = le32_to_cpu(v) ^ ror13(dircheck);\n\t} while (ptr.ptr32 < end.ptr32);\n\n\treturn (dircheck ^ (dircheck >> 8) ^ (dircheck >> 16) ^ (dircheck >> 24)) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&dir->dirhead.startname",
            "\"Hugo\"",
            "4"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&dir->dirhead.startname",
            "\"Nick\"",
            "4"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&dir->dirhead.startname",
            "&dir->dirtail.new.endname",
            "4"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dir->dirtail",
            "bufoff(dir->bh, 2007)",
            "sizeof(dir->dirtail)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufoff",
          "args": [
            "dir->bh",
            "2007"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dir->dirhead",
            "bufoff(dir->bh, 0)",
            "sizeof(dir->dirhead)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufoff",
          "args": [
            "dir->bh",
            "0"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__adfs_dir_put",
          "args": [
            "dir",
            "ret",
            "obj"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_dir_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "285-324",
          "snippet": "static int\n__adfs_dir_put(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\t/*\n\t * Get the entry in total\n\t */\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\t/*\n\t * update it\n\t */\n\tadfs_obj2dir(&de, obj);\n\n\t/*\n\t * Put the new entry back\n\t */\n\tmemcpy(dir->bh[buffer]->b_data + offset, &de, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(dir->bh[buffer + 1]->b_data, ((char *)&de) + thissize,\n\t\t       26 - thissize);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adfs_f_free(struct adfs_dir *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\n__adfs_dir_put(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\t/*\n\t * Get the entry in total\n\t */\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\t/*\n\t * update it\n\t */\n\tadfs_obj2dir(&de, obj);\n\n\t/*\n\t * Put the new entry back\n\t */\n\tmemcpy(dir->bh[buffer]->b_data + offset, &de, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(dir->bh[buffer + 1]->b_data, ((char *)&de) + thissize,\n\t\t       26 - thissize);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "dir->sb",
            "\"unable to locate entry to update\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_dir_find_entry",
          "args": [
            "dir",
            "obj->file_id"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_dir_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "330-350",
          "snippet": "static int\nadfs_dir_find_entry(struct adfs_dir *dir, unsigned long object_id)\n{\n\tint pos, ret;\n\n\tret = -ENOENT;\n\n\tfor (pos = 5; pos < ADFS_NUM_DIR_ENTRIES * 26 + 5; pos += 26) {\n\t\tstruct object_info obj;\n\n\t\tif (!__adfs_dir_get(dir, pos, &obj))\n\t\t\tbreak;\n\n\t\tif (obj.file_id == object_id) {\n\t\t\tret = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adfs_f_free(struct adfs_dir *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_dir_find_entry(struct adfs_dir *dir, unsigned long object_id)\n{\n\tint pos, ret;\n\n\tret = -ENOENT;\n\n\tfor (pos = 5; pos < ADFS_NUM_DIR_ENTRIES * 26 + 5; pos += 26) {\n\t\tstruct object_info obj;\n\n\t\tif (!__adfs_dir_get(dir, pos, &obj))\n\t\t\tbreak;\n\n\t\tif (obj.file_id == object_id) {\n\t\t\tret = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_f_update(struct adfs_dir *dir, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tint ret, i;\n\n\tret = adfs_dir_find_entry(dir, obj->file_id);\n\tif (ret < 0) {\n\t\tadfs_error(dir->sb, \"unable to locate entry to update\");\n\t\tgoto out;\n\t}\n\n\t__adfs_dir_put(dir, ret, obj);\n \n\t/*\n\t * Increment directory sequence number\n\t */\n\tdir->bh[0]->b_data[0] += 1;\n\tdir->bh[dir->nr_buffers - 1]->b_data[sb->s_blocksize - 6] += 1;\n\n\tret = adfs_dir_checkbyte(dir);\n\t/*\n\t * Update directory check byte\n\t */\n\tdir->bh[dir->nr_buffers - 1]->b_data[sb->s_blocksize - 1] = ret;\n\n#if 1\n\t{\n\tconst unsigned int blocksize_bits = sb->s_blocksize_bits;\n\n\tmemcpy(&dir->dirhead, bufoff(dir->bh, 0), sizeof(dir->dirhead));\n\tmemcpy(&dir->dirtail, bufoff(dir->bh, 2007), sizeof(dir->dirtail));\n\n\tif (dir->dirhead.startmasseq != dir->dirtail.new.endmasseq ||\n\t    memcmp(&dir->dirhead.startname, &dir->dirtail.new.endname, 4))\n\t\tgoto bad_dir;\n\n\tif (memcmp(&dir->dirhead.startname, \"Nick\", 4) &&\n\t    memcmp(&dir->dirhead.startname, \"Hugo\", 4))\n\t\tgoto bad_dir;\n\n\tif (adfs_dir_checkbyte(dir) != dir->dirtail.new.dircheckbyte)\n\t\tgoto bad_dir;\n\t}\n#endif\n\tfor (i = dir->nr_buffers - 1; i >= 0; i--)\n\t\tmark_buffer_dirty(dir->bh[i]);\n\n\tret = 0;\nout:\n\treturn ret;\n#if 1\nbad_dir:\n\tadfs_error(dir->sb, \"whoops!  I broke a directory!\");\n\treturn -EIO;\n#endif\n}"
  },
  {
    "function_name": "adfs_f_getnext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "379-389",
    "snippet": "static int\nadfs_f_getnext(struct adfs_dir *dir, struct object_info *obj)\n{\n\tunsigned int ret;\n\n\tret = __adfs_dir_get(dir, dir->pos, obj);\n\tif (ret == 0)\n\t\tdir->pos += 26;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__adfs_dir_get",
          "args": [
            "dir",
            "dir->pos",
            "obj"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_dir_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "255-283",
          "snippet": "static int\n__adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\tif (!de.dirobname[0])\n\t\treturn -ENOENT;\n\n\tadfs_dir2obj(dir, obj, &de);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adfs_f_free(struct adfs_dir *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\n__adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\tif (!de.dirobname[0])\n\t\treturn -ENOENT;\n\n\tadfs_dir2obj(dir, obj, &de);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_f_getnext(struct adfs_dir *dir, struct object_info *obj)\n{\n\tunsigned int ret;\n\n\tret = __adfs_dir_get(dir, dir->pos, obj);\n\tif (ret == 0)\n\t\tdir->pos += 26;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "adfs_f_setpos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "369-377",
    "snippet": "static int\nadfs_f_setpos(struct adfs_dir *dir, unsigned int fpos)\n{\n\tif (fpos >= ADFS_NUM_DIR_ENTRIES)\n\t\treturn -ENOENT;\n\n\tdir->pos = 5 + fpos * 26;\n\treturn 0;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_f_setpos(struct adfs_dir *dir, unsigned int fpos)\n{\n\tif (fpos >= ADFS_NUM_DIR_ENTRIES)\n\t\treturn -ENOENT;\n\n\tdir->pos = 5 + fpos * 26;\n\treturn 0;\n}"
  },
  {
    "function_name": "adfs_f_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "352-367",
    "snippet": "static int\nadfs_f_read(struct super_block *sb, unsigned int id, unsigned int sz, struct adfs_dir *dir)\n{\n\tint ret;\n\n\tif (sz != ADFS_NEWDIR_SIZE)\n\t\treturn -EIO;\n\n\tret = adfs_dir_read(sb, id, sz, dir);\n\tif (ret)\n\t\tadfs_error(sb, \"unable to read directory\");\n\telse\n\t\tdir->parent_id = adfs_readval(dir->dirtail.new.dirparent, 3);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adfs_readval",
          "args": [
            "dir->dirtail.new.dirparent",
            "3"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_readval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "21-32",
          "snippet": "static inline unsigned int adfs_readval(unsigned char *p, int len)\n{\n\tunsigned int val = 0;\n\n\tswitch (len) {\n\tcase 4:\t\tval |= p[3] << 24;\n\tcase 3:\t\tval |= p[2] << 16;\n\tcase 2:\t\tval |= p[1] << 8;\n\tdefault:\tval |= p[0];\n\t}\n\treturn val;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline unsigned int adfs_readval(unsigned char *p, int len)\n{\n\tunsigned int val = 0;\n\n\tswitch (len) {\n\tcase 4:\t\tval |= p[3] << 24;\n\tcase 3:\t\tval |= p[2] << 16;\n\tcase 2:\t\tval |= p[1] << 8;\n\tdefault:\tval |= p[0];\n\t}\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"unable to read directory\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_dir_read",
          "args": [
            "sb",
            "id",
            "sz",
            "dir"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_dir_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "142-204",
          "snippet": "static int\nadfs_dir_read(struct super_block *sb, unsigned long object_id,\n\t      unsigned int size, struct adfs_dir *dir)\n{\n\tconst unsigned int blocksize_bits = sb->s_blocksize_bits;\n\tint blk = 0;\n\n\t/*\n\t * Directories which are not a multiple of 2048 bytes\n\t * are considered bad v2 [3.6]\n\t */\n\tif (size & 2047)\n\t\tgoto bad_dir;\n\n\tsize >>= blocksize_bits;\n\n\tdir->nr_buffers = 0;\n\tdir->sb = sb;\n\n\tfor (blk = 0; blk < size; blk++) {\n\t\tint phys;\n\n\t\tphys = __adfs_block_map(sb, object_id, blk);\n\t\tif (!phys) {\n\t\t\tadfs_error(sb, \"dir object %lX has a hole at offset %d\",\n\t\t\t\t   object_id, blk);\n\t\t\tgoto release_buffers;\n\t\t}\n\n\t\tdir->bh[blk] = sb_bread(sb, phys);\n\t\tif (!dir->bh[blk])\n\t\t\tgoto release_buffers;\n\t}\n\n\tmemcpy(&dir->dirhead, bufoff(dir->bh, 0), sizeof(dir->dirhead));\n\tmemcpy(&dir->dirtail, bufoff(dir->bh, 2007), sizeof(dir->dirtail));\n\n\tif (dir->dirhead.startmasseq != dir->dirtail.new.endmasseq ||\n\t    memcmp(&dir->dirhead.startname, &dir->dirtail.new.endname, 4))\n\t\tgoto bad_dir;\n\n\tif (memcmp(&dir->dirhead.startname, \"Nick\", 4) &&\n\t    memcmp(&dir->dirhead.startname, \"Hugo\", 4))\n\t\tgoto bad_dir;\n\n\tif (adfs_dir_checkbyte(dir) != dir->dirtail.new.dircheckbyte)\n\t\tgoto bad_dir;\n\n\tdir->nr_buffers = blk;\n\n\treturn 0;\n\nbad_dir:\n\tadfs_error(sb, \"corrupted directory fragment %lX\",\n\t\t   object_id);\nrelease_buffers:\n\tfor (blk -= 1; blk >= 0; blk -= 1)\n\t\tbrelse(dir->bh[blk]);\n\n\tdir->sb = NULL;\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adfs_f_free(struct adfs_dir *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_dir_read(struct super_block *sb, unsigned long object_id,\n\t      unsigned int size, struct adfs_dir *dir)\n{\n\tconst unsigned int blocksize_bits = sb->s_blocksize_bits;\n\tint blk = 0;\n\n\t/*\n\t * Directories which are not a multiple of 2048 bytes\n\t * are considered bad v2 [3.6]\n\t */\n\tif (size & 2047)\n\t\tgoto bad_dir;\n\n\tsize >>= blocksize_bits;\n\n\tdir->nr_buffers = 0;\n\tdir->sb = sb;\n\n\tfor (blk = 0; blk < size; blk++) {\n\t\tint phys;\n\n\t\tphys = __adfs_block_map(sb, object_id, blk);\n\t\tif (!phys) {\n\t\t\tadfs_error(sb, \"dir object %lX has a hole at offset %d\",\n\t\t\t\t   object_id, blk);\n\t\t\tgoto release_buffers;\n\t\t}\n\n\t\tdir->bh[blk] = sb_bread(sb, phys);\n\t\tif (!dir->bh[blk])\n\t\t\tgoto release_buffers;\n\t}\n\n\tmemcpy(&dir->dirhead, bufoff(dir->bh, 0), sizeof(dir->dirhead));\n\tmemcpy(&dir->dirtail, bufoff(dir->bh, 2007), sizeof(dir->dirtail));\n\n\tif (dir->dirhead.startmasseq != dir->dirtail.new.endmasseq ||\n\t    memcmp(&dir->dirhead.startname, &dir->dirtail.new.endname, 4))\n\t\tgoto bad_dir;\n\n\tif (memcmp(&dir->dirhead.startname, \"Nick\", 4) &&\n\t    memcmp(&dir->dirhead.startname, \"Hugo\", 4))\n\t\tgoto bad_dir;\n\n\tif (adfs_dir_checkbyte(dir) != dir->dirtail.new.dircheckbyte)\n\t\tgoto bad_dir;\n\n\tdir->nr_buffers = blk;\n\n\treturn 0;\n\nbad_dir:\n\tadfs_error(sb, \"corrupted directory fragment %lX\",\n\t\t   object_id);\nrelease_buffers:\n\tfor (blk -= 1; blk >= 0; blk -= 1)\n\t\tbrelse(dir->bh[blk]);\n\n\tdir->sb = NULL;\n\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_f_read(struct super_block *sb, unsigned int id, unsigned int sz, struct adfs_dir *dir)\n{\n\tint ret;\n\n\tif (sz != ADFS_NEWDIR_SIZE)\n\t\treturn -EIO;\n\n\tret = adfs_dir_read(sb, id, sz, dir);\n\tif (ret)\n\t\tadfs_error(sb, \"unable to read directory\");\n\telse\n\t\tdir->parent_id = adfs_readval(dir->dirtail.new.dirparent, 3);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "adfs_dir_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "330-350",
    "snippet": "static int\nadfs_dir_find_entry(struct adfs_dir *dir, unsigned long object_id)\n{\n\tint pos, ret;\n\n\tret = -ENOENT;\n\n\tfor (pos = 5; pos < ADFS_NUM_DIR_ENTRIES * 26 + 5; pos += 26) {\n\t\tstruct object_info obj;\n\n\t\tif (!__adfs_dir_get(dir, pos, &obj))\n\t\t\tbreak;\n\n\t\tif (obj.file_id == object_id) {\n\t\t\tret = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__adfs_dir_get",
          "args": [
            "dir",
            "pos",
            "&obj"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_dir_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "255-283",
          "snippet": "static int\n__adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\tif (!de.dirobname[0])\n\t\treturn -ENOENT;\n\n\tadfs_dir2obj(dir, obj, &de);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adfs_f_free(struct adfs_dir *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\n__adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\tif (!de.dirobname[0])\n\t\treturn -ENOENT;\n\n\tadfs_dir2obj(dir, obj, &de);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_dir_find_entry(struct adfs_dir *dir, unsigned long object_id)\n{\n\tint pos, ret;\n\n\tret = -ENOENT;\n\n\tfor (pos = 5; pos < ADFS_NUM_DIR_ENTRIES * 26 + 5; pos += 26) {\n\t\tstruct object_info obj;\n\n\t\tif (!__adfs_dir_get(dir, pos, &obj))\n\t\t\tbreak;\n\n\t\tif (obj.file_id == object_id) {\n\t\t\tret = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__adfs_dir_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "285-324",
    "snippet": "static int\n__adfs_dir_put(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\t/*\n\t * Get the entry in total\n\t */\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\t/*\n\t * update it\n\t */\n\tadfs_obj2dir(&de, obj);\n\n\t/*\n\t * Put the new entry back\n\t */\n\tmemcpy(dir->bh[buffer]->b_data + offset, &de, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(dir->bh[buffer + 1]->b_data, ((char *)&de) + thissize,\n\t\t       26 - thissize);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dir->bh[buffer + 1]->b_data",
            "((char *)&de) + thissize",
            "26 - thissize"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dir->bh[buffer]->b_data + offset",
            "&de",
            "thissize"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_obj2dir",
          "args": [
            "&de",
            "obj"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_obj2dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "241-249",
          "snippet": "static inline void\nadfs_obj2dir(struct adfs_direntry *de, struct object_info *obj)\n{\n\tadfs_writeval(de->dirinddiscadd, 3, obj->file_id);\n\tadfs_writeval(de->dirload, 4, obj->loadaddr);\n\tadfs_writeval(de->direxec, 4, obj->execaddr);\n\tadfs_writeval(de->dirlen,  4, obj->size);\n\tde->newdiratts = obj->attr;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline void\nadfs_obj2dir(struct adfs_direntry *de, struct object_info *obj)\n{\n\tadfs_writeval(de->dirinddiscadd, 3, obj->file_id);\n\tadfs_writeval(de->dirload, 4, obj->loadaddr);\n\tadfs_writeval(de->direxec, 4, obj->execaddr);\n\tadfs_writeval(de->dirlen,  4, obj->size);\n\tde->newdiratts = obj->attr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "((char *)&de) + thissize",
            "dir->bh[buffer + 1]->b_data",
            "26 - thissize"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&de",
            "dir->bh[buffer]->b_data + offset",
            "thissize"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\n__adfs_dir_put(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\t/*\n\t * Get the entry in total\n\t */\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\t/*\n\t * update it\n\t */\n\tadfs_obj2dir(&de, obj);\n\n\t/*\n\t * Put the new entry back\n\t */\n\tmemcpy(dir->bh[buffer]->b_data + offset, &de, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(dir->bh[buffer + 1]->b_data, ((char *)&de) + thissize,\n\t\t       26 - thissize);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__adfs_dir_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "255-283",
    "snippet": "static int\n__adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\tif (!de.dirobname[0])\n\t\treturn -ENOENT;\n\n\tadfs_dir2obj(dir, obj, &de);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adfs_dir2obj",
          "args": [
            "dir",
            "obj",
            "&de"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_dir2obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "209-236",
          "snippet": "static inline void\nadfs_dir2obj(struct adfs_dir *dir, struct object_info *obj,\n\tstruct adfs_direntry *de)\n{\n\tobj->name_len =\tadfs_readname(obj->name, de->dirobname, ADFS_F_NAME_LEN);\n\tobj->file_id  = adfs_readval(de->dirinddiscadd, 3);\n\tobj->loadaddr = adfs_readval(de->dirload, 4);\n\tobj->execaddr = adfs_readval(de->direxec, 4);\n\tobj->size     = adfs_readval(de->dirlen,  4);\n\tobj->attr     = de->newdiratts;\n\tobj->filetype = -1;\n\n\t/*\n\t * object is a file and is filetyped and timestamped?\n\t * RISC OS 12-bit filetype is stored in load_address[19:8]\n\t */\n\tif ((0 == (obj->attr & ADFS_NDA_DIRECTORY)) &&\n\t\t(0xfff00000 == (0xfff00000 & obj->loadaddr))) {\n\t\tobj->filetype = (__u16) ((0x000fff00 & obj->loadaddr) >> 8);\n\n\t\t/* optionally append the ,xyz hex filetype suffix */\n\t\tif (ADFS_SB(dir->sb)->s_ftsuffix)\n\t\t\tobj->name_len +=\n\t\t\t\tappend_filetype_suffix(\n\t\t\t\t\t&obj->name[obj->name_len],\n\t\t\t\t\tobj->filetype);\n\t}\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adfs_f_free(struct adfs_dir *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic inline void\nadfs_dir2obj(struct adfs_dir *dir, struct object_info *obj,\n\tstruct adfs_direntry *de)\n{\n\tobj->name_len =\tadfs_readname(obj->name, de->dirobname, ADFS_F_NAME_LEN);\n\tobj->file_id  = adfs_readval(de->dirinddiscadd, 3);\n\tobj->loadaddr = adfs_readval(de->dirload, 4);\n\tobj->execaddr = adfs_readval(de->direxec, 4);\n\tobj->size     = adfs_readval(de->dirlen,  4);\n\tobj->attr     = de->newdiratts;\n\tobj->filetype = -1;\n\n\t/*\n\t * object is a file and is filetyped and timestamped?\n\t * RISC OS 12-bit filetype is stored in load_address[19:8]\n\t */\n\tif ((0 == (obj->attr & ADFS_NDA_DIRECTORY)) &&\n\t\t(0xfff00000 == (0xfff00000 & obj->loadaddr))) {\n\t\tobj->filetype = (__u16) ((0x000fff00 & obj->loadaddr) >> 8);\n\n\t\t/* optionally append the ,xyz hex filetype suffix */\n\t\tif (ADFS_SB(dir->sb)->s_ftsuffix)\n\t\t\tobj->name_len +=\n\t\t\t\tappend_filetype_suffix(\n\t\t\t\t\t&obj->name[obj->name_len],\n\t\t\t\t\tobj->filetype);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "((char *)&de) + thissize",
            "dir->bh[buffer + 1]->b_data",
            "26 - thissize"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&de",
            "dir->bh[buffer]->b_data + offset",
            "thissize"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\n__adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)\n{\n\tstruct super_block *sb = dir->sb;\n\tstruct adfs_direntry de;\n\tint thissize, buffer, offset;\n\n\tbuffer = pos >> sb->s_blocksize_bits;\n\n\tif (buffer > dir->nr_buffers)\n\t\treturn -EINVAL;\n\n\toffset = pos & (sb->s_blocksize - 1);\n\tthissize = sb->s_blocksize - offset;\n\tif (thissize > 26)\n\t\tthissize = 26;\n\n\tmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\n\tif (thissize != 26)\n\t\tmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\n\t\t       26 - thissize);\n\n\tif (!de.dirobname[0])\n\t\treturn -ENOENT;\n\n\tadfs_dir2obj(dir, obj, &de);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "adfs_obj2dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "241-249",
    "snippet": "static inline void\nadfs_obj2dir(struct adfs_direntry *de, struct object_info *obj)\n{\n\tadfs_writeval(de->dirinddiscadd, 3, obj->file_id);\n\tadfs_writeval(de->dirload, 4, obj->loadaddr);\n\tadfs_writeval(de->direxec, 4, obj->execaddr);\n\tadfs_writeval(de->dirlen,  4, obj->size);\n\tde->newdiratts = obj->attr;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adfs_writeval",
          "args": [
            "de->dirlen",
            "4",
            "obj->size"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_writeval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "34-42",
          "snippet": "static inline void adfs_writeval(unsigned char *p, int len, unsigned int val)\n{\n\tswitch (len) {\n\tcase 4:\t\tp[3] = val >> 24;\n\tcase 3:\t\tp[2] = val >> 16;\n\tcase 2:\t\tp[1] = val >> 8;\n\tdefault:\tp[0] = val;\n\t}\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline void adfs_writeval(unsigned char *p, int len, unsigned int val)\n{\n\tswitch (len) {\n\tcase 4:\t\tp[3] = val >> 24;\n\tcase 3:\t\tp[2] = val >> 16;\n\tcase 2:\t\tp[1] = val >> 8;\n\tdefault:\tp[0] = val;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline void\nadfs_obj2dir(struct adfs_direntry *de, struct object_info *obj)\n{\n\tadfs_writeval(de->dirinddiscadd, 3, obj->file_id);\n\tadfs_writeval(de->dirload, 4, obj->loadaddr);\n\tadfs_writeval(de->direxec, 4, obj->execaddr);\n\tadfs_writeval(de->dirlen,  4, obj->size);\n\tde->newdiratts = obj->attr;\n}"
  },
  {
    "function_name": "adfs_dir2obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "209-236",
    "snippet": "static inline void\nadfs_dir2obj(struct adfs_dir *dir, struct object_info *obj,\n\tstruct adfs_direntry *de)\n{\n\tobj->name_len =\tadfs_readname(obj->name, de->dirobname, ADFS_F_NAME_LEN);\n\tobj->file_id  = adfs_readval(de->dirinddiscadd, 3);\n\tobj->loadaddr = adfs_readval(de->dirload, 4);\n\tobj->execaddr = adfs_readval(de->direxec, 4);\n\tobj->size     = adfs_readval(de->dirlen,  4);\n\tobj->attr     = de->newdiratts;\n\tobj->filetype = -1;\n\n\t/*\n\t * object is a file and is filetyped and timestamped?\n\t * RISC OS 12-bit filetype is stored in load_address[19:8]\n\t */\n\tif ((0 == (obj->attr & ADFS_NDA_DIRECTORY)) &&\n\t\t(0xfff00000 == (0xfff00000 & obj->loadaddr))) {\n\t\tobj->filetype = (__u16) ((0x000fff00 & obj->loadaddr) >> 8);\n\n\t\t/* optionally append the ,xyz hex filetype suffix */\n\t\tif (ADFS_SB(dir->sb)->s_ftsuffix)\n\t\t\tobj->name_len +=\n\t\t\t\tappend_filetype_suffix(\n\t\t\t\t\t&obj->name[obj->name_len],\n\t\t\t\t\tobj->filetype);\n\t}\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "append_filetype_suffix",
          "args": [
            "&obj->name[obj->name_len]",
            "obj->filetype"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "append_filetype_suffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "116-126",
          "snippet": "static inline int append_filetype_suffix(char *buf, __u16 filetype)\n{\n\tif (filetype == 0xffff)\t/* no explicit 12-bit file type was set */\n\t\treturn 0;\n\n\t*buf++ = ',';\n\t*buf++ = hex_asc_lo(filetype >> 8);\n\t*buf++ = hex_asc_lo(filetype >> 4);\n\t*buf++ = hex_asc_lo(filetype >> 0);\n\treturn 4;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline int append_filetype_suffix(char *buf, __u16 filetype)\n{\n\tif (filetype == 0xffff)\t/* no explicit 12-bit file type was set */\n\t\treturn 0;\n\n\t*buf++ = ',';\n\t*buf++ = hex_asc_lo(filetype >> 8);\n\t*buf++ = hex_asc_lo(filetype >> 4);\n\t*buf++ = hex_asc_lo(filetype >> 0);\n\treturn 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "dir->sb"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(0x000fff00 & obj->loadaddr) >> 8"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_readval",
          "args": [
            "de->dirlen",
            "4"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_readval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "21-32",
          "snippet": "static inline unsigned int adfs_readval(unsigned char *p, int len)\n{\n\tunsigned int val = 0;\n\n\tswitch (len) {\n\tcase 4:\t\tval |= p[3] << 24;\n\tcase 3:\t\tval |= p[2] << 16;\n\tcase 2:\t\tval |= p[1] << 8;\n\tdefault:\tval |= p[0];\n\t}\n\treturn val;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline unsigned int adfs_readval(unsigned char *p, int len)\n{\n\tunsigned int val = 0;\n\n\tswitch (len) {\n\tcase 4:\t\tval |= p[3] << 24;\n\tcase 3:\t\tval |= p[2] << 16;\n\tcase 2:\t\tval |= p[1] << 8;\n\tdefault:\tval |= p[0];\n\t}\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_readname",
          "args": [
            "obj->name",
            "de->dirobname",
            "ADFS_F_NAME_LEN"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_readname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "44-57",
          "snippet": "static inline int adfs_readname(char *buf, char *ptr, int maxlen)\n{\n\tchar *old_buf = buf;\n\n\twhile ((unsigned char)*ptr >= ' ' && maxlen--) {\n\t\tif (*ptr == '/')\n\t\t\t*buf++ = '.';\n\t\telse\n\t\t\t*buf++ = *ptr;\n\t\tptr++;\n\t}\n\n\treturn buf - old_buf;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline int adfs_readname(char *buf, char *ptr, int maxlen)\n{\n\tchar *old_buf = buf;\n\n\twhile ((unsigned char)*ptr >= ' ' && maxlen--) {\n\t\tif (*ptr == '/')\n\t\t\t*buf++ = '.';\n\t\telse\n\t\t\t*buf++ = *ptr;\n\t\tptr++;\n\t}\n\n\treturn buf - old_buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic inline void\nadfs_dir2obj(struct adfs_dir *dir, struct object_info *obj,\n\tstruct adfs_direntry *de)\n{\n\tobj->name_len =\tadfs_readname(obj->name, de->dirobname, ADFS_F_NAME_LEN);\n\tobj->file_id  = adfs_readval(de->dirinddiscadd, 3);\n\tobj->loadaddr = adfs_readval(de->dirload, 4);\n\tobj->execaddr = adfs_readval(de->direxec, 4);\n\tobj->size     = adfs_readval(de->dirlen,  4);\n\tobj->attr     = de->newdiratts;\n\tobj->filetype = -1;\n\n\t/*\n\t * object is a file and is filetyped and timestamped?\n\t * RISC OS 12-bit filetype is stored in load_address[19:8]\n\t */\n\tif ((0 == (obj->attr & ADFS_NDA_DIRECTORY)) &&\n\t\t(0xfff00000 == (0xfff00000 & obj->loadaddr))) {\n\t\tobj->filetype = (__u16) ((0x000fff00 & obj->loadaddr) >> 8);\n\n\t\t/* optionally append the ,xyz hex filetype suffix */\n\t\tif (ADFS_SB(dir->sb)->s_ftsuffix)\n\t\t\tobj->name_len +=\n\t\t\t\tappend_filetype_suffix(\n\t\t\t\t\t&obj->name[obj->name_len],\n\t\t\t\t\tobj->filetype);\n\t}\n}"
  },
  {
    "function_name": "adfs_dir_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "142-204",
    "snippet": "static int\nadfs_dir_read(struct super_block *sb, unsigned long object_id,\n\t      unsigned int size, struct adfs_dir *dir)\n{\n\tconst unsigned int blocksize_bits = sb->s_blocksize_bits;\n\tint blk = 0;\n\n\t/*\n\t * Directories which are not a multiple of 2048 bytes\n\t * are considered bad v2 [3.6]\n\t */\n\tif (size & 2047)\n\t\tgoto bad_dir;\n\n\tsize >>= blocksize_bits;\n\n\tdir->nr_buffers = 0;\n\tdir->sb = sb;\n\n\tfor (blk = 0; blk < size; blk++) {\n\t\tint phys;\n\n\t\tphys = __adfs_block_map(sb, object_id, blk);\n\t\tif (!phys) {\n\t\t\tadfs_error(sb, \"dir object %lX has a hole at offset %d\",\n\t\t\t\t   object_id, blk);\n\t\t\tgoto release_buffers;\n\t\t}\n\n\t\tdir->bh[blk] = sb_bread(sb, phys);\n\t\tif (!dir->bh[blk])\n\t\t\tgoto release_buffers;\n\t}\n\n\tmemcpy(&dir->dirhead, bufoff(dir->bh, 0), sizeof(dir->dirhead));\n\tmemcpy(&dir->dirtail, bufoff(dir->bh, 2007), sizeof(dir->dirtail));\n\n\tif (dir->dirhead.startmasseq != dir->dirtail.new.endmasseq ||\n\t    memcmp(&dir->dirhead.startname, &dir->dirtail.new.endname, 4))\n\t\tgoto bad_dir;\n\n\tif (memcmp(&dir->dirhead.startname, \"Nick\", 4) &&\n\t    memcmp(&dir->dirhead.startname, \"Hugo\", 4))\n\t\tgoto bad_dir;\n\n\tif (adfs_dir_checkbyte(dir) != dir->dirtail.new.dircheckbyte)\n\t\tgoto bad_dir;\n\n\tdir->nr_buffers = blk;\n\n\treturn 0;\n\nbad_dir:\n\tadfs_error(sb, \"corrupted directory fragment %lX\",\n\t\t   object_id);\nrelease_buffers:\n\tfor (blk -= 1; blk >= 0; blk -= 1)\n\t\tbrelse(dir->bh[blk]);\n\n\tdir->sb = NULL;\n\n\treturn -EIO;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dir->bh[blk]"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"corrupted directory fragment %lX\"",
            "object_id"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "26-38",
          "snippet": "void __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tchar error_buf[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", error_buf);\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tchar error_buf[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_dir_checkbyte",
          "args": [
            "dir"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_dir_checkbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
          "lines": "84-137",
          "snippet": "static u8\nadfs_dir_checkbyte(const struct adfs_dir *dir)\n{\n\tstruct buffer_head * const *bh = dir->bh;\n\tconst int blocksize_bits = dir->sb->s_blocksize_bits;\n\tunion { __le32 *ptr32; u8 *ptr8; } ptr, end;\n\tu32 dircheck = 0;\n\tint last = 5 - 26;\n\tint i = 0;\n\n\t/*\n\t * Accumulate each word up to the last whole\n\t * word of the last directory entry.  This\n\t * can spread across several buffer heads.\n\t */\n\tdo {\n\t\tlast += 26;\n\t\tdo {\n\t\t\tdircheck = le32_to_cpu(dir_u32(i)) ^ ror13(dircheck);\n\n\t\t\ti += sizeof(u32);\n\t\t} while (i < (last & ~3));\n\t} while (dir_u8(last) != 0);\n\n\t/*\n\t * Accumulate the last few bytes.  These\n\t * bytes will be within the same bh.\n\t */\n\tif (i != last) {\n\t\tptr.ptr8 = bufoff(bh, i);\n\t\tend.ptr8 = ptr.ptr8 + last - i;\n\n\t\tdo {\n\t\t\tdircheck = *ptr.ptr8++ ^ ror13(dircheck);\n\t\t} while (ptr.ptr8 < end.ptr8);\n\t}\n\n\t/*\n\t * The directory tail is in the final bh\n\t * Note that contary to the RISC OS PRMs,\n\t * the first few bytes are NOT included\n\t * in the check.  All bytes are in the\n\t * same bh.\n\t */\n\tptr.ptr8 = bufoff(bh, 2008);\n\tend.ptr8 = ptr.ptr8 + 36;\n\n\tdo {\n\t\t__le32 v = *ptr.ptr32++;\n\t\tdircheck = le32_to_cpu(v) ^ ror13(dircheck);\n\t} while (ptr.ptr32 < end.ptr32);\n\n\treturn (dircheck ^ (dircheck >> 8) ^ (dircheck >> 16) ^ (dircheck >> 24)) & 0xff;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adfs_f_free(struct adfs_dir *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic u8\nadfs_dir_checkbyte(const struct adfs_dir *dir)\n{\n\tstruct buffer_head * const *bh = dir->bh;\n\tconst int blocksize_bits = dir->sb->s_blocksize_bits;\n\tunion { __le32 *ptr32; u8 *ptr8; } ptr, end;\n\tu32 dircheck = 0;\n\tint last = 5 - 26;\n\tint i = 0;\n\n\t/*\n\t * Accumulate each word up to the last whole\n\t * word of the last directory entry.  This\n\t * can spread across several buffer heads.\n\t */\n\tdo {\n\t\tlast += 26;\n\t\tdo {\n\t\t\tdircheck = le32_to_cpu(dir_u32(i)) ^ ror13(dircheck);\n\n\t\t\ti += sizeof(u32);\n\t\t} while (i < (last & ~3));\n\t} while (dir_u8(last) != 0);\n\n\t/*\n\t * Accumulate the last few bytes.  These\n\t * bytes will be within the same bh.\n\t */\n\tif (i != last) {\n\t\tptr.ptr8 = bufoff(bh, i);\n\t\tend.ptr8 = ptr.ptr8 + last - i;\n\n\t\tdo {\n\t\t\tdircheck = *ptr.ptr8++ ^ ror13(dircheck);\n\t\t} while (ptr.ptr8 < end.ptr8);\n\t}\n\n\t/*\n\t * The directory tail is in the final bh\n\t * Note that contary to the RISC OS PRMs,\n\t * the first few bytes are NOT included\n\t * in the check.  All bytes are in the\n\t * same bh.\n\t */\n\tptr.ptr8 = bufoff(bh, 2008);\n\tend.ptr8 = ptr.ptr8 + 36;\n\n\tdo {\n\t\t__le32 v = *ptr.ptr32++;\n\t\tdircheck = le32_to_cpu(v) ^ ror13(dircheck);\n\t} while (ptr.ptr32 < end.ptr32);\n\n\treturn (dircheck ^ (dircheck >> 8) ^ (dircheck >> 16) ^ (dircheck >> 24)) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&dir->dirhead.startname",
            "\"Hugo\"",
            "4"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&dir->dirhead.startname",
            "\"Nick\"",
            "4"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&dir->dirhead.startname",
            "&dir->dirtail.new.endname",
            "4"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dir->dirtail",
            "bufoff(dir->bh, 2007)",
            "sizeof(dir->dirtail)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufoff",
          "args": [
            "dir->bh",
            "2007"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dir->dirhead",
            "bufoff(dir->bh, 0)",
            "sizeof(dir->dirhead)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufoff",
          "args": [
            "dir->bh",
            "0"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "phys"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__adfs_block_map",
          "args": [
            "sb",
            "object_id",
            "blk"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "196-208",
          "snippet": "static inline int\n__adfs_block_map(struct super_block *sb, unsigned int object_id,\n\t\t unsigned int block)\n{\n\tif (object_id & 255) {\n\t\tunsigned int off;\n\n\t\toff = (object_id & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, object_id >> 8, block);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline int\n__adfs_block_map(struct super_block *sb, unsigned int object_id,\n\t\t unsigned int block)\n{\n\tif (object_id & 255) {\n\t\tunsigned int off;\n\n\t\toff = (object_id & 255) - 1;\n\t\tblock += off << ADFS_SB(sb)->s_log2sharesize;\n\t}\n\n\treturn adfs_map_lookup(sb, object_id >> 8, block);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic int\nadfs_dir_read(struct super_block *sb, unsigned long object_id,\n\t      unsigned int size, struct adfs_dir *dir)\n{\n\tconst unsigned int blocksize_bits = sb->s_blocksize_bits;\n\tint blk = 0;\n\n\t/*\n\t * Directories which are not a multiple of 2048 bytes\n\t * are considered bad v2 [3.6]\n\t */\n\tif (size & 2047)\n\t\tgoto bad_dir;\n\n\tsize >>= blocksize_bits;\n\n\tdir->nr_buffers = 0;\n\tdir->sb = sb;\n\n\tfor (blk = 0; blk < size; blk++) {\n\t\tint phys;\n\n\t\tphys = __adfs_block_map(sb, object_id, blk);\n\t\tif (!phys) {\n\t\t\tadfs_error(sb, \"dir object %lX has a hole at offset %d\",\n\t\t\t\t   object_id, blk);\n\t\t\tgoto release_buffers;\n\t\t}\n\n\t\tdir->bh[blk] = sb_bread(sb, phys);\n\t\tif (!dir->bh[blk])\n\t\t\tgoto release_buffers;\n\t}\n\n\tmemcpy(&dir->dirhead, bufoff(dir->bh, 0), sizeof(dir->dirhead));\n\tmemcpy(&dir->dirtail, bufoff(dir->bh, 2007), sizeof(dir->dirtail));\n\n\tif (dir->dirhead.startmasseq != dir->dirtail.new.endmasseq ||\n\t    memcmp(&dir->dirhead.startname, &dir->dirtail.new.endname, 4))\n\t\tgoto bad_dir;\n\n\tif (memcmp(&dir->dirhead.startname, \"Nick\", 4) &&\n\t    memcmp(&dir->dirhead.startname, \"Hugo\", 4))\n\t\tgoto bad_dir;\n\n\tif (adfs_dir_checkbyte(dir) != dir->dirtail.new.dircheckbyte)\n\t\tgoto bad_dir;\n\n\tdir->nr_buffers = blk;\n\n\treturn 0;\n\nbad_dir:\n\tadfs_error(sb, \"corrupted directory fragment %lX\",\n\t\t   object_id);\nrelease_buffers:\n\tfor (blk -= 1; blk >= 0; blk -= 1)\n\t\tbrelse(dir->bh[blk]);\n\n\tdir->sb = NULL;\n\n\treturn -EIO;\n}"
  },
  {
    "function_name": "adfs_dir_checkbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "84-137",
    "snippet": "static u8\nadfs_dir_checkbyte(const struct adfs_dir *dir)\n{\n\tstruct buffer_head * const *bh = dir->bh;\n\tconst int blocksize_bits = dir->sb->s_blocksize_bits;\n\tunion { __le32 *ptr32; u8 *ptr8; } ptr, end;\n\tu32 dircheck = 0;\n\tint last = 5 - 26;\n\tint i = 0;\n\n\t/*\n\t * Accumulate each word up to the last whole\n\t * word of the last directory entry.  This\n\t * can spread across several buffer heads.\n\t */\n\tdo {\n\t\tlast += 26;\n\t\tdo {\n\t\t\tdircheck = le32_to_cpu(dir_u32(i)) ^ ror13(dircheck);\n\n\t\t\ti += sizeof(u32);\n\t\t} while (i < (last & ~3));\n\t} while (dir_u8(last) != 0);\n\n\t/*\n\t * Accumulate the last few bytes.  These\n\t * bytes will be within the same bh.\n\t */\n\tif (i != last) {\n\t\tptr.ptr8 = bufoff(bh, i);\n\t\tend.ptr8 = ptr.ptr8 + last - i;\n\n\t\tdo {\n\t\t\tdircheck = *ptr.ptr8++ ^ ror13(dircheck);\n\t\t} while (ptr.ptr8 < end.ptr8);\n\t}\n\n\t/*\n\t * The directory tail is in the final bh\n\t * Note that contary to the RISC OS PRMs,\n\t * the first few bytes are NOT included\n\t * in the check.  All bytes are in the\n\t * same bh.\n\t */\n\tptr.ptr8 = bufoff(bh, 2008);\n\tend.ptr8 = ptr.ptr8 + 36;\n\n\tdo {\n\t\t__le32 v = *ptr.ptr32++;\n\t\tdircheck = le32_to_cpu(v) ^ ror13(dircheck);\n\t} while (ptr.ptr32 < end.ptr32);\n\n\treturn (dircheck ^ (dircheck >> 8) ^ (dircheck >> 16) ^ (dircheck >> 24)) & 0xff;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adfs_f_free(struct adfs_dir *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ror13",
          "args": [
            "dircheck"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "v"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bufoff",
          "args": [
            "bh",
            "2008"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror13",
          "args": [
            "dircheck"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufoff",
          "args": [
            "bh",
            "i"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_u8",
          "args": [
            "last"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror13",
          "args": [
            "dircheck"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_u32",
          "args": [
            "i"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic void adfs_f_free(struct adfs_dir *dir);\n\nstatic u8\nadfs_dir_checkbyte(const struct adfs_dir *dir)\n{\n\tstruct buffer_head * const *bh = dir->bh;\n\tconst int blocksize_bits = dir->sb->s_blocksize_bits;\n\tunion { __le32 *ptr32; u8 *ptr8; } ptr, end;\n\tu32 dircheck = 0;\n\tint last = 5 - 26;\n\tint i = 0;\n\n\t/*\n\t * Accumulate each word up to the last whole\n\t * word of the last directory entry.  This\n\t * can spread across several buffer heads.\n\t */\n\tdo {\n\t\tlast += 26;\n\t\tdo {\n\t\t\tdircheck = le32_to_cpu(dir_u32(i)) ^ ror13(dircheck);\n\n\t\t\ti += sizeof(u32);\n\t\t} while (i < (last & ~3));\n\t} while (dir_u8(last) != 0);\n\n\t/*\n\t * Accumulate the last few bytes.  These\n\t * bytes will be within the same bh.\n\t */\n\tif (i != last) {\n\t\tptr.ptr8 = bufoff(bh, i);\n\t\tend.ptr8 = ptr.ptr8 + last - i;\n\n\t\tdo {\n\t\t\tdircheck = *ptr.ptr8++ ^ ror13(dircheck);\n\t\t} while (ptr.ptr8 < end.ptr8);\n\t}\n\n\t/*\n\t * The directory tail is in the final bh\n\t * Note that contary to the RISC OS PRMs,\n\t * the first few bytes are NOT included\n\t * in the check.  All bytes are in the\n\t * same bh.\n\t */\n\tptr.ptr8 = bufoff(bh, 2008);\n\tend.ptr8 = ptr.ptr8 + 36;\n\n\tdo {\n\t\t__le32 v = *ptr.ptr32++;\n\t\tdircheck = le32_to_cpu(v) ^ ror13(dircheck);\n\t} while (ptr.ptr32 < end.ptr32);\n\n\treturn (dircheck ^ (dircheck >> 8) ^ (dircheck >> 16) ^ (dircheck >> 24)) & 0xff;\n}"
  },
  {
    "function_name": "adfs_readname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "44-57",
    "snippet": "static inline int adfs_readname(char *buf, char *ptr, int maxlen)\n{\n\tchar *old_buf = buf;\n\n\twhile ((unsigned char)*ptr >= ' ' && maxlen--) {\n\t\tif (*ptr == '/')\n\t\t\t*buf++ = '.';\n\t\telse\n\t\t\t*buf++ = *ptr;\n\t\tptr++;\n\t}\n\n\treturn buf - old_buf;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline int adfs_readname(char *buf, char *ptr, int maxlen)\n{\n\tchar *old_buf = buf;\n\n\twhile ((unsigned char)*ptr >= ' ' && maxlen--) {\n\t\tif (*ptr == '/')\n\t\t\t*buf++ = '.';\n\t\telse\n\t\t\t*buf++ = *ptr;\n\t\tptr++;\n\t}\n\n\treturn buf - old_buf;\n}"
  },
  {
    "function_name": "adfs_writeval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "34-42",
    "snippet": "static inline void adfs_writeval(unsigned char *p, int len, unsigned int val)\n{\n\tswitch (len) {\n\tcase 4:\t\tp[3] = val >> 24;\n\tcase 3:\t\tp[2] = val >> 16;\n\tcase 2:\t\tp[1] = val >> 8;\n\tdefault:\tp[0] = val;\n\t}\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline void adfs_writeval(unsigned char *p, int len, unsigned int val)\n{\n\tswitch (len) {\n\tcase 4:\t\tp[3] = val >> 24;\n\tcase 3:\t\tp[2] = val >> 16;\n\tcase 2:\t\tp[1] = val >> 8;\n\tdefault:\tp[0] = val;\n\t}\n}"
  },
  {
    "function_name": "adfs_readval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/dir_f.c",
    "lines": "21-32",
    "snippet": "static inline unsigned int adfs_readval(unsigned char *p, int len)\n{\n\tunsigned int val = 0;\n\n\tswitch (len) {\n\tcase 4:\t\tval |= p[3] << 24;\n\tcase 3:\t\tval |= p[2] << 16;\n\tcase 2:\t\tval |= p[1] << 8;\n\tdefault:\tval |= p[0];\n\t}\n\treturn val;\n}",
    "includes": [
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline unsigned int adfs_readval(unsigned char *p, int len)\n{\n\tunsigned int val = 0;\n\n\tswitch (len) {\n\tcase 4:\t\tval |= p[3] << 24;\n\tcase 3:\t\tval |= p[2] << 16;\n\tcase 2:\t\tval |= p[1] << 8;\n\tdefault:\tval |= p[0];\n\t}\n\treturn val;\n}"
  }
]