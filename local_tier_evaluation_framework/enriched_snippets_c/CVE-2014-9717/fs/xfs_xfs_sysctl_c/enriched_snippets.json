[
  {
    "function_name": "xfs_sysctl_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysctl.c",
    "lines": "239-243",
    "snippet": "void\nxfs_sysctl_unregister(void)\n{\n\tunregister_sysctl_table(xfs_table_header);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table_header *xfs_table_header;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_sysctl_table",
          "args": [
            "xfs_table_header"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1528-1555",
          "snippet": "void unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nvoid unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include \"xfs.h\"\n\nstatic struct ctl_table_header *xfs_table_header;\n\nvoid\nxfs_sysctl_unregister(void)\n{\n\tunregister_sysctl_table(xfs_table_header);\n}"
  },
  {
    "function_name": "xfs_sysctl_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysctl.c",
    "lines": "230-237",
    "snippet": "int\nxfs_sysctl_register(void)\n{\n\txfs_table_header = register_sysctl_table(xfs_root_table);\n\tif (!xfs_table_header)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table_header *xfs_table_header;",
      "static struct ctl_table xfs_root_table[] = {\n\t{\n\t\t.procname\t= \"fs\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= xfs_dir_table\n\t},\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_table",
          "args": [
            "xfs_root_table"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1528-1555",
          "snippet": "void unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nvoid unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include \"xfs.h\"\n\nstatic struct ctl_table_header *xfs_table_header;\nstatic struct ctl_table xfs_root_table[] = {\n\t{\n\t\t.procname\t= \"fs\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= xfs_dir_table\n\t},\n\t{}\n};\n\nint\nxfs_sysctl_register(void)\n{\n\txfs_table_header = register_sysctl_table(xfs_root_table);\n\tif (!xfs_table_header)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_panic_mask_proc_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysctl.c",
    "lines": "56-74",
    "snippet": "STATIC int\nxfs_panic_mask_proc_handler(\n\tstruct ctl_table\t*ctl,\n\tint\t\t\twrite,\n\tvoid\t\t\t__user *buffer,\n\tsize_t\t\t\t*lenp,\n\tloff_t\t\t\t*ppos)\n{\n\tint\t\tret, *valp = ctl->data;\n\n\tret = proc_dointvec_minmax(ctl, write, buffer, lenp, ppos);\n\tif (!ret && write) {\n\t\txfs_panic_mask = *valp;\n#ifdef DEBUG\n\t\txfs_panic_mask |= (XFS_PTAG_SHUTDOWN_CORRUPT | XFS_PTAG_LOGRES);\n#endif\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "ctl",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include \"xfs.h\"\n\nSTATIC int\nxfs_panic_mask_proc_handler(\n\tstruct ctl_table\t*ctl,\n\tint\t\t\twrite,\n\tvoid\t\t\t__user *buffer,\n\tsize_t\t\t\t*lenp,\n\tloff_t\t\t\t*ppos)\n{\n\tint\t\tret, *valp = ctl->data;\n\n\tret = proc_dointvec_minmax(ctl, write, buffer, lenp, ppos);\n\tif (!ret && write) {\n\t\txfs_panic_mask = *valp;\n#ifdef DEBUG\n\t\txfs_panic_mask |= (XFS_PTAG_SHUTDOWN_CORRUPT | XFS_PTAG_LOGRES);\n#endif\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_stats_clear_proc_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_sysctl.c",
    "lines": "26-54",
    "snippet": "STATIC int\nxfs_stats_clear_proc_handler(\n\tstruct ctl_table\t*ctl,\n\tint\t\t\twrite,\n\tvoid\t\t\t__user *buffer,\n\tsize_t\t\t\t*lenp,\n\tloff_t\t\t\t*ppos)\n{\n\tint\t\tc, ret, *valp = ctl->data;\n\t__uint32_t\tvn_active;\n\n\tret = proc_dointvec_minmax(ctl, write, buffer, lenp, ppos);\n\n\tif (!ret && write && *valp) {\n\t\txfs_notice(NULL, \"Clearing xfsstats\");\n\t\tfor_each_possible_cpu(c) {\n\t\t\tpreempt_disable();\n\t\t\t/* save vn_active, it's a universal truth! */\n\t\t\tvn_active = per_cpu(xfsstats, c).vn_active;\n\t\t\tmemset(&per_cpu(xfsstats, c), 0,\n\t\t\t       sizeof(struct xfsstats));\n\t\t\tper_cpu(xfsstats, c).vn_active = vn_active;\n\t\t\tpreempt_enable();\n\t\t}\n\t\txfs_stats_clear = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/sysctl.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "xfsstats",
            "c"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&per_cpu(xfsstats, c)",
            "0",
            "sizeof(struct xfsstats)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "xfsstats",
            "c"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "xfsstats",
            "c"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "NULL",
            "\"Clearing xfsstats\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "ctl",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include \"xfs.h\"\n\nSTATIC int\nxfs_stats_clear_proc_handler(\n\tstruct ctl_table\t*ctl,\n\tint\t\t\twrite,\n\tvoid\t\t\t__user *buffer,\n\tsize_t\t\t\t*lenp,\n\tloff_t\t\t\t*ppos)\n{\n\tint\t\tc, ret, *valp = ctl->data;\n\t__uint32_t\tvn_active;\n\n\tret = proc_dointvec_minmax(ctl, write, buffer, lenp, ppos);\n\n\tif (!ret && write && *valp) {\n\t\txfs_notice(NULL, \"Clearing xfsstats\");\n\t\tfor_each_possible_cpu(c) {\n\t\t\tpreempt_disable();\n\t\t\t/* save vn_active, it's a universal truth! */\n\t\t\tvn_active = per_cpu(xfsstats, c).vn_active;\n\t\t\tmemset(&per_cpu(xfsstats, c), 0,\n\t\t\t       sizeof(struct xfsstats));\n\t\t\tper_cpu(xfsstats, c).vn_active = vn_active;\n\t\t\tpreempt_enable();\n\t\t}\n\t\txfs_stats_clear = 0;\n\t}\n\n\treturn ret;\n}"
  }
]