[
  {
    "function_name": "reiserfs_security_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
    "lines": "107-113",
    "snippet": "void reiserfs_security_free(struct reiserfs_security_handle *sec)\n{\n\tkfree(sec->name);\n\tkfree(sec->value);\n\tsec->name = NULL;\n\tsec->value = NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include \"xattr.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sec->value"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sec->name"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_security_free(struct reiserfs_security_handle *sec)\n{\n\tkfree(sec->name);\n\tkfree(sec->value);\n\tsec->name = NULL;\n\tsec->value = NULL;\n}"
  },
  {
    "function_name": "reiserfs_security_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
    "lines": "91-105",
    "snippet": "int reiserfs_security_write(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode,\n\t\t\t    struct reiserfs_security_handle *sec)\n{\n\tint error;\n\tif (strlen(sec->name) < sizeof(XATTR_SECURITY_PREFIX))\n\t\treturn -EINVAL;\n\n\terror = reiserfs_xattr_set_handle(th, inode, sec->name, sec->value,\n\t\t\t\t\t  sec->length, XATTR_CREATE);\n\tif (error == -ENODATA || error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include \"xattr.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_xattr_set_handle",
          "args": [
            "th",
            "inode",
            "sec->name",
            "sec->value",
            "sec->length",
            "XATTR_CREATE"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "497-594",
          "snippet": "int\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_CACHE_SIZE)\n\t\t\t\tchunk = PAGE_CACHE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(dentry->d_inode)) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_fs_time(inode->i_sb),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);\n\t\tinode_dio_wait(dentry->d_inode);\n\n\t\terr = reiserfs_setattr(dentry, &newattrs);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_CACHE_SIZE)\n\t\t\t\tchunk = PAGE_CACHE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(dentry->d_inode)) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_fs_time(inode->i_sb),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);\n\t\tinode_dio_wait(dentry->d_inode);\n\n\t\terr = reiserfs_setattr(dentry, &newattrs);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sec->name"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nint reiserfs_security_write(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode,\n\t\t\t    struct reiserfs_security_handle *sec)\n{\n\tint error;\n\tif (strlen(sec->name) < sizeof(XATTR_SECURITY_PREFIX))\n\t\treturn -EINVAL;\n\n\terror = reiserfs_xattr_set_handle(th, inode, sec->name, sec->value,\n\t\t\t\t\t  sec->length, XATTR_CREATE);\n\tif (error == -ENODATA || error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}"
  },
  {
    "function_name": "reiserfs_security_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
    "lines": "56-89",
    "snippet": "int reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include \"xattr.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_nblocks",
          "args": [
            "inode",
            "sec->length"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "53-61",
          "snippet": "static inline loff_t reiserfs_xattr_nblocks(struct inode *inode, loff_t size)\n{\n\tloff_t ret = 0;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);\n\t\tret >>= inode->i_sb->s_blocksize_bits;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline loff_t reiserfs_xattr_nblocks(struct inode *inode, loff_t size)\n{\n\tloff_t ret = 0;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);\n\t\tret >>= inode->i_sb->s_blocksize_bits;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_jcreate_nblocks",
          "args": [
            "inode"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_jcreate_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "75-86",
          "snippet": "static inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)\n{\n\tsize_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\tif ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t\tif (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)\n\t\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t}\n\n\treturn nblocks;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)\n{\n\tsize_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\tif ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t\tif (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)\n\t\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t}\n\n\treturn nblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattrs_initialized",
          "args": [
            "inode->i_sb"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattrs_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "47-50",
          "snippet": "static inline int reiserfs_xattrs_initialized(struct super_block *sb)\n{\n\treturn REISERFS_SB(sb)->priv_root != NULL;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_lookup_privroot(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_lookup_privroot(struct super_block *sb);\n\nstatic inline int reiserfs_xattrs_initialized(struct super_block *sb)\n{\n\treturn REISERFS_SB(sb)->priv_root != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_old_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&sec->name",
            "&sec->value",
            "&sec->length"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "dir"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nint reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}"
  },
  {
    "function_name": "security_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
    "lines": "37-51",
    "snippet": "static size_t security_list(struct dentry *dentry, char *list, size_t list_len,\n\t\t\t    const char *name, size_t namelen, int handler_flags)\n{\n\tconst size_t len = namelen + 1;\n\n\tif (IS_PRIVATE(dentry->d_inode))\n\t\treturn 0;\n\n\tif (list && len <= list_len) {\n\t\tmemcpy(list, name, namelen);\n\t\tlist[namelen] = '\\0';\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include \"xattr.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "name",
            "namelen"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nstatic size_t security_list(struct dentry *dentry, char *list, size_t list_len,\n\t\t\t    const char *name, size_t namelen, int handler_flags)\n{\n\tconst size_t len = namelen + 1;\n\n\tif (IS_PRIVATE(dentry->d_inode))\n\t\treturn 0;\n\n\tif (list && len <= list_len) {\n\t\tmemcpy(list, name, namelen);\n\t\tlist[namelen] = '\\0';\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "security_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
    "lines": "24-35",
    "snippet": "static int\nsecurity_set(struct dentry *dentry, const char *name, const void *buffer,\n\t     size_t size, int flags, int handler_flags)\n{\n\tif (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))\n\t\treturn -EINVAL;\n\n\tif (IS_PRIVATE(dentry->d_inode))\n\t\treturn -EPERM;\n\n\treturn reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include \"xattr.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_xattr_set",
          "args": [
            "dentry->d_inode",
            "name",
            "buffer",
            "size",
            "flags"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "597-625",
          "snippet": "int reiserfs_xattr_set(struct inode *inode, const char *name,\n\t\t       const void *buffer, size_t buffer_size, int flags)\n{\n\n\tstruct reiserfs_transaction_handle th;\n\tint error, error2;\n\tsize_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);\n\n\tif (!(flags & XATTR_REPLACE))\n\t\tjbegin_count += reiserfs_xattr_jcreate_nblocks(inode);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\terror = reiserfs_xattr_set_handle(&th, inode, name,\n\t\t\t\t\t  buffer, buffer_size, flags);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror2 = journal_end(&th);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0)\n\t\terror = error2;\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_xattr_set(struct inode *inode, const char *name,\n\t\t       const void *buffer, size_t buffer_size, int flags)\n{\n\n\tstruct reiserfs_transaction_handle th;\n\tint error, error2;\n\tsize_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);\n\n\tif (!(flags & XATTR_REPLACE))\n\t\tjbegin_count += reiserfs_xattr_jcreate_nblocks(inode);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\terror = reiserfs_xattr_set_handle(&th, inode, name,\n\t\t\t\t\t  buffer, buffer_size, flags);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror2 = journal_end(&th);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0)\n\t\terror = error2;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nstatic int\nsecurity_set(struct dentry *dentry, const char *name, const void *buffer,\n\t     size_t size, int flags, int handler_flags)\n{\n\tif (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))\n\t\treturn -EINVAL;\n\n\tif (IS_PRIVATE(dentry->d_inode))\n\t\treturn -EPERM;\n\n\treturn reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);\n}"
  },
  {
    "function_name": "security_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
    "lines": "11-22",
    "snippet": "static int\nsecurity_get(struct dentry *dentry, const char *name, void *buffer, size_t size,\n\t\tint handler_flags)\n{\n\tif (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))\n\t\treturn -EINVAL;\n\n\tif (IS_PRIVATE(dentry->d_inode))\n\t\treturn -EPERM;\n\n\treturn reiserfs_xattr_get(dentry->d_inode, name, buffer, size);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include \"xattr.h\"",
      "#include <linux/slab.h>",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_xattr_get",
          "args": [
            "dentry->d_inode",
            "name",
            "buffer",
            "size"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "630-732",
          "snippet": "int\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can't have xattrs attached to v1 items since they don't have\n\t * generation numbers\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(dentry->d_inode);\n\n\t/* Just return the size needed */\n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t/* Magic doesn't match up.. */\n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can't have xattrs attached to v1 items since they don't have\n\t * generation numbers\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(dentry->d_inode);\n\n\t/* Just return the size needed */\n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t/* Magic doesn't match up.. */\n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nstatic int\nsecurity_get(struct dentry *dentry, const char *name, void *buffer, size_t size,\n\t\tint handler_flags)\n{\n\tif (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))\n\t\treturn -EINVAL;\n\n\tif (IS_PRIVATE(dentry->d_inode))\n\t\treturn -EPERM;\n\n\treturn reiserfs_xattr_get(dentry->d_inode, name, buffer, size);\n}"
  }
]