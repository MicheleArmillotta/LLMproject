[
  {
    "function_name": "nilfs_btnode_abort_change_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
    "lines": "281-297",
    "snippet": "void nilfs_btnode_abort_change_key(struct address_space *btnc,\n\t\t\t\t   struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *nbh = ctxt->newbh;\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\n\tif (oldkey == newkey)\n\t\treturn;\n\n\tif (nbh == NULL) {\t/* blocksize == pagesize */\n\t\tspin_lock_irq(&btnc->tree_lock);\n\t\tradix_tree_delete(&btnc->page_tree, newkey);\n\t\tspin_unlock_irq(&btnc->tree_lock);\n\t\tunlock_page(ctxt->bh->b_page);\n\t} else\n\t\tbrelse(nbh);\n}",
    "includes": [
      "#include \"btnode.h\"",
      "#include \"page.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "nbh"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "ctxt->bh->b_page"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&btnc->tree_lock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&btnc->page_tree",
            "newkey"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&btnc->tree_lock"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_btnode_abort_change_key(struct address_space *btnc,\n\t\t\t\t   struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *nbh = ctxt->newbh;\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\n\tif (oldkey == newkey)\n\t\treturn;\n\n\tif (nbh == NULL) {\t/* blocksize == pagesize */\n\t\tspin_lock_irq(&btnc->tree_lock);\n\t\tradix_tree_delete(&btnc->page_tree, newkey);\n\t\tspin_unlock_irq(&btnc->tree_lock);\n\t\tunlock_page(ctxt->bh->b_page);\n\t} else\n\t\tbrelse(nbh);\n}"
  },
  {
    "function_name": "nilfs_btnode_commit_change_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
    "lines": "240-275",
    "snippet": "void nilfs_btnode_commit_change_key(struct address_space *btnc,\n\t\t\t\t    struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *obh = ctxt->bh, *nbh = ctxt->newbh;\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\tstruct page *opage;\n\n\tif (oldkey == newkey)\n\t\treturn;\n\n\tif (nbh == NULL) {\t/* blocksize == pagesize */\n\t\topage = obh->b_page;\n\t\tif (unlikely(oldkey != opage->index))\n\t\t\tNILFS_PAGE_BUG(opage,\n\t\t\t\t       \"invalid oldkey %lld (newkey=%lld)\",\n\t\t\t\t       (unsigned long long)oldkey,\n\t\t\t\t       (unsigned long long)newkey);\n\t\tmark_buffer_dirty(obh);\n\n\t\tspin_lock_irq(&btnc->tree_lock);\n\t\tradix_tree_delete(&btnc->page_tree, oldkey);\n\t\tradix_tree_tag_set(&btnc->page_tree, newkey,\n\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irq(&btnc->tree_lock);\n\n\t\topage->index = obh->b_blocknr = newkey;\n\t\tunlock_page(opage);\n\t} else {\n\t\tnilfs_copy_buffer(nbh, obh);\n\t\tmark_buffer_dirty(nbh);\n\n\t\tnbh->b_blocknr = newkey;\n\t\tctxt->bh = nbh;\n\t\tnilfs_btnode_delete(obh); /* will decrement bh->b_count */\n\t}\n}",
    "includes": [
      "#include \"btnode.h\"",
      "#include \"page.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_btnode_delete",
          "args": [
            "obh"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_btnode_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
          "lines": "142-161",
          "snippet": "void nilfs_btnode_delete(struct buffer_head *bh)\n{\n\tstruct address_space *mapping;\n\tstruct page *page = bh->b_page;\n\tpgoff_t index = page_index(page);\n\tint still_dirty;\n\n\tpage_cache_get(page);\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\n\tnilfs_forget_buffer(bh);\n\tstill_dirty = PageDirty(page);\n\tmapping = page->mapping;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (!still_dirty && mapping)\n\t\tinvalidate_inode_pages2_range(mapping, index, index);\n}",
          "includes": [
            "#include \"btnode.h\"",
            "#include \"page.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_btnode_delete(struct buffer_head *bh)\n{\n\tstruct address_space *mapping;\n\tstruct page *page = bh->b_page;\n\tpgoff_t index = page_index(page);\n\tint still_dirty;\n\n\tpage_cache_get(page);\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\n\tnilfs_forget_buffer(bh);\n\tstill_dirty = PageDirty(page);\n\tmapping = page->mapping;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (!still_dirty && mapping)\n\t\tinvalidate_inode_pages2_range(mapping, index, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "nbh"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_copy_buffer",
          "args": [
            "nbh",
            "obh"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_copy_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "116-148",
          "snippet": "void nilfs_copy_buffer(struct buffer_head *dbh, struct buffer_head *sbh)\n{\n\tvoid *kaddr0, *kaddr1;\n\tunsigned long bits;\n\tstruct page *spage = sbh->b_page, *dpage = dbh->b_page;\n\tstruct buffer_head *bh;\n\n\tkaddr0 = kmap_atomic(spage);\n\tkaddr1 = kmap_atomic(dpage);\n\tmemcpy(kaddr1 + bh_offset(dbh), kaddr0 + bh_offset(sbh), sbh->b_size);\n\tkunmap_atomic(kaddr1);\n\tkunmap_atomic(kaddr0);\n\n\tdbh->b_state = sbh->b_state & NILFS_BUFFER_INHERENT_BITS;\n\tdbh->b_blocknr = sbh->b_blocknr;\n\tdbh->b_bdev = sbh->b_bdev;\n\n\tbh = dbh;\n\tbits = sbh->b_state & ((1UL << BH_Uptodate) | (1UL << BH_Mapped));\n\twhile ((bh = bh->b_this_page) != dbh) {\n\t\tlock_buffer(bh);\n\t\tbits &= bh->b_state;\n\t\tunlock_buffer(bh);\n\t}\n\tif (bits & (1UL << BH_Uptodate))\n\t\tSetPageUptodate(dpage);\n\telse\n\t\tClearPageUptodate(dpage);\n\tif (bits & (1UL << BH_Mapped))\n\t\tSetPageMappedToDisk(dpage);\n\telse\n\t\tClearPageMappedToDisk(dpage);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\n#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))\n\nvoid nilfs_copy_buffer(struct buffer_head *dbh, struct buffer_head *sbh)\n{\n\tvoid *kaddr0, *kaddr1;\n\tunsigned long bits;\n\tstruct page *spage = sbh->b_page, *dpage = dbh->b_page;\n\tstruct buffer_head *bh;\n\n\tkaddr0 = kmap_atomic(spage);\n\tkaddr1 = kmap_atomic(dpage);\n\tmemcpy(kaddr1 + bh_offset(dbh), kaddr0 + bh_offset(sbh), sbh->b_size);\n\tkunmap_atomic(kaddr1);\n\tkunmap_atomic(kaddr0);\n\n\tdbh->b_state = sbh->b_state & NILFS_BUFFER_INHERENT_BITS;\n\tdbh->b_blocknr = sbh->b_blocknr;\n\tdbh->b_bdev = sbh->b_bdev;\n\n\tbh = dbh;\n\tbits = sbh->b_state & ((1UL << BH_Uptodate) | (1UL << BH_Mapped));\n\twhile ((bh = bh->b_this_page) != dbh) {\n\t\tlock_buffer(bh);\n\t\tbits &= bh->b_state;\n\t\tunlock_buffer(bh);\n\t}\n\tif (bits & (1UL << BH_Uptodate))\n\t\tSetPageUptodate(dpage);\n\telse\n\t\tClearPageUptodate(dpage);\n\tif (bits & (1UL << BH_Mapped))\n\t\tSetPageMappedToDisk(dpage);\n\telse\n\t\tClearPageMappedToDisk(dpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "opage"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&btnc->tree_lock"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&btnc->page_tree",
            "newkey",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&btnc->page_tree",
            "oldkey"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&btnc->tree_lock"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_PAGE_BUG",
          "args": [
            "opage",
            "\"invalid oldkey %lld (newkey=%lld)\"",
            "(unsigned long long)oldkey",
            "(unsigned long long)newkey"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "oldkey != opage->index"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_btnode_commit_change_key(struct address_space *btnc,\n\t\t\t\t    struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *obh = ctxt->bh, *nbh = ctxt->newbh;\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\tstruct page *opage;\n\n\tif (oldkey == newkey)\n\t\treturn;\n\n\tif (nbh == NULL) {\t/* blocksize == pagesize */\n\t\topage = obh->b_page;\n\t\tif (unlikely(oldkey != opage->index))\n\t\t\tNILFS_PAGE_BUG(opage,\n\t\t\t\t       \"invalid oldkey %lld (newkey=%lld)\",\n\t\t\t\t       (unsigned long long)oldkey,\n\t\t\t\t       (unsigned long long)newkey);\n\t\tmark_buffer_dirty(obh);\n\n\t\tspin_lock_irq(&btnc->tree_lock);\n\t\tradix_tree_delete(&btnc->page_tree, oldkey);\n\t\tradix_tree_tag_set(&btnc->page_tree, newkey,\n\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irq(&btnc->tree_lock);\n\n\t\topage->index = obh->b_blocknr = newkey;\n\t\tunlock_page(opage);\n\t} else {\n\t\tnilfs_copy_buffer(nbh, obh);\n\t\tmark_buffer_dirty(nbh);\n\n\t\tnbh->b_blocknr = newkey;\n\t\tctxt->bh = nbh;\n\t\tnilfs_btnode_delete(obh); /* will decrement bh->b_count */\n\t}\n}"
  },
  {
    "function_name": "nilfs_btnode_prepare_change_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
    "lines": "170-234",
    "snippet": "int nilfs_btnode_prepare_change_key(struct address_space *btnc,\n\t\t\t\t    struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *obh, *nbh;\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\tint err;\n\n\tif (oldkey == newkey)\n\t\treturn 0;\n\n\tobh = ctxt->bh;\n\tctxt->newbh = NULL;\n\n\tif (inode->i_blkbits == PAGE_CACHE_SHIFT) {\n\t\tlock_page(obh->b_page);\n\t\t/*\n\t\t * We cannot call radix_tree_preload for the kernels older\n\t\t * than 2.6.23, because it is not exported for modules.\n\t\t */\nretry:\n\t\terr = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\t\tif (err)\n\t\t\tgoto failed_unlock;\n\t\t/* BUG_ON(oldkey != obh->b_page->index); */\n\t\tif (unlikely(oldkey != obh->b_page->index))\n\t\t\tNILFS_PAGE_BUG(obh->b_page,\n\t\t\t\t       \"invalid oldkey %lld (newkey=%lld)\",\n\t\t\t\t       (unsigned long long)oldkey,\n\t\t\t\t       (unsigned long long)newkey);\n\n\t\tspin_lock_irq(&btnc->tree_lock);\n\t\terr = radix_tree_insert(&btnc->page_tree, newkey, obh->b_page);\n\t\tspin_unlock_irq(&btnc->tree_lock);\n\t\t/*\n\t\t * Note: page->index will not change to newkey until\n\t\t * nilfs_btnode_commit_change_key() will be called.\n\t\t * To protect the page in intermediate state, the page lock\n\t\t * is held.\n\t\t */\n\t\tradix_tree_preload_end();\n\t\tif (!err)\n\t\t\treturn 0;\n\t\telse if (err != -EEXIST)\n\t\t\tgoto failed_unlock;\n\n\t\terr = invalidate_inode_pages2_range(btnc, newkey, newkey);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t\t/* fallback to copy mode */\n\t\tunlock_page(obh->b_page);\n\t}\n\n\tnbh = nilfs_btnode_create_block(btnc, newkey);\n\tif (!nbh)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(nbh == obh);\n\tctxt->newbh = nbh;\n\treturn 0;\n\n failed_unlock:\n\tunlock_page(obh->b_page);\n\treturn err;\n}",
    "includes": [
      "#include \"btnode.h\"",
      "#include \"page.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "obh->b_page"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nbh == obh"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_btnode_create_block",
          "args": [
            "btnc",
            "newkey"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_btnode_create_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
          "lines": "43-67",
          "snippet": "struct buffer_head *\nnilfs_btnode_create_block(struct address_space *btnc, __u64 blocknr)\n{\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\tstruct buffer_head *bh;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, 1 << BH_NILFS_Node);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\n\tif (unlikely(buffer_mapped(bh) || buffer_uptodate(bh) ||\n\t\t     buffer_dirty(bh))) {\n\t\tbrelse(bh);\n\t\tBUG();\n\t}\n\tmemset(bh->b_data, 0, 1 << inode->i_blkbits);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = blocknr;\n\tset_buffer_mapped(bh);\n\tset_buffer_uptodate(bh);\n\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\treturn bh;\n}",
          "includes": [
            "#include \"btnode.h\"",
            "#include \"page.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstruct buffer_head *\nnilfs_btnode_create_block(struct address_space *btnc, __u64 blocknr)\n{\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\tstruct buffer_head *bh;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, 1 << BH_NILFS_Node);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\n\tif (unlikely(buffer_mapped(bh) || buffer_uptodate(bh) ||\n\t\t     buffer_dirty(bh))) {\n\t\tbrelse(bh);\n\t\tBUG();\n\t}\n\tmemset(bh->b_data, 0, 1 << inode->i_blkbits);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = blocknr;\n\tset_buffer_mapped(bh);\n\tset_buffer_uptodate(bh);\n\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "btnc",
            "newkey",
            "newkey"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&btnc->tree_lock"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&btnc->page_tree",
            "newkey",
            "obh->b_page"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&btnc->tree_lock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_PAGE_BUG",
          "args": [
            "obh->b_page",
            "\"invalid oldkey %lld (newkey=%lld)\"",
            "(unsigned long long)oldkey",
            "(unsigned long long)newkey"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "oldkey != obh->b_page->index"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS & ~__GFP_HIGHMEM"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_BTNC_I",
          "args": [
            "btnc"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_BTNC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "89-94",
          "snippet": "static inline struct inode *NILFS_BTNC_I(struct address_space *btnc)\n{\n\tstruct nilfs_inode_info *ii =\n\t\tcontainer_of(btnc, struct nilfs_inode_info, i_btnode_cache);\n\treturn &ii->vfs_inode;\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *NILFS_BTNC_I(struct address_space *btnc)\n{\n\tstruct nilfs_inode_info *ii =\n\t\tcontainer_of(btnc, struct nilfs_inode_info, i_btnode_cache);\n\treturn &ii->vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_btnode_prepare_change_key(struct address_space *btnc,\n\t\t\t\t    struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *obh, *nbh;\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\tint err;\n\n\tif (oldkey == newkey)\n\t\treturn 0;\n\n\tobh = ctxt->bh;\n\tctxt->newbh = NULL;\n\n\tif (inode->i_blkbits == PAGE_CACHE_SHIFT) {\n\t\tlock_page(obh->b_page);\n\t\t/*\n\t\t * We cannot call radix_tree_preload for the kernels older\n\t\t * than 2.6.23, because it is not exported for modules.\n\t\t */\nretry:\n\t\terr = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\t\tif (err)\n\t\t\tgoto failed_unlock;\n\t\t/* BUG_ON(oldkey != obh->b_page->index); */\n\t\tif (unlikely(oldkey != obh->b_page->index))\n\t\t\tNILFS_PAGE_BUG(obh->b_page,\n\t\t\t\t       \"invalid oldkey %lld (newkey=%lld)\",\n\t\t\t\t       (unsigned long long)oldkey,\n\t\t\t\t       (unsigned long long)newkey);\n\n\t\tspin_lock_irq(&btnc->tree_lock);\n\t\terr = radix_tree_insert(&btnc->page_tree, newkey, obh->b_page);\n\t\tspin_unlock_irq(&btnc->tree_lock);\n\t\t/*\n\t\t * Note: page->index will not change to newkey until\n\t\t * nilfs_btnode_commit_change_key() will be called.\n\t\t * To protect the page in intermediate state, the page lock\n\t\t * is held.\n\t\t */\n\t\tradix_tree_preload_end();\n\t\tif (!err)\n\t\t\treturn 0;\n\t\telse if (err != -EEXIST)\n\t\t\tgoto failed_unlock;\n\n\t\terr = invalidate_inode_pages2_range(btnc, newkey, newkey);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t\t/* fallback to copy mode */\n\t\tunlock_page(obh->b_page);\n\t}\n\n\tnbh = nilfs_btnode_create_block(btnc, newkey);\n\tif (!nbh)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(nbh == obh);\n\tctxt->newbh = nbh;\n\treturn 0;\n\n failed_unlock:\n\tunlock_page(obh->b_page);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_btnode_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
    "lines": "142-161",
    "snippet": "void nilfs_btnode_delete(struct buffer_head *bh)\n{\n\tstruct address_space *mapping;\n\tstruct page *page = bh->b_page;\n\tpgoff_t index = page_index(page);\n\tint still_dirty;\n\n\tpage_cache_get(page);\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\n\tnilfs_forget_buffer(bh);\n\tstill_dirty = PageDirty(page);\n\tmapping = page->mapping;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (!still_dirty && mapping)\n\t\tinvalidate_inode_pages2_range(mapping, index, index);\n}",
    "includes": [
      "#include \"btnode.h\"",
      "#include \"page.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "mapping",
            "index",
            "index"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_forget_buffer",
          "args": [
            "bh"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_forget_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "89-109",
          "snippet": "void nilfs_forget_buffer(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\n\tlock_buffer(bh);\n\tclear_buffer_nilfs_volatile(bh);\n\tclear_buffer_nilfs_checked(bh);\n\tclear_buffer_nilfs_redirected(bh);\n\tclear_buffer_async_write(bh);\n\tclear_buffer_dirty(bh);\n\tif (nilfs_page_buffers_clean(page))\n\t\t__nilfs_clear_page_dirty(page);\n\n\tclear_buffer_uptodate(bh);\n\tclear_buffer_mapped(bh);\n\tbh->b_blocknr = -1;\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\tunlock_buffer(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_forget_buffer(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\n\tlock_buffer(bh);\n\tclear_buffer_nilfs_volatile(bh);\n\tclear_buffer_nilfs_checked(bh);\n\tclear_buffer_nilfs_redirected(bh);\n\tclear_buffer_async_write(bh);\n\tclear_buffer_dirty(bh);\n\tif (nilfs_page_buffers_clean(page))\n\t\t__nilfs_clear_page_dirty(page);\n\n\tclear_buffer_uptodate(bh);\n\tclear_buffer_mapped(bh);\n\tbh->b_blocknr = -1;\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\tunlock_buffer(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_btnode_delete(struct buffer_head *bh)\n{\n\tstruct address_space *mapping;\n\tstruct page *page = bh->b_page;\n\tpgoff_t index = page_index(page);\n\tint still_dirty;\n\n\tpage_cache_get(page);\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\n\tnilfs_forget_buffer(bh);\n\tstill_dirty = PageDirty(page);\n\tmapping = page->mapping;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (!still_dirty && mapping)\n\t\tinvalidate_inode_pages2_range(mapping, index, index);\n}"
  },
  {
    "function_name": "nilfs_btnode_submit_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
    "lines": "69-133",
    "snippet": "int nilfs_btnode_submit_block(struct address_space *btnc, __u64 blocknr,\n\t\t\t      sector_t pblocknr, int mode,\n\t\t\t      struct buffer_head **pbh, sector_t *submit_ptr)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\tstruct page *page;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, 1 << BH_NILFS_Node);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\terr = -EEXIST; /* internal code */\n\tpage = bh->b_page;\n\n\tif (buffer_uptodate(bh) || buffer_dirty(bh))\n\t\tgoto found;\n\n\tif (pblocknr == 0) {\n\t\tpblocknr = blocknr;\n\t\tif (inode->i_ino != NILFS_DAT_INO) {\n\t\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t\t/* blocknr is a virtual block number */\n\t\t\terr = nilfs_dat_translate(nilfs->ns_dat, blocknr,\n\t\t\t\t\t\t  &pblocknr);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto out_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mode == READA) {\n\t\tif (pblocknr != *submit_ptr + 1 || !trylock_buffer(bh)) {\n\t\t\terr = -EBUSY; /* internal code */\n\t\t\tbrelse(bh);\n\t\t\tgoto out_locked;\n\t\t}\n\t} else { /* mode == READ */\n\t\tlock_buffer(bh);\n\t}\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\terr = -EEXIST; /* internal code */\n\t\tgoto found;\n\t}\n\tset_buffer_mapped(bh);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = pblocknr; /* set block address for read */\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(mode, bh);\n\tbh->b_blocknr = blocknr; /* set back to the given block address */\n\t*submit_ptr = pblocknr;\n\terr = 0;\nfound:\n\t*pbh = bh;\n\nout_locked:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include \"btnode.h\"",
      "#include \"page.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "mode",
            "bh"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_dat_translate",
          "args": [
            "nilfs->ns_dat",
            "blocknr",
            "&pblocknr"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dat_translate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/dat.c",
          "lines": "397-431",
          "snippet": "int nilfs_dat_translate(struct inode *dat, __u64 vblocknr, sector_t *blocknrp)\n{\n\tstruct buffer_head *entry_bh, *bh;\n\tstruct nilfs_dat_entry *entry;\n\tsector_t blocknr;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_get_entry_block(dat, vblocknr, 0, &entry_bh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!nilfs_doing_gc() && buffer_nilfs_redirected(entry_bh)) {\n\t\tbh = nilfs_mdt_get_frozen_buffer(dat, entry_bh);\n\t\tif (bh) {\n\t\t\tWARN_ON(!buffer_uptodate(bh));\n\t\t\tbrelse(entry_bh);\n\t\t\tentry_bh = bh;\n\t\t}\n\t}\n\n\tkaddr = kmap_atomic(entry_bh->b_page);\n\tentry = nilfs_palloc_block_get_entry(dat, vblocknr, entry_bh, kaddr);\n\tblocknr = le64_to_cpu(entry->de_blocknr);\n\tif (blocknr == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*blocknrp = blocknr;\n\n out:\n\tkunmap_atomic(kaddr);\n\tbrelse(entry_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_dat_translate(struct inode *dat, __u64 vblocknr, sector_t *blocknrp)\n{\n\tstruct buffer_head *entry_bh, *bh;\n\tstruct nilfs_dat_entry *entry;\n\tsector_t blocknr;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_get_entry_block(dat, vblocknr, 0, &entry_bh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!nilfs_doing_gc() && buffer_nilfs_redirected(entry_bh)) {\n\t\tbh = nilfs_mdt_get_frozen_buffer(dat, entry_bh);\n\t\tif (bh) {\n\t\t\tWARN_ON(!buffer_uptodate(bh));\n\t\t\tbrelse(entry_bh);\n\t\t\tentry_bh = bh;\n\t\t}\n\t}\n\n\tkaddr = kmap_atomic(entry_bh->b_page);\n\tentry = nilfs_palloc_block_get_entry(dat, vblocknr, entry_bh, kaddr);\n\tblocknr = le64_to_cpu(entry->de_blocknr);\n\tif (blocknr == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*blocknrp = blocknr;\n\n out:\n\tkunmap_atomic(kaddr);\n\tbrelse(entry_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_grab_buffer",
          "args": [
            "inode",
            "btnc",
            "blocknr",
            "1 << BH_NILFS_Node"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_grab_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "61-82",
          "snippet": "struct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_BTNC_I",
          "args": [
            "btnc"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_BTNC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "89-94",
          "snippet": "static inline struct inode *NILFS_BTNC_I(struct address_space *btnc)\n{\n\tstruct nilfs_inode_info *ii =\n\t\tcontainer_of(btnc, struct nilfs_inode_info, i_btnode_cache);\n\treturn &ii->vfs_inode;\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *NILFS_BTNC_I(struct address_space *btnc)\n{\n\tstruct nilfs_inode_info *ii =\n\t\tcontainer_of(btnc, struct nilfs_inode_info, i_btnode_cache);\n\treturn &ii->vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_btnode_submit_block(struct address_space *btnc, __u64 blocknr,\n\t\t\t      sector_t pblocknr, int mode,\n\t\t\t      struct buffer_head **pbh, sector_t *submit_ptr)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\tstruct page *page;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, 1 << BH_NILFS_Node);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\terr = -EEXIST; /* internal code */\n\tpage = bh->b_page;\n\n\tif (buffer_uptodate(bh) || buffer_dirty(bh))\n\t\tgoto found;\n\n\tif (pblocknr == 0) {\n\t\tpblocknr = blocknr;\n\t\tif (inode->i_ino != NILFS_DAT_INO) {\n\t\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t\t/* blocknr is a virtual block number */\n\t\t\terr = nilfs_dat_translate(nilfs->ns_dat, blocknr,\n\t\t\t\t\t\t  &pblocknr);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto out_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mode == READA) {\n\t\tif (pblocknr != *submit_ptr + 1 || !trylock_buffer(bh)) {\n\t\t\terr = -EBUSY; /* internal code */\n\t\t\tbrelse(bh);\n\t\t\tgoto out_locked;\n\t\t}\n\t} else { /* mode == READ */\n\t\tlock_buffer(bh);\n\t}\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\terr = -EEXIST; /* internal code */\n\t\tgoto found;\n\t}\n\tset_buffer_mapped(bh);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = pblocknr; /* set block address for read */\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(mode, bh);\n\tbh->b_blocknr = blocknr; /* set back to the given block address */\n\t*submit_ptr = pblocknr;\n\terr = 0;\nfound:\n\t*pbh = bh;\n\nout_locked:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_btnode_create_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
    "lines": "43-67",
    "snippet": "struct buffer_head *\nnilfs_btnode_create_block(struct address_space *btnc, __u64 blocknr)\n{\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\tstruct buffer_head *bh;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, 1 << BH_NILFS_Node);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\n\tif (unlikely(buffer_mapped(bh) || buffer_uptodate(bh) ||\n\t\t     buffer_dirty(bh))) {\n\t\tbrelse(bh);\n\t\tBUG();\n\t}\n\tmemset(bh->b_data, 0, 1 << inode->i_blkbits);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = blocknr;\n\tset_buffer_mapped(bh);\n\tset_buffer_uptodate(bh);\n\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\treturn bh;\n}",
    "includes": [
      "#include \"btnode.h\"",
      "#include \"page.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "bh->b_page"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "bh->b_page"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "1 << inode->i_blkbits"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_mapped(bh) || buffer_uptodate(bh) ||\n\t\t     buffer_dirty(bh)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_grab_buffer",
          "args": [
            "inode",
            "btnc",
            "blocknr",
            "1 << BH_NILFS_Node"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_grab_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "61-82",
          "snippet": "struct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_BTNC_I",
          "args": [
            "btnc"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_BTNC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "89-94",
          "snippet": "static inline struct inode *NILFS_BTNC_I(struct address_space *btnc)\n{\n\tstruct nilfs_inode_info *ii =\n\t\tcontainer_of(btnc, struct nilfs_inode_info, i_btnode_cache);\n\treturn &ii->vfs_inode;\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *NILFS_BTNC_I(struct address_space *btnc)\n{\n\tstruct nilfs_inode_info *ii =\n\t\tcontainer_of(btnc, struct nilfs_inode_info, i_btnode_cache);\n\treturn &ii->vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstruct buffer_head *\nnilfs_btnode_create_block(struct address_space *btnc, __u64 blocknr)\n{\n\tstruct inode *inode = NILFS_BTNC_I(btnc);\n\tstruct buffer_head *bh;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, 1 << BH_NILFS_Node);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\n\tif (unlikely(buffer_mapped(bh) || buffer_uptodate(bh) ||\n\t\t     buffer_dirty(bh))) {\n\t\tbrelse(bh);\n\t\tBUG();\n\t}\n\tmemset(bh->b_data, 0, 1 << inode->i_blkbits);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = blocknr;\n\tset_buffer_mapped(bh);\n\tset_buffer_uptodate(bh);\n\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\treturn bh;\n}"
  },
  {
    "function_name": "nilfs_btnode_cache_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
    "lines": "37-41",
    "snippet": "void nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}",
    "includes": [
      "#include \"btnode.h\"",
      "#include \"page.h\"",
      "#include \"dat.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "btnc",
            "0"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "btnc",
            "0",
            "-1"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}"
  }
]