[
  {
    "function_name": "hfsplus_cat_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "542-614",
    "snippet": "int hfsplus_cat_write_inode(struct inode *inode)\n{\n\tstruct inode *main_inode = inode;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tmain_inode = HFSPLUS_I(inode)->rsrc_inode;\n\n\tif (!main_inode->i_nlink)\n\t\treturn 0;\n\n\tif (hfs_find_init(HFSPLUS_SB(main_inode->i_sb)->cat_tree, &fd))\n\t\t/* panic? */\n\t\treturn -EIO;\n\n\tif (hfsplus_find_cat(main_inode->i_sb, main_inode->i_ino, &fd))\n\t\t/* panic? */\n\t\tgoto out;\n\n\tif (S_ISDIR(main_inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t/* simple node checks? */\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tfolder->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfolder->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfolder->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);\n\t\tfolder->valence = cpu_to_be32(inode->i_size - 2);\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tfolder->subfolders =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->subfolders);\n\t\t}\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_folder));\n\t} else if (HFSPLUS_IS_RSRC(inode)) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t       sizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->rsrc_fork);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t} else {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->data_fork);\n\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\tfile->flags |= cpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\telse\n\t\t\tfile->flags &= cpu_to_be16(~HFSPLUS_FILE_LOCKED);\n\t\tfile->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfile->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfile->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_file));\n\t}\n\n\tset_bit(HFSPLUS_I_CAT_DIRTY, &HFSPLUS_I(inode)->flags);\nout:\n\thfs_find_exit(&fd);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFSPLUS_I_CAT_DIRTY",
            "&HFSPLUS_I(inode)->flags"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "fd.bnode",
            "&entry",
            "fd.entryoffset",
            "sizeof(struct hfsplus_cat_file)"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsp_ut2mt",
          "args": [
            "inode->i_ctime"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_ut2mt",
          "args": [
            "inode->i_mtime"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_ut2mt",
          "args": [
            "inode->i_atime"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "~HFSPLUS_FILE_LOCKED"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_FILE_LOCKED"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_set_perms",
          "args": [
            "inode",
            "&file->permissions"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "80-102",
          "snippet": "void hfsplus_cat_set_perms(struct inode *inode, struct hfsplus_perm *perms)\n{\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tperms->rootflags |= HFSPLUS_FLG_IMMUTABLE;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;\n\tif (inode->i_flags & S_APPEND)\n\t\tperms->rootflags |= HFSPLUS_FLG_APPEND;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_APPEND;\n\n\tperms->userflags = HFSPLUS_I(inode)->userflags;\n\tperms->mode = cpu_to_be16(inode->i_mode);\n\tperms->owner = cpu_to_be32(i_uid_read(inode));\n\tperms->group = cpu_to_be32(i_gid_read(inode));\n\n\tif (S_ISREG(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_nlink);\n\telse if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_rdev);\n\telse\n\t\tperms->dev = 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_set_perms(struct inode *inode, struct hfsplus_perm *perms)\n{\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tperms->rootflags |= HFSPLUS_FLG_IMMUTABLE;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;\n\tif (inode->i_flags & S_APPEND)\n\t\tperms->rootflags |= HFSPLUS_FLG_APPEND;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_APPEND;\n\n\tperms->userflags = HFSPLUS_I(inode)->userflags;\n\tperms->mode = cpu_to_be16(inode->i_mode);\n\tperms->owner = cpu_to_be32(i_uid_read(inode));\n\tperms->group = cpu_to_be32(i_gid_read(inode));\n\n\tif (S_ISREG(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_nlink);\n\telse if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_rdev);\n\telse\n\t\tperms->dev = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_inode_write_fork",
          "args": [
            "inode",
            "&file->data_fork"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_inode_write_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "466-473",
          "snippet": "void hfsplus_inode_write_fork(struct inode *inode,\n\t\tstruct hfsplus_fork_raw *fork)\n{\n\tmemcpy(&fork->extents, &HFSPLUS_I(inode)->first_extents,\n\t       sizeof(hfsplus_extent_rec));\n\tfork->total_size = cpu_to_be64(inode->i_size);\n\tfork->total_blocks = cpu_to_be32(HFSPLUS_I(inode)->alloc_blocks);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_inode_write_fork(struct inode *inode,\n\t\tstruct hfsplus_fork_raw *fork)\n{\n\tmemcpy(&fork->extents, &HFSPLUS_I(inode)->first_extents,\n\t       sizeof(hfsplus_extent_rec));\n\tfork->total_size = cpu_to_be64(inode->i_size);\n\tfork->total_blocks = cpu_to_be32(HFSPLUS_I(inode)->alloc_blocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&entry",
            "fd.entryoffset",
            "sizeof(struct hfsplus_cat_file)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_I(inode)->subfolders"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_HAS_FOLDER_COUNT"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_size - 2"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_ut2mt",
          "args": [
            "inode->i_ctime"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_ut2mt",
          "args": [
            "inode->i_mtime"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_ut2mt",
          "args": [
            "inode->i_atime"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "main_inode->i_mode"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_find_cat",
          "args": [
            "main_inode->i_sb",
            "main_inode->i_ino",
            "&fd"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "193-220",
          "snippet": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(main_inode->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "main_inode->i_sb"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nint hfsplus_cat_write_inode(struct inode *inode)\n{\n\tstruct inode *main_inode = inode;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tmain_inode = HFSPLUS_I(inode)->rsrc_inode;\n\n\tif (!main_inode->i_nlink)\n\t\treturn 0;\n\n\tif (hfs_find_init(HFSPLUS_SB(main_inode->i_sb)->cat_tree, &fd))\n\t\t/* panic? */\n\t\treturn -EIO;\n\n\tif (hfsplus_find_cat(main_inode->i_sb, main_inode->i_ino, &fd))\n\t\t/* panic? */\n\t\tgoto out;\n\n\tif (S_ISDIR(main_inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t/* simple node checks? */\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tfolder->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfolder->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfolder->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);\n\t\tfolder->valence = cpu_to_be32(inode->i_size - 2);\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tfolder->subfolders =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->subfolders);\n\t\t}\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_folder));\n\t} else if (HFSPLUS_IS_RSRC(inode)) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t       sizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->rsrc_fork);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t} else {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->data_fork);\n\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\tfile->flags |= cpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\telse\n\t\t\tfile->flags &= cpu_to_be16(~HFSPLUS_FILE_LOCKED);\n\t\tfile->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfile->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfile->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_file));\n\t}\n\n\tset_bit(HFSPLUS_I_CAT_DIRTY, &HFSPLUS_I(inode)->flags);\nout:\n\thfs_find_exit(&fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_cat_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "475-540",
    "snippet": "int hfsplus_cat_read_inode(struct inode *inode, struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry entry;\n\tint res = 0;\n\tu16 type;\n\n\ttype = hfs_bnode_read_u16(fd->bnode, fd->entryoffset);\n\n\tHFSPLUS_I(inode)->linkid = 0;\n\tif (type == HFSPLUS_FOLDER) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\thfsplus_get_perms(inode, &folder->permissions, 1);\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = 2 + be32_to_cpu(folder->valence);\n\t\tinode->i_atime = hfsp_mt2ut(folder->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(folder->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(folder->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = folder->create_date;\n\t\tHFSPLUS_I(inode)->fs_blocks = 0;\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tHFSPLUS_I(inode)->subfolders =\n\t\t\t\tbe32_to_cpu(folder->subfolders);\n\t\t}\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (type == HFSPLUS_FILE) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\n\t\thfsplus_inode_read_fork(inode, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t&file->rsrc_fork : &file->data_fork);\n\t\thfsplus_get_perms(inode, &file->permissions, 0);\n\t\tset_nlink(inode, 1);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (file->permissions.dev)\n\t\t\t\tset_nlink(inode,\n\t\t\t\t\t  be32_to_cpu(file->permissions.dev));\n\t\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\t\tinode->i_fop = &hfsplus_file_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t   be32_to_cpu(file->permissions.dev));\n\t\t}\n\t\tinode->i_atime = hfsp_mt2ut(file->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(file->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(file->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = file->create_date;\n\t} else {\n\t\tpr_err(\"bad catalog entry used to create inode\\n\");\n\t\tres = -EIO;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};",
      "static const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};",
      "static const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad catalog entry used to create inode\\n\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsp_mt2ut",
          "args": [
            "file->attribute_mod_date"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_mt2ut",
          "args": [
            "file->content_mod_date"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_mt2ut",
          "args": [
            "file->access_date"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "be32_to_cpu(file->permissions.dev)"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "file->permissions.dev"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "be32_to_cpu(file->permissions.dev)"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "file->permissions.dev"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_get_perms",
          "args": [
            "inode",
            "&file->permissions",
            "0"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_get_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "182-214",
          "snippet": "static void hfsplus_get_perms(struct inode *inode,\n\t\tstruct hfsplus_perm *perms, int dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tu16 mode;\n\n\tmode = be16_to_cpu(perms->mode);\n\n\ti_uid_write(inode, be32_to_cpu(perms->owner));\n\tif (!i_uid_read(inode) && !mode)\n\t\tinode->i_uid = sbi->uid;\n\n\ti_gid_write(inode, be32_to_cpu(perms->group));\n\tif (!i_gid_read(inode) && !mode)\n\t\tinode->i_gid = sbi->gid;\n\n\tif (dir) {\n\t\tmode = mode ? (mode & S_IALLUGO) : (S_IRWXUGO & ~(sbi->umask));\n\t\tmode |= S_IFDIR;\n\t} else if (!mode)\n\t\tmode = S_IFREG | ((S_IRUGO|S_IWUGO) & ~(sbi->umask));\n\tinode->i_mode = mode;\n\n\tHFSPLUS_I(inode)->userflags = perms->userflags;\n\tif (perms->rootflags & HFSPLUS_FLG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (perms->rootflags & HFSPLUS_FLG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic void hfsplus_get_perms(struct inode *inode,\n\t\tstruct hfsplus_perm *perms, int dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tu16 mode;\n\n\tmode = be16_to_cpu(perms->mode);\n\n\ti_uid_write(inode, be32_to_cpu(perms->owner));\n\tif (!i_uid_read(inode) && !mode)\n\t\tinode->i_uid = sbi->uid;\n\n\ti_gid_write(inode, be32_to_cpu(perms->group));\n\tif (!i_gid_read(inode) && !mode)\n\t\tinode->i_gid = sbi->gid;\n\n\tif (dir) {\n\t\tmode = mode ? (mode & S_IALLUGO) : (S_IRWXUGO & ~(sbi->umask));\n\t\tmode |= S_IFDIR;\n\t} else if (!mode)\n\t\tmode = S_IFREG | ((S_IRUGO|S_IWUGO) & ~(sbi->umask));\n\tinode->i_mode = mode;\n\n\tHFSPLUS_I(inode)->userflags = perms->userflags;\n\tif (perms->rootflags & HFSPLUS_FLG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (perms->rootflags & HFSPLUS_FLG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_inode_read_fork",
          "args": [
            "inode",
            "HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t&file->rsrc_fork : &file->data_fork"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_inode_read_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "436-464",
          "snippet": "void hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 count;\n\tint i;\n\n\tmemcpy(&hip->first_extents, &fork->extents, sizeof(hfsplus_extent_rec));\n\tfor (count = 0, i = 0; i < 8; i++)\n\t\tcount += be32_to_cpu(fork->extents[i].block_count);\n\thip->first_blocks = count;\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\n\thip->alloc_blocks = be32_to_cpu(fork->total_blocks);\n\thip->phys_size = inode->i_size = be64_to_cpu(fork->total_size);\n\thip->fs_blocks =\n\t\t(inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thip->clump_blocks =\n\t\tbe32_to_cpu(fork->clump_size) >> sbi->alloc_blksz_shift;\n\tif (!hip->clump_blocks) {\n\t\thip->clump_blocks = HFSPLUS_IS_RSRC(inode) ?\n\t\t\tsbi->rsrc_clump_blocks :\n\t\t\tsbi->data_clump_blocks;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 count;\n\tint i;\n\n\tmemcpy(&hip->first_extents, &fork->extents, sizeof(hfsplus_extent_rec));\n\tfor (count = 0, i = 0; i < 8; i++)\n\t\tcount += be32_to_cpu(fork->extents[i].block_count);\n\thip->first_blocks = count;\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\n\thip->alloc_blocks = be32_to_cpu(fork->total_blocks);\n\thip->phys_size = inode->i_size = be64_to_cpu(fork->total_size);\n\thip->fs_blocks =\n\t\t(inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thip->clump_blocks =\n\t\tbe32_to_cpu(fork->clump_size) >> sbi->alloc_blksz_shift;\n\tif (!hip->clump_blocks) {\n\t\thip->clump_blocks = HFSPLUS_IS_RSRC(inode) ?\n\t\t\tsbi->rsrc_clump_blocks :\n\t\t\tsbi->data_clump_blocks;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd->bnode",
            "&entry",
            "fd->entryoffset",
            "sizeof(struct hfsplus_cat_file)"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "folder->subfolders"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_HAS_FOLDER_COUNT"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_mt2ut",
          "args": [
            "folder->attribute_mod_date"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_mt2ut",
          "args": [
            "folder->content_mod_date"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_mt2ut",
          "args": [
            "folder->access_date"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "folder->valence"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "fd->bnode",
            "fd->entryoffset"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nconst struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};\nstatic const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};\nstatic const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};\n\nint hfsplus_cat_read_inode(struct inode *inode, struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry entry;\n\tint res = 0;\n\tu16 type;\n\n\ttype = hfs_bnode_read_u16(fd->bnode, fd->entryoffset);\n\n\tHFSPLUS_I(inode)->linkid = 0;\n\tif (type == HFSPLUS_FOLDER) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\thfsplus_get_perms(inode, &folder->permissions, 1);\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = 2 + be32_to_cpu(folder->valence);\n\t\tinode->i_atime = hfsp_mt2ut(folder->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(folder->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(folder->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = folder->create_date;\n\t\tHFSPLUS_I(inode)->fs_blocks = 0;\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tHFSPLUS_I(inode)->subfolders =\n\t\t\t\tbe32_to_cpu(folder->subfolders);\n\t\t}\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (type == HFSPLUS_FILE) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\n\t\thfsplus_inode_read_fork(inode, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t&file->rsrc_fork : &file->data_fork);\n\t\thfsplus_get_perms(inode, &file->permissions, 0);\n\t\tset_nlink(inode, 1);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (file->permissions.dev)\n\t\t\t\tset_nlink(inode,\n\t\t\t\t\t  be32_to_cpu(file->permissions.dev));\n\t\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\t\tinode->i_fop = &hfsplus_file_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t   be32_to_cpu(file->permissions.dev));\n\t\t}\n\t\tinode->i_atime = hfsp_mt2ut(file->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(file->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(file->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = file->create_date;\n\t} else {\n\t\tpr_err(\"bad catalog entry used to create inode\\n\");\n\t\tres = -EIO;\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_inode_write_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "466-473",
    "snippet": "void hfsplus_inode_write_fork(struct inode *inode,\n\t\tstruct hfsplus_fork_raw *fork)\n{\n\tmemcpy(&fork->extents, &HFSPLUS_I(inode)->first_extents,\n\t       sizeof(hfsplus_extent_rec));\n\tfork->total_size = cpu_to_be64(inode->i_size);\n\tfork->total_blocks = cpu_to_be32(HFSPLUS_I(inode)->alloc_blocks);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_I(inode)->alloc_blocks"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_size"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fork->extents",
            "&HFSPLUS_I(inode)->first_extents",
            "sizeof(hfsplus_extent_rec)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_inode_write_fork(struct inode *inode,\n\t\tstruct hfsplus_fork_raw *fork)\n{\n\tmemcpy(&fork->extents, &HFSPLUS_I(inode)->first_extents,\n\t       sizeof(hfsplus_extent_rec));\n\tfork->total_size = cpu_to_be64(inode->i_size);\n\tfork->total_blocks = cpu_to_be32(HFSPLUS_I(inode)->alloc_blocks);\n}"
  },
  {
    "function_name": "hfsplus_inode_read_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "436-464",
    "snippet": "void hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 count;\n\tint i;\n\n\tmemcpy(&hip->first_extents, &fork->extents, sizeof(hfsplus_extent_rec));\n\tfor (count = 0, i = 0; i < 8; i++)\n\t\tcount += be32_to_cpu(fork->extents[i].block_count);\n\thip->first_blocks = count;\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\n\thip->alloc_blocks = be32_to_cpu(fork->total_blocks);\n\thip->phys_size = inode->i_size = be64_to_cpu(fork->total_size);\n\thip->fs_blocks =\n\t\t(inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thip->clump_blocks =\n\t\tbe32_to_cpu(fork->clump_size) >> sbi->alloc_blksz_shift;\n\tif (!hip->clump_blocks) {\n\t\thip->clump_blocks = HFSPLUS_IS_RSRC(inode) ?\n\t\t\tsbi->rsrc_clump_blocks :\n\t\t\tsbi->data_clump_blocks;\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fork->clump_size"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_set_bytes",
          "args": [
            "inode",
            "hip->fs_blocks << sb->s_blocksize_bits"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "503-509",
          "snippet": "void inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "fork->total_size"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fork->total_blocks"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hip->cached_extents",
            "0",
            "sizeof(hfsplus_extent_rec)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fork->extents[i].block_count"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&hip->first_extents",
            "&fork->extents",
            "sizeof(hfsplus_extent_rec)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 count;\n\tint i;\n\n\tmemcpy(&hip->first_extents, &fork->extents, sizeof(hfsplus_extent_rec));\n\tfor (count = 0, i = 0; i < 8; i++)\n\t\tcount += be32_to_cpu(fork->extents[i].block_count);\n\thip->first_blocks = count;\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\n\thip->alloc_blocks = be32_to_cpu(fork->total_blocks);\n\thip->phys_size = inode->i_size = be64_to_cpu(fork->total_size);\n\thip->fs_blocks =\n\t\t(inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thip->clump_blocks =\n\t\tbe32_to_cpu(fork->clump_size) >> sbi->alloc_blksz_shift;\n\tif (!hip->clump_blocks) {\n\t\thip->clump_blocks = HFSPLUS_IS_RSRC(inode) ?\n\t\t\tsbi->rsrc_clump_blocks :\n\t\t\tsbi->data_clump_blocks;\n\t}\n}"
  },
  {
    "function_name": "hfsplus_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "414-434",
    "snippet": "void hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_mark_mdb_dirty",
          "args": [
            "sb"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_mdb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "258-273",
          "snippet": "void hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\n\nvoid hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_file_truncate",
          "args": [
            "inode"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_file_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "531-611",
          "snippet": "void hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}"
  },
  {
    "function_name": "hfsplus_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "356-412",
    "snippet": "struct inode *hfsplus_new_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};",
      "static const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};",
      "static const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_mark_mdb_dirty",
          "args": [
            "sb"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_mdb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "258-273",
          "snippet": "void hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\n\nvoid hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hip->cached_extents",
            "0",
            "sizeof(hfsplus_extent_rec)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hip->first_extents",
            "0",
            "sizeof(hfsplus_extent_rec)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&hip->opencnt",
            "0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&hip->open_dir_list"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nconst struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};\nstatic const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};\nstatic const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};\n\nstruct inode *hfsplus_new_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "hfsplus_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "273-328",
    "snippet": "int hfsplus_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tint error = 0, error2;\n\n\terror = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (error)\n\t\treturn error;\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Sync inode metadata into the catalog and extent trees.\n\t */\n\tsync_inode_metadata(inode, 1);\n\n\t/*\n\t * And explicitly write out the btrees.\n\t */\n\tif (test_and_clear_bit(HFSPLUS_I_CAT_DIRTY, &hip->flags))\n\t\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\n\tif (test_and_clear_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags)) {\n\t\terror2 =\n\t\t\tfilemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\tif (test_and_clear_bit(HFSPLUS_I_ATTR_DIRTY, &hip->flags)) {\n\t\tif (sbi->attr_tree) {\n\t\t\terror2 =\n\t\t\t\tfilemap_write_and_wait(\n\t\t\t\t\t    sbi->attr_tree->inode->i_mapping);\n\t\t\tif (!error)\n\t\t\t\terror = error2;\n\t\t} else {\n\t\t\tpr_err(\"sync non-existent attributes tree\\n\");\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(HFSPLUS_I_ALLOC_DIRTY, &hip->flags)) {\n\t\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "inode->i_sb->s_bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFSPLUS_SB_NOBARRIER",
            "&sbi->flags"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->alloc_file->i_mapping"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "HFSPLUS_I_ALLOC_DIRTY",
            "&hip->flags"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"sync non-existent attributes tree\\n\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->attr_tree->inode->i_mapping"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->ext_tree->inode->i_mapping"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->cat_tree->inode->i_mapping"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_inode_metadata",
          "args": [
            "inode",
            "1"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1513-1521",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nint hfsplus_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tint error = 0, error2;\n\n\terror = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (error)\n\t\treturn error;\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Sync inode metadata into the catalog and extent trees.\n\t */\n\tsync_inode_metadata(inode, 1);\n\n\t/*\n\t * And explicitly write out the btrees.\n\t */\n\tif (test_and_clear_bit(HFSPLUS_I_CAT_DIRTY, &hip->flags))\n\t\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\n\tif (test_and_clear_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags)) {\n\t\terror2 =\n\t\t\tfilemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\tif (test_and_clear_bit(HFSPLUS_I_ATTR_DIRTY, &hip->flags)) {\n\t\tif (sbi->attr_tree) {\n\t\t\terror2 =\n\t\t\t\tfilemap_write_and_wait(\n\t\t\t\t\t    sbi->attr_tree->inode->i_mapping);\n\t\t\tif (!error)\n\t\t\t\terror = error2;\n\t\t} else {\n\t\t\tpr_err(\"sync non-existent attributes tree\\n\");\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(HFSPLUS_I_ALLOC_DIRTY, &hip->flags)) {\n\t\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn error;\n}"
  },
  {
    "function_name": "hfsplus_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "245-271",
    "snippet": "static int hfsplus_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "inode->i_mode"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_file_truncate",
          "args": [
            "inode"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_file_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "531-611",
          "snippet": "void hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic int hfsplus_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "226-243",
    "snippet": "static int hfsplus_file_release(struct inode *inode, struct file *file)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tinode = HFSPLUS_I(inode)->rsrc_inode;\n\tif (atomic_dec_and_test(&HFSPLUS_I(inode)->opencnt)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\thfsplus_file_truncate(inode);\n\t\tif (inode->i_flags & S_DEAD) {\n\t\t\thfsplus_delete_cat(inode->i_ino,\n\t\t\t\t\t   HFSPLUS_SB(sb)->hidden_dir, NULL);\n\t\t\thfsplus_delete_inode(inode);\n\t\t}\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_inode",
          "args": [
            "inode"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "414-434",
          "snippet": "void hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_cat",
          "args": [
            "inode->i_ino",
            "HFSPLUS_SB(sb)->hidden_dir",
            "NULL"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "321-411",
          "snippet": "int hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_file_truncate",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_file_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "531-611",
          "snippet": "void hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&HFSPLUS_I(inode)->opencnt"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic int hfsplus_file_release(struct inode *inode, struct file *file)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tinode = HFSPLUS_I(inode)->rsrc_inode;\n\tif (atomic_dec_and_test(&HFSPLUS_I(inode)->opencnt)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\thfsplus_file_truncate(inode);\n\t\tif (inode->i_flags & S_DEAD) {\n\t\t\thfsplus_delete_cat(inode->i_ino,\n\t\t\t\t\t   HFSPLUS_SB(sb)->hidden_dir, NULL);\n\t\t\thfsplus_delete_inode(inode);\n\t\t}\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "216-224",
    "snippet": "static int hfsplus_file_open(struct inode *inode, struct file *file)\n{\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tinode = HFSPLUS_I(inode)->rsrc_inode;\n\tif (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\tatomic_inc(&HFSPLUS_I(inode)->opencnt);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&HFSPLUS_I(inode)->opencnt"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic int hfsplus_file_open(struct inode *inode, struct file *file)\n{\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tinode = HFSPLUS_I(inode)->rsrc_inode;\n\tif (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\tatomic_inc(&HFSPLUS_I(inode)->opencnt);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_get_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "182-214",
    "snippet": "static void hfsplus_get_perms(struct inode *inode,\n\t\tstruct hfsplus_perm *perms, int dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tu16 mode;\n\n\tmode = be16_to_cpu(perms->mode);\n\n\ti_uid_write(inode, be32_to_cpu(perms->owner));\n\tif (!i_uid_read(inode) && !mode)\n\t\tinode->i_uid = sbi->uid;\n\n\ti_gid_write(inode, be32_to_cpu(perms->group));\n\tif (!i_gid_read(inode) && !mode)\n\t\tinode->i_gid = sbi->gid;\n\n\tif (dir) {\n\t\tmode = mode ? (mode & S_IALLUGO) : (S_IRWXUGO & ~(sbi->umask));\n\t\tmode |= S_IFDIR;\n\t} else if (!mode)\n\t\tmode = S_IFREG | ((S_IRUGO|S_IWUGO) & ~(sbi->umask));\n\tinode->i_mode = mode;\n\n\tHFSPLUS_I(inode)->userflags = perms->userflags;\n\tif (perms->rootflags & HFSPLUS_FLG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (perms->rootflags & HFSPLUS_FLG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "be32_to_cpu(perms->group)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "perms->group"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "be32_to_cpu(perms->owner)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "perms->owner"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "perms->mode"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic void hfsplus_get_perms(struct inode *inode,\n\t\tstruct hfsplus_perm *perms, int dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tu16 mode;\n\n\tmode = be16_to_cpu(perms->mode);\n\n\ti_uid_write(inode, be32_to_cpu(perms->owner));\n\tif (!i_uid_read(inode) && !mode)\n\t\tinode->i_uid = sbi->uid;\n\n\ti_gid_write(inode, be32_to_cpu(perms->group));\n\tif (!i_gid_read(inode) && !mode)\n\t\tinode->i_gid = sbi->gid;\n\n\tif (dir) {\n\t\tmode = mode ? (mode & S_IALLUGO) : (S_IRWXUGO & ~(sbi->umask));\n\t\tmode |= S_IFDIR;\n\t} else if (!mode)\n\t\tmode = S_IFREG | ((S_IRUGO|S_IWUGO) & ~(sbi->umask));\n\tinode->i_mode = mode;\n\n\tHFSPLUS_I(inode)->userflags = perms->userflags;\n\tif (perms->rootflags & HFSPLUS_FLG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (perms->rootflags & HFSPLUS_FLG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n}"
  },
  {
    "function_name": "hfsplus_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "152-156",
    "snippet": "static int hfsplus_writepages(struct address_space *mapping,\n\t\t\t      struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hfsplus_get_block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "hfsplus_get_block"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic int hfsplus_writepages(struct address_space *mapping,\n\t\t\t      struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hfsplus_get_block);\n}"
  },
  {
    "function_name": "hfsplus_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "125-150",
    "snippet": "static ssize_t hfsplus_direct_IO(int rw, struct kiocb *iocb,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file_inode(file)->i_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, \n\t\t\t\t hfsplus_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\thfsplus_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_write_failed",
          "args": [
            "mapping",
            "end"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "34-42",
          "snippet": "static void hfsplus_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic void hfsplus_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(rw & WRITE) && ret < 0"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "hfsplus_get_block"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic ssize_t hfsplus_direct_IO(int rw, struct kiocb *iocb,\n\t\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file_inode(file)->i_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, \n\t\t\t\t hfsplus_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\thfsplus_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hfsplus_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "65-123",
    "snippet": "static int hfsplus_releasepage(struct page *page, gfp_t mask)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node;\n\tu32 nidx;\n\tint i, res = 1;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\ttree = HFSPLUS_SB(sb)->ext_tree;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\ttree = HFSPLUS_SB(sb)->cat_tree;\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\ttree = HFSPLUS_SB(sb)->attr_tree;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\tif (!tree)\n\t\treturn 0;\n\tif (tree->node_size >= PAGE_CACHE_SIZE) {\n\t\tnidx = page->index >>\n\t\t\t(tree->node_size_shift - PAGE_CACHE_SHIFT);\n\t\tspin_lock(&tree->hash_lock);\n\t\tnode = hfs_bnode_findhash(tree, nidx);\n\t\tif (!node)\n\t\t\t;\n\t\telse if (atomic_read(&node->refcnt))\n\t\t\tres = 0;\n\t\tif (res && node) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t} else {\n\t\tnidx = page->index <<\n\t\t\t(PAGE_CACHE_SHIFT - tree->node_size_shift);\n\t\ti = 1 << (PAGE_CACHE_SHIFT - tree->node_size_shift);\n\t\tspin_lock(&tree->hash_lock);\n\t\tdo {\n\t\t\tnode = hfs_bnode_findhash(tree, nidx++);\n\t\t\tif (!node)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&node->refcnt)) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t} while (--i && nidx < tree->node_count);\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n\treturn res ? try_to_free_buffers(page) : 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_free",
          "args": [
            "node"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "567-577",
          "snippet": "void hfs_bnode_free(struct hfs_bnode *node)\n{\n#if 0\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tpage_cache_release(node->page[i]);\n#endif\n\tkfree(node);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_free(struct hfs_bnode *node)\n{\n#if 0\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tpage_cache_release(node->page[i]);\n#endif\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_unhash",
          "args": [
            "node"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_unhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "467-479",
          "snippet": "void hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_findhash",
          "args": [
            "tree",
            "nidx++"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_findhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "384-399",
          "snippet": "struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic int hfsplus_releasepage(struct page *page, gfp_t mask)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node;\n\tu32 nidx;\n\tint i, res = 1;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\ttree = HFSPLUS_SB(sb)->ext_tree;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\ttree = HFSPLUS_SB(sb)->cat_tree;\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\ttree = HFSPLUS_SB(sb)->attr_tree;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\tif (!tree)\n\t\treturn 0;\n\tif (tree->node_size >= PAGE_CACHE_SIZE) {\n\t\tnidx = page->index >>\n\t\t\t(tree->node_size_shift - PAGE_CACHE_SHIFT);\n\t\tspin_lock(&tree->hash_lock);\n\t\tnode = hfs_bnode_findhash(tree, nidx);\n\t\tif (!node)\n\t\t\t;\n\t\telse if (atomic_read(&node->refcnt))\n\t\t\tres = 0;\n\t\tif (res && node) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t} else {\n\t\tnidx = page->index <<\n\t\t\t(PAGE_CACHE_SHIFT - tree->node_size_shift);\n\t\ti = 1 << (PAGE_CACHE_SHIFT - tree->node_size_shift);\n\t\tspin_lock(&tree->hash_lock);\n\t\tdo {\n\t\t\tnode = hfs_bnode_findhash(tree, nidx++);\n\t\t\tif (!node)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&node->refcnt)) {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t} while (--i && nidx < tree->node_count);\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n\treturn res ? try_to_free_buffers(page) : 0;\n}"
  },
  {
    "function_name": "hfsplus_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "60-63",
    "snippet": "static sector_t hfsplus_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, hfsplus_get_block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "hfsplus_get_block"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic sector_t hfsplus_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, hfsplus_get_block);\n}"
  },
  {
    "function_name": "hfsplus_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "44-58",
    "snippet": "static int hfsplus_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\thfsplus_get_block,\n\t\t\t\t&HFSPLUS_I(mapping->host)->phys_size);\n\tif (unlikely(ret))\n\t\thfsplus_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "34-42",
          "snippet": "static void hfsplus_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic void hfsplus_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cont_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata",
            "hfsplus_get_block",
            "&HFSPLUS_I(mapping->host)->phys_size"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "cont_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2352-2373",
          "snippet": "int cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "mapping->host"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic int hfsplus_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\thfsplus_get_block,\n\t\t\t\t&HFSPLUS_I(mapping->host)->phys_size);\n\tif (unlikely(ret))\n\t\thfsplus_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hfsplus_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "34-42",
    "snippet": "static void hfsplus_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_file_truncate",
          "args": [
            "inode"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_file_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "531-611",
          "snippet": "void hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic void hfsplus_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfsplus_file_truncate(inode);\n\t}\n}"
  },
  {
    "function_name": "hfsplus_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "29-32",
    "snippet": "static int hfsplus_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, hfsplus_get_block, wbc);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "hfsplus_get_block",
            "wbc"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic int hfsplus_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, hfsplus_get_block, wbc);\n}"
  },
  {
    "function_name": "hfsplus_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
    "lines": "24-27",
    "snippet": "static int hfsplus_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, hfsplus_get_block);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "hfsplus_get_block"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nstatic int hfsplus_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, hfsplus_get_block);\n}"
  }
]