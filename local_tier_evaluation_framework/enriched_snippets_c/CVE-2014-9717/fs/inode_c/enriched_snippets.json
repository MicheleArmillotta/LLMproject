[
  {
    "function_name": "inode_set_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1979-1990",
    "snippet": "void inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = ACCESS_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&inode->i_flags",
            "old_flags",
            "new_flags"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "inode->i_flags"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "flags & ~mask"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = ACCESS_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}"
  },
  {
    "function_name": "inode_dio_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1955-1959",
    "snippet": "void inode_dio_done(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_DIO_WAKEUP"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_done(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}"
  },
  {
    "function_name": "inode_dio_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1941-1945",
    "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "__inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1918-1929",
          "snippet": "static void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wait);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
  },
  {
    "function_name": "__inode_dio_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1918-1929",
    "snippet": "static void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wait);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&q.wait"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&q.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "q",
            "&inode->i_state",
            "__I_DIO_WAKEUP"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&inode->i_state",
            "__I_DIO_WAKEUP"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wait);\n}"
  },
  {
    "function_name": "inode_owner_or_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1901-1912",
    "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "ns",
            "inode->i_uid"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns",
            "CAP_FOWNER"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "inode->i_uid"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "inode_init_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1880-1891",
    "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
  },
  {
    "function_name": "init_special_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1854-1871",
    "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\"",
            "mode",
            "inode->i_sb->s_id",
            "inode->i_ino"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
  },
  {
    "function_name": "inode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1823-1852",
    "snippet": "void __init inode_init(void)\n{\n\tunsigned int loop;\n\n\t/* inode slab cache */\n\tinode_cachep = kmem_cache_create(\"inode_cache\",\n\t\t\t\t\t sizeof(struct inode),\n\t\t\t\t\t 0,\n\t\t\t\t\t (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD),\n\t\t\t\t\t init_once);\n\n\t/* Hash may have been set up in inode_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\t0,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\n\tfor (loop = 0; loop < (1U << i_hash_shift); loop++)\n\t\tINIT_HLIST_HEAD(&inode_hashtable[loop]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int i_hash_mask",
      "static unsigned int i_hash_shift",
      "static struct hlist_head *inode_hashtable",
      "static struct kmem_cache *inode_cachep",
      "static void __wait_on_freeing_inode(struct inode *inode);",
      "static __initdata unsigned long ihash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&inode_hashtable[loop]"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"Inode-cache\"",
            "sizeof(struct hlist_head)",
            "ihash_entries",
            "14",
            "0",
            "&i_hash_shift",
            "&i_hash_mask",
            "0",
            "0"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"inode_cache\"",
            "sizeof(struct inode)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic unsigned int i_hash_mask;\nstatic unsigned int i_hash_shift;\nstatic struct hlist_head *inode_hashtable;\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\nstatic __initdata unsigned long ihash_entries;\n\nvoid __init inode_init(void)\n{\n\tunsigned int loop;\n\n\t/* inode slab cache */\n\tinode_cachep = kmem_cache_create(\"inode_cache\",\n\t\t\t\t\t sizeof(struct inode),\n\t\t\t\t\t 0,\n\t\t\t\t\t (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD),\n\t\t\t\t\t init_once);\n\n\t/* Hash may have been set up in inode_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\t0,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\n\tfor (loop = 0; loop < (1U << i_hash_shift); loop++)\n\t\tINIT_HLIST_HEAD(&inode_hashtable[loop]);\n}"
  },
  {
    "function_name": "inode_init_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1798-1821",
    "snippet": "void __init inode_init_early(void)\n{\n\tunsigned int loop;\n\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\n\tfor (loop = 0; loop < (1U << i_hash_shift); loop++)\n\t\tINIT_HLIST_HEAD(&inode_hashtable[loop]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int i_hash_mask",
      "static unsigned int i_hash_shift",
      "static struct hlist_head *inode_hashtable",
      "static __initdata unsigned long ihash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&inode_hashtable[loop]"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"Inode-cache\"",
            "sizeof(struct hlist_head)",
            "ihash_entries",
            "14",
            "HASH_EARLY",
            "&i_hash_shift",
            "&i_hash_mask",
            "0",
            "0"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic unsigned int i_hash_mask;\nstatic unsigned int i_hash_shift;\nstatic struct hlist_head *inode_hashtable;\nstatic __initdata unsigned long ihash_entries;\n\nvoid __init inode_init_early(void)\n{\n\tunsigned int loop;\n\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\n\tfor (loop = 0; loop < (1U << i_hash_shift); loop++)\n\t\tINIT_HLIST_HEAD(&inode_hashtable[loop]);\n}"
  },
  {
    "function_name": "set_ihash_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1786-1792",
    "snippet": "static int __init set_ihash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tihash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __initdata unsigned long ihash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "0"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __initdata unsigned long ihash_entries;\n\nstatic int __init set_ihash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tihash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "__wait_on_freeing_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1772-1783",
    "snippet": "static void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wait);\n\tspin_lock(&inode_hash_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&wait.wait"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&wait.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wait",
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wait);\n\tspin_lock(&inode_hash_lock);\n}"
  },
  {
    "function_name": "inode_needs_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1751-1758",
    "snippet": "int inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "inode"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "file_update_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1716-1748",
    "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "482-485",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_time",
          "args": [
            "inode",
            "&now",
            "sync_it"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1569-1577",
          "snippet": "static int update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "425-431",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_I_VERSION",
          "args": [
            "inode"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_ctime",
            "&now"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_mtime",
            "&now"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOCMTIME",
          "args": [
            "inode"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "file_remove_suid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1675-1700",
    "snippet": "int file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_suid",
          "args": [
            "dentry",
            "killsuid"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1663-1673",
          "snippet": "static int __remove_suid(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic int __remove_suid(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_killpriv",
          "args": [
            "dentry"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_need_killpriv",
          "args": [
            "dentry"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_remove_suid",
          "args": [
            "dentry"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "should_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1640-1660",
          "snippet": "int should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NOSEC",
          "args": [
            "inode"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}"
  },
  {
    "function_name": "__remove_suid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1663-1673",
    "snippet": "static int __remove_suid(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "dentry",
            "&newattrs",
            "NULL"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic int __remove_suid(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}"
  },
  {
    "function_name": "should_remove_suid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1640-1660",
    "snippet": "int should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kill && !capable(CAP_FSETID) && S_ISREG(mode)"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_FSETID"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(mode & S_ISGID) && (mode & S_IXGRP)"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mode & S_ISUID"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "touch_atime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1587-1631",
    "snippet": "void touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tif (!relatime_need_update(mnt, inode, now))\n\t\treturn;\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt))\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "inode->i_sb"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mnt_drop_write",
          "args": [
            "mnt"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "482-485",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_time",
          "args": [
            "inode",
            "&now",
            "S_ATIME"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1569-1577",
          "snippet": "static int update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_want_write",
          "args": [
            "mnt"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "425-431",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write_trylock",
          "args": [
            "inode->i_sb"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_atime",
            "&now"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relatime_need_update",
          "args": [
            "mnt",
            "inode",
            "now"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "relatime_need_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1516-1543",
          "snippet": "static int relatime_need_update(struct vfsmount *mnt, struct inode *inode,\n\t\t\t     struct timespec now)\n{\n\n\tif (!(mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int relatime_need_update(struct vfsmount *mnt, struct inode *inode,\n\t\t\t     struct timespec now)\n{\n\n\tif (!(mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOATIME",
          "args": [
            "inode"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tif (!relatime_need_update(mnt, inode, now))\n\t\treturn;\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt))\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}"
  },
  {
    "function_name": "update_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1569-1577",
    "snippet": "static int update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_time",
          "args": [
            "inode",
            "time",
            "flags"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1569-1577",
          "snippet": "static int update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}"
  },
  {
    "function_name": "generic_update_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1545-1562",
    "snippet": "int generic_update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint iflags = I_DIRTY_TIME;\n\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *time;\n\tif (flags & S_VERSION)\n\t\tinode_inc_iversion(inode);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *time;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *time;\n\n\tif (!(inode->i_sb->s_flags & MS_LAZYTIME) || (flags & S_VERSION))\n\t\tiflags |= I_DIRTY_SYNC;\n\t__mark_inode_dirty(inode, iflags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "iflags"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_iversion",
          "args": [
            "inode"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint generic_update_time(struct inode *inode, struct timespec *time, int flags)\n{\n\tint iflags = I_DIRTY_TIME;\n\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *time;\n\tif (flags & S_VERSION)\n\t\tinode_inc_iversion(inode);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *time;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *time;\n\n\tif (!(inode->i_sb->s_flags & MS_LAZYTIME) || (flags & S_VERSION))\n\t\tiflags |= I_DIRTY_SYNC;\n\t__mark_inode_dirty(inode, iflags);\n\treturn 0;\n}"
  },
  {
    "function_name": "relatime_need_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1516-1543",
    "snippet": "static int relatime_need_update(struct vfsmount *mnt, struct inode *inode,\n\t\t\t     struct timespec now)\n{\n\n\tif (!(mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&inode->i_ctime",
            "&inode->i_atime"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&inode->i_mtime",
            "&inode->i_atime"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int relatime_need_update(struct vfsmount *mnt, struct inode *inode,\n\t\t\t     struct timespec now)\n{\n\n\tif (!(mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1502-1508",
    "snippet": "sector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode->i_mapping->a_ops->bmap",
          "args": [
            "inode->i_mapping",
            "block"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1502-1508",
          "snippet": "sector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nsector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}"
  },
  {
    "function_name": "iput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1471-1488",
    "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput_final",
          "args": [
            "inode"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "iput_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1425-1460",
          "snippet": "static void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & MS_ACTIVE)) {\n\t\tinode->i_state |= I_REFERENCED;\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & MS_ACTIVE)) {\n\t\tinode->i_state |= I_REFERENCED;\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_lazytime_iput",
          "args": [
            "inode"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&inode->i_count"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&inode->i_count",
            "&inode->i_lock"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_state & I_CLEAR"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
  },
  {
    "function_name": "iput_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1425-1460",
    "snippet": "static void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & MS_ACTIVE)) {\n\t\tinode->i_state |= I_REFERENCED;\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evict",
          "args": [
            "inode"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "evict_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "590-614",
          "snippet": "void evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lru_list_del",
          "args": [
            "inode"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "inode_lru_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "414-419",
          "snippet": "static void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_lru"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_NEW"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "1"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_lru",
          "args": [
            "inode"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "405-411",
          "snippet": "void inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & MS_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & MS_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->drop_inode",
          "args": [
            "inode"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_NEW"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & MS_ACTIVE)) {\n\t\tinode->i_state |= I_REFERENCED;\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}"
  },
  {
    "function_name": "generic_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1409-1412",
    "snippet": "int generic_delete_inode(struct inode *inode)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint generic_delete_inode(struct inode *inode)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "insert_inode_locked4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1365-1405",
    "snippet": "int insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "old"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode_unhashed(old)"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "old"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "old"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "old"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "head"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!old"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test",
          "args": [
            "old",
            "data"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "test_inode_iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1119-1134",
          "snippet": "static int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "old",
            "head",
            "i_hash"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "hashval"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
  },
  {
    "function_name": "insert_inode_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1323-1362",
    "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "old"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode_unhashed(old)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "old"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "old"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "old"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "head"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!old"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "old",
            "head",
            "i_hash"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
  },
  {
    "function_name": "find_inode_nowait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1296-1320",
    "snippet": "struct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "inode",
            "hashval",
            "data"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "other_inode_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4189-4219",
          "snippet": "static int other_inode_match(struct inode * inode, unsigned long ino,\n\t\t\t     void *data)\n{\n\tstruct other_inode *oi = (struct other_inode *) data;\n\n\tif ((inode->i_ino != ino) ||\n\t    (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t       I_DIRTY_SYNC | I_DIRTY_DATASYNC)) ||\n\t    ((inode->i_state & I_DIRTY_TIME) == 0))\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tif (((inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t\tI_DIRTY_SYNC | I_DIRTY_DATASYNC)) == 0) &&\n\t    (inode->i_state & I_DIRTY_TIME)) {\n\t\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\n\t\tinode->i_state &= ~(I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tspin_lock(&ei->i_raw_lock);\n\t\tEXT4_INODE_SET_XTIME(i_ctime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_mtime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_atime, inode, oi->raw_inode);\n\t\text4_inode_csum_set(inode, oi->raw_inode, ei);\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\ttrace_ext4_other_inode_update_time(inode, oi->orig_ino);\n\t\treturn -1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int other_inode_match(struct inode * inode, unsigned long ino,\n\t\t\t     void *data)\n{\n\tstruct other_inode *oi = (struct other_inode *) data;\n\n\tif ((inode->i_ino != ino) ||\n\t    (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t       I_DIRTY_SYNC | I_DIRTY_DATASYNC)) ||\n\t    ((inode->i_state & I_DIRTY_TIME) == 0))\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tif (((inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t\tI_DIRTY_SYNC | I_DIRTY_DATASYNC)) == 0) &&\n\t    (inode->i_state & I_DIRTY_TIME)) {\n\t\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\n\t\tinode->i_state &= ~(I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tspin_lock(&ei->i_raw_lock);\n\t\tEXT4_INODE_SET_XTIME(i_ctime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_mtime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_atime, inode, oi->raw_inode);\n\t\text4_inode_csum_set(inode, oi->raw_inode, ei);\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\ttrace_ext4_other_inode_update_time(inode, oi->orig_ino);\n\t\treturn -1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "inode",
            "head",
            "i_hash"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "hashval"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}"
  },
  {
    "function_name": "ilookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1258-1270",
    "snippet": "struct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inode_fast",
          "args": [
            "sb",
            "head",
            "ino"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "787-808",
          "snippet": "static struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "ilookup5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1239-1247",
    "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilookup5_nowait",
          "args": [
            "sb",
            "hashval",
            "test",
            "data"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1208-1219",
          "snippet": "struct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "ilookup5_nowait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1208-1219",
    "snippet": "struct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inode",
          "args": [
            "sb",
            "head",
            "test",
            "data"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1296-1320",
          "snippet": "struct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "hashval"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "igrab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1173-1189",
    "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "iunique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1150-1170",
    "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&iunique_lock"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_inode_iunique",
          "args": [
            "sb",
            "res"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "test_inode_iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1119-1134",
          "snippet": "static int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&iunique_lock"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "test_inode_iunique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1119-1134",
    "snippet": "static int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "inode",
            "b",
            "i_hash"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "iget_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "1063-1109",
    "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_inode",
          "args": [
            "inode"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "250-258",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sb_list_add",
          "args": [
            "inode"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "425-430",
          "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "head"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inode_fast",
          "args": [
            "sb",
            "head",
            "ino"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "787-808",
          "snippet": "static struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode",
          "args": [
            "sb"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "194-215",
          "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inode_cachep",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "iget5_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "991-1047",
    "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inode",
          "args": [
            "inode"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "250-258",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_sb_list_add",
          "args": [
            "inode"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "425-430",
          "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "head"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set",
          "args": [
            "inode",
            "data"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inode",
          "args": [
            "sb",
            "head",
            "test",
            "data"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1296-1320",
          "snippet": "struct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode",
          "args": [
            "sb"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "194-215",
          "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inode_cachep",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "hashval"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "unlock_two_nondirectories",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "962-968",
    "snippet": "void unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_unlock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_unlock(&inode2->i_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode2->i_mutex"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode2->i_mode"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode1->i_mutex"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode1->i_mode"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_unlock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_unlock(&inode2->i_mutex);\n}"
  },
  {
    "function_name": "lock_two_nondirectories",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "945-954",
    "snippet": "void lock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 > inode2)\n\t\tswap(inode1, inode2);\n\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_lock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_NONDIR2);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&inode2->i_mutex",
            "I_MUTEX_NONDIR2"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode2->i_mode"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode1->i_mutex"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode1->i_mode"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "inode1",
            "inode2"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2438-2481",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tkmemcheck_mark_initialized(dentry->d_iname, DNAME_INLINE_LEN);\n\t\t\tkmemcheck_mark_initialized(target->d_iname, DNAME_INLINE_LEN);\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 > inode2)\n\t\tswap(inode1, inode2);\n\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_lock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_NONDIR2);\n}"
  },
  {
    "function_name": "unlock_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "924-933",
    "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & I_NEW)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_annotate_inode_mutex_key",
          "args": [
            "inode"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_annotate_inode_mutex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "897-913",
          "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "lockdep_annotate_inode_mutex_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "897-913",
    "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_mutex",
            "&type->i_mutex_dir_key"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_match_class",
          "args": [
            "&inode->i_mutex",
            "&type->i_mutex_key"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_mutex, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tmutex_destroy(&inode->i_mutex);\n\t\t\tmutex_init(&inode->i_mutex);\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "883-893",
    "snippet": "struct inode *new_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tspin_lock_prefetch(&inode_sb_list_lock);\n\n\tinode = new_inode_pseudo(sb);\n\tif (inode)\n\t\tinode_sb_list_add(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_sb_list_add",
          "args": [
            "inode"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "425-430",
          "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_pseudo",
          "args": [
            "sb"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "858-869",
          "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_prefetch",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tspin_lock_prefetch(&inode_sb_list_lock);\n\n\tinode = new_inode_pseudo(sb);\n\tif (inode)\n\t\tinode_sb_list_add(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "new_inode_pseudo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "858-869",
    "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_sb_list"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode",
          "args": [
            "sb"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "194-215",
          "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inode_cachep",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "get_next_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "828-845",
    "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define LAST_INO_BATCH 1024"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned int, last_ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "last_ino"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "LAST_INO_BATCH",
            "&shared_last_ino"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(res & (LAST_INO_BATCH-1)) == 0"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "last_ino"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
  },
  {
    "function_name": "find_inode_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "787-808",
    "snippet": "static struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_freeing_inode",
          "args": [
            "inode"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_freeing_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1772-1783",
          "snippet": "static void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wait);\n\tspin_lock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wait);\n\tspin_lock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "inode",
            "head",
            "i_hash"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "758-781",
    "snippet": "static struct inode *find_inode(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head,\n\t\t\t\tint (*test)(struct inode *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tif (!test(inode, data))\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_freeing_inode",
          "args": [
            "inode"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_freeing_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1772-1783",
          "snippet": "static void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wait);\n\tspin_lock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wait);\n\tspin_lock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test",
          "args": [
            "inode",
            "data"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "test_inode_iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1119-1134",
          "snippet": "static int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "inode",
            "head",
            "i_hash"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *find_inode(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head,\n\t\t\t\tint (*test)(struct inode *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tif (!test(inode, data))\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "prune_icache_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "743-752",
    "snippet": "long prune_icache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_inode_lru, sc,\n\t\t\t\t     inode_lru_isolate, &freeable);\n\tdispose_list(&freeable);\n\treturn freed;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispose_list",
          "args": [
            "&freeable"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "569-579",
          "snippet": "static void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_walk",
          "args": [
            "&sb->s_inode_lru",
            "sc",
            "inode_lru_isolate",
            "&freeable"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "freeable"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nlong prune_icache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_inode_lru, sc,\n\t\t\t\t     inode_lru_isolate, &freeable);\n\tdispose_list(&freeable);\n\treturn freed;\n}"
  },
  {
    "function_name": "inode_lru_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "677-735",
    "snippet": "static enum lru_status inode_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct inode\t*inode = container_of(item, struct inode, i_lru);\n\n\t/*\n\t * we are inverting the lru lock/inode->i_lock here, so use a trylock.\n\t * If we fail to get the lock, just skip it.\n\t */\n\tif (!spin_trylock(&inode->i_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * Referenced or dirty inodes are still in use. Give them another pass\n\t * through the LRU as we canot reclaim them now.\n\t */\n\tif (atomic_read(&inode->i_count) ||\n\t    (inode->i_state & ~I_REFERENCED)) {\n\t\tlist_lru_isolate(lru, &inode->i_lru);\n\t\tspin_unlock(&inode->i_lock);\n\t\tthis_cpu_dec(nr_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t/* recently referenced inodes get one more pass */\n\tif (inode->i_state & I_REFERENCED) {\n\t\tinode->i_state &= ~I_REFERENCED;\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn LRU_ROTATE;\n\t}\n\n\tif (inode_has_buffers(inode) || inode->i_data.nrpages) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(lru_lock);\n\t\tif (remove_inode_buffers(inode)) {\n\t\t\tunsigned long reap;\n\t\t\treap = invalidate_mapping_pages(&inode->i_data, 0, -1);\n\t\t\tif (current_is_kswapd())\n\t\t\t\t__count_vm_events(KSWAPD_INODESTEAL, reap);\n\t\t\telse\n\t\t\t\t__count_vm_events(PGINODESTEAL, reap);\n\t\t\tif (current->reclaim_state)\n\t\t\t\tcurrent->reclaim_state->reclaimed_slab += reap;\n\t\t}\n\t\tiput(inode);\n\t\tspin_lock(lru_lock);\n\t\treturn LRU_RETRY;\n\t}\n\n\tWARN_ON(inode->i_state & I_NEW);\n\tinode->i_state |= I_FREEING;\n\tlist_lru_isolate_move(lru, &inode->i_lru, freeable);\n\tspin_unlock(&inode->i_lock);\n\n\tthis_cpu_dec(nr_unused);\n\treturn LRU_REMOVED;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_unused);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_unused"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_isolate_move",
          "args": [
            "lru",
            "&inode->i_lru",
            "freeable"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_NEW"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lru_lock"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGINODESTEAL",
            "reap"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "KSWAPD_INODESTEAL",
            "reap"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "&inode->i_data",
            "0",
            "-1"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "remove_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "823-844",
          "snippet": "int remove_inode_buffers(struct inode *inode)\n{\n\tint ret = 1;\n\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct buffer_head *bh = BH_ENTRY(list->next);\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__remove_assoc_queue(bh);\n\t\t}\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nint remove_inode_buffers(struct inode *inode)\n{\n\tint ret = 1;\n\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct buffer_head *bh = BH_ENTRY(list->next);\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__remove_assoc_queue(bh);\n\t\t}\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_has_buffers",
          "args": [
            "inode"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "inode_has_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "488-491",
          "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_unused"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_isolate",
          "args": [
            "lru",
            "&inode->i_lru"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structinode",
            "i_lru"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic enum lru_status inode_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct inode\t*inode = container_of(item, struct inode, i_lru);\n\n\t/*\n\t * we are inverting the lru lock/inode->i_lock here, so use a trylock.\n\t * If we fail to get the lock, just skip it.\n\t */\n\tif (!spin_trylock(&inode->i_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * Referenced or dirty inodes are still in use. Give them another pass\n\t * through the LRU as we canot reclaim them now.\n\t */\n\tif (atomic_read(&inode->i_count) ||\n\t    (inode->i_state & ~I_REFERENCED)) {\n\t\tlist_lru_isolate(lru, &inode->i_lru);\n\t\tspin_unlock(&inode->i_lock);\n\t\tthis_cpu_dec(nr_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t/* recently referenced inodes get one more pass */\n\tif (inode->i_state & I_REFERENCED) {\n\t\tinode->i_state &= ~I_REFERENCED;\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn LRU_ROTATE;\n\t}\n\n\tif (inode_has_buffers(inode) || inode->i_data.nrpages) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(lru_lock);\n\t\tif (remove_inode_buffers(inode)) {\n\t\t\tunsigned long reap;\n\t\t\treap = invalidate_mapping_pages(&inode->i_data, 0, -1);\n\t\t\tif (current_is_kswapd())\n\t\t\t\t__count_vm_events(KSWAPD_INODESTEAL, reap);\n\t\t\telse\n\t\t\t\t__count_vm_events(PGINODESTEAL, reap);\n\t\t\tif (current->reclaim_state)\n\t\t\t\tcurrent->reclaim_state->reclaimed_slab += reap;\n\t\t}\n\t\tiput(inode);\n\t\tspin_lock(lru_lock);\n\t\treturn LRU_RETRY;\n\t}\n\n\tWARN_ON(inode->i_state & I_NEW);\n\tinode->i_state |= I_FREEING;\n\tlist_lru_isolate_move(lru, &inode->i_lru, freeable);\n\tspin_unlock(&inode->i_lock);\n\n\tthis_cpu_dec(nr_unused);\n\treturn LRU_REMOVED;\n}"
  },
  {
    "function_name": "invalidate_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "626-660",
    "snippet": "int invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "569-579",
          "snippet": "static void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&inode->i_lru",
            "&dispose"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lru_list_del",
          "args": [
            "inode"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "inode_lru_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "414-419",
          "snippet": "static void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "inode",
            "next",
            "&sb->s_inodes",
            "i_sb_list"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}"
  },
  {
    "function_name": "evict_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "590-614",
    "snippet": "void evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "569-579",
          "snippet": "static void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&inode->i_lru",
            "&dispose"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lru_list_del",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "inode_lru_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "414-419",
          "snippet": "static void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "inode",
            "next",
            "&sb->s_inodes",
            "i_sb_list"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n}"
  },
  {
    "function_name": "dispose_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "569-579",
    "snippet": "static void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evict",
          "args": [
            "inode"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "evict_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "590-614",
          "snippet": "void evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_lru"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structinode",
            "i_lru"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t}\n}"
  },
  {
    "function_name": "evict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "521-560",
    "snippet": "static void evict(struct inode *inode)\n{\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(!list_empty(&inode->i_lru));\n\n\tif (!list_empty(&inode->i_wb_list))\n\t\tinode_wb_list_del(inode);\n\n\tinode_sb_list_del(inode);\n\n\t/*\n\t * Wait for flusher thread to be done with the inode so that filesystem\n\t * does not start destroying it while writeback is still running. Since\n\t * the inode has I_FREEING set, flusher thread won't start new work on\n\t * the inode.  We just have to wait for running writeback to finish.\n\t */\n\tinode_wait_for_writeback(inode);\n\n\tif (op->evict_inode) {\n\t\top->evict_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t}\n\tif (S_ISBLK(inode->i_mode) && inode->i_bdev)\n\t\tbd_forget(inode);\n\tif (S_ISCHR(inode->i_mode) && inode->i_cdev)\n\t\tcd_forget(inode);\n\n\tremove_inode_hash(inode);\n\n\tspin_lock(&inode->i_lock);\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tBUG_ON(inode->i_state != (I_FREEING | I_CLEAR));\n\tspin_unlock(&inode->i_lock);\n\n\tdestroy_inode(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inode",
          "args": [
            "inode"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "250-258",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_state != (I_FREEING | I_CLEAR)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_inode_hash",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "478-485",
          "snippet": "void __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_forget",
          "args": [
            "inode"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "cd_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "400-406",
          "snippet": "void cd_forget(struct inode *inode)\n{\n\tspin_lock(&cdev_lock);\n\tlist_del_init(&inode->i_devices);\n\tinode->i_cdev = NULL;\n\tspin_unlock(&cdev_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(cdev_lock);\n\nvoid cd_forget(struct inode *inode)\n{\n\tspin_lock(&cdev_lock);\n\tlist_del_init(&inode->i_devices);\n\tinode->i_cdev = NULL;\n\tspin_unlock(&cdev_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_forget",
          "args": [
            "inode"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "bd_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "699-711",
          "snippet": "void bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\t__bd_forget(inode);\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\t__bd_forget(inode);\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->evict_inode",
          "args": [
            "inode"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_wait_for_writeback",
          "args": [
            "inode"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "inode_wait_for_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "376-381",
          "snippet": "void inode_wait_for_writeback(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_wait_for_writeback(inode);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid inode_wait_for_writeback(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_wait_for_writeback(inode);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sb_list_del",
          "args": [
            "inode"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_wb_list_del",
          "args": [
            "inode"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "inode_wb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "191-198",
          "snippet": "void inode_wb_list_del(struct inode *inode)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\n\tspin_lock(&bdi->wb.list_lock);\n\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&bdi->wb.list_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid inode_wb_list_del(struct inode *inode)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\n\tspin_lock(&bdi->wb.list_lock);\n\tlist_del_init(&inode->i_wb_list);\n\tspin_unlock(&bdi->wb.list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&inode->i_lru)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(inode->i_state & I_FREEING)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void evict(struct inode *inode)\n{\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(!list_empty(&inode->i_lru));\n\n\tif (!list_empty(&inode->i_wb_list))\n\t\tinode_wb_list_del(inode);\n\n\tinode_sb_list_del(inode);\n\n\t/*\n\t * Wait for flusher thread to be done with the inode so that filesystem\n\t * does not start destroying it while writeback is still running. Since\n\t * the inode has I_FREEING set, flusher thread won't start new work on\n\t * the inode.  We just have to wait for running writeback to finish.\n\t */\n\tinode_wait_for_writeback(inode);\n\n\tif (op->evict_inode) {\n\t\top->evict_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t}\n\tif (S_ISBLK(inode->i_mode) && inode->i_bdev)\n\t\tbd_forget(inode);\n\tif (S_ISCHR(inode->i_mode) && inode->i_cdev)\n\t\tcd_forget(inode);\n\n\tremove_inode_hash(inode);\n\n\tspin_lock(&inode->i_lock);\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tBUG_ON(inode->i_state != (I_FREEING | I_CLEAR));\n\tspin_unlock(&inode->i_lock);\n\n\tdestroy_inode(inode);\n}"
  },
  {
    "function_name": "clear_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "488-505",
    "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_state & I_CLEAR"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(inode->i_state & I_FREEING)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&inode->i_data.private_list)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_data.private_list"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&inode->i_data.tree_lock"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_data.nrshadows"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_data.nrpages"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&inode->i_data.tree_lock"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
  },
  {
    "function_name": "__remove_inode_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "478-485",
    "snippet": "void __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&inode->i_hash"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
  },
  {
    "function_name": "__insert_inode_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "460-469",
    "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "b"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "inode->i_sb",
            "hashval"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "442-450",
    "snippet": "static unsigned long hash(struct super_block *sb, unsigned long hashval)\n{\n\tunsigned long tmp;\n\n\ttmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) /\n\t\t\tL1_CACHE_BYTES;\n\ttmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) >> i_hash_shift);\n\treturn tmp & i_hash_mask;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int i_hash_mask",
      "static unsigned int i_hash_shift"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic unsigned int i_hash_mask;\nstatic unsigned int i_hash_shift;\n\nstatic unsigned long hash(struct super_block *sb, unsigned long hashval)\n{\n\tunsigned long tmp;\n\n\ttmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) /\n\t\t\tL1_CACHE_BYTES;\n\ttmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) >> i_hash_shift);\n\treturn tmp & i_hash_mask;\n}"
  },
  {
    "function_name": "inode_sb_list_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "433-440",
    "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_sb_list"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_sb_list"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
  },
  {
    "function_name": "inode_sb_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "425-430",
    "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&inode->i_sb_list",
            "&inode->i_sb->s_inodes"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}"
  },
  {
    "function_name": "inode_lru_list_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "414-419",
    "snippet": "static void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_unused);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_unused"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&inode->i_sb->s_inode_lru",
            "&inode->i_lru"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}"
  },
  {
    "function_name": "inode_add_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "405-411",
    "snippet": "void inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & MS_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_lru_list_add",
          "args": [
            "inode"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "inode_lru_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "394-398",
          "snippet": "static void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & MS_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}"
  },
  {
    "function_name": "inode_lru_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "394-398",
    "snippet": "static void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_unused);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "nr_unused"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_add",
          "args": [
            "&inode->i_sb->s_inode_lru",
            "&inode->i_lru"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n}"
  },
  {
    "function_name": "ihold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "388-391",
    "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_inc_return(&inode->i_count) < 2"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&inode->i_count"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
  },
  {
    "function_name": "__iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "380-383",
    "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&inode->i_count"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "370-375",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct inode *inode = (struct inode *) foo;\n\n\tinode_init_once(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "inode"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void init_once(void *foo)\n{\n\tstruct inode *inode = (struct inode *) foo;\n\n\tinode_init_once(inode);\n}"
  },
  {
    "function_name": "inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "355-367",
    "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&inode->i_fsnotify_marks"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_ordered_init",
          "args": [
            "inode"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address_space_init_once",
          "args": [
            "&inode->i_data"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "address_space_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "338-347",
          "snippet": "void address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_lru"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_devices"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&inode->i_hash"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "inode",
            "0",
            "sizeof(*inode)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
  },
  {
    "function_name": "address_space_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "338-347",
    "snippet": "void address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mapping->private_list"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&mapping->i_mmap_rwsem"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mapping->tree_lock"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&mapping->page_tree",
            "GFP_ATOMIC"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mapping",
            "0",
            "sizeof(*mapping)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}"
  },
  {
    "function_name": "inc_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "327-335",
    "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & I_LINKABLE)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_nlink == 0"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
  },
  {
    "function_name": "set_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "305-316",
    "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
  },
  {
    "function_name": "clear_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "288-294",
    "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
  },
  {
    "function_name": "drop_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "271-277",
    "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_nlink == 0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
  },
  {
    "function_name": "destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "250-258",
    "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "i_callback"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_sb->s_op->destroy_inode",
          "args": [
            "inode"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "250-258",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__destroy_inode",
          "args": [
            "inode"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "223-241",
          "snippet": "void __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode->i_flctx);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && inode->i_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && inode->i_default_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode->i_flctx);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && inode->i_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && inode->i_default_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&inode->i_lru)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_lru"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
  },
  {
    "function_name": "i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "244-248",
    "snippet": "static void i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(inode_cachep, inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inode_cachep",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_cachep",
            "inode"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(inode_cachep, inode);\n}"
  },
  {
    "function_name": "__destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "223-241",
    "snippet": "void __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode->i_flctx);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && inode->i_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && inode->i_default_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_inodes"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "inode->i_default_acl"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "inode->i_acl"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_long_read(&inode->i_sb->s_remove_count) == 0"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock_context",
          "args": [
            "inode->i_flctx"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "239-248",
          "snippet": "void\nlocks_free_lock_context(struct file_lock_context *ctx)\n{\n\tif (ctx) {\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_flock));\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_posix));\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_lease));\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flctx_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nvoid\nlocks_free_lock_context(struct file_lock_context *ctx)\n{\n\tif (ctx) {\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_flock));\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_posix));\n\t\tWARN_ON_ONCE(!list_empty(&ctx->flc_lease));\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_inode_delete",
          "args": [
            "inode"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_inode_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "34-37",
          "snippet": "void __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_free",
          "args": [
            "inode"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode_has_buffers(inode)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_has_buffers",
          "args": [
            "inode"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "inode_has_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "488-491",
          "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode->i_flctx);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && inode->i_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && inode->i_default_acl != ACL_NOT_CACHED)\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}"
  },
  {
    "function_name": "free_inode_nonrcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "217-220",
    "snippet": "void free_inode_nonrcu(struct inode *inode)\n{\n\tkmem_cache_free(inode_cachep, inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inode_cachep",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_cachep",
            "inode"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid free_inode_nonrcu(struct inode *inode)\n{\n\tkmem_cache_free(inode_cachep, inode);\n}"
  },
  {
    "function_name": "alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "194-215",
    "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inode_cachep",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_cachep",
            "inode"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_sb->s_op->destroy_inode",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "250-258",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode_init_always(sb, inode)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_always",
          "args": [
            "sb",
            "inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_always",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "131-191",
          "snippet": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations empty_aops = {\n};",
            "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nconst struct address_space_operations empty_aops = {\n};\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->alloc_inode",
          "args": [
            "sb"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "194-215",
          "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "inode_init_always",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "131-191",
    "snippet": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations empty_aops = {\n};",
      "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "nr_inodes"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&inode->i_dentry"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "mapping",
            "GFP_HIGHUSER_MOVABLE"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mapping->i_mmap_writable",
            "0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&inode->i_dio_count",
            "0"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_mutex",
            "&sb->s_type->i_mutex_key"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_lock",
            "&sb->s_type->i_lock_key"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&inode->i_lock"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_alloc",
          "args": [
            "inode"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&inode->i_writecount",
            "0"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&inode->i_count",
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nconst struct address_space_operations empty_aops = {\n};\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "no_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "118-121",
    "snippet": "static int no_open(struct inode *inode, struct file *file)\n{\n\treturn -ENXIO;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int no_open(struct inode *inode, struct file *file)\n{\n\treturn -ENXIO;\n}"
  },
  {
    "function_name": "proc_nr_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "109-115",
    "snippet": "int proc_nr_inodes(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tinodes_stat.nr_inodes = get_nr_inodes();\n\tinodes_stat.nr_unused = get_nr_inodes_unused();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct inodes_stat_t inodes_stat;",
      "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
      "static DEFINE_PER_CPU(unsigned long, nr_unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_inodes_unused",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_inodes_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "89-96",
          "snippet": "static inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nstatic inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstruct inodes_stat_t inodes_stat;\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nint proc_nr_inodes(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tinodes_stat.nr_inodes = get_nr_inodes();\n\tinodes_stat.nr_unused = get_nr_inodes_unused();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "get_nr_dirty_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "98-103",
    "snippet": "long get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_nr_inodes_unused",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_inodes_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "89-96",
          "snippet": "static inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nstatic inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nlong get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}"
  },
  {
    "function_name": "get_nr_inodes_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "89-96",
    "snippet": "static inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_unused);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nstatic inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}"
  },
  {
    "function_name": "get_nr_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
    "lines": "80-87",
    "snippet": "static long get_nr_inodes(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_inodes, i);\n\treturn sum < 0 ? 0 : sum;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_inodes);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\n\nstatic long get_nr_inodes(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_inodes, i);\n\treturn sum < 0 ? 0 : sum;\n}"
  }
]