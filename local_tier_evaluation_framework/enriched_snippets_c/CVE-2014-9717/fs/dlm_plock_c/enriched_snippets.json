[
  {
    "function_name": "dlm_plock_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "510-514",
    "snippet": "void dlm_plock_exit(void)\n{\n\tif (misc_deregister(&plock_dev_misc) < 0)\n\t\tlog_print(\"dlm_plock_exit: misc_deregister failed\");\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice plock_dev_misc = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = DLM_PLOCK_MISC_NAME,\n\t.fops = &dev_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm_plock_exit: misc_deregister failed\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&plock_dev_misc"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic struct miscdevice plock_dev_misc = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = DLM_PLOCK_MISC_NAME,\n\t.fops = &dev_fops\n};\n\nvoid dlm_plock_exit(void)\n{\n\tif (misc_deregister(&plock_dev_misc) < 0)\n\t\tlog_print(\"dlm_plock_exit: misc_deregister failed\");\n}"
  },
  {
    "function_name": "dlm_plock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "494-508",
    "snippet": "int dlm_plock_init(void)\n{\n\tint rv;\n\n\tspin_lock_init(&ops_lock);\n\tINIT_LIST_HEAD(&send_list);\n\tINIT_LIST_HEAD(&recv_list);\n\tinit_waitqueue_head(&send_wq);\n\tinit_waitqueue_head(&recv_wq);\n\n\trv = misc_register(&plock_dev_misc);\n\tif (rv)\n\t\tlog_print(\"dlm_plock_init: misc_register failed %d\", rv);\n\treturn rv;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;",
      "static struct list_head send_list;",
      "static struct list_head recv_list;",
      "static wait_queue_head_t send_wq;",
      "static wait_queue_head_t recv_wq;",
      "static struct miscdevice plock_dev_misc = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = DLM_PLOCK_MISC_NAME,\n\t.fops = &dev_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm_plock_init: misc_register failed %d\"",
            "rv"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&plock_dev_misc"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&recv_wq"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&send_wq"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&recv_list"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&send_list"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ops_lock"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head send_list;\nstatic struct list_head recv_list;\nstatic wait_queue_head_t send_wq;\nstatic wait_queue_head_t recv_wq;\nstatic struct miscdevice plock_dev_misc = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = DLM_PLOCK_MISC_NAME,\n\t.fops = &dev_fops\n};\n\nint dlm_plock_init(void)\n{\n\tint rv;\n\n\tspin_lock_init(&ops_lock);\n\tINIT_LIST_HEAD(&send_list);\n\tINIT_LIST_HEAD(&recv_list);\n\tinit_waitqueue_head(&send_wq);\n\tinit_waitqueue_head(&recv_wq);\n\n\trv = misc_register(&plock_dev_misc);\n\tif (rv)\n\t\tlog_print(\"dlm_plock_init: misc_register failed %d\", rv);\n\treturn rv;\n}"
  },
  {
    "function_name": "dev_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "466-478",
    "snippet": "static unsigned int dev_poll(struct file *file, poll_table *wait)\n{\n\tunsigned int mask = 0;\n\n\tpoll_wait(file, &send_wq, wait);\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&send_list))\n\t\tmask = POLLIN | POLLRDNORM;\n\tspin_unlock(&ops_lock);\n\n\treturn mask;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;",
      "static struct list_head send_list;",
      "static wait_queue_head_t send_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ops_lock"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&send_list"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ops_lock"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&send_wq",
            "wait"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head send_list;\nstatic wait_queue_head_t send_wq;\n\nstatic unsigned int dev_poll(struct file *file, poll_table *wait)\n{\n\tunsigned int mask = 0;\n\n\tpoll_wait(file, &send_wq, wait);\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&send_list))\n\t\tmask = POLLIN | POLLRDNORM;\n\tspin_unlock(&ops_lock);\n\n\treturn mask;\n}"
  },
  {
    "function_name": "dev_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "421-464",
    "snippet": "static ssize_t dev_write(struct file *file, const char __user *u, size_t count,\n\t\t\t loff_t *ppos)\n{\n\tstruct dlm_plock_info info;\n\tstruct plock_op *op;\n\tint found = 0, do_callback = 0;\n\n\tif (count != sizeof(info))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&info, u, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (check_version(&info))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ops_lock);\n\tlist_for_each_entry(op, &recv_list, list) {\n\t\tif (op->info.fsid == info.fsid &&\n\t\t    op->info.number == info.number &&\n\t\t    op->info.owner == info.owner) {\n\t\t\tstruct plock_xop *xop = (struct plock_xop *)op;\n\t\t\tlist_del_init(&op->list);\n\t\t\tmemcpy(&op->info, &info, sizeof(info));\n\t\t\tif (xop->callback)\n\t\t\t\tdo_callback = 1;\n\t\t\telse\n\t\t\t\top->done = 1;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ops_lock);\n\n\tif (found) {\n\t\tif (do_callback)\n\t\t\tdlm_plock_callback(op);\n\t\telse\n\t\t\twake_up(&recv_wq);\n\t} else\n\t\tlog_print(\"dev_write no op %x %llx\", info.fsid,\n\t\t\t  (unsigned long long)info.number);\n\treturn count;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;",
      "static struct list_head recv_list;",
      "static wait_queue_head_t recv_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dev_write no op %x %llx\"",
            "info.fsid",
            "(unsigned long long)info.number"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&recv_wq"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_plock_callback",
          "args": [
            "op"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_plock_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "188-242",
          "snippet": "static int dlm_plock_callback(struct plock_op *op)\n{\n\tstruct file *file;\n\tstruct file_lock *fl;\n\tstruct file_lock *flc;\n\tint (*notify)(struct file_lock *fl, int result) = NULL;\n\tstruct plock_xop *xop = (struct plock_xop *)op;\n\tint rv = 0;\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_print(\"dlm_plock_callback: op on list %llx\",\n\t\t\t  (unsigned long long)op->info.number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* check if the following 2 are still valid or make a copy */\n\tfile = xop->file;\n\tflc = &xop->flc;\n\tfl = xop->fl;\n\tnotify = xop->callback;\n\n\tif (op->info.rv) {\n\t\tnotify(fl, op->info.rv);\n\t\tgoto out;\n\t}\n\n\t/* got fs lock; bookkeep locally as well: */\n\tflc->fl_flags &= ~FL_SLEEP;\n\tif (posix_lock_file(file, flc, NULL)) {\n\t\t/*\n\t\t * This can only happen in the case of kmalloc() failure.\n\t\t * The filesystem's own lock is the authoritative lock,\n\t\t * so a failure to get the lock locally is not a disaster.\n\t\t * As long as the fs cannot reliably cancel locks (especially\n\t\t * in a low-memory situation), we're better off ignoring\n\t\t * this failure than trying to recover.\n\t\t */\n\t\tlog_print(\"dlm_plock_callback: vfs lock error %llx file %p fl %p\",\n\t\t\t  (unsigned long long)op->info.number, file, fl);\n\t}\n\n\trv = notify(fl, 0);\n\tif (rv) {\n\t\t/* XXX: We need to cancel the fs lock here: */\n\t\tlog_print(\"dlm_plock_callback: lock granted after lock request \"\n\t\t\t  \"failed; dangling lock!\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(xop);\n\treturn rv;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\n\nstatic int dlm_plock_callback(struct plock_op *op)\n{\n\tstruct file *file;\n\tstruct file_lock *fl;\n\tstruct file_lock *flc;\n\tint (*notify)(struct file_lock *fl, int result) = NULL;\n\tstruct plock_xop *xop = (struct plock_xop *)op;\n\tint rv = 0;\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_print(\"dlm_plock_callback: op on list %llx\",\n\t\t\t  (unsigned long long)op->info.number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* check if the following 2 are still valid or make a copy */\n\tfile = xop->file;\n\tflc = &xop->flc;\n\tfl = xop->fl;\n\tnotify = xop->callback;\n\n\tif (op->info.rv) {\n\t\tnotify(fl, op->info.rv);\n\t\tgoto out;\n\t}\n\n\t/* got fs lock; bookkeep locally as well: */\n\tflc->fl_flags &= ~FL_SLEEP;\n\tif (posix_lock_file(file, flc, NULL)) {\n\t\t/*\n\t\t * This can only happen in the case of kmalloc() failure.\n\t\t * The filesystem's own lock is the authoritative lock,\n\t\t * so a failure to get the lock locally is not a disaster.\n\t\t * As long as the fs cannot reliably cancel locks (especially\n\t\t * in a low-memory situation), we're better off ignoring\n\t\t * this failure than trying to recover.\n\t\t */\n\t\tlog_print(\"dlm_plock_callback: vfs lock error %llx file %p fl %p\",\n\t\t\t  (unsigned long long)op->info.number, file, fl);\n\t}\n\n\trv = notify(fl, 0);\n\tif (rv) {\n\t\t/* XXX: We need to cancel the fs lock here: */\n\t\tlog_print(\"dlm_plock_callback: lock granted after lock request \"\n\t\t\t  \"failed; dangling lock!\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(xop);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ops_lock"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&op->info",
            "&info",
            "sizeof(info)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "op",
            "&recv_list",
            "list"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ops_lock"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_version",
          "args": [
            "&info"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "check_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "47-62",
          "snippet": "static int check_version(struct dlm_plock_info *info)\n{\n\tif ((DLM_PLOCK_VERSION_MAJOR != info->version[0]) ||\n\t    (DLM_PLOCK_VERSION_MINOR < info->version[1])) {\n\t\tlog_print(\"plock device version mismatch: \"\n\t\t\t  \"kernel (%u.%u.%u), user (%u.%u.%u)\",\n\t\t\t  DLM_PLOCK_VERSION_MAJOR,\n\t\t\t  DLM_PLOCK_VERSION_MINOR,\n\t\t\t  DLM_PLOCK_VERSION_PATCH,\n\t\t\t  info->version[0],\n\t\t\t  info->version[1],\n\t\t\t  info->version[2]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic int check_version(struct dlm_plock_info *info)\n{\n\tif ((DLM_PLOCK_VERSION_MAJOR != info->version[0]) ||\n\t    (DLM_PLOCK_VERSION_MINOR < info->version[1])) {\n\t\tlog_print(\"plock device version mismatch: \"\n\t\t\t  \"kernel (%u.%u.%u), user (%u.%u.%u)\",\n\t\t\t  DLM_PLOCK_VERSION_MAJOR,\n\t\t\t  DLM_PLOCK_VERSION_MINOR,\n\t\t\t  DLM_PLOCK_VERSION_PATCH,\n\t\t\t  info->version[0],\n\t\t\t  info->version[1],\n\t\t\t  info->version[2]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info",
            "u",
            "sizeof(info)"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head recv_list;\nstatic wait_queue_head_t recv_wq;\n\nstatic ssize_t dev_write(struct file *file, const char __user *u, size_t count,\n\t\t\t loff_t *ppos)\n{\n\tstruct dlm_plock_info info;\n\tstruct plock_op *op;\n\tint found = 0, do_callback = 0;\n\n\tif (count != sizeof(info))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&info, u, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (check_version(&info))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ops_lock);\n\tlist_for_each_entry(op, &recv_list, list) {\n\t\tif (op->info.fsid == info.fsid &&\n\t\t    op->info.number == info.number &&\n\t\t    op->info.owner == info.owner) {\n\t\t\tstruct plock_xop *xop = (struct plock_xop *)op;\n\t\t\tlist_del_init(&op->list);\n\t\t\tmemcpy(&op->info, &info, sizeof(info));\n\t\t\tif (xop->callback)\n\t\t\t\tdo_callback = 1;\n\t\t\telse\n\t\t\t\top->done = 1;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ops_lock);\n\n\tif (found) {\n\t\tif (do_callback)\n\t\t\tdlm_plock_callback(op);\n\t\telse\n\t\t\twake_up(&recv_wq);\n\t} else\n\t\tlog_print(\"dev_write no op %x %llx\", info.fsid,\n\t\t\t  (unsigned long long)info.number);\n\treturn count;\n}"
  },
  {
    "function_name": "dev_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "384-417",
    "snippet": "static ssize_t dev_read(struct file *file, char __user *u, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct dlm_plock_info info;\n\tstruct plock_op *op = NULL;\n\n\tif (count < sizeof(info))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&send_list)) {\n\t\top = list_entry(send_list.next, struct plock_op, list);\n\t\tif (op->info.flags & DLM_PLOCK_FL_CLOSE)\n\t\t\tlist_del(&op->list);\n\t\telse\n\t\t\tlist_move(&op->list, &recv_list);\n\t\tmemcpy(&info, &op->info, sizeof(info));\n\t}\n\tspin_unlock(&ops_lock);\n\n\tif (!op)\n\t\treturn -EAGAIN;\n\n\t/* there is no need to get a reply from userspace for unlocks\n\t   that were generated by the vfs cleaning up for a close\n\t   (the process did not make an unlock call). */\n\n\tif (op->info.flags & DLM_PLOCK_FL_CLOSE)\n\t\tkfree(op);\n\n\tif (copy_to_user(u, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn sizeof(info);\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;",
      "static struct list_head send_list;",
      "static struct list_head recv_list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "u",
            "&info",
            "sizeof(info)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ops_lock"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&info",
            "&op->info",
            "sizeof(info)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&op->list",
            "&recv_list"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&op->list"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "send_list.next",
            "structplock_op",
            "list"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&send_list"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ops_lock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head send_list;\nstatic struct list_head recv_list;\n\nstatic ssize_t dev_read(struct file *file, char __user *u, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct dlm_plock_info info;\n\tstruct plock_op *op = NULL;\n\n\tif (count < sizeof(info))\n\t\treturn -EINVAL;\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&send_list)) {\n\t\top = list_entry(send_list.next, struct plock_op, list);\n\t\tif (op->info.flags & DLM_PLOCK_FL_CLOSE)\n\t\t\tlist_del(&op->list);\n\t\telse\n\t\t\tlist_move(&op->list, &recv_list);\n\t\tmemcpy(&info, &op->info, sizeof(info));\n\t}\n\tspin_unlock(&ops_lock);\n\n\tif (!op)\n\t\treturn -EAGAIN;\n\n\t/* there is no need to get a reply from userspace for unlocks\n\t   that were generated by the vfs cleaning up for a close\n\t   (the process did not make an unlock call). */\n\n\tif (op->info.flags & DLM_PLOCK_FL_CLOSE)\n\t\tkfree(op);\n\n\tif (copy_to_user(u, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn sizeof(info);\n}"
  },
  {
    "function_name": "dlm_posix_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "318-380",
    "snippet": "int dlm_posix_get(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t  struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_GET;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_get: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* info.rv from userspace is 1 for conflict, 0 for no-conflict,\n\t   -ENOENT if there are no locks on the file */\n\n\trv = op->info.rv;\n\n\tfl->fl_type = F_UNLCK;\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\telse if (rv > 0) {\n\t\tlocks_init_lock(fl);\n\t\tfl->fl_type = (op->info.ex) ? F_WRLCK : F_RDLCK;\n\t\tfl->fl_flags = FL_POSIX;\n\t\tfl->fl_pid = op->info.pid;\n\t\tfl->fl_start = op->info.start;\n\t\tfl->fl_end = op->info.end;\n\t\trv = 0;\n\t}\n\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;",
      "static wait_queue_head_t recv_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "fl"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ops_lock"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&op->list"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_posix_get: op on list %llx\"",
            "(unsigned long long)number"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ops_lock"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "recv_wq",
            "(op->done != 0)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_op",
          "args": [
            "op"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "send_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "64-72",
          "snippet": "static void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static struct list_head send_list;",
            "static wait_queue_head_t send_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head send_list;\nstatic wait_queue_head_t send_wq;\n\nstatic void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*op)",
            "GFP_NOFS"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "lockspace"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_get(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t  struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_GET;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_get: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* info.rv from userspace is 1 for conflict, 0 for no-conflict,\n\t   -ENOENT if there are no locks on the file */\n\n\trv = op->info.rv;\n\n\tfl->fl_type = F_UNLCK;\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\telse if (rv > 0) {\n\t\tlocks_init_lock(fl);\n\t\tfl->fl_type = (op->info.ex) ? F_WRLCK : F_RDLCK;\n\t\tfl->fl_flags = FL_POSIX;\n\t\tfl->fl_pid = op->info.pid;\n\t\tfl->fl_start = op->info.start;\n\t\tfl->fl_end = op->info.end;\n\t\trv = 0;\n\t}\n\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}"
  },
  {
    "function_name": "dlm_posix_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "244-315",
    "snippet": "int dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t     struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* cause the vfs unlock to return ENOENT if lock is not found */\n\tfl->fl_flags |= FL_EXISTS;\n\n\trv = posix_lock_file_wait(file, fl);\n\tif (rv == -ENOENT) {\n\t\trv = 0;\n\t\tgoto out_free;\n\t}\n\tif (rv < 0) {\n\t\tlog_error(ls, \"dlm_posix_unlock: vfs unlock error %d %llx\",\n\t\t\t  rv, (unsigned long long)number);\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tif (fl->fl_flags & FL_CLOSE) {\n\t\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\t\tsend_op(op);\n\t\trv = 0;\n\t\tgoto out;\n\t}\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_unlock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\nout_free:\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\tfl->fl_flags = fl_flags;\n\treturn rv;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;",
      "static wait_queue_head_t recv_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ops_lock"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&op->list"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_posix_unlock: op on list %llx\"",
            "(unsigned long long)number"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ops_lock"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "recv_wq",
            "(op->done != 0)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_op",
          "args": [
            "op"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "send_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "64-72",
          "snippet": "static void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static struct list_head send_list;",
            "static wait_queue_head_t send_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head send_list;\nstatic wait_queue_head_t send_wq;\n\nstatic void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_posix_unlock: vfs unlock error %d %llx\"",
            "rv",
            "(unsigned long long)number"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1173-1189",
          "snippet": "int posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*op)",
            "GFP_NOFS"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "lockspace"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t     struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tint rv;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* cause the vfs unlock to return ENOENT if lock is not found */\n\tfl->fl_flags |= FL_EXISTS;\n\n\trv = posix_lock_file_wait(file, fl);\n\tif (rv == -ENOENT) {\n\t\trv = 0;\n\t\tgoto out_free;\n\t}\n\tif (rv < 0) {\n\t\tlog_error(ls, \"dlm_posix_unlock: vfs unlock error %d %llx\",\n\t\t\t  rv, (unsigned long long)number);\n\t}\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\tif (fl->fl_flags & FL_CLOSE) {\n\t\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\t\tsend_op(op);\n\t\trv = 0;\n\t\tgoto out;\n\t}\n\n\tsend_op(op);\n\twait_event(recv_wq, (op->done != 0));\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_unlock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (rv == -ENOENT)\n\t\trv = 0;\n\nout_free:\n\tkfree(op);\nout:\n\tdlm_put_lockspace(ls);\n\tfl->fl_flags = fl_flags;\n\treturn rv;\n}"
  },
  {
    "function_name": "dlm_plock_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "188-242",
    "snippet": "static int dlm_plock_callback(struct plock_op *op)\n{\n\tstruct file *file;\n\tstruct file_lock *fl;\n\tstruct file_lock *flc;\n\tint (*notify)(struct file_lock *fl, int result) = NULL;\n\tstruct plock_xop *xop = (struct plock_xop *)op;\n\tint rv = 0;\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_print(\"dlm_plock_callback: op on list %llx\",\n\t\t\t  (unsigned long long)op->info.number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* check if the following 2 are still valid or make a copy */\n\tfile = xop->file;\n\tflc = &xop->flc;\n\tfl = xop->fl;\n\tnotify = xop->callback;\n\n\tif (op->info.rv) {\n\t\tnotify(fl, op->info.rv);\n\t\tgoto out;\n\t}\n\n\t/* got fs lock; bookkeep locally as well: */\n\tflc->fl_flags &= ~FL_SLEEP;\n\tif (posix_lock_file(file, flc, NULL)) {\n\t\t/*\n\t\t * This can only happen in the case of kmalloc() failure.\n\t\t * The filesystem's own lock is the authoritative lock,\n\t\t * so a failure to get the lock locally is not a disaster.\n\t\t * As long as the fs cannot reliably cancel locks (especially\n\t\t * in a low-memory situation), we're better off ignoring\n\t\t * this failure than trying to recover.\n\t\t */\n\t\tlog_print(\"dlm_plock_callback: vfs lock error %llx file %p fl %p\",\n\t\t\t  (unsigned long long)op->info.number, file, fl);\n\t}\n\n\trv = notify(fl, 0);\n\tif (rv) {\n\t\t/* XXX: We need to cancel the fs lock here: */\n\t\tlog_print(\"dlm_plock_callback: lock granted after lock request \"\n\t\t\t  \"failed; dangling lock!\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(xop);\n\treturn rv;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xop"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm_plock_callback: lock granted after lock request \"\n\t\t\t  \"failed; dangling lock!\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify",
          "args": [
            "fl",
            "0"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "proc_notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "102-118",
          "snippet": "static int proc_notify_change(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct proc_dir_entry *de = PDE(inode);\n\tint error;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\n\tproc_set_user(de, inode->i_uid, inode->i_gid);\n\tde->mode = inode->i_mode;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic int proc_notify_change(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct proc_dir_entry *de = PDE(inode);\n\tint error;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\n\tproc_set_user(de, inode->i_uid, inode->i_gid);\n\tde->mode = inode->i_mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm_plock_callback: vfs lock error %llx file %p fl %p\"",
            "(unsigned long long)op->info.number",
            "file",
            "fl"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "file",
            "flc",
            "NULL"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1157-1161",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ops_lock"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&op->list"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm_plock_callback: op on list %llx\"",
            "(unsigned long long)op->info.number"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ops_lock"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\n\nstatic int dlm_plock_callback(struct plock_op *op)\n{\n\tstruct file *file;\n\tstruct file_lock *fl;\n\tstruct file_lock *flc;\n\tint (*notify)(struct file_lock *fl, int result) = NULL;\n\tstruct plock_xop *xop = (struct plock_xop *)op;\n\tint rv = 0;\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_print(\"dlm_plock_callback: op on list %llx\",\n\t\t\t  (unsigned long long)op->info.number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\t/* check if the following 2 are still valid or make a copy */\n\tfile = xop->file;\n\tflc = &xop->flc;\n\tfl = xop->fl;\n\tnotify = xop->callback;\n\n\tif (op->info.rv) {\n\t\tnotify(fl, op->info.rv);\n\t\tgoto out;\n\t}\n\n\t/* got fs lock; bookkeep locally as well: */\n\tflc->fl_flags &= ~FL_SLEEP;\n\tif (posix_lock_file(file, flc, NULL)) {\n\t\t/*\n\t\t * This can only happen in the case of kmalloc() failure.\n\t\t * The filesystem's own lock is the authoritative lock,\n\t\t * so a failure to get the lock locally is not a disaster.\n\t\t * As long as the fs cannot reliably cancel locks (especially\n\t\t * in a low-memory situation), we're better off ignoring\n\t\t * this failure than trying to recover.\n\t\t */\n\t\tlog_print(\"dlm_plock_callback: vfs lock error %llx file %p fl %p\",\n\t\t\t  (unsigned long long)op->info.number, file, fl);\n\t}\n\n\trv = notify(fl, 0);\n\tif (rv) {\n\t\t/* XXX: We need to cancel the fs lock here: */\n\t\tlog_print(\"dlm_plock_callback: lock granted after lock request \"\n\t\t\t  \"failed; dangling lock!\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(xop);\n\treturn rv;\n}"
  },
  {
    "function_name": "dlm_posix_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "104-184",
    "snippet": "int dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t   int cmd, struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tstruct plock_xop *xop;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\txop = kzalloc(sizeof(*xop), GFP_NOFS);\n\tif (!xop) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top = &xop->xop;\n\top->info.optype\t\t= DLM_PLOCK_OP_LOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.wait\t\t= IS_SETLKW(cmd);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* fl_owner is lockd which doesn't distinguish\n\t\t   processes on the nfs client */\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\t\txop->callback\t= fl->fl_lmops->lm_grant;\n\t\tlocks_init_lock(&xop->flc);\n\t\tlocks_copy_lock(&xop->flc, fl);\n\t\txop->fl\t\t= fl;\n\t\txop->file\t= file;\n\t} else {\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\t\txop->callback\t= NULL;\n\t}\n\n\tsend_op(op);\n\n\tif (xop->callback == NULL) {\n\t\trv = wait_event_killable(recv_wq, (op->done != 0));\n\t\tif (rv == -ERESTARTSYS) {\n\t\t\tlog_debug(ls, \"dlm_posix_lock: wait killed %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t\t\tspin_lock(&ops_lock);\n\t\t\tlist_del(&op->list);\n\t\t\tspin_unlock(&ops_lock);\n\t\t\tkfree(xop);\n\t\t\tdo_unlock_close(ls, number, file, fl);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\trv = FILE_LOCK_DEFERRED;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_lock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (!rv) {\n\t\tif (posix_lock_file_wait(file, fl) < 0)\n\t\t\tlog_error(ls, \"dlm_posix_lock: vfs lock error %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t}\n\n\tkfree(xop);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;",
      "static wait_queue_head_t recv_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xop"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_posix_lock: vfs lock error %llx\"",
            "(unsigned long long)number"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1173-1189",
          "snippet": "int posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ops_lock"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&op->list"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_posix_lock: op on list %llx\"",
            "(unsigned long long)number"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ops_lock"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unlock_close",
          "args": [
            "ls",
            "number",
            "file",
            "fl"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "do_unlock_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "80-102",
          "snippet": "static void do_unlock_close(struct dlm_ls *ls, u64 number,\n\t\t\t    struct file *file, struct file_lock *fl)\n{\n\tstruct plock_op *op;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op)\n\t\treturn;\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= 0;\n\top->info.end\t\t= OFFSET_MAX;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\tsend_op(op);\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic void do_unlock_close(struct dlm_ls *ls, u64 number,\n\t\t\t    struct file *file, struct file_lock *fl)\n{\n\tstruct plock_op *op;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op)\n\t\treturn;\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= 0;\n\top->info.end\t\t= OFFSET_MAX;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\tsend_op(op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xop"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"dlm_posix_lock: wait killed %llx\"",
            "(unsigned long long)number"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_killable",
          "args": [
            "recv_wq",
            "(op->done != 0)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_op",
          "args": [
            "op"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "send_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "64-72",
          "snippet": "static void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static struct list_head send_list;",
            "static wait_queue_head_t send_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head send_list;\nstatic wait_queue_head_t send_wq;\n\nstatic void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_copy_lock",
          "args": [
            "&xop->flc",
            "fl"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "341-355",
          "snippet": "void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "&xop->flc"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*xop)",
            "GFP_NOFS"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "lockspace"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic wait_queue_head_t recv_wq;\n\nint dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\n\t\t   int cmd, struct file_lock *fl)\n{\n\tstruct dlm_ls *ls;\n\tstruct plock_op *op;\n\tstruct plock_xop *xop;\n\tint rv;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\txop = kzalloc(sizeof(*xop), GFP_NOFS);\n\tif (!xop) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top = &xop->xop;\n\top->info.optype\t\t= DLM_PLOCK_OP_LOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.ex\t\t= (fl->fl_type == F_WRLCK);\n\top->info.wait\t\t= IS_SETLKW(cmd);\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= fl->fl_start;\n\top->info.end\t\t= fl->fl_end;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\n\t\t/* fl_owner is lockd which doesn't distinguish\n\t\t   processes on the nfs client */\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\t\txop->callback\t= fl->fl_lmops->lm_grant;\n\t\tlocks_init_lock(&xop->flc);\n\t\tlocks_copy_lock(&xop->flc, fl);\n\t\txop->fl\t\t= fl;\n\t\txop->file\t= file;\n\t} else {\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\t\txop->callback\t= NULL;\n\t}\n\n\tsend_op(op);\n\n\tif (xop->callback == NULL) {\n\t\trv = wait_event_killable(recv_wq, (op->done != 0));\n\t\tif (rv == -ERESTARTSYS) {\n\t\t\tlog_debug(ls, \"dlm_posix_lock: wait killed %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t\t\tspin_lock(&ops_lock);\n\t\t\tlist_del(&op->list);\n\t\t\tspin_unlock(&ops_lock);\n\t\t\tkfree(xop);\n\t\t\tdo_unlock_close(ls, number, file, fl);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\trv = FILE_LOCK_DEFERRED;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ops_lock);\n\tif (!list_empty(&op->list)) {\n\t\tlog_error(ls, \"dlm_posix_lock: op on list %llx\",\n\t\t\t  (unsigned long long)number);\n\t\tlist_del(&op->list);\n\t}\n\tspin_unlock(&ops_lock);\n\n\trv = op->info.rv;\n\n\tif (!rv) {\n\t\tif (posix_lock_file_wait(file, fl) < 0)\n\t\t\tlog_error(ls, \"dlm_posix_lock: vfs lock error %llx\",\n\t\t\t\t  (unsigned long long)number);\n\t}\n\n\tkfree(xop);\nout:\n\tdlm_put_lockspace(ls);\n\treturn rv;\n}"
  },
  {
    "function_name": "do_unlock_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "80-102",
    "snippet": "static void do_unlock_close(struct dlm_ls *ls, u64 number,\n\t\t\t    struct file *file, struct file_lock *fl)\n{\n\tstruct plock_op *op;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op)\n\t\treturn;\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= 0;\n\top->info.end\t\t= OFFSET_MAX;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\tsend_op(op);\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_op",
          "args": [
            "op"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "send_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "64-72",
          "snippet": "static void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static spinlock_t ops_lock;",
            "static struct list_head send_list;",
            "static wait_queue_head_t send_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head send_list;\nstatic wait_queue_head_t send_wq;\n\nstatic void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*op)",
            "GFP_NOFS"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic void do_unlock_close(struct dlm_ls *ls, u64 number,\n\t\t\t    struct file *file, struct file_lock *fl)\n{\n\tstruct plock_op *op;\n\n\top = kzalloc(sizeof(*op), GFP_NOFS);\n\tif (!op)\n\t\treturn;\n\n\top->info.optype\t\t= DLM_PLOCK_OP_UNLOCK;\n\top->info.pid\t\t= fl->fl_pid;\n\top->info.fsid\t\t= ls->ls_global_id;\n\top->info.number\t\t= number;\n\top->info.start\t\t= 0;\n\top->info.end\t\t= OFFSET_MAX;\n\tif (fl->fl_lmops && fl->fl_lmops->lm_grant)\n\t\top->info.owner\t= (__u64) fl->fl_pid;\n\telse\n\t\top->info.owner\t= (__u64)(long) fl->fl_owner;\n\n\top->info.flags |= DLM_PLOCK_FL_CLOSE;\n\tsend_op(op);\n}"
  },
  {
    "function_name": "send_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "64-72",
    "snippet": "static void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static spinlock_t ops_lock;",
      "static struct list_head send_list;",
      "static wait_queue_head_t send_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&send_wq"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ops_lock"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&op->list",
            "&send_list"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ops_lock"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&op->list"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_version",
          "args": [
            "&op->info"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "set_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
          "lines": "40-45",
          "snippet": "static inline void set_version(struct dlm_plock_info *info)\n{\n\tinfo->version[0] = DLM_PLOCK_VERSION_MAJOR;\n\tinfo->version[1] = DLM_PLOCK_VERSION_MINOR;\n\tinfo->version[2] = DLM_PLOCK_VERSION_PATCH;\n}",
          "includes": [
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic inline void set_version(struct dlm_plock_info *info)\n{\n\tinfo->version[0] = DLM_PLOCK_VERSION_MAJOR;\n\tinfo->version[1] = DLM_PLOCK_VERSION_MINOR;\n\tinfo->version[2] = DLM_PLOCK_VERSION_PATCH;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic spinlock_t ops_lock;\nstatic struct list_head send_list;\nstatic wait_queue_head_t send_wq;\n\nstatic void send_op(struct plock_op *op)\n{\n\tset_version(&op->info);\n\tINIT_LIST_HEAD(&op->list);\n\tspin_lock(&ops_lock);\n\tlist_add_tail(&op->list, &send_list);\n\tspin_unlock(&ops_lock);\n\twake_up(&send_wq);\n}"
  },
  {
    "function_name": "check_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "47-62",
    "snippet": "static int check_version(struct dlm_plock_info *info)\n{\n\tif ((DLM_PLOCK_VERSION_MAJOR != info->version[0]) ||\n\t    (DLM_PLOCK_VERSION_MINOR < info->version[1])) {\n\t\tlog_print(\"plock device version mismatch: \"\n\t\t\t  \"kernel (%u.%u.%u), user (%u.%u.%u)\",\n\t\t\t  DLM_PLOCK_VERSION_MAJOR,\n\t\t\t  DLM_PLOCK_VERSION_MINOR,\n\t\t\t  DLM_PLOCK_VERSION_PATCH,\n\t\t\t  info->version[0],\n\t\t\t  info->version[1],\n\t\t\t  info->version[2]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"plock device version mismatch: \"\n\t\t\t  \"kernel (%u.%u.%u), user (%u.%u.%u)\"",
            "DLM_PLOCK_VERSION_MAJOR",
            "DLM_PLOCK_VERSION_MINOR",
            "DLM_PLOCK_VERSION_PATCH",
            "info->version[0]",
            "info->version[1]",
            "info->version[2]"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic int check_version(struct dlm_plock_info *info)\n{\n\tif ((DLM_PLOCK_VERSION_MAJOR != info->version[0]) ||\n\t    (DLM_PLOCK_VERSION_MINOR < info->version[1])) {\n\t\tlog_print(\"plock device version mismatch: \"\n\t\t\t  \"kernel (%u.%u.%u), user (%u.%u.%u)\",\n\t\t\t  DLM_PLOCK_VERSION_MAJOR,\n\t\t\t  DLM_PLOCK_VERSION_MINOR,\n\t\t\t  DLM_PLOCK_VERSION_PATCH,\n\t\t\t  info->version[0],\n\t\t\t  info->version[1],\n\t\t\t  info->version[2]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/plock.c",
    "lines": "40-45",
    "snippet": "static inline void set_version(struct dlm_plock_info *info)\n{\n\tinfo->version[0] = DLM_PLOCK_VERSION_MAJOR;\n\tinfo->version[1] = DLM_PLOCK_VERSION_MINOR;\n\tinfo->version[2] = DLM_PLOCK_VERSION_PATCH;\n}",
    "includes": [
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_plock.h>",
      "#include <linux/dlm.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n\nstatic inline void set_version(struct dlm_plock_info *info)\n{\n\tinfo->version[0] = DLM_PLOCK_VERSION_MAJOR;\n\tinfo->version[1] = DLM_PLOCK_VERSION_MINOR;\n\tinfo->version[2] = DLM_PLOCK_VERSION_PATCH;\n}"
  }
]