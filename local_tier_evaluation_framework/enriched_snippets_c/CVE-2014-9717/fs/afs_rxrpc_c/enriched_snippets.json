[
  {
    "function_name": "afs_extract_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "841-865",
    "snippet": "int afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -EAGAIN\""
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -EBADMSG [%d < %zu]\"",
            "call->offset",
            "count"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pskb_pull",
          "args": [
            "skb",
            "len"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_copy_bits",
          "args": [
            "skb",
            "0",
            "buf + call->offset",
            "len"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "len",
            "count - call->offset"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "call->offset",
            "<,count"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%zu},%d,,%zu\"",
            "call->offset",
            "len",
            "last",
            "count"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_send_simple_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "805-836",
    "snippet": "void afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint n;\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= (void *) buf;\n\tiov[0].iov_len\t\t= len;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1, len);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tn = rxrpc_kernel_send_data(call->rxcall, &msg, len);\n\tif (n >= 0) {\n\t\t/* Success */\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\t}\n\n\tif (n == -ENOMEM) {\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\t}\n\tafs_end_call(call);\n\t_leave(\" [error]\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [error]\""
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_end_call",
          "args": [
            "call"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "afs_end_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "209-213",
          "snippet": "static void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_abort_call",
          "args": [
            "call->rxcall",
            "RX_USER_ABORT"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"oom\""
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_send_data",
          "args": [
            "call->rxcall",
            "&msg",
            "len"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_kvec",
          "args": [
            "&msg.msg_iter",
            "WRITE | ITER_KVEC",
            "iov",
            "1",
            "len"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_send_simple_reply(struct afs_call *call, const void *buf, size_t len)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint n;\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= (void *) buf;\n\tiov[0].iov_len\t\t= len;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1, len);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tn = rxrpc_kernel_send_data(call->rxcall, &msg, len);\n\tif (n >= 0) {\n\t\t/* Success */\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\t}\n\n\tif (n == -ENOMEM) {\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\t}\n\tafs_end_call(call);\n\t_leave(\" [error]\");\n}"
  },
  {
    "function_name": "afs_send_empty_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "770-800",
    "snippet": "void afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= NULL;\n\tiov[0].iov_len\t\t= 0;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 0, 0);\t/* WTF? */\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\tdefault:\n\t\tafs_end_call(call);\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [error]\""
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_end_call",
          "args": [
            "call"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "afs_end_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "209-213",
          "snippet": "static void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_abort_call",
          "args": [
            "call->rxcall",
            "RX_USER_ABORT"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"oom\""
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_send_data",
          "args": [
            "call->rxcall",
            "&msg",
            "0"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_kvec",
          "args": [
            "&msg.msg_iter",
            "WRITE | ITER_KVEC",
            "iov",
            "0",
            "0"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_send_empty_reply(struct afs_call *call)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\n\t_enter(\"\");\n\n\tiov[0].iov_base\t\t= NULL;\n\tiov[0].iov_len\t\t= 0;\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 0, 0);\t/* WTF? */\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= 0;\n\n\tcall->state = AFS_CALL_AWAIT_ACK;\n\tswitch (rxrpc_kernel_send_data(call->rxcall, &msg, 0)) {\n\tcase 0:\n\t\t_leave(\" [replied]\");\n\t\treturn;\n\n\tcase -ENOMEM:\n\t\t_debug(\"oom\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_USER_ABORT);\n\tdefault:\n\t\tafs_end_call(call);\n\t\t_leave(\" [error]\");\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "afs_deliver_cm_op_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "728-765",
    "snippet": "static int afs_deliver_cm_op_id(struct afs_call *call, struct sk_buff *skb,\n\t\t\t\tbool last)\n{\n\tsize_t len = skb->len;\n\tvoid *oibuf = (void *) &call->operation_ID;\n\n\t_enter(\"{%u},{%zu},%d\", call->offset, len, last);\n\n\tASSERTCMP(call->offset, <, 4);\n\n\t/* the operation ID forms the first four bytes of the request data */\n\tlen = min_t(size_t, len, 4 - call->offset);\n\tif (skb_copy_bits(skb, 0, oibuf + call->offset, len) < 0)\n\t\tBUG();\n\tif (!pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < 4) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [op ID short]\");\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = 0 [incomplete]\");\n\t\treturn 0;\n\t}\n\n\tcall->state = AFS_CALL_AWAIT_REQUEST;\n\n\t/* ask the cache manager to route the call (it'll change the call type\n\t * if successful) */\n\tif (!afs_cm_incoming_call(call))\n\t\treturn -ENOTSUPP;\n\n\t/* pass responsibility for the remainer of this message off to the\n\t * cache manager op */\n\treturn call->type->deliver(call, skb, last);\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call->type->deliver",
          "args": [
            "call",
            "skb",
            "last"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_cm_incoming_call",
          "args": [
            "call"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cm_incoming_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cmservice.c",
          "lines": "99-124",
          "snippet": "bool afs_cm_incoming_call(struct afs_call *call)\n{\n\tu32 operation_id = ntohl(call->operation_ID);\n\n\t_enter(\"{CB.OP %u}\", operation_id);\n\n\tswitch (operation_id) {\n\tcase CBCallBack:\n\t\tcall->type = &afs_SRXCBCallBack;\n\t\treturn true;\n\tcase CBInitCallBackState:\n\t\tcall->type = &afs_SRXCBInitCallBackState;\n\t\treturn true;\n\tcase CBInitCallBackState3:\n\t\tcall->type = &afs_SRXCBInitCallBackState3;\n\t\treturn true;\n\tcase CBProbe:\n\t\tcall->type = &afs_SRXCBProbe;\n\t\treturn true;\n\tcase CBTellMeAboutYourself:\n\t\tcall->type = &afs_SRXCBTellMeAboutYourself;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <linux/ip.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_cm_destructor(struct afs_call *);",
            "static const struct afs_call_type afs_SRXCBCallBack = {\n\t.name\t\t= \"CB.CallBack\",\n\t.deliver\t= afs_deliver_cb_callback,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};",
            "static const struct afs_call_type afs_SRXCBInitCallBackState = {\n\t.name\t\t= \"CB.InitCallBackState\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};",
            "static const struct afs_call_type afs_SRXCBInitCallBackState3 = {\n\t.name\t\t= \"CB.InitCallBackState3\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state3,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};",
            "static const struct afs_call_type afs_SRXCBProbe = {\n\t.name\t\t= \"CB.Probe\",\n\t.deliver\t= afs_deliver_cb_probe,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};",
            "static const struct afs_call_type afs_SRXCBTellMeAboutYourself = {\n\t.name\t\t= \"CB.TellMeAboutYourself\",\n\t.deliver\t= afs_deliver_cb_tell_me_about_yourself,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <linux/ip.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void afs_cm_destructor(struct afs_call *);\nstatic const struct afs_call_type afs_SRXCBCallBack = {\n\t.name\t\t= \"CB.CallBack\",\n\t.deliver\t= afs_deliver_cb_callback,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\nstatic const struct afs_call_type afs_SRXCBInitCallBackState = {\n\t.name\t\t= \"CB.InitCallBackState\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\nstatic const struct afs_call_type afs_SRXCBInitCallBackState3 = {\n\t.name\t\t= \"CB.InitCallBackState3\",\n\t.deliver\t= afs_deliver_cb_init_call_back_state3,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\nstatic const struct afs_call_type afs_SRXCBProbe = {\n\t.name\t\t= \"CB.Probe\",\n\t.deliver\t= afs_deliver_cb_probe,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\nstatic const struct afs_call_type afs_SRXCBTellMeAboutYourself = {\n\t.name\t\t= \"CB.TellMeAboutYourself\",\n\t.deliver\t= afs_deliver_cb_tell_me_about_yourself,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_cm_destructor,\n};\n\nbool afs_cm_incoming_call(struct afs_call *call)\n{\n\tu32 operation_id = ntohl(call->operation_ID);\n\n\t_enter(\"{CB.OP %u}\", operation_id);\n\n\tswitch (operation_id) {\n\tcase CBCallBack:\n\t\tcall->type = &afs_SRXCBCallBack;\n\t\treturn true;\n\tcase CBInitCallBackState:\n\t\tcall->type = &afs_SRXCBInitCallBackState;\n\t\treturn true;\n\tcase CBInitCallBackState3:\n\t\tcall->type = &afs_SRXCBInitCallBackState3;\n\t\treturn true;\n\tcase CBProbe:\n\t\tcall->type = &afs_SRXCBProbe;\n\t\treturn true;\n\tcase CBTellMeAboutYourself:\n\t\tcall->type = &afs_SRXCBTellMeAboutYourself;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [incomplete]\""
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pskb_pull",
          "args": [
            "skb",
            "len"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_copy_bits",
          "args": [
            "skb",
            "0",
            "oibuf + call->offset",
            "len"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "len",
            "4 - call->offset"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "call->offset",
            "<,4"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%zu},%d\"",
            "call->offset",
            "len",
            "last"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic int afs_deliver_cm_op_id(struct afs_call *call, struct sk_buff *skb,\n\t\t\t\tbool last)\n{\n\tsize_t len = skb->len;\n\tvoid *oibuf = (void *) &call->operation_ID;\n\n\t_enter(\"{%u},{%zu},%d\", call->offset, len, last);\n\n\tASSERTCMP(call->offset, <, 4);\n\n\t/* the operation ID forms the first four bytes of the request data */\n\tlen = min_t(size_t, len, 4 - call->offset);\n\tif (skb_copy_bits(skb, 0, oibuf + call->offset, len) < 0)\n\t\tBUG();\n\tif (!pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < 4) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [op ID short]\");\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = 0 [incomplete]\");\n\t\treturn 0;\n\t}\n\n\tcall->state = AFS_CALL_AWAIT_REQUEST;\n\n\t/* ask the cache manager to route the call (it'll change the call type\n\t * if successful) */\n\tif (!afs_cm_incoming_call(call))\n\t\treturn -ENOTSUPP;\n\n\t/* pass responsibility for the remainer of this message off to the\n\t * cache manager op */\n\treturn call->type->deliver(call, skb, last);\n}"
  },
  {
    "function_name": "afs_collect_incoming_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "680-723",
    "snippet": "static void afs_collect_incoming_call(struct work_struct *work)\n{\n\tstruct rxrpc_call *rxcall;\n\tstruct afs_call *call = NULL;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&afs_incoming_calls))) {\n\t\t_debug(\"new call\");\n\n\t\t/* don't need the notification */\n\t\tafs_free_skb(skb);\n\n\t\tif (!call) {\n\t\t\tcall = kzalloc(sizeof(struct afs_call), GFP_KERNEL);\n\t\t\tif (!call) {\n\t\t\t\trxrpc_kernel_reject_call(afs_socket);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcall->async_workfn = afs_process_async_call;\n\t\t\tINIT_WORK(&call->async_work, afs_async_workfn);\n\t\t\tcall->wait_mode = &afs_async_incoming_call;\n\t\t\tcall->type = &afs_RXCMxxxx;\n\t\t\tinit_waitqueue_head(&call->waitq);\n\t\t\tskb_queue_head_init(&call->rx_queue);\n\t\t\tcall->state = AFS_CALL_AWAIT_OP_ID;\n\n\t\t\t_debug(\"CALL %p{%s} [%d]\",\n\t\t\t       call, call->type->name,\n\t\t\t       atomic_read(&afs_outstanding_calls));\n\t\t\tatomic_inc(&afs_outstanding_calls);\n\t\t}\n\n\t\trxcall = rxrpc_kernel_accept_call(afs_socket,\n\t\t\t\t\t\t  (unsigned long) call);\n\t\tif (!IS_ERR(rxcall)) {\n\t\t\tcall->rxcall = rxcall;\n\t\t\tcall = NULL;\n\t\t}\n\t}\n\n\tif (call)\n\t\tafs_free_call(call);\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct socket *afs_socket;",
      "static atomic_t afs_outstanding_calls;",
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);",
      "static const struct afs_wait_mode afs_async_incoming_call = {\n\t.rx_wakeup\t= afs_wake_up_async_call,\n};",
      "static const struct afs_call_type afs_RXCMxxxx = {\n\t.name\t\t= \"CB.xxxx\",\n\t.deliver\t= afs_deliver_cm_op_id,\n\t.abort_to_error\t= afs_abort_to_error,\n};",
      "static void afs_collect_incoming_call(struct work_struct *);",
      "static struct sk_buff_head afs_incoming_calls;",
      "static DECLARE_WORK(afs_collect_incoming_call_work, afs_collect_incoming_call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_free_call",
          "args": [
            "call"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "177-191",
          "snippet": "static void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rxcall"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_accept_call",
          "args": [
            "afs_socket",
            "(unsigned long) call"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&afs_outstanding_calls"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"CALL %p{%s} [%d]\"",
            "call",
            "call->type->name",
            "atomic_read(&afs_outstanding_calls)"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_calls"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&call->rx_queue"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&call->waitq"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&call->async_work",
            "afs_async_workfn"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_reject_call",
          "args": [
            "afs_socket"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct afs_call)",
            "GFP_KERNEL"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_free_skb",
          "args": [
            "skb"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "160-172",
          "snippet": "static void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_skbs;",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_skbs;\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"new call\""
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "&afs_incoming_calls"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\nstatic const struct afs_wait_mode afs_async_incoming_call = {\n\t.rx_wakeup\t= afs_wake_up_async_call,\n};\nstatic const struct afs_call_type afs_RXCMxxxx = {\n\t.name\t\t= \"CB.xxxx\",\n\t.deliver\t= afs_deliver_cm_op_id,\n\t.abort_to_error\t= afs_abort_to_error,\n};\nstatic void afs_collect_incoming_call(struct work_struct *);\nstatic struct sk_buff_head afs_incoming_calls;\nstatic DECLARE_WORK(afs_collect_incoming_call_work, afs_collect_incoming_call);\n\nstatic void afs_collect_incoming_call(struct work_struct *work)\n{\n\tstruct rxrpc_call *rxcall;\n\tstruct afs_call *call = NULL;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&afs_incoming_calls))) {\n\t\t_debug(\"new call\");\n\n\t\t/* don't need the notification */\n\t\tafs_free_skb(skb);\n\n\t\tif (!call) {\n\t\t\tcall = kzalloc(sizeof(struct afs_call), GFP_KERNEL);\n\t\t\tif (!call) {\n\t\t\t\trxrpc_kernel_reject_call(afs_socket);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcall->async_workfn = afs_process_async_call;\n\t\t\tINIT_WORK(&call->async_work, afs_async_workfn);\n\t\t\tcall->wait_mode = &afs_async_incoming_call;\n\t\t\tcall->type = &afs_RXCMxxxx;\n\t\t\tinit_waitqueue_head(&call->waitq);\n\t\t\tskb_queue_head_init(&call->rx_queue);\n\t\t\tcall->state = AFS_CALL_AWAIT_OP_ID;\n\n\t\t\t_debug(\"CALL %p{%s} [%d]\",\n\t\t\t       call, call->type->name,\n\t\t\t       atomic_read(&afs_outstanding_calls));\n\t\t\tatomic_inc(&afs_outstanding_calls);\n\t\t}\n\n\t\trxcall = rxrpc_kernel_accept_call(afs_socket,\n\t\t\t\t\t\t  (unsigned long) call);\n\t\tif (!IS_ERR(rxcall)) {\n\t\t\tcall->rxcall = rxcall;\n\t\t\tcall = NULL;\n\t\t}\n\t}\n\n\tif (call)\n\t\tafs_free_call(call);\n}"
  },
  {
    "function_name": "afs_transfer_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "668-675",
    "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_copy_bits",
          "args": [
            "skb",
            "0",
            "call->buffer + call->reply_size",
            "len"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
  },
  {
    "function_name": "afs_process_async_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "640-663",
    "snippet": "static void afs_process_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tif (!skb_queue_empty(&call->rx_queue))\n\t\tafs_deliver_to_call(call);\n\n\tif (call->state >= AFS_CALL_COMPLETE && call->wait_mode) {\n\t\tif (call->wait_mode->async_complete)\n\t\t\tcall->wait_mode->async_complete(call->reply,\n\t\t\t\t\t\t\tcall->error);\n\t\tcall->reply = NULL;\n\n\t\t/* kill the call */\n\t\tafs_end_call_nofree(call);\n\n\t\t/* we can't just delete the call because the work item may be\n\t\t * queued */\n\t\tcall->async_workfn = afs_delete_async_call;\n\t\tqueue_work(afs_async_calls, &call->async_work);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *afs_async_calls;",
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_async_calls",
            "&call->async_work"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_end_call_nofree",
          "args": [
            "call"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "afs_end_call_nofree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "196-204",
          "snippet": "static void afs_end_call_nofree(struct afs_call *call)\n{\n\tif (call->rxcall) {\n\t\trxrpc_kernel_end_call(call->rxcall);\n\t\tcall->rxcall = NULL;\n\t}\n\tif (call->type->destructor)\n\t\tcall->type->destructor(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call_nofree(struct afs_call *call)\n{\n\tif (call->rxcall) {\n\t\trxrpc_kernel_end_call(call->rxcall);\n\t\tcall->rxcall = NULL;\n\t}\n\tif (call->type->destructor)\n\t\tcall->type->destructor(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call->wait_mode->async_complete",
          "args": [
            "call->reply",
            "call->error"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_deliver_to_call",
          "args": [
            "call"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "afs_deliver_to_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "456-544",
          "snippet": "static void afs_deliver_to_call(struct afs_call *call)\n{\n\tstruct sk_buff *skb;\n\tbool last;\n\tu32 abort_code;\n\tint ret;\n\n\t_enter(\"\");\n\n\twhile ((call->state == AFS_CALL_AWAIT_REPLY ||\n\t\tcall->state == AFS_CALL_AWAIT_OP_ID ||\n\t\tcall->state == AFS_CALL_AWAIT_REQUEST ||\n\t\tcall->state == AFS_CALL_AWAIT_ACK) &&\n\t       (skb = skb_dequeue(&call->rx_queue))) {\n\t\tswitch (skb->mark) {\n\t\tcase RXRPC_SKB_MARK_DATA:\n\t\t\t_debug(\"Rcv DATA\");\n\t\t\tlast = rxrpc_kernel_is_data_last(skb);\n\t\t\tret = call->type->deliver(call, skb, last);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tif (last &&\n\t\t\t\t    call->state == AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\t\tbreak;\n\t\t\tcase -ENOTCONN:\n\t\t\t\tabort_code = RX_CALL_DEAD;\n\t\t\t\tgoto do_abort;\n\t\t\tcase -ENOTSUPP:\n\t\t\t\tabort_code = RX_INVALID_OPERATION;\n\t\t\t\tgoto do_abort;\n\t\t\tdefault:\n\t\t\t\tabort_code = RXGEN_CC_UNMARSHAL;\n\t\t\t\tif (call->state != AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tabort_code = RXGEN_SS_UNMARSHAL;\n\t\t\tdo_abort:\n\t\t\t\trxrpc_kernel_abort_call(call->rxcall,\n\t\t\t\t\t\t\tabort_code);\n\t\t\t\tcall->error = ret;\n\t\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tafs_data_delivered(skb);\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\tcase RXRPC_SKB_MARK_FINAL_ACK:\n\t\t\t_debug(\"Rcv ACK\");\n\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_BUSY:\n\t\t\t_debug(\"Rcv BUSY\");\n\t\t\tcall->error = -EBUSY;\n\t\t\tcall->state = AFS_CALL_BUSY;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_REMOTE_ABORT:\n\t\t\tabort_code = rxrpc_kernel_get_abort_code(skb);\n\t\t\tcall->error = call->type->abort_to_error(abort_code);\n\t\t\tcall->state = AFS_CALL_ABORTED;\n\t\t\t_debug(\"Rcv ABORT %u -> %d\", abort_code, call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_NET_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv NET ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_LOCAL_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv LOCAL ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tafs_free_skb(skb);\n\t}\n\n\t/* make sure the queue is empty if the call is done with (we might have\n\t * aborted the call early because of an unmarshalling error) */\n\tif (call->state >= AFS_CALL_COMPLETE) {\n\t\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\t\tafs_free_skb(skb);\n\t\tif (call->incoming)\n\t\t\tafs_end_call(call);\n\t}\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_deliver_to_call(struct afs_call *call)\n{\n\tstruct sk_buff *skb;\n\tbool last;\n\tu32 abort_code;\n\tint ret;\n\n\t_enter(\"\");\n\n\twhile ((call->state == AFS_CALL_AWAIT_REPLY ||\n\t\tcall->state == AFS_CALL_AWAIT_OP_ID ||\n\t\tcall->state == AFS_CALL_AWAIT_REQUEST ||\n\t\tcall->state == AFS_CALL_AWAIT_ACK) &&\n\t       (skb = skb_dequeue(&call->rx_queue))) {\n\t\tswitch (skb->mark) {\n\t\tcase RXRPC_SKB_MARK_DATA:\n\t\t\t_debug(\"Rcv DATA\");\n\t\t\tlast = rxrpc_kernel_is_data_last(skb);\n\t\t\tret = call->type->deliver(call, skb, last);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tif (last &&\n\t\t\t\t    call->state == AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\t\tbreak;\n\t\t\tcase -ENOTCONN:\n\t\t\t\tabort_code = RX_CALL_DEAD;\n\t\t\t\tgoto do_abort;\n\t\t\tcase -ENOTSUPP:\n\t\t\t\tabort_code = RX_INVALID_OPERATION;\n\t\t\t\tgoto do_abort;\n\t\t\tdefault:\n\t\t\t\tabort_code = RXGEN_CC_UNMARSHAL;\n\t\t\t\tif (call->state != AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tabort_code = RXGEN_SS_UNMARSHAL;\n\t\t\tdo_abort:\n\t\t\t\trxrpc_kernel_abort_call(call->rxcall,\n\t\t\t\t\t\t\tabort_code);\n\t\t\t\tcall->error = ret;\n\t\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tafs_data_delivered(skb);\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\tcase RXRPC_SKB_MARK_FINAL_ACK:\n\t\t\t_debug(\"Rcv ACK\");\n\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_BUSY:\n\t\t\t_debug(\"Rcv BUSY\");\n\t\t\tcall->error = -EBUSY;\n\t\t\tcall->state = AFS_CALL_BUSY;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_REMOTE_ABORT:\n\t\t\tabort_code = rxrpc_kernel_get_abort_code(skb);\n\t\t\tcall->error = call->type->abort_to_error(abort_code);\n\t\t\tcall->state = AFS_CALL_ABORTED;\n\t\t\t_debug(\"Rcv ABORT %u -> %d\", abort_code, call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_NET_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv NET ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_LOCAL_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv LOCAL ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tafs_free_skb(skb);\n\t}\n\n\t/* make sure the queue is empty if the call is done with (we might have\n\t * aborted the call early because of an unmarshalling error) */\n\tif (call->state >= AFS_CALL_COMPLETE) {\n\t\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\t\tafs_free_skb(skb);\n\t\tif (call->incoming)\n\t\t\tafs_end_call(call);\n\t}\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_empty",
          "args": [
            "&call->rx_queue"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct workqueue_struct *afs_async_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_process_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tif (!skb_queue_empty(&call->rx_queue))\n\t\tafs_deliver_to_call(call);\n\n\tif (call->state >= AFS_CALL_COMPLETE && call->wait_mode) {\n\t\tif (call->wait_mode->async_complete)\n\t\t\tcall->wait_mode->async_complete(call->reply,\n\t\t\t\t\t\t\tcall->error);\n\t\tcall->reply = NULL;\n\n\t\t/* kill the call */\n\t\tafs_end_call_nofree(call);\n\n\t\t/* we can't just delete the call because the work item may be\n\t\t * queued */\n\t\tcall->async_workfn = afs_delete_async_call;\n\t\tqueue_work(afs_async_calls, &call->async_work);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_delete_async_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "626-633",
    "snippet": "static void afs_delete_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tafs_free_call(call);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_free_call",
          "args": [
            "call"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "177-191",
          "snippet": "static void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_delete_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tafs_free_call(call);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_dont_wait_for_call_to_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "617-621",
    "snippet": "static int afs_dont_wait_for_call_to_complete(struct afs_call *call)\n{\n\t_enter(\"\");\n\treturn -EINPROGRESS;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *call)\n{\n\t_enter(\"\");\n\treturn -EINPROGRESS;\n}"
  },
  {
    "function_name": "afs_wake_up_async_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "606-610",
    "snippet": "static void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *afs_async_calls;",
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_async_calls",
            "&call->async_work"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct workqueue_struct *afs_async_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}"
  },
  {
    "function_name": "afs_wake_up_call_waiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "598-601",
    "snippet": "static void afs_wake_up_call_waiter(struct afs_call *call)\n{\n\twake_up(&call->waitq);\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&call->waitq"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "afs_wake_up_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "606-610",
          "snippet": "static void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_async_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct workqueue_struct *afs_async_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_wake_up_call_waiter(struct afs_call *call)\n{\n\twake_up(&call->waitq);\n}"
  },
  {
    "function_name": "afs_wait_for_call_to_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "549-593",
    "snippet": "static int afs_wait_for_call_to_complete(struct afs_call *call)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"\");\n\n\tadd_wait_queue(&call->waitq, &myself);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t/* deliver any messages that are in the queue */\n\t\tif (!skb_queue_empty(&call->rx_queue)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tafs_deliver_to_call(call);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = call->error;\n\t\tif (call->state >= AFS_CALL_COMPLETE)\n\t\t\tbreak;\n\t\tret = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\n\tremove_wait_queue(&call->waitq, &myself);\n\t__set_current_state(TASK_RUNNING);\n\n\t/* kill the call */\n\tif (call->state < AFS_CALL_COMPLETE) {\n\t\t_debug(\"call incomplete\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_CALL_DEAD);\n\t\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\t\tafs_free_skb(skb);\n\t}\n\n\t_debug(\"call complete\");\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_end_call",
          "args": [
            "call"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "afs_end_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "209-213",
          "snippet": "static void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"call complete\""
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_free_skb",
          "args": [
            "skb"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "160-172",
          "snippet": "static void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_skbs;",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_skbs;\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "&call->rx_queue"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_abort_call",
          "args": [
            "call->rxcall",
            "RX_CALL_DEAD"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&call->waitq",
            "&myself"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_deliver_to_call",
          "args": [
            "call"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "afs_deliver_to_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "456-544",
          "snippet": "static void afs_deliver_to_call(struct afs_call *call)\n{\n\tstruct sk_buff *skb;\n\tbool last;\n\tu32 abort_code;\n\tint ret;\n\n\t_enter(\"\");\n\n\twhile ((call->state == AFS_CALL_AWAIT_REPLY ||\n\t\tcall->state == AFS_CALL_AWAIT_OP_ID ||\n\t\tcall->state == AFS_CALL_AWAIT_REQUEST ||\n\t\tcall->state == AFS_CALL_AWAIT_ACK) &&\n\t       (skb = skb_dequeue(&call->rx_queue))) {\n\t\tswitch (skb->mark) {\n\t\tcase RXRPC_SKB_MARK_DATA:\n\t\t\t_debug(\"Rcv DATA\");\n\t\t\tlast = rxrpc_kernel_is_data_last(skb);\n\t\t\tret = call->type->deliver(call, skb, last);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tif (last &&\n\t\t\t\t    call->state == AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\t\tbreak;\n\t\t\tcase -ENOTCONN:\n\t\t\t\tabort_code = RX_CALL_DEAD;\n\t\t\t\tgoto do_abort;\n\t\t\tcase -ENOTSUPP:\n\t\t\t\tabort_code = RX_INVALID_OPERATION;\n\t\t\t\tgoto do_abort;\n\t\t\tdefault:\n\t\t\t\tabort_code = RXGEN_CC_UNMARSHAL;\n\t\t\t\tif (call->state != AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tabort_code = RXGEN_SS_UNMARSHAL;\n\t\t\tdo_abort:\n\t\t\t\trxrpc_kernel_abort_call(call->rxcall,\n\t\t\t\t\t\t\tabort_code);\n\t\t\t\tcall->error = ret;\n\t\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tafs_data_delivered(skb);\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\tcase RXRPC_SKB_MARK_FINAL_ACK:\n\t\t\t_debug(\"Rcv ACK\");\n\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_BUSY:\n\t\t\t_debug(\"Rcv BUSY\");\n\t\t\tcall->error = -EBUSY;\n\t\t\tcall->state = AFS_CALL_BUSY;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_REMOTE_ABORT:\n\t\t\tabort_code = rxrpc_kernel_get_abort_code(skb);\n\t\t\tcall->error = call->type->abort_to_error(abort_code);\n\t\t\tcall->state = AFS_CALL_ABORTED;\n\t\t\t_debug(\"Rcv ABORT %u -> %d\", abort_code, call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_NET_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv NET ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_LOCAL_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv LOCAL ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tafs_free_skb(skb);\n\t}\n\n\t/* make sure the queue is empty if the call is done with (we might have\n\t * aborted the call early because of an unmarshalling error) */\n\tif (call->state >= AFS_CALL_COMPLETE) {\n\t\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\t\tafs_free_skb(skb);\n\t\tif (call->incoming)\n\t\t\tafs_end_call(call);\n\t}\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_deliver_to_call(struct afs_call *call)\n{\n\tstruct sk_buff *skb;\n\tbool last;\n\tu32 abort_code;\n\tint ret;\n\n\t_enter(\"\");\n\n\twhile ((call->state == AFS_CALL_AWAIT_REPLY ||\n\t\tcall->state == AFS_CALL_AWAIT_OP_ID ||\n\t\tcall->state == AFS_CALL_AWAIT_REQUEST ||\n\t\tcall->state == AFS_CALL_AWAIT_ACK) &&\n\t       (skb = skb_dequeue(&call->rx_queue))) {\n\t\tswitch (skb->mark) {\n\t\tcase RXRPC_SKB_MARK_DATA:\n\t\t\t_debug(\"Rcv DATA\");\n\t\t\tlast = rxrpc_kernel_is_data_last(skb);\n\t\t\tret = call->type->deliver(call, skb, last);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tif (last &&\n\t\t\t\t    call->state == AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\t\tbreak;\n\t\t\tcase -ENOTCONN:\n\t\t\t\tabort_code = RX_CALL_DEAD;\n\t\t\t\tgoto do_abort;\n\t\t\tcase -ENOTSUPP:\n\t\t\t\tabort_code = RX_INVALID_OPERATION;\n\t\t\t\tgoto do_abort;\n\t\t\tdefault:\n\t\t\t\tabort_code = RXGEN_CC_UNMARSHAL;\n\t\t\t\tif (call->state != AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tabort_code = RXGEN_SS_UNMARSHAL;\n\t\t\tdo_abort:\n\t\t\t\trxrpc_kernel_abort_call(call->rxcall,\n\t\t\t\t\t\t\tabort_code);\n\t\t\t\tcall->error = ret;\n\t\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tafs_data_delivered(skb);\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\tcase RXRPC_SKB_MARK_FINAL_ACK:\n\t\t\t_debug(\"Rcv ACK\");\n\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_BUSY:\n\t\t\t_debug(\"Rcv BUSY\");\n\t\t\tcall->error = -EBUSY;\n\t\t\tcall->state = AFS_CALL_BUSY;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_REMOTE_ABORT:\n\t\t\tabort_code = rxrpc_kernel_get_abort_code(skb);\n\t\t\tcall->error = call->type->abort_to_error(abort_code);\n\t\t\tcall->state = AFS_CALL_ABORTED;\n\t\t\t_debug(\"Rcv ABORT %u -> %d\", abort_code, call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_NET_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv NET ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_LOCAL_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv LOCAL ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tafs_free_skb(skb);\n\t}\n\n\t/* make sure the queue is empty if the call is done with (we might have\n\t * aborted the call early because of an unmarshalling error) */\n\tif (call->state >= AFS_CALL_COMPLETE) {\n\t\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\t\tafs_free_skb(skb);\n\t\tif (call->incoming)\n\t\t\tafs_end_call(call);\n\t}\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_empty",
          "args": [
            "&call->rx_queue"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&call->waitq",
            "&myself"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "myself",
            "current"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic int afs_wait_for_call_to_complete(struct afs_call *call)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tDECLARE_WAITQUEUE(myself, current);\n\n\t_enter(\"\");\n\n\tadd_wait_queue(&call->waitq, &myself);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t/* deliver any messages that are in the queue */\n\t\tif (!skb_queue_empty(&call->rx_queue)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tafs_deliver_to_call(call);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = call->error;\n\t\tif (call->state >= AFS_CALL_COMPLETE)\n\t\t\tbreak;\n\t\tret = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\n\tremove_wait_queue(&call->waitq, &myself);\n\t__set_current_state(TASK_RUNNING);\n\n\t/* kill the call */\n\tif (call->state < AFS_CALL_COMPLETE) {\n\t\t_debug(\"call incomplete\");\n\t\trxrpc_kernel_abort_call(call->rxcall, RX_CALL_DEAD);\n\t\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\t\tafs_free_skb(skb);\n\t}\n\n\t_debug(\"call complete\");\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_deliver_to_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "456-544",
    "snippet": "static void afs_deliver_to_call(struct afs_call *call)\n{\n\tstruct sk_buff *skb;\n\tbool last;\n\tu32 abort_code;\n\tint ret;\n\n\t_enter(\"\");\n\n\twhile ((call->state == AFS_CALL_AWAIT_REPLY ||\n\t\tcall->state == AFS_CALL_AWAIT_OP_ID ||\n\t\tcall->state == AFS_CALL_AWAIT_REQUEST ||\n\t\tcall->state == AFS_CALL_AWAIT_ACK) &&\n\t       (skb = skb_dequeue(&call->rx_queue))) {\n\t\tswitch (skb->mark) {\n\t\tcase RXRPC_SKB_MARK_DATA:\n\t\t\t_debug(\"Rcv DATA\");\n\t\t\tlast = rxrpc_kernel_is_data_last(skb);\n\t\t\tret = call->type->deliver(call, skb, last);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tif (last &&\n\t\t\t\t    call->state == AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\t\tbreak;\n\t\t\tcase -ENOTCONN:\n\t\t\t\tabort_code = RX_CALL_DEAD;\n\t\t\t\tgoto do_abort;\n\t\t\tcase -ENOTSUPP:\n\t\t\t\tabort_code = RX_INVALID_OPERATION;\n\t\t\t\tgoto do_abort;\n\t\t\tdefault:\n\t\t\t\tabort_code = RXGEN_CC_UNMARSHAL;\n\t\t\t\tif (call->state != AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tabort_code = RXGEN_SS_UNMARSHAL;\n\t\t\tdo_abort:\n\t\t\t\trxrpc_kernel_abort_call(call->rxcall,\n\t\t\t\t\t\t\tabort_code);\n\t\t\t\tcall->error = ret;\n\t\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tafs_data_delivered(skb);\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\tcase RXRPC_SKB_MARK_FINAL_ACK:\n\t\t\t_debug(\"Rcv ACK\");\n\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_BUSY:\n\t\t\t_debug(\"Rcv BUSY\");\n\t\t\tcall->error = -EBUSY;\n\t\t\tcall->state = AFS_CALL_BUSY;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_REMOTE_ABORT:\n\t\t\tabort_code = rxrpc_kernel_get_abort_code(skb);\n\t\t\tcall->error = call->type->abort_to_error(abort_code);\n\t\t\tcall->state = AFS_CALL_ABORTED;\n\t\t\t_debug(\"Rcv ABORT %u -> %d\", abort_code, call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_NET_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv NET ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_LOCAL_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv LOCAL ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tafs_free_skb(skb);\n\t}\n\n\t/* make sure the queue is empty if the call is done with (we might have\n\t * aborted the call early because of an unmarshalling error) */\n\tif (call->state >= AFS_CALL_COMPLETE) {\n\t\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\t\tafs_free_skb(skb);\n\t\tif (call->incoming)\n\t\t\tafs_end_call(call);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_end_call",
          "args": [
            "call"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "afs_end_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "209-213",
          "snippet": "static void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_free_skb",
          "args": [
            "skb"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "160-172",
          "snippet": "static void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_skbs;",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_skbs;\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "&call->rx_queue"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"Rcv LOCAL ERROR %d\"",
            "call->error"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_get_error_number",
          "args": [
            "skb"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_get_error_number",
          "args": [
            "skb"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"Rcv ABORT %u -> %d\"",
            "abort_code",
            "call->error"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "call->type->abort_to_error",
          "args": [
            "abort_code"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_get_abort_code",
          "args": [
            "skb"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"Rcv BUSY\""
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_data_delivered",
          "args": [
            "skb"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "afs_data_delivered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "143-155",
          "snippet": "static void afs_data_delivered(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"DLVR NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"DLVR %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_data_delivered(skb);\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_skbs;",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_skbs;\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_data_delivered(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"DLVR NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"DLVR %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_data_delivered(skb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_abort_call",
          "args": [
            "call->rxcall",
            "abort_code"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call->type->deliver",
          "args": [
            "call",
            "skb",
            "last"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_is_data_last",
          "args": [
            "skb"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "&call->rx_queue"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_deliver_to_call(struct afs_call *call)\n{\n\tstruct sk_buff *skb;\n\tbool last;\n\tu32 abort_code;\n\tint ret;\n\n\t_enter(\"\");\n\n\twhile ((call->state == AFS_CALL_AWAIT_REPLY ||\n\t\tcall->state == AFS_CALL_AWAIT_OP_ID ||\n\t\tcall->state == AFS_CALL_AWAIT_REQUEST ||\n\t\tcall->state == AFS_CALL_AWAIT_ACK) &&\n\t       (skb = skb_dequeue(&call->rx_queue))) {\n\t\tswitch (skb->mark) {\n\t\tcase RXRPC_SKB_MARK_DATA:\n\t\t\t_debug(\"Rcv DATA\");\n\t\t\tlast = rxrpc_kernel_is_data_last(skb);\n\t\t\tret = call->type->deliver(call, skb, last);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tif (last &&\n\t\t\t\t    call->state == AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\t\tbreak;\n\t\t\tcase -ENOTCONN:\n\t\t\t\tabort_code = RX_CALL_DEAD;\n\t\t\t\tgoto do_abort;\n\t\t\tcase -ENOTSUPP:\n\t\t\t\tabort_code = RX_INVALID_OPERATION;\n\t\t\t\tgoto do_abort;\n\t\t\tdefault:\n\t\t\t\tabort_code = RXGEN_CC_UNMARSHAL;\n\t\t\t\tif (call->state != AFS_CALL_AWAIT_REPLY)\n\t\t\t\t\tabort_code = RXGEN_SS_UNMARSHAL;\n\t\t\tdo_abort:\n\t\t\t\trxrpc_kernel_abort_call(call->rxcall,\n\t\t\t\t\t\t\tabort_code);\n\t\t\t\tcall->error = ret;\n\t\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tafs_data_delivered(skb);\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\tcase RXRPC_SKB_MARK_FINAL_ACK:\n\t\t\t_debug(\"Rcv ACK\");\n\t\t\tcall->state = AFS_CALL_COMPLETE;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_BUSY:\n\t\t\t_debug(\"Rcv BUSY\");\n\t\t\tcall->error = -EBUSY;\n\t\t\tcall->state = AFS_CALL_BUSY;\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_REMOTE_ABORT:\n\t\t\tabort_code = rxrpc_kernel_get_abort_code(skb);\n\t\t\tcall->error = call->type->abort_to_error(abort_code);\n\t\t\tcall->state = AFS_CALL_ABORTED;\n\t\t\t_debug(\"Rcv ABORT %u -> %d\", abort_code, call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_NET_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv NET ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tcase RXRPC_SKB_MARK_LOCAL_ERROR:\n\t\t\tcall->error = -rxrpc_kernel_get_error_number(skb);\n\t\t\tcall->state = AFS_CALL_ERROR;\n\t\t\t_debug(\"Rcv LOCAL ERROR %d\", call->error);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tafs_free_skb(skb);\n\t}\n\n\t/* make sure the queue is empty if the call is done with (we might have\n\t * aborted the call early because of an unmarshalling error) */\n\tif (call->state >= AFS_CALL_COMPLETE) {\n\t\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\t\tafs_free_skb(skb);\n\t\tif (call->incoming)\n\t\t\tafs_end_call(call);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_rx_interceptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "427-451",
    "snippet": "static void afs_rx_interceptor(struct sock *sk, unsigned long user_call_ID,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct afs_call *call = (struct afs_call *) user_call_ID;\n\n\t_enter(\"%p,,%u\", call, skb->mark);\n\n\t_debug(\"ICPT %p{%u} [%d]\",\n\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\n\tASSERTCMP(sk, ==, afs_socket->sk);\n\tatomic_inc(&afs_outstanding_skbs);\n\n\tif (!call) {\n\t\t/* its an incoming call for our callback service */\n\t\tskb_queue_tail(&afs_incoming_calls, skb);\n\t\tqueue_work(afs_wq, &afs_collect_incoming_call_work);\n\t} else {\n\t\t/* route the messages directly to the appropriate call */\n\t\tskb_queue_tail(&call->rx_queue, skb);\n\t\tcall->wait_mode->rx_wakeup(call);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct socket *afs_socket;",
      "static atomic_t afs_outstanding_skbs;",
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);",
      "static struct sk_buff_head afs_incoming_calls;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call->wait_mode->rx_wakeup",
          "args": [
            "call"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "&call->rx_queue",
            "skb"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "afs_wq",
            "&afs_collect_incoming_call_work"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_tail",
          "args": [
            "&afs_incoming_calls",
            "skb"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "sk",
            "==,afs_socket->sk"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"ICPT %p{%u} [%d]\"",
            "skb",
            "skb->mark",
            "atomic_read(&afs_outstanding_skbs)"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,,%u\"",
            "call",
            "skb->mark"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_skbs;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\nstatic struct sk_buff_head afs_incoming_calls;\n\nstatic void afs_rx_interceptor(struct sock *sk, unsigned long user_call_ID,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct afs_call *call = (struct afs_call *) user_call_ID;\n\n\t_enter(\"%p,,%u\", call, skb->mark);\n\n\t_debug(\"ICPT %p{%u} [%d]\",\n\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\n\tASSERTCMP(sk, ==, afs_socket->sk);\n\tatomic_inc(&afs_outstanding_skbs);\n\n\tif (!call) {\n\t\t/* its an incoming call for our callback service */\n\t\tskb_queue_tail(&afs_incoming_calls, skb);\n\t\tqueue_work(afs_wq, &afs_collect_incoming_call_work);\n\t} else {\n\t\t/* route the messages directly to the appropriate call */\n\t\tskb_queue_tail(&call->rx_queue, skb);\n\t\tcall->wait_mode->rx_wakeup(call);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_make_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "338-420",
    "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct socket *afs_socket;",
      "static atomic_t afs_outstanding_calls;",
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_end_call",
          "args": [
            "call"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "afs_end_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "209-213",
          "snippet": "static void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_free_skb",
          "args": [
            "skb"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "160-172",
          "snippet": "static void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_skbs;",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_skbs;\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_dequeue",
          "args": [
            "&call->rx_queue"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_abort_call",
          "args": [
            "rxcall",
            "RX_USER_ABORT"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_mode->wait",
          "args": [
            "call"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_send_pages",
          "args": [
            "call",
            "&msg",
            "iov"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "afs_send_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "273-333",
          "snippet": "static int afs_send_pages(struct afs_call *call, struct msghdr *msg,\n\t\t\t  struct kvec *iov)\n{\n\tstruct page *pages[8];\n\tunsigned count, n, loop, offset, to;\n\tpgoff_t first = call->first, last = call->last;\n\tint ret;\n\n\t_enter(\"\");\n\n\toffset = call->first_offset;\n\tcall->first_offset = 0;\n\n\tdo {\n\t\t_debug(\"attach %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > ARRAY_SIZE(pages))\n\t\t\tcount = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(call->mapping, first, count, pages);\n\t\tASSERTCMP(n, ==, count);\n\n\t\tloop = 0;\n\t\tdo {\n\t\t\tmsg->msg_flags = 0;\n\t\t\tto = PAGE_SIZE;\n\t\t\tif (first + loop >= last)\n\t\t\t\tto = call->last_to;\n\t\t\telse\n\t\t\t\tmsg->msg_flags = MSG_MORE;\n\t\t\tiov->iov_base = kmap(pages[loop]) + offset;\n\t\t\tiov->iov_len = to - offset;\n\t\t\toffset = 0;\n\n\t\t\t_debug(\"- range %u-%u%s\",\n\t\t\t       offset, to, msg->msg_flags ? \" [more]\" : \"\");\n\t\t\tiov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC,\n\t\t\t\t      iov, 1, to - offset);\n\n\t\t\t/* have to change the state *before* sending the last\n\t\t\t * packet as RxRPC might give us the reply before it\n\t\t\t * returns from sending the request */\n\t\t\tif (first + loop >= last)\n\t\t\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\t\t\tret = rxrpc_kernel_send_data(call->rxcall, msg,\n\t\t\t\t\t\t     to - offset);\n\t\t\tkunmap(pages[loop]);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} while (++loop < count);\n\t\tfirst += count;\n\n\t\tfor (loop = 0; loop < count; loop++)\n\t\t\tput_page(pages[loop]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t} while (first <= last);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic int afs_send_pages(struct afs_call *call, struct msghdr *msg,\n\t\t\t  struct kvec *iov)\n{\n\tstruct page *pages[8];\n\tunsigned count, n, loop, offset, to;\n\tpgoff_t first = call->first, last = call->last;\n\tint ret;\n\n\t_enter(\"\");\n\n\toffset = call->first_offset;\n\tcall->first_offset = 0;\n\n\tdo {\n\t\t_debug(\"attach %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > ARRAY_SIZE(pages))\n\t\t\tcount = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(call->mapping, first, count, pages);\n\t\tASSERTCMP(n, ==, count);\n\n\t\tloop = 0;\n\t\tdo {\n\t\t\tmsg->msg_flags = 0;\n\t\t\tto = PAGE_SIZE;\n\t\t\tif (first + loop >= last)\n\t\t\t\tto = call->last_to;\n\t\t\telse\n\t\t\t\tmsg->msg_flags = MSG_MORE;\n\t\t\tiov->iov_base = kmap(pages[loop]) + offset;\n\t\t\tiov->iov_len = to - offset;\n\t\t\toffset = 0;\n\n\t\t\t_debug(\"- range %u-%u%s\",\n\t\t\t       offset, to, msg->msg_flags ? \" [more]\" : \"\");\n\t\t\tiov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC,\n\t\t\t\t      iov, 1, to - offset);\n\n\t\t\t/* have to change the state *before* sending the last\n\t\t\t * packet as RxRPC might give us the reply before it\n\t\t\t * returns from sending the request */\n\t\t\tif (first + loop >= last)\n\t\t\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\t\t\tret = rxrpc_kernel_send_data(call->rxcall, msg,\n\t\t\t\t\t\t     to - offset);\n\t\t\tkunmap(pages[loop]);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} while (++loop < count);\n\t\tfirst += count;\n\n\t\tfor (loop = 0; loop < count; loop++)\n\t\t\tput_page(pages[loop]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t} while (first <= last);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_send_data",
          "args": [
            "rxcall",
            "&msg",
            "call->request_size"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_kvec",
          "args": [
            "&msg.msg_iter",
            "WRITE | ITER_KVEC",
            "iov",
            "1",
            "call->request_size"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rxcall"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rxcall"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_begin_call",
          "args": [
            "afs_socket",
            "&srx",
            "call->key",
            "(unsigned long) call",
            "gfp"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&srx.transport.sin.sin_addr",
            "addr",
            "4"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&srx",
            "0",
            "sizeof(srx)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&call->async_work",
            "afs_async_workfn"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"____MAKE %p{%s,%x} [%d]____\"",
            "call",
            "call->type->name",
            "key_serial(call->key)",
            "atomic_read(&afs_outstanding_calls)"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_calls"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "call->key"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "call->type->name != NULL"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "call->type != NULL"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%x,{%d},\"",
            "addr->s_addr",
            "ntohs(call->port)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "call->port"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_send_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "273-333",
    "snippet": "static int afs_send_pages(struct afs_call *call, struct msghdr *msg,\n\t\t\t  struct kvec *iov)\n{\n\tstruct page *pages[8];\n\tunsigned count, n, loop, offset, to;\n\tpgoff_t first = call->first, last = call->last;\n\tint ret;\n\n\t_enter(\"\");\n\n\toffset = call->first_offset;\n\tcall->first_offset = 0;\n\n\tdo {\n\t\t_debug(\"attach %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > ARRAY_SIZE(pages))\n\t\t\tcount = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(call->mapping, first, count, pages);\n\t\tASSERTCMP(n, ==, count);\n\n\t\tloop = 0;\n\t\tdo {\n\t\t\tmsg->msg_flags = 0;\n\t\t\tto = PAGE_SIZE;\n\t\t\tif (first + loop >= last)\n\t\t\t\tto = call->last_to;\n\t\t\telse\n\t\t\t\tmsg->msg_flags = MSG_MORE;\n\t\t\tiov->iov_base = kmap(pages[loop]) + offset;\n\t\t\tiov->iov_len = to - offset;\n\t\t\toffset = 0;\n\n\t\t\t_debug(\"- range %u-%u%s\",\n\t\t\t       offset, to, msg->msg_flags ? \" [more]\" : \"\");\n\t\t\tiov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC,\n\t\t\t\t      iov, 1, to - offset);\n\n\t\t\t/* have to change the state *before* sending the last\n\t\t\t * packet as RxRPC might give us the reply before it\n\t\t\t * returns from sending the request */\n\t\t\tif (first + loop >= last)\n\t\t\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\t\t\tret = rxrpc_kernel_send_data(call->rxcall, msg,\n\t\t\t\t\t\t     to - offset);\n\t\t\tkunmap(pages[loop]);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} while (++loop < count);\n\t\tfirst += count;\n\n\t\tfor (loop = 0; loop < count; loop++)\n\t\t\tput_page(pages[loop]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t} while (first <= last);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[loop]"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "pages[loop]"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_send_data",
          "args": [
            "call->rxcall",
            "msg",
            "to - offset"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_kvec",
          "args": [
            "&msg->msg_iter",
            "WRITE | ITER_KVEC",
            "iov",
            "1",
            "to - offset"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"- range %u-%u%s\"",
            "offset",
            "to",
            "msg->msg_flags ? \" [more]\" : \"\""
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "pages[loop]"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "n",
            "==,count"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "call->mapping",
            "first",
            "count",
            "pages"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic int afs_send_pages(struct afs_call *call, struct msghdr *msg,\n\t\t\t  struct kvec *iov)\n{\n\tstruct page *pages[8];\n\tunsigned count, n, loop, offset, to;\n\tpgoff_t first = call->first, last = call->last;\n\tint ret;\n\n\t_enter(\"\");\n\n\toffset = call->first_offset;\n\tcall->first_offset = 0;\n\n\tdo {\n\t\t_debug(\"attach %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > ARRAY_SIZE(pages))\n\t\t\tcount = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(call->mapping, first, count, pages);\n\t\tASSERTCMP(n, ==, count);\n\n\t\tloop = 0;\n\t\tdo {\n\t\t\tmsg->msg_flags = 0;\n\t\t\tto = PAGE_SIZE;\n\t\t\tif (first + loop >= last)\n\t\t\t\tto = call->last_to;\n\t\t\telse\n\t\t\t\tmsg->msg_flags = MSG_MORE;\n\t\t\tiov->iov_base = kmap(pages[loop]) + offset;\n\t\t\tiov->iov_len = to - offset;\n\t\t\toffset = 0;\n\n\t\t\t_debug(\"- range %u-%u%s\",\n\t\t\t       offset, to, msg->msg_flags ? \" [more]\" : \"\");\n\t\t\tiov_iter_kvec(&msg->msg_iter, WRITE | ITER_KVEC,\n\t\t\t\t      iov, 1, to - offset);\n\n\t\t\t/* have to change the state *before* sending the last\n\t\t\t * packet as RxRPC might give us the reply before it\n\t\t\t * returns from sending the request */\n\t\t\tif (first + loop >= last)\n\t\t\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\t\t\tret = rxrpc_kernel_send_data(call->rxcall, msg,\n\t\t\t\t\t\t     to - offset);\n\t\t\tkunmap(pages[loop]);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} while (++loop < count);\n\t\tfirst += count;\n\n\t\tfor (loop = 0; loop < count; loop++)\n\t\t\tput_page(pages[loop]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t} while (first <= last);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_flat_call_destructor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "260-268",
    "snippet": "void afs_flat_call_destructor(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tkfree(call->request);\n\tcall->request = NULL;\n\tkfree(call->buffer);\n\tcall->buffer = NULL;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->buffer"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->request"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_flat_call_destructor(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tkfree(call->request);\n\tcall->request = NULL;\n\tkfree(call->buffer);\n\tcall->buffer = NULL;\n}"
  },
  {
    "function_name": "afs_alloc_flat_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "218-255",
    "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t afs_outstanding_calls;",
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_free_call",
          "args": [
            "call"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "177-191",
          "snippet": "static void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&call->rx_queue"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&call->waitq"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "reply_size",
            "GFP_NOFS"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&afs_outstanding_calls"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"CALL %p{%s} [%d]\"",
            "call",
            "type->name",
            "atomic_read(&afs_outstanding_calls)"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_calls"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*call)",
            "GFP_NOFS"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
  },
  {
    "function_name": "afs_end_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "209-213",
    "snippet": "static void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_free_call",
          "args": [
            "call"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "177-191",
          "snippet": "static void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_end_call_nofree",
          "args": [
            "call"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "afs_end_call_nofree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "196-204",
          "snippet": "static void afs_end_call_nofree(struct afs_call *call)\n{\n\tif (call->rxcall) {\n\t\trxrpc_kernel_end_call(call->rxcall);\n\t\tcall->rxcall = NULL;\n\t}\n\tif (call->type->destructor)\n\t\tcall->type->destructor(call);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call_nofree(struct afs_call *call)\n{\n\tif (call->rxcall) {\n\t\trxrpc_kernel_end_call(call->rxcall);\n\t\tcall->rxcall = NULL;\n\t}\n\tif (call->type->destructor)\n\t\tcall->type->destructor(call);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call(struct afs_call *call)\n{\n\tafs_end_call_nofree(call);\n\tafs_free_call(call);\n}"
  },
  {
    "function_name": "afs_end_call_nofree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "196-204",
    "snippet": "static void afs_end_call_nofree(struct afs_call *call)\n{\n\tif (call->rxcall) {\n\t\trxrpc_kernel_end_call(call->rxcall);\n\t\tcall->rxcall = NULL;\n\t}\n\tif (call->type->destructor)\n\t\tcall->type->destructor(call);\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call->type->destructor",
          "args": [
            "call"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_end_call",
          "args": [
            "call->rxcall"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_end_call_nofree(struct afs_call *call)\n{\n\tif (call->rxcall) {\n\t\trxrpc_kernel_end_call(call->rxcall);\n\t\tcall->rxcall = NULL;\n\t}\n\tif (call->type->destructor)\n\t\tcall->type->destructor(call);\n}"
  },
  {
    "function_name": "afs_free_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "177-191",
    "snippet": "static void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t afs_outstanding_calls;",
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->request"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "call->type->name != NULL"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "skb_queue_empty(&call->rx_queue)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_empty",
          "args": [
            "&call->rx_queue"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!work_pending(&call->async_work)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_pending",
          "args": [
            "&call->async_work"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "call->rxcall",
            "==,NULL"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&afs_outstanding_calls"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"DONE %p{%s} [%d]\"",
            "call",
            "call->type->name",
            "atomic_read(&afs_outstanding_calls)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_calls"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_free_call(struct afs_call *call)\n{\n\t_debug(\"DONE %p{%s} [%d]\",\n\t       call, call->type->name, atomic_read(&afs_outstanding_calls));\n\tif (atomic_dec_return(&afs_outstanding_calls) == -1)\n\t\tBUG();\n\n\tASSERTCMP(call->rxcall, ==, NULL);\n\tASSERT(!work_pending(&call->async_work));\n\tASSERT(skb_queue_empty(&call->rx_queue));\n\tASSERT(call->type->name != NULL);\n\n\tkfree(call->request);\n\tkfree(call);\n}"
  },
  {
    "function_name": "afs_free_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "160-172",
    "snippet": "static void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t afs_outstanding_skbs;",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rxrpc_kernel_free_skb",
          "args": [
            "skb"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"FREE %p{%u} [%d]\"",
            "skb",
            "skb->mark",
            "atomic_read(&afs_outstanding_skbs)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"FREE NULL [%d]\"",
            "atomic_read(&afs_outstanding_skbs)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_skbs;\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_free_skb(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"FREE NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"FREE %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_free_skb(skb);\n\t}\n}"
  },
  {
    "function_name": "afs_data_delivered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "143-155",
    "snippet": "static void afs_data_delivered(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"DLVR NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"DLVR %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_data_delivered(skb);\n\t}\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t afs_outstanding_skbs;",
      "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
      "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rxrpc_kernel_data_delivered",
          "args": [
            "skb"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"DLVR %p{%u} [%d]\"",
            "skb",
            "skb->mark",
            "atomic_read(&afs_outstanding_skbs)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"DLVR NULL [%d]\"",
            "atomic_read(&afs_outstanding_skbs)"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_skbs;\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nstatic void afs_data_delivered(struct sk_buff *skb)\n{\n\tif (!skb) {\n\t\t_debug(\"DLVR NULL [%d]\", atomic_read(&afs_outstanding_skbs));\n\t\tdump_stack();\n\t} else {\n\t\t_debug(\"DLVR %p{%u} [%d]\",\n\t\t       skb, skb->mark, atomic_read(&afs_outstanding_skbs));\n\t\tif (atomic_dec_return(&afs_outstanding_skbs) == -1)\n\t\t\tBUG();\n\t\trxrpc_kernel_data_delivered(skb);\n\t}\n}"
  },
  {
    "function_name": "afs_close_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "125-137",
    "snippet": "void afs_close_socket(void)\n{\n\t_enter(\"\");\n\n\tsock_release(afs_socket);\n\n\t_debug(\"dework\");\n\tdestroy_workqueue(afs_async_calls);\n\n\tASSERTCMP(atomic_read(&afs_outstanding_skbs), ==, 0);\n\tASSERTCMP(atomic_read(&afs_outstanding_calls), ==, 0);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct socket *afs_socket;",
      "static struct workqueue_struct *afs_async_calls;",
      "static atomic_t afs_outstanding_calls;",
      "static atomic_t afs_outstanding_skbs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&afs_outstanding_calls)",
            "==,0"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_calls"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&afs_outstanding_skbs)",
            "==,0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&afs_outstanding_skbs"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "afs_async_calls"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"dework\""
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "afs_socket"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic struct workqueue_struct *afs_async_calls;\nstatic atomic_t afs_outstanding_calls;\nstatic atomic_t afs_outstanding_skbs;\n\nvoid afs_close_socket(void)\n{\n\t_enter(\"\");\n\n\tsock_release(afs_socket);\n\n\t_debug(\"dework\");\n\tdestroy_workqueue(afs_async_calls);\n\n\tASSERTCMP(atomic_read(&afs_outstanding_skbs), ==, 0);\n\tASSERTCMP(atomic_read(&afs_outstanding_calls), ==, 0);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_open_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "72-120",
    "snippet": "int afs_open_socket(void)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct socket *socket;\n\tint ret;\n\n\t_enter(\"\");\n\n\tskb_queue_head_init(&afs_incoming_calls);\n\n\tafs_async_calls = create_singlethread_workqueue(\"kafsd\");\n\tif (!afs_async_calls) {\n\t\t_leave(\" = -ENOMEM [wq]\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sock_create_kern(AF_RXRPC, SOCK_DGRAM, PF_INET, &socket);\n\tif (ret < 0) {\n\t\tdestroy_workqueue(afs_async_calls);\n\t\t_leave(\" = %d [socket]\", ret);\n\t\treturn ret;\n\t}\n\n\tsocket->sk->sk_allocation = GFP_NOFS;\n\n\t/* bind the callback manager's address to make this a server socket */\n\tsrx.srx_family\t\t\t= AF_RXRPC;\n\tsrx.srx_service\t\t\t= CM_SERVICE;\n\tsrx.transport_type\t\t= SOCK_DGRAM;\n\tsrx.transport_len\t\t= sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family\t= AF_INET;\n\tsrx.transport.sin.sin_port\t= htons(AFS_CM_PORT);\n\tmemset(&srx.transport.sin.sin_addr, 0,\n\t       sizeof(srx.transport.sin.sin_addr));\n\n\tret = kernel_bind(socket, (struct sockaddr *) &srx, sizeof(srx));\n\tif (ret < 0) {\n\t\tsock_release(socket);\n\t\tdestroy_workqueue(afs_async_calls);\n\t\t_leave(\" = %d [bind]\", ret);\n\t\treturn ret;\n\t}\n\n\trxrpc_kernel_intercept_rx_messages(socket, afs_rx_interceptor);\n\n\tafs_socket = socket;\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct socket *afs_socket;",
      "static struct workqueue_struct *afs_async_calls;",
      "static struct sk_buff_head afs_incoming_calls;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rxrpc_kernel_intercept_rx_messages",
          "args": [
            "socket",
            "afs_rx_interceptor"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [bind]\"",
            "ret"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "afs_async_calls"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_release",
          "args": [
            "socket"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_bind",
          "args": [
            "socket",
            "(struct sockaddr *) &srx",
            "sizeof(srx)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&srx.transport.sin.sin_addr",
            "0",
            "sizeof(srx.transport.sin.sin_addr)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_CM_PORT"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_create_kern",
          "args": [
            "AF_RXRPC",
            "SOCK_DGRAM",
            "PF_INET",
            "&socket"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"kafsd\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_queue_head_init",
          "args": [
            "&afs_incoming_calls"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic struct workqueue_struct *afs_async_calls;\nstatic struct sk_buff_head afs_incoming_calls;\n\nint afs_open_socket(void)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct socket *socket;\n\tint ret;\n\n\t_enter(\"\");\n\n\tskb_queue_head_init(&afs_incoming_calls);\n\n\tafs_async_calls = create_singlethread_workqueue(\"kafsd\");\n\tif (!afs_async_calls) {\n\t\t_leave(\" = -ENOMEM [wq]\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sock_create_kern(AF_RXRPC, SOCK_DGRAM, PF_INET, &socket);\n\tif (ret < 0) {\n\t\tdestroy_workqueue(afs_async_calls);\n\t\t_leave(\" = %d [socket]\", ret);\n\t\treturn ret;\n\t}\n\n\tsocket->sk->sk_allocation = GFP_NOFS;\n\n\t/* bind the callback manager's address to make this a server socket */\n\tsrx.srx_family\t\t\t= AF_RXRPC;\n\tsrx.srx_service\t\t\t= CM_SERVICE;\n\tsrx.transport_type\t\t= SOCK_DGRAM;\n\tsrx.transport_len\t\t= sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family\t= AF_INET;\n\tsrx.transport.sin.sin_port\t= htons(AFS_CM_PORT);\n\tmemset(&srx.transport.sin.sin_addr, 0,\n\t       sizeof(srx.transport.sin.sin_addr));\n\n\tret = kernel_bind(socket, (struct sockaddr *) &srx, sizeof(srx));\n\tif (ret < 0) {\n\t\tsock_release(socket);\n\t\tdestroy_workqueue(afs_async_calls);\n\t\t_leave(\" = %d [bind]\", ret);\n\t\treturn ret;\n\t}\n\n\trxrpc_kernel_intercept_rx_messages(socket, afs_rx_interceptor);\n\n\tafs_socket = socket;\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_async_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
    "lines": "61-66",
    "snippet": "static void afs_async_workfn(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, async_work);\n\n\tcall->async_workfn(call);\n}",
    "includes": [
      "#include \"afs_cm.h\"",
      "#include \"internal.h\"",
      "#include <rxrpc/packet.h>",
      "#include <net/af_rxrpc.h>",
      "#include <net/sock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_wake_up_call_waiter(struct afs_call *);",
      "static int afs_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_wake_up_async_call(struct afs_call *);",
      "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
      "static void afs_process_async_call(struct afs_call *);",
      "static void afs_collect_incoming_call(struct work_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call->async_workfn",
          "args": [
            "call"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structafs_call",
            "async_work"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_collect_incoming_call(struct work_struct *);\n\nstatic void afs_async_workfn(struct work_struct *work)\n{\n\tstruct afs_call *call = container_of(work, struct afs_call, async_work);\n\n\tcall->async_workfn(call);\n}"
  }
]